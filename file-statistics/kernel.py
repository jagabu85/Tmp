from __future__ import division
# -* - coding:UTF-8 -*-
# coding=gbk
# -*- coding:cp936 -*-
# coding=2312
## Chinese coding display test: 中文显示

if 'vars_old' not in globals().keys():
	vars_old = globals().keys()

changing = 0
developed_by = 'Yuqi Jiang'

annotation_xloc = 6
annotation_yloc = 10

border_x = 2000
border_y = 2000
border_z = 2000
_scale = 2000

## PPA-SMIL
## batch run
provide_DOE_table = False
provide_levels_list = True		## changing1

##cae_name_postfix = {'_th':'Tcc'}
cae_name_postfix = ''

def input_levels_list(levels_list={}):
	## VER: 2013-05-08, v1.1

	global single_level;	single_level = {}
	global cae_name_postfix

##	levels_list['Tcc'] = 7,8,9,10,11,12,13,14,15
##	single_level['Tcc'] = 7   ## Applied for every treat run

##	levels_list['pressure'] = 80, 100, 120, 140, 160, 200
##	levels_list['gap'] = [1.0, 0.5, 0, -0.5, -1.0, -1.5]
##	levels_list['wall'] = [20, 25, 28, 30, 35]

	if len(levels_list.keys()) == 1:
		par = levels_list.keys()[0]

		py_file = get_file_name()
		py_file = py_file[:-3]

		if py_file.endswith(par) == False:
			cae_name_postfix = {'_' + par: par}
		else:
			cae_name_postfix = {'_':par}

	return levels_list

def specify_run_indexs(run_indexs=()):
	## VER: 2013-05-08, v1.0

##	run_indexs = 3

	return tolist(run_indexs)


## Functions ============================
## Selection:
## General: body_obj, obj_at, objs_of_mdb_leaf, objs_of_odb_leaf, obj_select,	radial_select, reselect_by_pointOn, select_single_obj, unselect,
## 点\线\体\单元\节点:  cell_at, cell_select, cell_select_by_container, cell_select_by_face, check_entity, edge_select_by_facing, edges_at, edges_of_cells, edges_of_cut, edges_of_face, faces_to_edges, edges_of_insts, vertices_to_edges, edge_select, end_edges, find_circular_edges, find_slope_edges， get_cell_edge_in_dir, get_face_edge_in_dir, long_edges_of_faces, node_select, point_at, point_nearby,	short_edges_of_faces, treat_curve, treat_line, two_points_of_edge, edges_to_vertices, faces_to_vertices, vertices_of_objs, vertice_select,
## Faces:   select_by_expand_faces, connect_all_faces, ymax_faces, zmin_faces, check_facing_dir, end_faces, exterior_faces_of_faces, face_at, face_at_range_grids, faces_of_cut, edges_to_faces, faces_of_insts, face_select, get_inner_faces, get_outer_faces, get_uncover_faces, real_objs
## Faces:   face_with, faces_of_cells, find_slope_faces, ymin_faces, objs_of_internal_set, xmin_faces, refine_side2_faces_ndir, cross_faces_by_dir_inplane, mate_faces_in_inst, refine_faces_pair_inplane, xmax_faces, zmax_faces, treat_face,	wall_faces,
## 转换:    create_mix_region, elements_to_model_element_labels, faceset2sequence, list2region, list2sequence, nodes_to_model_node_labels, poi2region, poi2sequence, pointOns2faces, region2objs, set2face_point, set2list_dict, set2objs,
## select inst&Part: _pois, find_mdb_insts, find_mdb_parts, find_odb_insts, get_hiden_insts, get_suppressed_insts, inst_select, insts_by_set, insts_of_part, insts_of_parts,  inst_of_pre, leaf_ids_to_insts, part_byset, part_list, part_of_pre, partkey_ofpre, parts_by_set, poi_of_region, poi_with_setname, objs_of_dg, real_insts, real_parts,

## Set/surface/sequence/region: add2set, change_part_setname, clear_empty_sets, create_nodal_surface, create_set,	create_side_sets, create_surface, create_symset, dir_points, disp_group, get_eset, get_surface_side, insts_to_region, KP_set, line_points, mirror_mat_set,	mirror_set,	obj2sequence, RP2region, sequence_to_region, set_append,	set_space, set_unselect, set2surface, set2region, set2sequence, type_of_set,

## Datum/RP//csys/矢量: clear_datum_axis, clear_datum_points, create_csys, create_datum_axis_by_2points, create_datum_plane_by_2axis,
## Datum/RP//csys/矢量: create_datum_point, create_right_edge, create_RP, create_datum_plane_by_3points， create_datum_plane_by_offset,
## Datum/RP//csys/矢量: create_datum_plane_by_point_and_axis, datum_plane_and_right_axis, edge_to_vector, edir_of_vector, get_datum_pointOn, get_project_point,get_RP_objs, hide_csys,  intersect_point_of_line_and_plane,
## Datum/RP/csys/矢量: intersect_point_of_two_edges, is_vector, move_RP, ndir_of_datum_plane, normal_datum_plane_of_edge, project_axis_to_plane, right_edge_of_datum_plane,
## Datum/RP//csys/矢量: rotate_plane_to_datum_plane, rotated_vector, set_RP, show_csys, tangent_datum_axis_of_edge, tangent_vector_of_edge, two_points_of_datum_axis, update_csys, vector, vector_angle, vector_of_two_points, xmove, ymove, zmove
## Feature: create_point_mass_damping, del_features, feature_to_obj, get_RP_names, id_to_feature_name, obj_to_feature, poa_feature_objs, get_RP_objs,

## index: get_feature_id, id_to_feature_name, objs2index, change_key_name, get_repository_key

## space/range: _xspace,_yspace,_zspace, check_loc, check_space, circular_space_of_face, circular_space_of_faces, collect_odb_insts_space, collect_space_of_curved_faces, curve_space,get_part_space, mids_of_poi, model_space, obj_space, objs_space, poi_space, point_range, real_space,
## space/range: space_at, space_of_cell, space_of_curved_faces, space_of_edges, space_of_element, objs_space, space_of_insts, space_of_points, space_of_sequence, tospace, update_insts_space,

## cross info: cross_of_cell_and_space, cross_of_faces_and_faces, cross_of_faces_and_inst, cross_of_pois, cross_of_ranges, cross_of_spaces, meet_search_range,

## loc info: _xmid, _ymid, _zmid, _xmin, _xmax, _ymin, _ymax, _zmin, _zmax, _xmin_sketch, _xmax_sketch, _xmid_sketch, _ymin_sketch, _ymax_sketch, _ymid_sketch, center_axis_of_cylind_face, centroid_of_cell, get_volume_centroid, centroid_of_face, centroid_of_faces, poi_centroid, circular_center,
## loc info: contain, face_seeds, from_to, loc_unselect, locs_of_poi, end_locs_of_edge, get_poi_position, iget_rail_dir, ntervals, key_locs, KPx,	KPy, KPz, KPxyz, loc_at, loc_of_feature_point, pointOns_of_faces, locs_of_edge, locs_of_face, coords_of_objs, max_ofset, mid_of_edge, min_ofset,
## loc info: plane_normal_and_offset, ndir_and_offset_of_curve, poi2poi, pointOn_of, pointOns_of_curve, points_sort_byx, points_sort_byy, points_sort_byz, real_x, real_y, real_z, real_xyz, real_xyz_in_space, real_value_in_range, round_loc, round_locs, RPxyz, RPx, RPy, RPz, seeds_of_face, set2locx, set2locy,
## loc info: set2locz, set2pointOns,	through_points_in_x, through_points_in_y, through_points_in_z, ylist_of_sketch_points, xlocs,ylocs,zlocs,x_at, y_at, z_at,

## 尺寸/大小/计算：cal_axial_pressure, clear_user_data, edge_angle, edges_length, face_to_face_gap,
## 尺寸/大小/计算：frame_weight_of_module, get_area, get_aspect_ratio, get_PH_PFH, get_mass, get_diamond_dims,
## 尺寸/大小/计算：get_bulk_modulus, get_frameless_module_dims, get_intersect_angle, get_module_dims, get_nib_bearing, get_poi_length,
## 尺寸/大小/计算：get_punch_volume, get_radius, get_real_angle, get_size, get_volume, pressure_on_area, read_vars_from_model_description,
## 尺寸/大小/计算：cross_section_length, side_on_area, get_dxdy, smart_round, space_volume_of_poi, vol_of, rect_face_info, save_user_data, ton_on_area

## 形状/法线/方向：area_shape, edge_dir, edge_dir_ends, edges_ndir, edges_offset, edge_shape, face_angle, face_dirx,	face_diry,	face_dirz,	face_ndir, face_normal_by_num,	face_shape, face_shape, facing_dir, get_curvature, get_beam_dir, get_normal, section_normal, AV_shape,
## name/key/字符串: brief_name, check_faces, new_key, create_poi_vars, get_decimal_num, locs_of_substring, formatted_name, get_text， modify_string, partial_setname, poi_names, poi_name_of_var, radius_of_curvature, reduce_insts_names, swap_dict_key, text2varname,

## 列表/判断: _sort, add2my_globals, all_equal, all_is, all_is_type, all_is_value, is_empties, all_lists_not_empty, backup, check_values, remove_repeated_items, collect_new_key, connect_edges, coplanar, cover, create_periodic_amplitude, is_empties, create_timepoints, get_amplitude, get_common, get_sequence_index, get_real_input, have_common, have_curve, inside,
## 列表/判断: is_empty, is_2D_or_3D, is_3D_loc, is_cylind_faces, is_empty_repository, is_inner_plane, check_mm_unit, is_numeric,
## 列表/判断: is_outer_plane, is_plane, is_plane_list, is_objs_sequence, is_parallel_vector, is_same_axis, is_same_loc, is_similar_part, is_similar_edge, len_num, keys_num, list_op, same_axis_direction, mems_num, merge_lists, move_items, myrange, nodes_sort_byx, nodes_sort_byy, nodes_sort_byz, objs_num, parallel_to_axis, PK
## 列表/判断: randomize, random_sub_set, real_key, remove_empty, remove_sub, remove_item, set_length, show_in_items, solid_sequence, sort, sort_by_key, sort_by_value, sort_dict_type_elements, sort_tuple_type_elements, sort_space, sort_tuple_type_elements, tolist, totuple, trend, totable, within_list, within_range,

## 调试：add_VIP_var, add_to_process, call_line_history, caller_fnln, caller_name, caller_names, change_module, print2, dig_points, error_record,exist, get_caller_code, get_python_version, get_runtime, get_time, get_traceback, get_user_parameters, inspect_trace, ln, fnln, fnln_fnln, this_and_caller, lineno_and_codes,  please_check, print_caller_code, print_traceback, 	record_time
## 转换: dir2num,get_SN, index_range, index2objs, num2dir,	num2char, printw, round6, sec2str, timetuple2sec, totext
## 打印：disclose, myprint, print_attributes, print_dir, print_DOE_table, text_of_objs_sequence, text_of_sequence, use_poi_var_name,
## 类型：type_of,

## 函数/参数: check_func, find_func, VER: , func_process, function_name, get_func_defaults， get_func_loc, get_function_handler,
## 函数/参数: get_function_info, get_function_pars, get_inputs, get_line_code, get_real_antype, get_real_input, get_parameters, type_of_repository,
## 函数/参数：get_user_functions, local2global, locals2globals, print_function_handler, read_vars_from_file, real_xyz, real_xy_sketch, start_func, to_symbol, write_global_variables,

## model: blank_cae, clear_model_settings, copy_model, create_new_model, get_current_model, get_cae_file_title, import_initial_state, update_mdb_vars, refresh, model_backup, model_restore, model_summary, module_summary, open_cae, refresh, save_mdb, switch_model, switch_part, update_cae_model
## poi/poa: get_poa, get_poi, check_pias,
## Assembly/instance: check_ia, check_inst, coaxial， copy_insts, del_hiden_insts, del_insts,	duplicate_inst, face2face, new_instance, pattern, pattern_insts, patternx, patterny,  patternz,	pattern_xy, rotate_instances, translate_instances,

## Part1: blank_part, bolt_outside, chamfer_edges, change_part_name, check_part, copy_part, create_cell_block, create_C_clamp, create_C_clamp_with_rubber, create_circular_shell, create_dam, create_double_lam, create_frame_rail, create_half_ball, create_line_part, create_plate, assembly_and_fill, create_rectangle_shell, create_round_block, create_single_lam, create_rail, create_single_cell, create_std_module, create_std_rail, create_T_clamp, create_Z_clamp, cylinder_grow, del_parts_without_instance, drill_hole_and_install_bolt, edges_to_wirepart， expand,	half_bolt,	create_block, faces_extrude, inst2part, merge_instances,
## Part2: create_1_bolt, create_I_bolt, create_T_bolt, deformable_to_discrete_rigid, faces_to_shellpart, high_node_line, import_part_from_cae, mirror_part, move_clamp, move_part, node_line, part_parallel, part_shape_and_type, part2cae, parts_of_insts, qtr_rect_frame, radial_cut, radial_grow, real_pshape_and_ptype, rect_bolt, rect_frame, create_pipe_steel, rect_steel, remove_redundant_edges, psum, rigid_to_deformable_part, rotate_part, rotate_part_from_xysketch, round_edges, round_grow, scale_part, section_grow, sheet_grow, simple_line, sketch_part, sweep_solid_through_wire, temp_part_from_inst, temp_part_of_poi, update_part, use_part

## DOE: input_treats_list, fn_get_levels, get_all_treats_from_levels_list, get_treat_setting, global_vars_for_this_run, input_levels_list, get_all_treats_and_run_indexs
## Tool/calculation:  fn_bolt_load, fn_cal_inertia, fn_cell_temp, fn_cost_down, fn_delta_T, fn_h_surf, fn_inertia_of_faces, fn_kph2ms, fn_mph2ms, fn_plate_stress_deflection, fn_pressure2speed, get_air_conductivity, get_air_density, get_Gr, get_hc, get_Nu, get_Pr, get_Re, get_thermal_diffusivity
## Tool/calculation: fn_silic_dim, fn_speed2pressure, fn_strain_eng, fn_strain_true,  fn_tape_width_dynamic, fn_tape_width_static, fn_time_zone, fn_water2pressure, fn_wind_load, key_locs, reduce_model, set_mount_options,

## Divide: batch_divide, circular_divide,	contact_divide, corner_divide, cross_divide,  divide,	divide_by3points, divide_bycorner,	divide_byedge_set,  divide_by_face, divide_byinst_ends, divide_bypart, divide_bypointNormal, divide_edge_by_loc, divide_edge_by_par,
## Divide: divide_frame_by_clamp, divide_faces, divide_faces_by_two_points, divide_in_assembly, divide_insts, mid_divide, self_divide, divide_part_in_clamp, divide_part_on_rail,

## Delete: bias_cut,bias_cut1, bias_cut, boolean_cut, cut_instances, del_cells, del_features, del_parts, drill_hole, get_angle_of_cut_sides, hex_cut,	section_cut,

## SVK: australia_die, cutted_punch_tip_length, get_velocity

## Plot: addplot, animate, assembly_module, del_all_models_and_odbs, cross_section_plot, cshow, cshow1, fr, get_leaf_of_assembly_sets, get_leaf_of_odb_sets, hide_set, hideedge, hide_datum, iso, left, mark_loc, mat_deform, mat_view, plot, replot, right, set_colormap, plotset, show_datum,
## Plot: LBC_plot, leaf2dg, leaf_type, light, light_esize, light_enum, mplot, noplot, plot_insts, plotset, pshow, set_scale, showedge, show_parts, show_loc, show_symm, show_time,	ttl, unlight, unlock, view_group,

## File: attrib, bit2KB, bit2MB, brief_file_name, check_script_file, copy_files, files_in_folder, file_time_second, file_time_date, get_file_name, get_files_in_dir, get_file_path, get_script_work_and_result_files, file2lines, line_print, line_print, my_walk, read_lines, read_rpy, real_dir, save_avi, save_image, sort_files_by_time, stop, list_to_txt_line,
## output vars: add_VIP_var, write_user_parameters, save_user_data, field_output_request, history_output_request

## Sketch: add_sketches, all_regular_geometry, create_arc, bias_cut_sketch, create_part_sketch, create_base_sketch, check_sketch, count_sketch_geometry, convert_loc, create_construction, create_sketch_line,
## Sketch:  datum_plane_to_blank_sketch, del_geometry, del_sketch_objs, dir_of_sketch_line, draw_lines_in_sketch, edges_to_sketch, extrude_sketch_to_part, find_loc, get_cutting_section, locs_of_sketch, get_connected_geometry, ndir_of_sketch, get_sketch_transform, geometry_to_sketch, hide_grid, id_of_sketch_vertice, loc_dict_of_sketch_vertices, locs_poi_to_sketch, mirror_sketch
## Sketch: pattern_geometry, vertice_locs_of_geometry, points_at_geometry_x, points_at_geometry_y, locs_sketch_to_poi, mirror_geometry, move_geometry, move_sketch, move_sketch_in_ndir, ndir_of_sketch, objs2construction, poly_lines_in_sketch, print_geometry_info, print_sketch_csys, rectangle,
## Sketch: radial_constraint, radius_of_geometry, round_sketch_corner, select_construction_lines, select_lines_in_sketch, show_grid, show_sketch, geometry_select, geometry_at, sketch_line_dir, sketch_vertice_select, space_of_sketch, threeD_to_sketch_points, trim_geometry, trim_sketch, type_and_shape_of_sketch_geometry, sketch_to_wirepart1,

## material: apply_mat_etype, clear_empty_sets, copy_material, create_contact_props, set_CTE, set_hyperElastic, create_mat_hex, material_database, create_materials_PV, cross_set_mat, get_all_mats, get_density, get_mats, get_true_stress_and_plastic_strain, list_mats, print_mat_sections, section_shell, set_mat, set_thermal_prop, show_mat_props
## Step: create_coupled_temp_displacement_step, create_dynamic_explicit_step, frequency_and_mode_shapes_step, create_heat_transfer_step, history_output_request, time_response_modal_dynamics_step, create_general_static_step, frequency_response_modal_dynamics_step, create_step, create_T_output, check_step, get_antype, get_solver, get_next_step, get_steps_sequence, print_steps, suggested_analysis_step

## Interaction: active_steps_of_interact, apply_surface_convection, apply_radiation, batch_tie,	bolt_tie, check_fix_extend, check_in_contact, contact_select, contact_sets, contacts_of_inst, contacts_of_pois, create_clamp_contacts, create_contacts, create_module_contacts, create_frame_rail_contacts,
## Interaction: part_to_rigid_body, refine_faces_pair_inplane, del_contacts_of_inst, find_contacts,  get_constraint_type, get_constraint_info, get_interact_surface, get_msface_and_msregion, line2surface_interact, line2surface_tie, list_contacts, ms_reverse, node_region_contact, print_contacts, railedge2frame_contact, s2s_contact_std, s2s_interact_explicit, s2s_interact_std, create_self_contact,	s2s_tie, side1_faces_to_pair,	swap_interact_tie, swap_master_slave

## Load/BC: add_BC_status, apply_BC_on_RP_2D, apply_bodyforce,	apply_boltload,  apply_CF, apply_clamp_fix, apply_force, apply_frame_bolt_load_BC, apply_gravity, apply_gravity_body_force, apply_heat_flux, apply_pressure,  apply_pressure_on_lam, apply_pressure_on_frame, apply_velocity
## Load/BC: apply_disp_fix, apply_disp_symm, apply_rail_fix, apply_zero_acceleration_BC, BC_status_initiate, convert_constraint,
## Load/BC: create_new_parts_with_deformed_mesh, coupling_faces_to_point, apply_load_BC, fix_no_rotate, fix_can_rotate, get_fix_status, get_region_info, list_load_BC, modify_acceleration_BC, print_load_BC, set_temperature_BC, s2b_flux, set_temperature_predefined_field

## region命令：Surface, regionToolset.Region,
## surface like region: Interaction, Loading--FilmCondition(apply_surface_convection)
## set like region: Boundary Conditions--TemperatureBC(set_temperature_BC)
## sequence like region: Surface(Surface命令的参数是一个sequence，结果为surface like region)

## Mesh: adaptive_mesh_control, apply_adaptive_mesh, bias_seed_edges, create_mesh_part, elem_edge_facing, element_edge_select, element_select,
## Mesh:  exterior_edges_of_element, ignore_vertices, set_element_type, check_in_seeding, del_edges_seed, unmesh_part, elements_of_faces,
## Mesh: elements_region_of_faces, elements_sequence_of_faces, elements_to_labels_dict, get_edge_seeds, get_edge_esize, get_edge_enum, get_element_type,
## Mesh: elements_dict_by_face, face_and_nodes_of_element, get_mesh_control, get_part_esize, get_part_seed, get_unmeshed_region, hex_mesh,
## Mesh: labels_dict_to_elements, labels_dict_to_nodes, labels_of_nodes, list_element_type, long_short_edges_of_face, long_short_edges_of_faces
## Mesh: mapped_seed, merge_edges, mesh_2D, mesh_data, mesh_3D_TET_disp_exp, mesh_frame, mesh_lam, sort_nodes, mesh_part,mesh_region, mesh_status,
## Mesh: meshing, nodes_of_faces, nodes_region_of_faces, nodes_to_elements, nodes_to_labels_dict, remesh_region, seed_circular_edges, seed_edge, seed_edges,
## Mesh: seed_edges_of_faces, seed_section, set_element_shape, set_sweep_path, face_numbers_of_element, bias_seed_single, unmesh_region

## Job: cancel_job, create_inp, batch_file, job_info, related_jobs, restart_analysis, submit_job,	write_inp,

## viewport/Odb/Visulization: apply_view_location, average_density, chart_curves_axis_of_xyplot, check_odb, check_odb_inst, check_odb_step, check_stress, check_viewport, check_xyplot, clear_xyPlots, close_all_odbs, collect_and_write_results, collect_results, create_insts_dg, create_mdb_annotation, create_odb_annotation, close_odb, path_from_odb_nodes, create_odb_node_set,datum_off, dg_now, current_variable_setting, current_view_location, delete_all_annotations, delete_viewport_annotations,
## viewport/Odb/Visulization: edel, edel_of_frame, edel_of_glass, edel_of_set, fine_display, get_display_now, get_dpo, get_element_index_in_field, get_fontsize, get_inst_index_in_field, get_jobnum_and_runtime, get_maxElem, get_mdb_viewports, get_mode_frequency, get_nodal_result, get_odb_elements_num, get_odb_file_title, get_odb_mesh_data, get_odb_nodes_by_labels, get_output_list, get_output_list_others, get_PEEQ, get_plot_state,
## viewport/Odb/Visulization: get_result, get_stress_direction, get_main_sub_var, get_dpo_type, get_step_frame_time, value_of_current_viewport, get_viewport_annotations, get_vpnow, get_warpage, info, inst_dot_esets, leaf2insts, leaf2sets, loc_of_odb_node, lockV, low_limit, up_limit, minmax_of_step_value, minmax_value_of_step, minmax_value_of_viewport, var_to_refinement_position, odb_variables, odb_insts_names, odb_main_vars, odb_node_select, odb_node_set_to_nodes, odb_nodes_to_sequence, odb_title_of_inst, open_odb,
## viewport/Odb/Visulization: plot_all, plot_dg, plot_frequency_response, plot_nodal_path, plot_time_response, plot_variable, plot_variable0, post, post_temp, post_disp, post_temp_disp, print_leaf_history, real_odb_insts, remove_minmax, open_and_write_odb, read_odbs, res2file1, save_dg, set_decimal, set_journal_options, show_hiden_insts, suppress_hiden_insts, contour_values_vs_time, vsweep, write_odb, update_current_viewport, update_mdb_viewport, update_odb_viewport, update_all_viewports, viewport_to_image, write_results

## my global variables: my_globals

## debug functions:
## print2(*vars)
## print2('Results of',get_caller_code(),':')
## ['refresh', 17344, 'myprint', 24712] Results of myprint(part_vars) :

## fnln_fnln()
## print fnln_fnln(),'Results of',get_caller_code(),':'
##['refresh', 17344, 'myprint', 24712] Results of myprint(part_vars) :

## ln()
## print ln(),'RPxyz(p)=',RPxyz(p)
## 21601 RPxyz(p)= (0,0,0)

## fnln_fnln(to_print=True,toPrint=None)
## print fnln_fnln(),'******' + part1 + ' has been meshed, cannot mesh again.'

import __main__
from abaqus import *  ## 用于GUI界面调用时，需要关闭。
from abaqusConstants import *
from assembly import *
from caeModules import *
from cmd import *
from codecs import *
from connectorBehavior import *
import copy
import displayGroupMdbToolset as dgm
import displayGroupOdbToolset as dgo
from driverUtils import executeOnCaeStartup
import exceptions
import getpass  ## about user name
from interaction import *
import inspect		## for debug
from job import *
from jobMessage import *
from load import *
from math import *
from material import *
from mesh import *
import meshEdit
import numpy
from odbAccess import *
from odbMaterial import *
from odbSection import *
import os
from opcode import opname, HAVE_ARGUMENT
from part import *
from py_compile import compile
import platform
from random import *
import regionToolset
##from rsg.rsgGui import *   ## Import Error
from section import *
import shutil
from step import *
from sketch import *
import string
from StringIO import *
import stat
import sys
from textRepr import *		## prettyPrint for odb info
import testUtils
##from time import *	  ##??****
import time
##from Tkinter import *    ## No module named Tkinter
import traceback
import types
from visualization import *
from viewerModules import *
import win32com.client as win32
import xyPlot

imported = True

f1 = open('start.log','a')
print >>f1, 'Kernel'
f1.close()

file1 = open('start.log').readlines()
if len(file1) == 1:
	by_GUI = False
else:
	if 'GUI' in file1[-2]:
		by_GUI = True
	else:
		by_GUI = False

if by_GUI == True:
	imported = True
if len(file1) >= 4 and 'GUI' in file1[-4]:
	imported = True
if len(file1) >= 3 and 'GUI' in file1[-3]:
	imported = True

if imported == False:
	print '********************************************************************************************'
	print 'New run.'
	print ' '

	clear = True
	for job1 in mdb.jobs.values():
		if job1.status in [RUNNING,SUBMITTED]:
			clear = False
			break

	if clear == True:
		Mdb()
	else:
		mdb.Model(name='_temp', modelType=STANDARD_EXPLICIT)
		for name in mdb.models.keys():
			if name != '_temp':
				del mdb.models[name]
		mdb.models.changeKey(fromName='_temp', toName='Model-1')

	print 'clear =',clear
##	mdb.saveAs('_temp.cae')
##	save_mdb()

	if 'Viewport: 1' not in session.viewports.keys():
		session.Viewport(name='Viewport: 1', origin=(0.0, 0.0), width=280, height=180)

	session.viewports['Viewport: 1'].makeCurrent()
	session.viewports['Viewport: 1'].maximize()

	for viewport1 in session.viewports.keys():
		if viewport1 != 'Viewport: 1':
			del session.viewports[viewport1]

##_m = mdb.models.values()[0]   ## temperary
##a = _m.rootAssembly
my_globals = []	##存贮自定义全局变量的名称
function_labels = {}	## 帮助搜索合适的函数，而不是仅仅搜索函数名

_prop = prettyPrint   ## function
journal = 'findAt'	## mask, findAt

##	>>> _prop(session.paths)
##	{}
##	>>>

if 'screen_output' not in globals().keys():
	screen_output = sys.stdout

backwardCompatibility.setValues(reportDeprecated=False)  ## There may be deprecated commands that will not be supported in future release.

## you can also use set_journal_options() later
if journal == 'findAt':   ## COORDINATE, INDEX, and COMPRESSEDINDEX
	session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE)
##	session.journalOptions.setValues(replayGeometry=INDEX, recoverGeometry=INDEX)
else:  ## default = COMPRESSEDINDEX
	session.journalOptions.setValues(replayGeometry=COMPRESSEDINDEX, recoverGeometry=COMPRESSEDINDEX)

##raise Exception

vpnow = session.viewports[session.currentViewportName]
vpnow.odbDisplay.commonOptions.setValues(deformationScaling=UNIFORM, uniformScaleFactor=1,visibleEdges=FEATURE)

if 'aba_globals' not in globals().keys():  ## 第一次运行有效
	aba_globals = globals().keys()

##def changing():
##	pass
##	return

changing1 = changing

class Codeline:   ## property包括：filename,frame_name,command_lineno, final_command
	pass



def seat():
	## for rotary cutter in laptop

	leaf = dgo.Leaf(leafType=DEFAULT_MODEL)
	session.viewports['Viewport: 1'].odbDisplay.displayGroup.replace(leaf=leaf)

	session.viewports['Viewport: 1'].view.setValues(session.views['Front'])
	session.viewports['Viewport: 1'].view.setValues(session.views['Front'])
	session.viewports['Viewport: 1'].view.setProjection(projection=PARALLEL)
	session.viewports['Viewport: 1'].view.setValues(session.views['Iso'])
	session.viewports['Viewport: 1'].view.setValues(nearPlane=496.502,
	    farPlane=1046.09, cameraPosition=(715.829, 493.798, 307.168),
	    cameraTarget=(270.523, 48.4909, -138.139))
	session.viewports['Viewport: 1'].view.setValues(nearPlane=488.594,
	    farPlane=983.088, cameraPosition=(647.456, 18.0096, 534.086),
	    cameraUpVector=(-0.0745249, 0.951805, -0.297511), cameraTarget=(270.523,
	    48.491, -138.139))
	session.viewports['Viewport: 1'].view.setValues(nearPlane=485.568,
	    farPlane=990.723, cameraPosition=(600.146, 454.081, 420.292),
	    cameraUpVector=(-0.377617, 0.600592, -0.704766), cameraTarget=(272.802,
	    27.4811, -132.656))
	session.viewports['Viewport: 1'].view.setValues(cameraPosition=(602.93,
	    433.951, 434.174), cameraTarget=(275.586, 7.35077, -118.774))
	session.viewports['Viewport: 1'].view.setValues(cameraPosition=(585.058,
	    443.334, 437.515), cameraTarget=(257.714, 16.7341, -115.433))
	session.viewports['Viewport: 1'].view.setValues(nearPlane=485.568,
	    farPlane=990.722, cameraPosition=(595.837, 437.952, 435.286),
	    cameraTarget=(268.493, 11.3526, -117.662))
	session.viewports['Viewport: 1'].view.setValues(nearPlane=489.495,
	    farPlane=958.506, cameraPosition=(519.397, 362.752, 520.784),
	    cameraUpVector=(-0.299463, 0.690111, -0.658839), cameraTarget=(271.926,
	    14.7296, -121.501))
	session.viewports['Viewport: 1'].view.setValues(nearPlane=482.045,
	    farPlane=965.956, cameraPosition=(535.105, 363.436, 514.361),
	    cameraTarget=(287.634, 15.4139, -127.924))

	save_image()

	return

def set_annotation(fitview=False):
	## VER: 2014-08-25, v1.4
	## dont' run this function in each save_image()
	## Viewport - > Viewport annotation options -> Legend -> Fontsize

	## 10.23: set_annotation()不会使密度结果消失。

	vpnow = get_vpnow()
	print fnln(),'vpnow.name=',vpnow.name
##	print fnln(),'fontsize=',fontsize

	type1 = get_dpo_type()
	if type1 in ['ASSEMBLY','PART']:
		vpnow.viewportAnnotationOptions.setValues(compass=OFF,triad=ON, triadPosition=(90, 65))
		vpnow.assemblyDisplay.geometryOptions.setValues(datumPlanes=OFF,datumPoints=OFF, datumAxes=OFF, datumCoordSystems=ON, referencePointLabels=ON, referencePointSymbols=ON)
		vpnow.viewportAnnotationOptions.setValues(compass=OFF,triad=ON, triadPosition=(90, 65))
		vpnow.partDisplay.geometryOptions.setValues(datumPlanes=OFF,datumPoints=OFF, datumAxes=OFF,referencePointLabels=ON, referencePointSymbols=ON)

	elif type1 == 'ODB':
		vpnow.odbDisplay.contourOptions.setValues(numIntervals=10)
		vpnow.viewportAnnotationOptions.setValues(compass=OFF,triad=ON, triadPosition=(90, 65))
		vpnow.viewportAnnotationOptions.setValues(legend=ON,legendBox=OFF, legendPosition=(1, 99), title=OFF, state=OFF,statePosition=(60, 90))
		vpnow.viewportAnnotationOptions.setValues(legendFont='-*-verdana-medium-r-normal-*-*-' + str(fontsize) + '0-*-*-p-*-*-*')   ## 字体大小13
		vpnow.viewportAnnotationOptions.setValues(stateFont='-*-verdana-medium-r-normal-*-*-110-*-*-p-*-*-*')

	globals()['_set_annotation'] = True
##	if fitview == True:
##		vpnow.view.fitView()

	return

function_labels['set_background'] = 'gradient','color','background','graphics'
def set_background(mode='gradient'):
	## VER: 2016-11-25, v1.2
	## 默认为gradient

##	>>> set_background('blue')
##	>>> set_background('white')
##	>>>

	mode = totext(mode).lower()
	if mode == 'white':  ## 后处理时，设置背景为白色之后，可以不用保存图片而直接保存。
		session.graphicsOptions.setValues(backgroundStyle=SOLID, backgroundColor='#FFFFFF', translucencyMode=1,backgroundOverride=OFF)
	elif mode == 'blue':  ## abaqusBlue
		session.graphicsOptions.setValues(backgroundColor= '#003366', backgroundBottomColor='#003366')  ## 都为blue，相当于solid blue
	else:  ## default gradient, for RGB中的R: 1B=1*16+11 = 27, A3=10*16+3=163
		session.graphicsOptions.setValues(backgroundStyle=GRADIENT, backgroundColor= '#1B2D46', backgroundBottomColor = '#A3B1C6', translucencyMode=1, backgroundOverride=OFF)

	return

def set_white():
	## VER: 2016-11-28, v1.0
	set_background('white')

##	>>> set_white()
##	>>> unset_white()
##	>>>

	return

def unset_white():
	## VER: 2016-11-28, v1.0
	set_background('gradient')

##	>>> set_white()
##	>>> unset_white()
##	>>>

	return

##def settings():
##	## VER: 2013-08-23, v1.0, use datum_off() instead, may cause error or slow run
##
####	set_background()
##	vpnow = get_vpnow()
##
## 	##Setting
##	session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE)
####	session.journalOptions.setValues(replayGeometry=INDEX,recoverGeometry=INDEX)
##	vpnow.view.setProjection(projection=PARALLEL)
##
##	vpnow.viewportAnnotationOptions.setValues(compass=OFF,triad=ON, state=ON, legend=ON,title=OFF,
##		legendBox=OFF, legendPosition=(1, 99),statePosition=(60, 90), triadPosition=(90, 65))
##	vpnow.viewportAnnotationOptions.setValues(legendNumberFormat=FIXED,legendDecimalPlaces=2)
##	vpnow.viewportAnnotationOptions.setValues(legendFont='-*-verdana-medium-r-normal-*-*-' + str(fontsize) + '0-*-*-p-*-*-*')   ## 字体大小13
####	vpnow.view.setValues(nearPlane=1901.93, farPlane=3608.61, width=1811.86, height=902.959, cameraPosition=(1537.4, -1673.83, 1532.79), cameraUpVector=(-0.507999, 0.631337, 0.585961))
####	vpnow.setColor(colorMapping=vpnow.colorMappings['Material'])
####	vpnow.disableMultipleColors()
##
##	vpnow.partDisplay.geometryOptions.setValues(datumPlanes=OFF,datumPoints=OFF, datumAxes=OFF,referencePointLabels=ON, referencePointSymbols=ON)
##	vpnow.partDisplay.setValues(mesh=ON)
##	vpnow.partDisplay.meshOptions.setValues(meshTechnique=ON)
####	vpnow.partDisplay.setValues(renderStyle=SHADED)   ##  This function will cause error for batch run (database is cleared thus cannot shade)
##
##	vpnow.assemblyDisplay.geometryOptions.setValues(datumPlanes=OFF,datumPoints=OFF, datumAxes=OFF, datumCoordSystems=ON, referencePointLabels=ON, referencePointSymbols=ON)
####	vpnow.assemblyDisplay.setValues(renderStyle=SHADED)   ##  This function will cause error for batch run (database is cleared thus cannot shade)
##	vpnow.assemblyDisplay.geometryOptions.setValues(geometryEdgesInShaded=ON)
##
##	##vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName=GLOBAL, mirrorAboutXzPlane=True, mirrorAboutYzPlane=True)
##	vpnow.odbDisplay.commonOptions.setValues(deformationScaling=UNIFORM, uniformScaleFactor=1,visibleEdges=FEATURE)
##	vpnow.odbDisplay.commonOptions.setValues(deformationScaling=UNIFORM,visibleEdges=FEATURE)
##	vpnow.odbDisplay.contourOptions.setValues(numIntervals=12)
##	vpnow.odbDisplay.contourOptions.setValues(maxAutoCompute=ON)
##	vpnow.odbDisplay.basicOptions.setValues(averageOnlyDisplayed=True)  ##??
##	vpnow.odbDisplay.contourOptions.setValues(contourEdges=ON)
####	vpnow.odbDisplay.contourOptions.setValues(contourEdges=ON, contourEdgeColor='#000000')	## 等值线
##
##	## symbol plot for principal stress
##	vpnow.odbDisplay.symbolOptions.setValues(symbolDensity=2.5, arrowScaleMode=MODEL_SIZE, tensorLineThickness=THICK)
##	##vpnow.odbDisplay.symbolOptions.setValues(tensorLineThickness=THICK)
##	##vpnow.odbDisplay.symbolOptions.setValues(arrowSymbolSize=12)
##
##	session.animationController.animationOptions.setValues(frameRate=20)
##
##	 ## Button of right()
##	session.View(name='User-3', nearPlane=1860.2, farPlane=5580.5, width=1598.8,
##	    height=1118.1, projection=PARALLEL, cameraPosition=(5930.4, 1196.7,
##	    -532.45), cameraUpVector=(0, 0, 1), cameraTarget=(2210, 1196.7, -532.45),
##	    viewOffsetX=0, viewOffsetY=0, autoFit=ON)
##
##	 ## Button of iso()
##	session.View(name='User-1', nearPlane=1566.6, farPlane=4699.9, width=489.33,
##	    height=559.18, projection=PERSPECTIVE, cameraPosition=(2437.1, -951.39,
##	    1129), cameraUpVector=(-0.4, 0.8, 0.45), cameraTarget=(-0.73107, -97.634,
##	    -644.53), viewOffsetX=0, viewOffsetY=0, autoFit=ON)
##
##	 ## Button of left()
##	session.View(name='User-2', nearPlane=1433, farPlane=4299.1, width=111.91,
##	    height=754.06, projection=PERSPECTIVE, cameraPosition=(-2823.5, -105,
##	    -707.5), cameraUpVector=(0, 0, 1), cameraTarget=(42.5, -105, -707.5),
##	    viewOffsetX=0, viewOffsetY=0, autoFit=ON)
##
####	session.saveOptions(directory=CURRENT)
##
##
##	return

def show_findAt_location():
	session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE)   ## eg.    pickedRegions = f.findAt(((9.302743, -0.229733, 0.0), ))
	return

def iso():
	## VER: 2010-01-01

	vpnow = get_vpnow()

	vpnow.view.setValues(nearPlane=6399.41,
	    farPlane=12130, cameraPosition=(8675.15, -3128.21, 5572.87),
	    cameraUpVector=(-0.4, 0.8, 0.45))
	vpnow.maximize()
##	vpnow.view.fitView()

	return

def labels_to_elements(poi,labels):
	## VER: 2016-12-07, v1.0

	poi = check_poi(poi)
	labels = tolist(labels)

	elems = []
	dict1 = elem_label_to_index(poi)
	for label in labels:
		index = dict1[label]
		elem = poi.elements[index]
		if elem not in elems:
			elems.append(elem)

	return elems

def labels_to_nodes(poi,labels):
	## VER: 2016-11-2, v1.0
	## node[index:label]  label = index + 1

	## nodes = labels_to_nodes(get_p1(),labels)
	## Example: light(labels_to_nodes(get_p1(),labels=[167, 629, 2821, 7910]))

	poi = check_poi(poi)
	labels = tolist(labels)
	nodes = []
	for label in labels:
		node = poi.nodes[label-1]
		nodes.append(node)

	return nodes

def landscape():
	## VER: 2012-01-11, v1.0 组件横着安装，压块在长边。

	vpnow = get_vpnow()
	vpnow.view.setValues(session.views['User-1'])

	vpnow.view.setValues(nearPlane=3725.7,
		farPlane=5638.34, width=2329.74, height=1054.12, cameraPosition=(3977.88,
		-584.301, 2402.24), cameraUpVector=(-0.932074, 0.0627281, 0.356795),
		viewOffsetX=110.351, viewOffsetY=-73.2743)

	vpnow.maximize()
##	vpnow.view.fitView()

	return

def left():

	vpnow = get_vpnow()
	vpnow.view.setValues(session.views['Left'])
	vpnow.view.setValues(cameraUpVector=(0, 0, 1))
	vpnow.maximize()
##	vpnow.view.fitView()

def right():

	vpnow = get_vpnow()
	vpnow.view.setValues(session.views['Right'])
	vpnow.view.setValues(cameraUpVector=(0, 0, 1))
	vpnow.maximize()
##	vpnow.view.fitView()

###=========================================

function_labels['angle_between_query_elements'] = 'angle','insert','element face','abaqus.rpy','file','query','pick'
def angle_between_query_elements():
	## VER: 2017-06-15, v1.0
	## Please query the angle between two elements in GUI, repeatedly 反复地query任意两个单元之间的夹角，然后获得这些夹角的平均值的补角。
	## 如果两个角的和是一个直角（90deg),那么称这两个角互为余角,简称互余,也可以说其中一个角是另一个角的余角
	## 如果两个角的和是一个平角(180deg)，那么这两个角叫互为补角．其中一个角叫做另一个角的补角
	## Query时：display all显示成display elements faces, 旁边的选项按钮选择:Select the entity closest to the screen; Select from exterior entities

	file1 = open(get_rpy()).readlines()

	angles = []
	num = 0
	started = False
	ended = False
	for i in range(len(file1) -1, -1, -1):
		num += 1
		if num > 200:
			break

		code = file1[i]  ## no change line mark

		if code.startswith('  ') or code.startswith('session.viewports['):
			continue

		if code.startswith('#: The angle between the arrows is'):
			if started == False:
				started = True
			loc = code.rfind('degrees')
			code = code[:loc].strip()

			loc = code.rfind(' ')
			angle1 = code[loc:]
			angle1 = eval(angle1.strip())
##			print 'angle1=',angle1
			angles.append(angle1)
		else:
			if started == True:
				break
			elif num > 100:
				break

	if len(angles) == 0:
		raise Exception('*** Please query the angle between two elements in GUI.')

	angles.reverse()
	print 'angles=',angles
	newlist = []
	for i in range(len(angles)):
		newlist.append(180 - angles[i])
	angles = newlist
	print 'real angles=',angles

	angle = round(sum(angles)/len(angles),4)
	minutes = (angle - int(angle))*60
	minutes = int(minutes)
	print ' '
	print fnln(),'average angle =',str(int(angle)) + 'deg' + str(minutes) + "'"

	return angle

function_labels['angle_of_elements'] = 'normal','vector'
def angle_of_elements(elems1,elems2):
	## VER: 2016-12-07, v1.0
	## create element sets in GUI, then get the labels of these elements


##	>>> angle_of_elements('elems1','elems2')
##	['get_p1', 39436] Created global var p1. You can use in GUI command.
##	['get_p1', 39437] p1.name= OB_0
##
##	*** This is an corner/edge element
##	Average by 39 angles
##	89.452
##	>>>

	## job#: A0177
##	>>> e1 = elements_to_labels(set2objs(p1,'Set-1'))
##	>>> e2 = elements_to_labels(set2objs(p1,'Set-2'))
##	refresh()
##	get_p1()
##	nodes1 = labels_to_elements(p1,e1)
##	nodes2 = labels_to_elements(p1,e2)
##	nodes3 = labels_to_elements(p1,e3)
##	nodes4 = labels_to_elements(p1,e4)
##	nodes5 = labels_to_elements(p1,e5)
##	nodes6 = labels_to_elements(p1,e6)
##	nodes7 = labels_to_elements(p1,e7)
##	nodes8 = labels_to_elements(p1,e8)
##	nodes9 = labels_to_elements(p1,e9)
##	nodes10 = labels_to_elements(p1,e10)
##	nodes11 = labels_to_elements(p1,e11)
##	nodes12 = labels_to_elements(p1,e12)
##
##	a1 = 180-angle_of_elements(nodes1,nodes2)
##	a2 = 180-angle_of_elements(nodes3,nodes4)
##	a3 = 180-angle_of_elements(nodes5,nodes6)
##	a4 = 180-angle_of_elements(nodes7,nodes8)
##	a5 = 180-angle_of_elements(nodes9,nodes10)
##	a6 = 180-angle_of_elements(nodes11,nodes12)
##
##	angles = [a1,a2,a3,a4,a5,a6]
##	avg = round(sum(angles)/6,3)


	if type_of(elems1) == 'STR' or type_of(elems2) == 'STR':
		p1 = get_p1()
		if type_of(elems1) == 'STR':
			elems1 = set2objs(p1,name=elems1)
		if type_of(elems2) == 'STR':
			elems2 = set2objs(p1,name=elems2)

	elems1 = tolist(elems1)
	elems2 = tolist(elems2)

	elems1 = exterior_elements(elems1)
	elems2 = exterior_elements(elems2)

	num1 = len(elems1)
	num2 = len(elems2)
	if num1 == 0 or num2 == 0:
		raise Exception('*** element surface is required.')

	num = min(num1,num2)

	angles = []
	for i in range(num):
		e1 = elems1[i]
		e2 = elems2[i]
		vector1 = normal_vector_of_element(e1)
		vector2 = normal_vector_of_element(e2)
		if vector1 != None and vector2 != None:
			angle = vector_angle(vector1=vector1,vector2=vector2,absolute=False,print_info=False)
			angles.append(angle)

	if len(angles) > 0:
		angle = sum(angles)/len(angles)
		angle = round(angle,3)
		print 'Averaged by',num,'angles'
	else:
		angle = None
		print 'Elements should have only one exterior surface.'

	return angle

function_labels['angle_of_pick_nodes'] = 'vector','pick','point','displayGroup','axis','dg'
def angle_of_pick_nodes(nodes=None,axis=None,indexs=None,labels=None,indices=None,indexes=None,p1=None,rest=False):
	## VER: 2016-12-06, v1.2
	## pick nodes in displaGroup and save the displayGroup.
	## 注意：在GUI下，query angle，选择两个element face，所得到的角度相当于rest=True的情形，即补角

	## 如果在几何模型下，可以直接query两条edge之间的夹角。
	## 对于网格模型，选择两个节点（可以相距很远），就想象地组成一条line。类似地选择另外两个节点组成另外一条line。求这两条line之间的夹角。
	## 方法：create display group->nodes->pick from viewport->edit selection->pick one or two nodes->Done->add selection->pick another one or two points->Done ->Save selection as->OK->查rpy文件，有编号。
	## or query 4 nodes to write down the labels, line1=node1,node2; line2=node3,node4. node1,node2不受起始点和终点的困扰。node3,node4也是。

##	>>> angle_of_pick_nodes(axis='x')  ## pick only two nodes in displayGroup
##	pick1= [mdb.models['Model-1'].parts['side1'].nodes[10603], mdb.models['Model-1'].parts['side1'].nodes[12001]]
##
##	['angle_of_pick_nodes', 796] angle= 89.966
##	['angle_of_pick_nodes', 797] 180-angle= 90.034
##	89.966
##	>>> pick1
##	[mdb.models['Model-1'].parts['side1'].nodes[10603], mdb.models['Model-1'].parts['side1'].nodes[12001]]
##	>>>

##	>>> angle_of_pick_nodes()
##	pick1= [mdb.models['Model-1'].parts['OB_0'].nodes[823], mdb.models['Model-1'].parts['OB_0'].nodes[6754], mdb.models['Model-1'].parts['OB_0'].nodes[8480]]
##	['vector_angle', 77759] angle = 90deg24'
##	90.402
##	>>>

##	>>> angle_of_pick_nodes(indexs=[823,6754,8480])
##	['get_p1', 39403] Created global var p1. You can use in GUI command.
##	['get_p1', 39404] p1.name= OB_0
##
##	['vector_angle', 77780] angle = 90deg24'
##	['angle_of_pick_nodes', 672] 180-angle= 89.598
##	90.402
##	>>>

	if indices not in empty:
		indexs = indices
	if indexes not in empty:
		indexs = indexes

	if is_numbers(labels):
		if p1 in empty:
			p1 = get_p1()
		else:
			p1 = check_poi(p1)
		nodes = labels_to_nodes(p1,labels=labels)

	elif is_numbers(indexs):
		if p1 in empty:
			p1 = get_p1()
		else:
			p1 = check_poi(p1)
		nodes = index_to_nodes(p1,index=indexs)

	picks = 0
	if nodes in empty:
		nodes = pick_dg()
		picks = len(nodes)

	if nodes in empty:
		raise Exception('*** nodes required.')

	newlist = []
	for item in nodes:
		if is_location(item):
			newlist.append(item)
		else:
			newlist = newlist + tolist(item)

	if len(newlist) == 1:
		raise Exception('*** Error input. Two node lines, or reference axis are required.')

	if type_of(newlist[0]) == 'nodes':
		newlist1 = exterior_nodes(newlist)
		if len(newlist1) < len(newlist):
			raise Exception('*** Nodes should be exterior element nodes.')

	absolute = False
	if len(newlist) == 2:
		if axis in empty:
			raise Exception('*** two node lines, or reference axis are required.')

		axis = axis.lower()
		if axis not in ['x','y','z']:
			raise Exception('*** reference axis should be x,y or z.')

		start1 = point_loc(newlist[0])
		end1 = point_loc(newlist[1])

		if axis == 'x':
			vector2 = (1,0,0)
		elif axis == 'y':
			vector2 = (0,1,0)
		elif axis == 'z':
			vector2 = (0,0,1)

		vector1 = vector_of_two_points(start1,end1)
		absolute = True

	elif len(newlist) == 3:
		exts = []
		for node in newlist:
			if is_feature_edge_node(node):
				exts.append(node)

		if len(exts) == 1:   ## only one feature edge node
			others = unselect(newlist,exts)
			vector1,vector2 = two_vectors_of_4points(exts[0],others[0],exts[0],others[1])

		else:
			print fnln(),'Found',len(exts),'feature edge nodes'
			if picks == 3:  ## 中间点为连接点, three picks
				vector1,vector2 = two_vectors_of_4points(newlist[0],newlist[1],newlist[1],newlist[2])
			else:
				raise Exception('*** Error or confused selection')

	elif len(newlist) == 4:
		if len(nodes) == 4:
			vector1,vector2 = two_vectors_of_4points(nodes)
		elif len(nodes) == 2:
			vector1,vector2 = two_vectors_of_4points(nodes[0][0],nodes[0][1],nodes[1][0],nodes[1][1])
		else:
			raise Exception('*** Error or confused selection')

	else:
		raise Exception('*** Error or confused selection')

	angle = vector_angle(vector1=vector1,vector2=vector2,absolute=absolute)
	print fnln(),'angle=',angle
	print fnln(),'180-angle=',180-angle

	result = angle
	if rest == True:  ## 补角
		result = 180-angle

	return	result

def animate(scale=10,max=None,timestep=0.2,frame=10):
##	VER: ('VER: 2012-05-04, v1.4')

	refresh()

	print 'Usage: animate(scale=10,max=None,timestep=0.2,frame=10)'
	print 'e.g., animate(5), animate(max=143).'
##	ttl()
	print ' '

	vpnow = get_vpnow()
	if max in empty:
		vpnow.odbDisplay.contourOptions.setValues(maxAutoCompute=ON)
	else:
		vpnow.odbDisplay.contourOptions.setValues(maxAutoCompute=OFF, maxValue=max)

	session.animationController.animationOptions.setValues(
	    timeHistoryMode=TIME_BASED, timeIncrement=timestep)
	session.animationController.setValues(animationType=SCALE_FACTOR, viewports=('Viewport: 1', ))
	session.animationController.play(duration=UNLIMITED)
	session.animationController.animationOptions.setValues(frameRate=frame)
	vpnow.odbDisplay.commonOptions.setValues(uniformScaleFactor=scale)
##	session.viewports['Viewport: 1'].odbDisplay.commonOptions.setValues(visibleEdges=EXTERIOR)

	return

def set_scale(scale=1):
	## VER: 2011-01-27, v1.0

	vpnow = get_vpnow()
	vpnow.odbDisplay.commonOptions.setValues(uniformScaleFactor=scale)

	return

function_labels['del_all_curves'] = 'session','xydata','xyplot','curve','chart'
def del_all_curves():
	## VER: 2017-06-22, v1.0

	curves = session.xyDataObjects.keys()
	for curve in curves:
		del session.xyDataObjects[curve]

	print '--->All xydata have been deleted.'

	return

def del_all_models_and_odbs():
##	VER: 2013-06-11, v1.3'	## clear screen
	## VER: 2012-05-08, v1.2

	print ' '
	close_all_odbs()
	if len(session.xyDataObjects) > 0:
		for key in session.xyDataObjects.keys():
			del session.xyDataObjects[key]
	session.viewports['Viewport: 1'].setValues(displayedObject=None)

	Mdb()   ## current viewport displayed object = None
##	update_cae_model(force_show=True)
	get_current_model()

	return

def show_two_viewports():
	## VER: 2016-09-09, v1.1
	## restore()是隐藏起来的意思
	## 窗口的origin是从底部左下角开始的。
	## restore(): This method restores a maximized or minimized Viewport object to its previous size and location.

	vp1 = get_vpnow()
	vp1.makeCurrent()
	vp1.maximize()
	vp1 = get_vpnow()

	dpo = get_dpo()

	width = vp1.currentWidth		## vp1.width  不准确
	height = vp1.currentHeight
	x,y = vp1.currentOrigin  ## 当人为改变窗口之后，currentOrigin也会改变，反正就是当前的左下角。

##	print ' '
##	print fnln(),'current width=',vp1.currentWidth
##	print fnln(),'current height=',vp1.currentHeight
##	print fnln(),'current origin=',(x,y)

	half_width = round((width-0.5)/2,2)
##	print 'half_width=',half_width

	try:
		del session.viewports['Viewport: 2']
	except:
		pass
	session.Viewport(name='Viewport: 2', origin=(x+width, y), width=half_width, height=height)

	try:
		del session.viewports['Viewport: 1']
	except:
		pass
	session.Viewport(name='Viewport: 1', origin=(x, y), width=half_width, height=height)

	vp1 = session.viewports['Viewport: 1']
	vp2 = session.viewports['Viewport: 2']

##	print 'vp1.height=',vp1.height

	## 下面对origin及height的调整不能删除。
	vp1.setValues(origin=(x, y))
	vp2.setValues(origin=(x+half_width, y))

	vp1.setValues(height=height)
	vp2.setValues(height=height)

	vp1.setValues(displayedObject=dpo)
	vp2.setValues(displayedObject=dpo)

	vp1.view.setValues(session.views['Iso'])
	vp2.view.setValues(session.views['Right'])

	vp1.view.fitView()
	vp2.view.fitView()

	vp1.makeCurrent()

	vp1.view.setProjection(projection=PARALLEL)
	vp2.makeCurrent()
	vp2.view.setProjection(projection=PARALLEL)

	vp1.view.setValues(session.views['Right'])
	vp2.view.setValues(session.views['Iso'])

	vp1.makeCurrent()

	return vp1,vp2

def showedge():
	## VER: 2010-05-25
	session.viewports['Viewport: 1'].odbDisplay.commonOptions.setValues(visibleEdges=EXTERIOR)

def show_grid():
	## VER: 2013-05-22, v1.0

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) == 'sketch':
		vpnow.displayedObject.sketchOptions.setValues(grid=ON)

	return

def hide_grid():
	## VER: 2013-05-22, v1.0

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) == 'sketch':
		vpnow.displayedObject.sketchOptions.setValues(grid=OFF)

	return

def hide_set(setnames=(),insts=None):
	## VER: 2012-12-11, v1.0

	setnames = tolist(setnames)

	vpnow = get_vpnow()
	type1 = type_of(vpnow.displayedObject)
	if type1 == 'PART':
		part = vpnow.displayedObject

		sets = []
		for set1 in setnames:
			for set2 in part.sets.keys():
				if set1.upper() == set2.upper():
					sets.append(part.sets[set2])
					break

		sets = totuple(sets)
		leaf = dgm.LeafFromSets(sets=sets)
		vpnow.partDisplay.displayGroup.remove(leaf=leaf)

	elif type1 == 'ASSEMBLY':
		leaf = get_leaf_of_assembly_sets(setnames=setnames,insts=insts)
		vpnow.assemblyDisplay.displayGroup.remove(leaf=leaf)

	elif type1 == 'ODB':
		leaf = get_leaf_of_odb_sets(setname[0])
		vpnow.odbDisplay.displayGroup.remove(leaf=leaf)

	return


def hideedge():
	## VER: 2010-05-25
	session.viewports['Viewport: 1'].odbDisplay.commonOptions.setValues(visibleEdges=FREE)

def setting_display():
	## VER: 2014-07-17, v1.0

	vpnow = get_vpnow()

	## to prevent setting display for individual instances...
	dpo = get_dpo()
	if type_of(dpo) in ['NONE','ASSEMBLY']:
		vpnow.enableMultipleColors()
		vpnow.setColor(initialColor='#BDBDBD')
		cmap=vpnow.colorMappings['Assembly']
		vpnow.setColor(colorMapping=cmap)
		vpnow.disableMultipleColors()
	elif type_of(dpo) == 'PART':
		vpnow.enableMultipleColors()
		vpnow.setColor(initialColor='#BDBDBD')
		cmap=vpnow.colorMappings['Part geometry']
		vpnow.setColor(colorMapping=cmap)
		vpnow.disableMultipleColors()

	return


def hide_csys():
	## VER: 2011-12-11, v1.1

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.geometryOptions.setValues(datumCoordSystems=OFF, referencePointLabels=OFF, referencePointSymbols=OFF)
	vpnow.partDisplay.geometryOptions.setValues(datumCoordSystems=OFF, referencePointLabels=OFF, referencePointSymbols=OFF)

	return

def show_csys():
	## VER: 2011-12-11, v1.0

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.geometryOptions.setValues(datumCoordSystems=ON, referencePointLabels=ON, referencePointSymbols=ON)
	vpnow.partDisplay.geometryOptions.setValues(datumCoordSystems=ON, referencePointLabels=ON, referencePointSymbols=ON)

	return

show_axis = show_csys

def fr():

##	VER: ('VER: 2012-05-04, v1.2')

	global odb, assembly
	global _ndel, _inst

	_ndel = 0
	_inst = 'frL_A1'

	vpnow = get_vpnow()
	odb = vpnow.displayedObject
	odb = get_dpo()
	assembly = odb.rootAssembly
	display = vpnow.odbDisplay

	display.display.setValues(plotState=(CONTOURS_ON_DEF, ))
	display.contourOptions.setValues(showMaxLocation=ON)
	display.commonOptions.setValues(uniformScaleFactor=15)

	plot_variable('Mises')
	leaf = dgo.LeafFromElementSets(elementSets=('frS_A1.FRAME', 'frL_A1.FRAME', ))
	display.displayGroup.replace(leaf=leaf)

	ttl()
	iso()

	return


def replot():
	## VER: 2010-06-01, will fit view

	vpnow = get_vpnow()
	vpnow.view.fitView()
	vpnow.maximize()

	return

##repl = replot

##raise Exception

 ## ********=======================

## 三角函数
def sinD(alpha):
	## VER: 2014-02-15, v1.0, alpha in degree
	return sin(alpha/180.0*pi)

def cosD(alpha):
	## VER: 2014-02-15, v1.0, alpha in degree
	return cos(alpha/180.0*pi)

def tanD(alpha):
	## VER: 2014-02-15, v1.0, alpha in degree
	return tan(alpha/180.0*pi)

def ctanD(alpha):
	## VER: 2014-02-15, v1.0, alpha in degree
	return 1/tan(alpha/180.0*pi)

def asinD(value):
	## VER: 2014-02-25, v1.0, result in deg
	return asin(value)/pi*180

def acosD(value):
	## VER: 2014-02-25, v1.0, result in deg
	return acos(value)/pi*180

def atanD(value):
	## VER: 2014-02-25, v1.0, result in deg
	return atan(value)/pi*180

def _BC(bc1):
	## VER: 2014-08-04, v1.0

	found = False
	if bc1 in _m.boundaryConditions.keys():
		bc1 = _m.boundaryConditions[bc1]
		found = True
	elif bc1 in _m.boundaryConditions.values():
		found = True
	elif type_of(bc1) == 'STR':
		for key in _m.boundaryConditions.keys():
			if bc1 in key:
				bc1 = _m.boundaryConditions[key]
				found = True
				break

	if found == False:
		raise Exception('*** Fail to found the bc')

	return bc1

def _inst(inst):
	## VER: 2014-08-01, v1.0
	return check_inst(inst)

def _int(int1):
	## VER: 2014-08-04, v1.0

	found = False
	if int1 in _m.interactions.keys():
		int1 = _m.interactions[int1]
		found = True
	elif int1 in _m.interactions.values():
		found = True
	elif type_of(int1) == 'STR':
		for key in _m.interactions.keys():
			if int1 in key:
				int1 = _m.interactions[key]
				found = True
				break

	if found == False:
		raise Exception('*** Fail to found the interaction')

	return int1

def _load(load1):
	## VER: 2014-08-04, v1.0

	found = False
	if load1 in _m.loads.keys():
		load1 = _m.loads[load1]
		found = True
	elif load1 in _m.loads.values():
		found = True
	elif type_of(load1) == 'STR':
		for key in _m.loads.keys():
			if load1 in key:
				load1 = _m.loads[key]
				found = True
				break

	if found == False:
		raise Exception('*** Fail to found the load')

	return load1

def _obj(setname):
	## VER: 2015-06-19, v1.1

##	>>> _obj('e1')
##
##	mdb.models['Model-1'].parts['p1'].elements[141860]
##	obj.label = 47722
##	obj.index = NA.
##	Seq index = 141860 ( for list2sequence(),obj2sequence(),list2region(), create_set())
##	Parent = mdb.models['Model-1'].parts['p1']
##
##	Var name: e1
##	mdb.models['Model-1'].parts['p1'].elements[141860]
##	>>>

	dpo = get_dpo()
	if type_of(dpo) not in ['PART','ASSEMBLY']:
		print '** Please set the viewport as part or assembly type.'
		return

	if setname in dpo.sets.keys():
		poi = dpo
	else:
		poi = None

	objs = set2objs(setname,p=poi)
	obj = objs[0]

	print ' '
	print repr(obj)
	if 'label' in obj.__members__:
		print 'obj.label =',obj.label
	else:
		print 'This obj do not have obj.label.'
	if 'index' in obj.__members__:
		print 'obj.index =',obj.index
	else:
		print 'obj.index = NA.'
	print 'Seq index =',get_index(obj),'( for list2sequence(),obj2sequence(),list2region(), create_set())'
	print 'Parent =',repr(get_parent(obj))

	print ' '

	name1 = modify_string(setname,' ','_')
	name1 = modify_string(name1,'-','_')
	name1 = modify_string(name1,'.','_')
	name1 = modify_string(name1,'/','_')

	while name1.find('__') > 0:		##将所有的连续的下划线合并成一个下划线字符
		name1 = modify_string(name1,'__','_')

	globals()[name1] = obj
	print 'Var name:',name1

	return obj

def _objs(*insts):
	## VER: 2014-11-19, v1.1
	## applicable for insts

##>>> objs = _objs(carbide_A1,diamond_A1)
##>>> light(objs)

##	remove_cells = unselect(_objs(carbide_A1,diamond_A1), final_cells)
##	set2 = create_set(name='remove_cells', cells=remove_cells)

	insts = real_insts(insts)
	objs = None

	for inst in insts:
		if len(inst.cells) > 0:
			if objs in empty:
				objs = inst.cells[:]
			else:
				objs = objs + inst.cells[:]
		elif len(inst.faces) > 0:
			if objs in empty:
				objs = inst.faces[:]
			else:
				objs = objs + inst.faces[:]
		elif len(inst.edges) > 0:
			if objs in empty:
				objs = inst.edges[:]
			else:
				objs = objs + inst.edges[:]

	if objs in empty:
		raise Exception('*** Fail to get the region from insts')

	return objs

def _part(part):
	## VER: 2014-08-01, v1.0
	return check_part(part)

def _sketch(sketch):
	## VER: 2014-09-10, v1.0

	sketch = check_sketch(sketch)
	return sketch

def _geometry(sketch):
	## VER: 2015-04-17, v1.0

	sketch = check_sketch(sketch)
	return sketch.geometry

function_labels['pick'] = 'obj','light'
def pick(varname=None):
	## VER: 2017-07-24, v1.6
	## 获得最近手工创建的set的名字及其引用变量。varname是指定的变量名
	## 即使不指定varname，也将同时建立两个全局变量：v1和setname对应的全局变量。当然，如果setname='v1'，则只建立一个。然后，通过varname=v1，将v1赋值给另外一个变量

	global v1

	get_current_model()

	dpo = get_dpo()
	if type_of(dpo) not in ['PART','ASSEMBLY']:
		print '** Please set the viewport as part or assembly type.'
		return

	rpy = get_rpy()
	file1 = open(rpy).readlines()
	code1 = ''
	code2 = ''
	dpo = None

	setname = None
	num = 0
	create_line = None
	for i in range(len(file1) -1, -1, -1):
		num += 1
		if num > 300:  ## 仅搜索不多于300行。
			break

		line = file1[i]
		if '.Set(' in line and 'name=' in line and line[-2] == ')' and '#' not in line:
			code = line[:-1].strip()
##			print2('code=',code)
			code2 = code
			loc = code.find('name=')
			setname = code[loc + 6:-2]
			create_line = i
			break

		elif 'Created new' in line and 'setname=' in line and '#:' in line:
			code = line[:-1].strip()
##			print2('code=',code)
			code2 = code
			loc = code.find('setname=')
			setname = code[loc + 8:].strip()
			create_line = i
			break

	if create_line == None:
		raise Exception('*** Fail to get the line code for creating set.')

##	print fnln(),'setname=',setname

	if create_line != None:
		num = 0
		for i in range(create_line -1, -1, -1):
			num += 1
			if num > 150:  ## 仅搜索不多于150行。
				break

			line = file1[i]
			if '= mdb.models[' in line and ('.parts[' in line or '.rootAssembly' in line) and '#' not in line:
				code = line[:-1].strip()
				code1 = code

				loc = code.find(' = ')
				expression = code[loc + 3:]
				try:
					dpo	= eval(expression)
				except:
					pass

				if type_of(dpo) in ['PART','ASSEMBLY']:
					break

##	print fnln(),'setname=',setname
##	print fnln(),'dpo=',type_of(dpo)

	if setname == None and dpo == None:
		raise Exception('*** Fail to obtain the setname and dpo name.')

	objs = None
	v1 = None
##	print fnln(),'setname=',setname,', dpo=',dpo

	if dpo == None:
		print fnln(),'*** Fail to get the dpo.'
		return

	var = text2varname(setname,poi_type='object')
	objs = set2objs(dpo,setname)
	pois = get_pois(objs)
	names = poi_names(pois)

	if len(objs) > 1:
		globals()[var] = objs
		v1 = objs
	elif len(objs) == 1:
		globals()[var] = objs[0]
		v1 = objs[0]

	globals()['_pois'] = pois
	obj = objs[0]
	globals()['_poi'] = get_poi(obj)

##		light(objs)

	print code1
	print code2
	print 'Setname is',setname, ', related pois are:',names,', global variable for objs[0] is',var,', poi is _poi'
	if type_of(pois[0]) == 'PINSTANCE' and len(pois) < len(a.instances):
		print 'plot(_pois) to show only these insts'
		print ' '

##	print ' '
##	print repr(obj)
##	if 'label' in obj.__members__:
##		print 'obj.label =',obj.label
##	else:
##		print 'This obj do not have obj.label.'
##	if 'index' in obj.__members__:
##		print 'obj.index =',obj.index
##	else:
##		print 'obj.index = NA.'
##	print 'Seq index =',get_index(obj),'( for list2sequence(),obj2sequence(),list2region(), create_set())'
##	print 'Parent =',repr(get_parent(obj))

	print ' '
	print 'Variable = v1 ='

	if type_of(varname) == 'STR':
		globals()[varname] = v1
		print 'Also created global varname=',varname

	return var

read_abaqus_rpy = pick

def _pois():
	## VER: 2015-10-10, v1.2
	## 获得最近手工创建的set的名字及其引用变量。

	dpo = get_dpo()
	if type_of(dpo) not in ['PART','ASSEMBLY']:
		print '** Please set the viewport as part or assembly type.'
		return

	file1 = open(get_rpy()).readlines()
	code1 = ''
	code2 = ''
	dpo = None

	setname = None
	num = 0
	create_line = None
	for i in range(len(file1) -1, -1, -1):
		num += 1
		if num > 300:  ## 仅搜索不多于100行。
			break

		line = file1[i]
		if '.Set(' in line and 'name=' in line and line[-2] == ')' and '#' not in line:
			code = line[:-1].strip()
##			print2('code=',code)
			code2 = code
			loc = code.find('name=')
			setname = code[loc + 6:-2]
			create_line = i
			break

	if create_line != None:
		num = 0
		for i in range(create_line -1, -1, -1):
			num += 1
			if num > 20:  ## 仅搜索不多于100行。
				break

			line = file1[i]
			if '= mdb.models[' in line:
				if '.parts[' in line or '.rootAssembly' in line and '#' not in line:
					code = line[:-1].strip()
	##				print2('code=',code)
					code1 = code

					loc = code.find(' = ')
					expression = code[loc + 3:]
					try:
						dpo	= eval(expression)
					except:
						pass

					if type_of(dpo) in ['PART','ASSEMBLY']:
						break

	if setname != None and dpo != None:
		var = text2varname(setname,poi_type='object')
		objs = set2objs(dpo,setname)
		pois = get_pois(objs)
		names = poi_names(pois)

	return names

def _tie(int1):
	## VER: 2014-08-04, v1.0
	## 类似于_part(), _inst()的功能，相当于check tie

	found = False
	if int1 in _m.constraints.keys():
		int1 = _m.constraints[int1]
		found = True
	elif int1 in _m.constraints.values():
		found = True
	elif type_of(int1) == 'STR':
		for key in _m.constraints.keys():
			if int1 in key:
				int1 = _m.constraints[key]
				found = True
				break

	if found == False:
		raise Exception('*** Fail to found the cosntraint')

	return int1


def _xspace(poi):
##	VER: ('VER: 2012-08-27, v1.0')
	return poi_space(poi)[0:2]

def _yspace(poi):
##	VER: ('VER: 2012-08-27, v1.0')
	return poi_space(poi)[2:4]

def _zspace(poi):
##	VER: ('VER: 2012-08-27, v1.0')
	return poi_space(poi)[4:6]

def _xgap(p1,p2):
	## VER: 2014-07-30, v1.0

	p1 = check_poi(p1)
	p2 = check_poi(p2)

	space1 = poi_space(p1)
	space2 = poi_space(p2)

	cross = cross_of_ranges(space1[0:2],space2[0:2])

	return cross

def _ygap(p1,p2):
	## VER: 2014-07-30, v1.0

	p1 = check_poi(p1)
	p2 = check_poi(p2)

	space1 = poi_space(p1)
	space2 = poi_space(p2)

	cross = cross_of_ranges(space1[2:4],space2[2:4])

	return cross

def _zgap(p1,p2):
	## VER: 2014-07-30, v1.0

	p1 = check_poi(p1)
	p2 = check_poi(p2)

	space1 = poi_space(p1)
	space2 = poi_space(p2)

	cross = cross_of_ranges(space1[4:6],space2[4:6])

	return cross


def _xmid(poi,renew=False,csys=(0,0,0),y=None,z=None,allow_nearby=False):
	## VER: 2014-05-21, v1.4
##	>>> _zmid(nodes)
##	-2.82357
##	>>> _xmid(nodes)
##	4.77157
##	>>> _ymid(nodes)
##	-0.006995
##	>>>

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
		return _xmid_sketch(sketch)
	else:
		if is_poi(poi) == False:
			return objs_xmid(poi)

	x,y,z = real_xyz(poi,y=y,z=z)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if y in empty and z in empty:
		result = (x01+x02)/2
	else:
		if allow_nearby == True:
			if type_of(y) in numerics:
				if PK(y,y01) == 0:
					y = y01 + 0.001
				elif PK(y,y02) == 0:
					y = y02 - 0.001

			if type_of(z) in numerics:
				if PK(z,z01) == 0:
					z = z01 + 0.001
				elif PK(z,z02) == 0:
					z = z02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(y) in ['FLOAT','INT']:
			divide(temp_part,y=y)
		if type_of(z) in ['FLOAT','INT']:
			divide(temp_part,z=z)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,y=y,z=z,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,y=y,z=z)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _xmid()')

		result = (space[0] + space[1])/2
		del_parts(temp_part)

	return	result

def _ymid(poi,renew=False,csys=(0,0,0),x=None,z=None,allow_nearby=False):
	## VER: 2014-05-21, v1.4
##	>>> _zmid(nodes)
##	-2.82357
##	>>> _xmid(nodes)
##	4.77157
##	>>> _ymid(nodes)
##	-0.006995
##	>>>

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
		return _ymid_sketch(sketch)
	else:
		if is_poi(poi) == False:
			return objs_ymid(poi)

	x,y,z = real_xyz(poi,x=x,z=z)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if x in empty and z in empty:
		result = (y01+y02)/2
	else:
		if allow_nearby == True:
			if type_of(x) in numerics:
				if PK(x,x01) == 0:
					x = x01 + 0.001
				elif PK(x,x02) == 0:
					x = x02 - 0.001

			if type_of(z) in numerics:
				if PK(z,z01) == 0:
					z = z01 + 0.001
				elif PK(z,z02) == 0:
					z = z02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(x) in ['FLOAT','INT']:
			divide(temp_part,x=x)
		if type_of(z) in ['FLOAT','INT']:
			divide(temp_part,z=z)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,x=x,z=z,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,x=x,z=z)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _ymid()')

		result = (space[2] + space[3])/2
		del_parts(temp_part)

	return	result

def _zmid(poi,renew=False,csys=(0,0,0),x=None,y=None,allow_nearby=False):
	## VER: 2014-05-21, v1.4

##	>>> _zmid(nodes)
##	-2.82357
##	>>> _xmid(nodes)
##	4.77157
##	>>> _ymid(nodes)
##	-0.006995
##	>>>

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
		return _zmid_sketch(sketch)
	else:
		if is_poi(poi) == False:
			return objs_zmid(poi)

	x,y,z = real_xyz(poi,x=x,y=y)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if x in empty and y in empty:
		result = (z01+z02)/2.0
	else:
		if allow_nearby == True:
			if type_of(x) in numerics:
				if PK(x,x01) == 0:
					x = x01 + 0.001
				elif PK(x,x02) == 0:
					x = x02 - 0.001

			if type_of(y) in numerics:
				if PK(y,y01) == 0:
					y = y01 + 0.001
				elif PK(y,y02) == 0:
					y = y02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(x) in ['FLOAT','INT']:
			divide(temp_part,x=x)
		if type_of(y) in ['FLOAT','INT']:
			divide(temp_part,y=y)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,x=x,y=y,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,x=x,y=y)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _zmid()')

		result = (space[4] + space[5])/2
		del_parts(temp_part)

	return	result

def objs_xmid(objs):
	## VER: 2017-02-17, v1.0

	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	mid = (x1+x2)/2
	mid = round(mid,6)

	return mid

def objs_ymid(objs):
	## VER: 2017-02-17, v1.0

	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	mid = (y1+y2)/2
	mid = round(mid,6)

	return mid

def objs_zmid(objs):
	## VER: 2017-02-17, v1.0

	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	mid = (z1+z2)/2
	mid = round(mid,6)

	return mid

def _xmin(poi,renew=False,csys=(0,0,0),y=None,z=None,allow_nearby=False):
	## VER: 2014-10-09, v1.5

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
		loc = find_loc(sketch,y=y,groupX=MIN)
		return loc[0]
##		return _xmin_sketch(sketch)

	x,y,z = real_xyz(poi,y=y,z=z)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if y in empty and z in empty:
		result = x01
	else:
		if allow_nearby == True:
			if type_of(y) in numerics:
				if PK(y,y01) == 0:
					y = y01 + 0.001
				elif PK(y,y02) == 0:
					y = y02 - 0.001

			if type_of(z) in numerics:
				if PK(z,z01) == 0:
					z = z01 + 0.001
				elif PK(z,z02) == 0:
					z = z02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(y) in ['FLOAT','INT']:
			divide(temp_part,y=y)
		if type_of(z) in ['FLOAT','INT']:
			divide(temp_part,z=z)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,y=y,z=z,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,y=y,z=z)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _xmin()')

		result = space[0]
		del_parts(temp_part)

	return	result

def _xmin1(poi,renew=False,csys=(0,0,0),y=None,z=None):
	## VER: 2013-04-02, v1.0
	return _xmin(poi=poi,renew=renew,csys=csys,y=y,z=z) + _nearby

def _xmax1(poi,renew=False,csys=(0,0,0),y=None,z=None):
	## VER: 2013-04-02, v1.0
	return _xmax(poi=poi,renew=renew,csys=csys,y=y,z=z) - _nearby


def _xmax(poi,renew=False,csys=(0,0,0),y=None,z=None,allow_nearby=False):
	## VER: 2014-10-09, v1.5

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
##		return _xmax_sketch(sketch,y=y)
		loc = find_loc(sketch,y=y,groupX=MAX)
		return loc[0]

	x,y,z = real_xyz(poi,y=y,z=z)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if y in empty and z in empty:
		result = x02
	else:
		if allow_nearby == True:
			if type_of(y) in numerics:
				if PK(y,y01) == 0:
					y = y01 + 0.001
				elif PK(y,y02) == 0:
					y = y02 - 0.001

			if type_of(z) in numerics:
				if PK(z,z01) == 0:
					z = z01 + 0.001
				elif PK(z,z02) == 0:
					z = z02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(y) in ['FLOAT','INT']:
			divide(temp_part,y=y)
		if type_of(z) in ['FLOAT','INT']:
			divide(temp_part,z=z)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,y=y,z=z,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,y=y,z=z)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _xmax()')

		result = space[1]
		del_parts(temp_part)

	return	result

def _xmin_sketch(sketch):
	## VER: 2012-11-13, v1.0

	sketch = check_sketch(sketch)
	x1,x2,y1,y2 = space_of_sketch(sketch)
	show_sketch(sketch)

	return x1

def _xmin1_sketch(sketch):
	## VER: 2013-04-02, v1.0
	return _xmin_sketch(sketch=sketch) + _nearby

def _xmax1_sketch(sketch):
	## VER: 2013-04-02, v1.0
	return _xmax_sketch(sketch=sketch) - _nearby

def _xmax_sketch(sketch):
	## VER: 2012-11-13, v1.0

	sketch = check_sketch(sketch)
	x1,x2,y1,y2 = space_of_sketch(sketch)
	show_sketch(sketch)

	return x2

def _xmid_sketch(sketch):
	## VER: 2012-11-13, v1.0

	sketch = check_sketch(sketch)
	x1,x2,y1,y2 = space_of_sketch(sketch)
	show_sketch(sketch)

	return (x1+x2)/2

def _ymin(poi,renew=False,csys=(0,0,0),x=None,z=None,allow_nearby=False):
	## VER: 2014-12-23, v1.6
	## reference: ylocs()

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
##		return _ymin_sketch(sketch)
		loc = find_loc(sketch,x=x,groupY=MIN)
		return loc[1]

	x,y,z = real_xyz(poi,x=x,z=z)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if x in empty and z in empty:
		result = y01
	else:
		locs = ylocs(poi,x=x, z=z,pointOn=False)
		if locs not in empty:
			result = locs[0]
		else:
			raise Exception('*** Fail to get the ylocs()')

##		if allow_nearby == True:
##			if type_of(x) in numerics:
##				if PK(x,x01) == 0:
##					x = x01 + 0.001
##				elif PK(x,x02) == 0:
##					x = x02 - 0.001
##
##			if type_of(z) in numerics:
##				if PK(z,z01) == 0:
##					z = z01 + 0.001
##				elif PK(z,z02) == 0:
##					z = z02 - 0.001
##
##		temp_part = temp_part_of_poi(poi)
##		if type_of(x) in ['FLOAT','INT']:
##			divide(temp_part,x=x)
##		if type_of(z) in ['FLOAT','INT']:
##			divide(temp_part,z=z)
##
##		space = ()
##		if 'wire' not in part_shape(temp_part)[1]:
##			edges = edge_select(temp_part,x=x,z=z,mark_select=False)
##			if edges not in empty:
##				space = objs_space(edges)
##		else:
##			vertices = vertice_select(temp_part,x=x,z=z)
##			if vertices not in empty:
##				space = objs_space(vertices)
##
##		if space == ():
##			raise Exception('*** Fail to get the _ymin()')
##
##		result = space[2]
##		del_parts(temp_part)

	return	result

def _ymax(poi,renew=False,csys=(0,0,0),x=None,z=None,allow_nearby=False):
	## VER: 2014-10-09, v1.5

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
##		return _ymax_sketch(sketch)
		loc = find_loc(sketch,x=x,groupY=MAX)
		return loc[1]

	x,y,z = real_xyz(poi,x=x,z=z)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if x in empty and z in empty:
		result = y02
	else:
		if allow_nearby == True:
			if type_of(x) in numerics:
				if PK(x,x01) == 0:
					x = x01 + 0.001
				elif PK(x,x02) == 0:
					x = x02 - 0.001

			if type_of(z) in numerics:
				if PK(z,z01) == 0:
					z = z01 + 0.001
				elif PK(z,z02) == 0:
					z = z02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(x) in ['FLOAT','INT']:
			divide(temp_part,x=x)
		if type_of(z) in ['FLOAT','INT']:
			divide(temp_part,z=z)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,x=x,z=z,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,x=x,z=z)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _ymax()')

		result = space[3]
		del_parts(temp_part)

	return	result

def _ymin1(poi,renew=False,csys=(0,0,0),x=None,z=None):
	## 2013-04-02, v1.0
	return _ymin(poi=poi,renew=renew,csys=csys,x=x,z=z) + _nearby

def _ymax1(poi,renew=False,csys=(0,0,0),x=None,z=None):
	## 2013-04-02, v1.0
	return _ymax(poi=poi,renew=renew,csys=csys,x=x,z=z) - _nearby

def _ymin1_sketch(sketch):
	## 2013-04-02, v1.0
	return _ymin_sketch(sketch=sketch) + _nearby

def _ymax1_sketch(sketch):
	## 2013-04-02, v1.0
	return _ymax_sketch(sketch=sketch) - _nearby



def _ymin_sketch(sketch):
	## VER: 2012-11-13, v1.0

	sketch = check_sketch(sketch)
	x1,x2,y1,y2 = space_of_sketch(sketch)
	show_sketch(sketch)

	return y1

def _ymax_sketch(sketch):
	## VER: 2012-11-13, v1.0

	sketch = check_sketch(sketch)
	x1,x2,y1,y2 = space_of_sketch(sketch)
	show_sketch(sketch)  ## 不能省，因为前面经历的part的生成。

	return y2

def _ymid_sketch(sketch):
	## VER: 2012-11-13, v1.0

	sketch = check_sketch(sketch)
	x1,x2,y1,y2 = space_of_sketch(sketch)
	show_sketch(sketch)

	return (y1+y2)/2

def _zmin(poi,renew=False,csys=(0,0,0),x=None,y=None,allow_nearby=False):
	## VER: 2014-05-21, v1.4

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
		return _zmin_sketch(sketch)

	x,y,z = real_xyz(poi,x=x,y=y)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if x in empty and y in empty:
		result = z01
	else:
		if allow_nearby == True:
			if type_of(x) in numerics:
				if PK(x,x01) == 0:
					x = x01 + 0.001
				elif PK(x,x02) == 0:
					x = x02 - 0.001

			if type_of(y) in numerics:
				if PK(y,y01) == 0:
					y = y01 + 0.001
				elif PK(y,y02) == 0:
					y = y02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(x) in ['FLOAT','INT']:
			divide(temp_part,x=x)
		if type_of(y) in ['FLOAT','INT']:
			divide(temp_part,y=y)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,x=x,y=y,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,x=x,y=y)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _zmin()')

		result = space[4]
		del_parts(temp_part)

	return	result

def _zmax(poi,renew=False,csys=(0,0,0),x=None,y=None,allow_nearby=False):
	## VER: 2014-05-21, v1.4

	if poi in _m.sketches.values() or poi in _m.sketches.keys():
		sketch = poi
		return _zmax_sketch(sketch)

	x,y,z = real_xyz(poi,x=x,y=y)
	x01,x02,y01,y02,z01,z02 = poi_space(poi)

	if x in empty and y in empty:
		result = z02
	else:
		if allow_nearby == True:
			if type_of(x) in numerics:
				if PK(x,x01) == 0:
					x = x01 + 0.001
				elif PK(x,x02) == 0:
					x = x02 - 0.001

			if type_of(y) in numerics:
				if PK(y,y01) == 0:
					y = y01 + 0.001
				elif PK(y,y02) == 0:
					y = y02 - 0.001

		temp_part = temp_part_of_poi(poi)
		if type_of(x) in ['FLOAT','INT']:
			divide(temp_part,x=x)
		if type_of(y) in ['FLOAT','INT']:
			divide(temp_part,y=y)

		space = ()
		if 'wire' not in part_shape(temp_part)[1]:
			edges = edge_select(temp_part,x=x,y=y,mark_select=False)
			if edges not in empty:
				space = objs_space(edges)
		else:
			vertices = vertice_select(temp_part,x=x,y=y)
			if vertices not in empty:
				space = objs_space(vertices)

		if space == ():
			raise Exception('*** Fail to get the _zmax()')

		result = space[5]
		del_parts(temp_part)

	return	result

def _zmin1(poi,renew=False,csys=(0,0,0),x=None,y=None):
	## 2013-04-02, v1.0
	return _zmin(poi=poi,renew=renew,csys=csys,x=x,y=y) + _nearby

def _zmax1(poi,renew=False,csys=(0,0,0),x=None,y=None):
	## 2013-04-02, v1.0
	return _zmax(poi=poi,renew=renew,csys=csys,x=x,y=y) - _nearby

def span_of_odb_nodes(nodes,step=-1,frame=-1,dir='x'):
	## VER: 2015-06-25, v1.0
	## reference: distance_of_odb_nodes()

##	>>> span_of_odb_nodes((1296, 1167),dir='z')
##	7.969
##	>>>

##	>>> span_of_odb_nodes((1296, 1167),dir='z')
##	7.969
##	>>>
##	>>> distance_of_odb_nodes((1296, 1167),dir='z')
##	7.9688
##	>>>


	variable = None
	if dir == 'x':
		variable = 'COOR1'
	elif dir == 'y':
		variable = 'COOR2'
	elif dir == 'z':
		variable = 'COOR3'

	variable = variable.upper()
	data = xydata_of_nodes(nodes=nodes,sort=dir,step=step,frame=frame,variable=variable)

	values = []
	for k,v in data:
		values.append(v)

	min1,max1 = min(values),max(values)
	min1 = smart_round(min1)
	max1 = smart_round(max1)
	length = max1 - min1   ## range is (min1,max1)

	length = round(length,3)
##	print fnln(),'length=',length,'in',dir

	return length

function_labels['distance_between_nodes'] = 'nodes','distance','average','node set','ndir','gap'
def distance_between_nodes(nodes1,nodes2,ndir=''):
	## VER: 2016-11-17, v1.0

##	>>> distance_between_nodes('top','bot',ndir='z')
##	['get_p1', 38918] Created global var p1. You can use in GUI command.
##	['get_p1', 38919] p1.name= carmex_1
##
##	['get_p1', 38918] Created global var p1. You can use in GUI command.
##	['get_p1', 38919] p1.name= carmex_1
##
##	9.507
##	>>>

	if type_of(nodes1) == 'STR':
		nodes1 = set2objs(get_p1(),nodes1)

	if type_of(nodes2) == 'STR':
		nodes2 = set2objs(get_p1(),nodes2)

	nodes1 = randomize(nodes1)
	nodes2 = randomize(nodes2)

	ndir = ndir.lower()
	if ndir not in ['x','y','z']:
		raise Exception('*** ndir should be x,y or z')

	num = min(len(nodes1),len(nodes2))

	dists = []
	for i in range(int(num/2)):
		x1,y1,z1 = nodes1[i].coordinates
		x2,y2,z2 = nodes2[i].coordinates

		if ndir == 'x':
			dist = abs(x1-x2)
		elif ndir == 'y':
			dist = abs(y1-y2)
		elif ndir == 'z':
			dist = abs(z1-z2)
		dists.append(dist)

	dist = sum(dists)/len(dists)
	dist = round(dist,3)

	return dist

def distance_of_odb_nodes(nodes,step=-1,frame=-1,variable='',dir=None):
	## VER: 2015-11-30, v1.2
	## reference: coord_of_node(), span_of_odb_nodes()

	## distance_of_odb_nodes('dim_bigR_x')

##	>>> span_of_odb_nodes((1296, 1167),dir='z')
##	7.969
##	>>>
##	>>> distance_of_odb_nodes((1296, 1167),dir='z')
##	7.9688
##	>>>

	if dir not in empty:
		variable = dir

	if variable in [1,'x','X']:
		variable = 'COOR1'
	elif variable in [2,'y','Y']:
		variable = 'COOR2'
	elif variable in [3,'z','Z']:
		variable = 'COOR3'

	## 下面分别求出三个方向的距离
	## x dir
	data = xydata_of_nodes(nodes=nodes,sort='x',step=step,frame=frame,variable='COOR1')

	values = []
	for k,v in data:
		values.append(v)

	min1,max1 = min(values),max(values)
	min1 = smart_round(min1)
	max1 = smart_round(max1)
	dist_x = max1 - min1   ## range is (min1,max1)

	## y dir
	data = xydata_of_nodes(nodes=nodes,sort='y',step=step,frame=frame,variable='COOR2')

	values = []
	for k,v in data:
		values.append(v)

	min1,max1 = min(values),max(values)
	min1 = smart_round(min1)
	max1 = smart_round(max1)
	dist_y = max1 - min1   ## range is (min1,max1)

	## z dir
	data = xydata_of_nodes(nodes=nodes,sort='z',step=step,frame=frame,variable='COOR3')

	values = []
	for k,v in data:
		values.append(v)

	min1,max1 = min(values),max(values)
	min1 = smart_round(min1)
	max1 = smart_round(max1)
	dist_z = max1 - min1   ## range is (min1,max1)

	if variable in empty:
		distance = sqrt(dist_x*dist_x + dist_y*dist_y + dist_z*dist_z)
		distance = round(distance,3)
	elif variable == 'COOR1':
		distance = dist_x
	elif variable == 'COOR2':
		distance = dist_y
	elif variable == 'COOR3':
		distance = dist_z
	else:
		raise Exception('*** Invalid variable, should be None, COOR1, COOR2, or COOR3')

	return distance

def spans_of_poi(poi):
	## VER: 2014-06-25, v1.0

	x1,x2,y1,y2,z1,z2 = poi_space(poi)
	lenx = x2 - x1
	leny = y2 - y1
	lenz = z2 - z1

	return lenx,leny,lenz

def _lenx(poi):
	## VER: 2014-04-16, v1.1

	try:
		poi = check_poi(poi)
		result = _xmax(poi) - _xmin(poi)
	except:
		sketch = check_sketch(poi)
		x1,x2,y1,y2 = space_of_sketch(sketch)
		result = x2-x1

	return result

def _leny(poi):
	## VER: 2014-04-16, v1.1

	try:
		poi = check_poi(poi)
		result = _ymax(poi) - _ymin(poi)
	except:
		sketch = check_sketch(poi)
		x1,x2,y1,y2 = space_of_sketch(sketch)
		result = y2-y1

	return result

def _xspan_sketch(sketch):
	## VER: 2014-04-15, v1.0

	x1,x2,y1,y2 = space_of_sketch(sketch)

	return x2-x1

def _yspan_sketch(sketch):
	## VER: 2014-04-15, v1.0

	x1,x2,y1,y2 = space_of_sketch(sketch)

	return y2-y1

def _lenz(poi):
	## VER: 2013-11-30, v1.0
	return _zmax(poi) - _zmin(poi)


def add2set(part,setname,objs=None,vertices=None,edges=None,faces=None,cells=None):
	## VER: 2013-06-12, v1.2

	part = check_part(part)
	if type_of(setname) != 'STR':
		raise Exception('setname is required.')

	objs = get_real_input(objs,vertices,edges,faces,cells)
	objs = real_objs(part,objs)

	if setname in part.sets.keys():
		objs1 = set2objs(part,setname)
	else:
		objs1 = []

	objs = objs + objs1
	create_set(part,objs=objs,setname=setname,check_name=False)

	print '--->set',setname,'is updated in',part.name

	return

def add_VIP_var(var):
	## VER: 2012-01-14, v1.1, var是一个变量名，不是变量值。

	command = get_caller_code()
	command = command[:-1]
	loc = command.find('(')
	var_name = command[loc+1:]

	globals()[var_name] = var
	output_vars[var_name] = var
	write_global_variables(var_file_full,var_name)
	add2my_globals(var_name)

	return

def active_steps_of_interact(name):
	## VER: 2013-06-14, v1.0

	steps = []
	for step in _m.steps.values():
		if name in step.interactionStates.keys() and step.name != 'Initial':
			steps.append(step.name)

	return steps

function_labels['adaptive_mesh_control'] = 'volume'
def adaptive_mesh_control(name='Ada-1',smooth_priority='aspect_ratio', smooth_algorithm='enhanced', predictor='previous',
	curvature=1, weight=(1,0,0), order='first'):
	## VER: 2014-12-22, v1.2
	## Reference: apply_adaptive_mesh()
	## 先有adaptive_mesh_control()，才有apply_aptive_mesh()
	## curvature refinement=1 (default)   ## 我有时用0.05
	## weight=(volumetric,laplacian,equipptential), 默认=(1,0,0), kevin取默认
	## 有别于:Mesh模块: Adaptivity->remesh rule->generate: remesh仅适用于自由网格划分或以quad-dominate mesh or tri mesh(三角形单元)

	## Example:
##	choose_element_type(powder)
##	set_element_shape(powder, objs=_part(powder).faces, technique=SWEEP)
##	mesh_region(powder,esize=0.8)
##
##	adaptive_mesh_control()
##	apply_adaptive_mesh(elements=_inst(powder_A1).elements)	;changing

	for step1 in _m.steps.keys()[1:]:
		if _m.steps[step1].adaptiveMeshDomains.keys() not in empty:
			raise Exception('*** Please create adaptive_mesh_control() first. ')

	name = new_key(_m.adaptiveMeshControls.keys(),name)

	## smooth_priority: 平滑的目的； smooth_algolorithm：平衡算法
	## smooth objective
	smooth_priority = totext(smooth_priority).lower()
	if smooth_priority in ['uniform', 'aspect_ratio','aspect']:   ## improve aspect ratio(纵横比)
		smooth_priority = UNIFORM
	else:
		smooth_priority = GRADED   ## to keep initial mesh grading (网格梯度)

	smooth_algorithm = totext(smooth_algorithm).lower()
	if 'default' in smooth_algorithm:
		smooth_algorithm = ANALYSIS_PRODUCT_DEFAULT
	elif 'enhanced' in smooth_algorithm or 'geometry' in smooth_algorithm:
		smooth_algorithm = GEOMETRY_ENHANCED  ## Enhanced algorithm based on evolving(不断变化的) geometry,使得sweep算法更具健壮性，更好用，更牛逼
	else:
		smooth_algorithm = STANDARD

	predictor = totext(predictor).lower()
	if predictor in ['position','previous']:
		predictor = PREVIOUS   ## position from previous adative mesh increment,使用上一次remesh形成的网格节点位置来进行sweep迭代
	else:
		predictor = CURRENT   ## default in GUI, current deformed position. 使用当前节点位置来进行sweep迭代

	## curvature refinement: 高曲率边界网格密度设置
	if is_numbers(curvature) == False:    ## default = 1.0
		raise Exception('*** numeric curvature is required')

	a,b,c = weight ## default=(1,0,0)
	## volume smoothing: 体积算法。该算法十分健壮，为默认算法，大多数情况下适用。
	## laplacian smoothing: 拉普拉斯算法，相当于一阶体积算法，类似于求平均值。对于曲率比较高的曲线表面边界，效果不理想。
	## equipotential smoothing: 等位算法。基于拉普拉斯算法基础上的复杂算法，对于曲率较大的曲面边界效果较好。
	##      在节点被非结构化网格包围时，此算法为推荐算法；若节点被结构化网格包围，效果与体积算法相当。

	if a + b + c != 1.0:
		raise Exception('*** fraction in weight should add up to 1.0')

	## 静变量转换算法设置
	order = totext(order).lower()
	if order == 'first':
		order = FIRST_ORDER_ADVECTION
	else:
		order = SECOND_ORDER_ADVECTION   ## default

	_m.AdaptiveMeshControl(name=name,
		smoothingPriority=smooth_priority, smoothingAlgorithm=smooth_algorithm, ## smooth
		meshingPredictor=predictor,  ## nodal position
		curvatureRefinement=curvature,  ## curvature
		volumetricSmoothingWeight=weight[0], laplacianSmoothingWeight=weight[1], equipotentialSmoothingWeight=weight[2],
	    remapping=order)

##	>>> _m.adaptiveMeshControls.keys()
##	['Ada-1']
##	>>>

	print '--->Created adative mesh control',name
	print 'predictor=',predictor
	print 'curvature=',curvature
	print 'weight=',weight
	print 'order=',order

	return name


def add2my_globals(*names):
	## VER: 2013-06-06, v1.1

	global my_globals  ## a var name list
	## my_globals will be set to [] by every 'file-->Run Script...' for the main script.

	for name in names:
		if type_of(name) == 'STR' and name not in my_globals:
			my_globals.append(name)

	my_globals.sort()

	return

def add_BC_status(name,objs=None,insts=None, inst_names=None, DOFs=()):
	## VER: 2013-06-03, v1.2
	## please run myprint(BC_status) to see the current BC status

	global BC_status

	if BC_status.keys() in empty:
		BC_status_initiate()

	if type_of(objs) == 'STR' and type_of(name) != 'STR':
		objs,name = name,objs

	if type_of(name) != 'STR':
		raise Exception('**** BC name is required.')

	if name not in _m.boundaryConditions.keys():
		raise Exception('**** BC name is required.')

	DOFs = tolist(DOFs)

	if objs not in empty:
		insts = get_pois(objs)

	if insts not in empty:
		inst_names = poi_names(insts)

	print2('inst_names=',inst_names)

	for inst in inst_names:
		if inst not in BC_status.keys():
			BC_status_initiate()
			break

	for inst in inst_names:
		for DOF in DOFs:
			if DOF in all_DOFs:
				BC_status[inst][DOF].append(name)

	return

def add_model_from_inp(inpfile,name='Model-2',replace=False):
	## VER: 2015-03-24, v1.0
	## poi name都将是大写的部件名，而且没有几何。

	if len(mdb.models) == 1:
		replace = False

	if replace == False:
		name = new_key(mdb.models.keys(),name)
	else:
		if name in mdb.models.keys():
			del mdb.models[name]

	ext = inpfile[-4:]
	if ext.lower() != '.inp':
		inpfile = inpfile + '.inp'

	mdb.ModelFromInputFile(name=name, inputFileName=inpfile)

	vpnow = get_vpnow()
	a = mdb.models[name].rootAssembly
	vpnow.setValues(displayedObject=a)

	refresh()

	print '---> Imported new model from inp, model name =', name

	return name

def add_points(*points):
	## VER: 2016-09-26, v1.0

##	set_point0(loc0)
##	add_points(xytilt4(y=0,Ay=steel_exit_angle),loc1)
##	poly_line(s1)

	global poly_points

	if 'poly_sketch' not in globals().keys():
		raise Exception('*** run set_pt0() first')

	s1 = check_sketch(poly_sketch)
	get_locs(s1,points)

	return poly_points[-1]

def add_sketches(new_sketch=None,sketches=(),dx=0,dy=0, x1=None, x2=None, y1=None, y2=None):
	## VER: 2013-11-01, v1.2

	## Example:
##	create_base_sketch(name='s_pressed',ndir='z')
##	add_sketches('s_pressed',['s_ejector'])
##	add_sketches('s_pressed',['s_punch'],dy=PH - PFH - punch_depth)

	if new_sketch in empty and sketches in empty:
		print '**Usage: add_sketches(new_sketch=None,sketches=(),dx=0,dy=0, x1=None, x2=None, y1=None, y2=None)'
		print '         Adding new sketches to create a new sketch, you can run this command in the command window.'
		return

	if type_of(new_sketch) in ['TUPLE','LIST']:
		new_sketch,sketches = sketches, new_sketch

	if new_sketch in empty:
		new_sketch = create_base_sketch(name='s_new',ndir='z', return_sketch=True)
	elif type_of(new_sketch) == 'STR' and new_sketch not in _m.sketches.keys():
		new_sketch = create_base_sketch(name=new_sketch,ndir='z', return_sketch=True)
	new_sketch = check_sketch(new_sketch)

	if x1 not in empty:
		x1 = real_xy_sketch(new_sketch,x=x1,Xonly=True)

	if x2 not in empty:
		x2 = real_xy_sketch(new_sketch,x=x2,Xonly=True)

	if y1 not in empty:
		y1 = real_xy_sketch(new_sketch,y=y1,Yonly=True)

	if y2 not in empty:
		y2 = real_xy_sketch(new_sketch,y=y2,Yonly=True)

	if type_of(y1) in numerics and type_of(y2) in numerics:
		dy = y2 - y1

	if type_of(x1) in numerics and type_of(x2) in numerics:
		dx = x2 - x1

	geometry0 = new_sketch.geometry.values()  ## including construction lines

	sketches = tolist(sketches)
	names = []
	for sketch1 in sketches:
		if sketch1 in _m.sketches.keys():
			new_sketch.retrieveSketch(sketch=_m.sketches[sketch1])
			names.append(sketch1)
		elif sketch1 in _m.sketches.values():
			new_sketch.retrieveSketch(sketch=sketch1)
			names.append(sketch1.name)

	if dx!= 0 or dy!= 0:
		geometry = unselect(new_sketch.geometry.values(),geometry0)
		geometry = totuple(geometry)
		new_sketch.move(vector=(dx,dy), objectList=geometry)

	print '--->',len(names),'sketches are added into the new sketch',new_sketch.name

	return	new_sketch.name

def add_to_process():
	## VER: 2011-05-16, v1.1

	global find_process, s2s_process

	caller = caller_names()[-1]

	try:
		find_process.append(caller)
	except:
		pass

	try:
		s2s_process.append(caller)
	except:
		pass

	return

def addplot(*setname):
	## VER: 2010-02-15, v1.0

	vpnow = get_vpnow()
	leaf = get_leaf_of_odb_sets(setname)
	vpnow.odbDisplay.displayGroup.add(leaf=leaf)

	return

function_labels['adjacent_nodes'] = 'select','line','curve','direction','nearby','flatness','extend'
def adjacent_nodes(node1,dir1='+x'):
	## VER: 2017-06-08, v1.0

	if type_of(node1) != 'nodes':
		raise Exception('*** a node is required.')

	dir1 = dir1.lower()
	if dir1 == 'x+':
		dir1 = '+x'
	elif dir1 == 'x-':
		dir1 = '-x'
	elif dir1 == 'y+':
		dir1 = '+y'
	elif dir1 == 'y-':
		dir1 = '-y'
	elif dir1 == 'z+':
		dir1 = '+z'
	elif dir1 == 'z-':
		dir1 = '-z'

	edges = node1.getElemEdges()
	nodes1 = []
	for edge in edges:
		nodes0 = list(edge.getNodes())
		nodes1 = nodes1 + nodes0
	nodes1 = remove_repeated_items(nodes1)
	nodes1 = exterior_nodes(nodes1)
	nodes1 = unselect(nodes1,node1)

	newlist = []
	x1,y1,z1 = node1.coordinates
	for node in nodes1:
		x0,y0,z0 = node.coordinates
		if dir1 == '+x' and x0 - x1 > 0.05:		## changing
			newlist.append(node)
		elif dir1 == '-x' and x1 - x0 > 0.05:		## changing
			newlist.append(node)
		elif dir1 == '+y' and y0 - y1 > 0.05:		## changing
			newlist.append(node)
		elif dir1 == '-y' and y1 - y0 > 0.05:		## changing
			newlist.append(node)
		elif dir1 == '+z' and z0 - z1 > 0.05:		## changing
			newlist.append(node)
		elif dir1 == '-z' and z1 - z0 > 0.05:		## changing
			newlist.append(node)

	nodes1 = newlist

	return nodes1

def adjust_instance_by_rotate(inst,nodeset,target='x',about='y'):
	## VER: 2015-07-23, v1.0

	## Example:
	## adjust_instance_by_rotate('ins1',nodeset='DIM_SMALLR_X',about='y')

##	partname = import_part_from_odb(prefix='dim_')
##	instname = new_instance(partname)
##	adjust_instance_by_rotate(instname,nodeset='DIM_SMALLR_X',about='y')
##	refresh()
##	inst1 = a.instances.keys()[0]
##
##	nodes = nodes_by_face(inst1,ny=1,y=MAX)
##	space = objs_space(nodes)
##	xlength1 = space[1]-space[0]

	inst = check_inst(inst)
	nodes = set2objs(poi=inst,setname=nodeset)

	target = target.lower()
	if target not in ['x','y','z']:
		raise Exception('*** Target direction should be x,y,or z')

	about = about.lower()
	if about not in ['x','y','z']:
		raise Exception('*** About direction should be x,y,or z')

	if about == target:
		raise Exception('*** target direction can not the same as rotation about axis')

	angle = vector_angle(start=nodes[0],end=nodes[1],axis=target)

	if about == 'x':
		rotate_instances(inst,angle_x=angle)
	elif about == 'y':
		rotate_instances(inst,angle_y=angle)
	elif about == 'z':
		rotate_instances(inst,angle_z=angle)

	return

def all_equal(*values):
	## VER: 2013-10-01, v1.0

	values = tolist(values)
	if len(values) < 2:
		raise Exception('*** At least two values are required.')

	if all_is_value(values,values[0]):
		same = True
	else:
		same = False

	return same

def all_is(*list1):
	## VER: 2011-11-07, v1.0

	list1 = tolist(list1)
	if type_of(list1) != 'LIST':
		list1 = [list1]

	if len(list1) <= 1:
		raise Exception('At least two elements are required.')

	result = list1[0]
	item = list1[0]
	for i in range(1,len(list1)):
		if list1[i] != item:
			result = 'different'
			break

	return result

##def is_empty_lists(*lists):
####	VER: ('2012-06-25, v1.2')
##
##	lists = tolist(lists)
##	if type_of(lists) != 'LIST':
##		raise Exception('lists, or tuples are required.')
##	elif type_of(lists[0]) not in ['LIST','TUPLE']:
##		raise Exception('lists, or tuples are required.')
##
##	result = True
##	for list1 in lists:
##		if is_empties(list1) == False:
##			result = False
##			break
##
##	return result

def all_regular_geometry(sketch):
	## VER: 2013-11-18, v1.0, all geometry = regular geometry + construction geometry

	sketch = check_sketch(sketch)

	curves = []
	for curve in sketch.geometry.values():
		if 'construction' not in type_of(curve):
			curves.append(curve)

	curves = totuple(curves)

	return curves

def all_lists_not_empty(*lists):
	## 2011-11-09, v1.1

	lists = tolist(lists)
	if type_of(lists) != 'LIST':
		raise Exception('lists, or tuples are required.')
	elif type_of(lists[0]) not in ['LIST','TUPLE']:
		raise Exception('lists, or tuples are required.')

	result = True
	for list1 in lists:
		if is_empties(list1) == True:
			result = False
			break

	return result

def apply_velocity(name='velocity', insts=None, cells=None, faces=None, edges=None, region=None, RP=None,Vx=0, Vy=0, Vz=0, VR1=0, VR2=0, VR3=0, step='step1',deactive_step=None):
	## VER: 2017-10-25, v1.5, angular velocity: in radians/sec
	## region is set-like region
	## Can be used in a general static step, applying a velocity

##	apply_velocity(name='pull_speed',RP='wire_A1', Vy=speed, step='step2')	;把速度加载在参考点上

##	faces = face_select('shaft_A1',y=MIN)
##	apply_velocity('move',faces=faces, Vy=50,step='step3')	## 50*0.1(period) = 5mm, but usually time period is very short, such as 1e-3sec

	if type_of(region) == 'STR' and region in a.sets.keys():
		region = a.sets[region]

	if RP not in empty:
		if is_inst(RP):
			inst = check_inst(RP)
			if len(inst.referencePoints) > 0:	## 这样的RP是在part模块建立的。否则属于a.referencePoints
				RP = inst.referencePoints.values()[0]
			else:
				RP = create_RP(inst)

	if region in empty:
		if insts not in empty:
			insts = real_insts(insts)
			region = insts_to_region(insts,info='velocity')

		else:
			objs = get_real_input(cells, faces, edges,RP)
			region = create_set(objs=objs,info='velocity')

	step = check_step(step)

	if Vx == 0:
		Vx=UNSET
	if Vy == 0:
		Vy = UNSET
	if Vz == 0:
		Vz = UNSET
	if VR1 == 0:
		VR1 = UNSET
	if VR2 == 0:
		VR2 = UNSET
	if VR3 == 0:
		VR3 = UNSET

	shape = is_2D_or_3D()

	if step != 'Initial':  ## constant velocity, apply as BC
##		name = new_key(_m.boundaryConditions.keys(), name)
		name = formatted_name(_m.boundaryConditions, name)
		if shape == '2D':
			_m.VelocityBC(name=name, createStepName=step, region=region, v1=Vx, v2=Vy,
				vr3=VR3, amplitude=UNSET, localCsys=None, distributionType=UNIFORM, fieldName='')
			print fnln(),'--->Applied velocity:', name, ', Vx=', Vx, ', Vy=', Vy, ', VR3=', VR3, ', step=',step

		elif shape == '3D':
			_m.VelocityBC(name=name, createStepName=step, region=region, v1=Vx, v2=Vy, v3=Vz,
				vr1=VR1, vr2=VR2, vr3=VR3, amplitude=UNSET, localCsys=None, distributionType=UNIFORM, fieldName='')
			print fnln(),'--->Applied velocity:', name, ', Vx=', Vx, ', Vy=', Vy, ', Vz=', Vz, ', VR1=', VR1,', VR2=', VR2,', VR3=', VR3, ', step=',step

	else:  ## Initial velocity, apply as predefinedFields
##		name = new_key(_m.predefinedFields.keys(),name)
		name = formatted_name(_m.predefinedFields.keys(),name)
		Vx = unset2zero(Vx)
		Vy = unset2zero(Vy)
		Vz = unset2zero(Vz)
		omega = 0	## angular speed

		if shape == '2D':
			omega = unset2zero(VR3)   ## omega cannot be UNSET
			if (abs(Vx) > 0 or abs(Vy) > 0) and omega == 0:
				_m.Velocity(name=name, region=region, field='', distributionType=MAGNITUDE,
					velocity1=Vx, velocity2=Vy)
			elif (abs(Vx) == 0 and abs(Vy) == 0) and abs(omega) > 0:    ## can only rotate about z axis
				_m.Velocity(name=name, region=region, field='', distributionType=MAGNITUDE,
					omega=omega, axisBegin=(0.0, ))
			else:
				_m.Velocity(name=name, region=region, field='', distributionType=MAGNITUDE,
					velocity1=Vx, velocity2=Vy, omega=omega, axisBegin=(0.0, ))

		elif shape == '3D':
			if type_of(VR1) in numerics:
				omega = VR1   ## axis in x direction, y-z-x
				axis_point1 = (0,0,0)
				axis_point2 = (1,0,0)
			elif type_of(VR2) in numerics:
				omega = VR2		## axis in y direction, z-x-y
				axis_point1 = (0,0,0)
				axis_point2 = (0,1,0)
			elif type_of(VR3) in numerics:		## axis in z direction, x-y-z
				omega = VR3
				axis_point1 = (0,0,0)
				axis_point2 = (0,0,1)

			omega = unset2zero(omega)   ## omega cannot be UNSET
			if (abs(Vx) > 0 or abs(Vy) > 0 or abs(Vz) > 0) and omega == 0:
				_m.Velocity(name=name, region=region, field='', distributionType=MAGNITUDE,
					velocity1=Vx, velocity2=Vy, velocity3=Vz)
			elif abs(Vx) == 0 and abs(Vy) == 0 and abs(Vz) ==0 and abs(omega) > 0:
				_m.Velocity(name=name, region=region, field='', distributionType=MAGNITUDE,
					omega=omega, axisBegin=axis_point1, axisEnd=axis_point2)
			else:
				_m.Velocity(name=name, region=region, field='', distributionType=MAGNITUDE,
					velocity1=Vx, velocity2=Vy, velocity3=Vz, omega=omega, axisBegin=axis_point1, axisEnd=axis_point2)

	if deactive_step not in empty:
		deactive_step = check_step(deactive_step)
		_m.boundaryConditions[name].deactivate(deactive_step)

	return name

def apply_view_location(locs):
	## VER: 2014-04-11, v1.0

	if type_of(locs) != 'DICT':
		raise Exception('*** locations dict is required.')

	vpnow = get_vpnow()
	for k, v in locs.items():
		str1 = 'vpnow.view.setValues(' + k + '=' + repr(v) + ')'
		try:
			exec(str1)
		except:
			pass

##	vpnow = get_vpnow()
##	vpnow.view.setValues(cameraPosition=view.cameraPosition, cameraTarget=view.cameraTarget, cameraUpVector=view.cameraUpVector,
##		farPlane=view.farPlane, farPlaneMode=view.farPlaneMode,
##		height=view.height, nearPlane=view.nearPlane, projection=view.projection, viewOffsetX=view.viewOffsetX,
##		viewOffsetY=view.viewOffsetY, width=view.width)
##
##({'cameraPosition': 'tuple object',
##  'cameraTarget': 'tuple object',
##  'cameraUpVector': 'tuple object',
##  'displayedObjectScreenHeight': 265.901,
##  'displayedObjectScreenWidth': 197.35,
##  'farPlane': 132.977,
##  'farPlaneMode': AUTOCOMPUTE,
##  'fieldOfViewAngle': 10.0882,
##  'height': 7.49293,
##  'movieMode': OFF,
##  'nearPlane': 103.338,
##  'projection': PERSPECTIVE,
##  'viewOffsetX': 10.8936,
##  'viewOffsetY': -7.31359,
##  'viewVector': 'tuple object',
##  'width': 18.242})

	return


def apply_zero_acceleration_BC(faces=None,a1=None,a2=None,a3=None,ar1=None,ar2=None,ar3=None,amplitude=None,name='BC_1'):

##	VER: ('VER: 2012-05-24, v1.3')

	if faces in empty:
		raise Exception('faces are required to apply acceleration BC')

	faces = tolist(faces)
	region = create_set(a,faces=faces,name='set1')

	if a1 in empty:
		a10 = UNSET
	else:
		a10 = 0

	if a2 in empty:
		a20=UNSET
	else:
		a20 = 0

	if a3 in empty:
		a30=UNSET
	else:
		a30 = 0

	if ar1 in empty:
		ar10=UNSET
	else:
		ar10 = 0

	if ar2 in empty:
		ar20=UNSET
	else:
		ar20 = 0

	if ar3 in empty:
		ar30=UNSET
	else:
		ar30 = 0

	if amplitude in empty:
		amplitude=UNSET
	else:
		amplitude = 0

	name = new_key(_m.boundaryConditions.keys(),name)
	seq = get_SN(_m.boundaryConditions,2)
	_lineno = lineno_and_codes()[-2]
	name = '_' + seq + '_' + name + '_' + str(_lineno)

	_m.AccelerationBC(name=name, createStepName='Initial',
	    region=region, a1=a10, a2=a20, a3=a30, ar1=ar10, ar2=ar20, ar3=ar30,
	    amplitude=UNSET, localCsys=None, distributionType=UNIFORM, fieldName='')

	if name in _m.boundaryConditions.keys():
		print '--->Applied acceleration BC: a1=',a1,', a2=',a2,', a3=', a3, ', ar1=',ar1, ', ar2=', ar2, ', ar3=', ar3, ', amplitude=',amplitude

	return name

def another_end_of_geometry(sketch,curve,loc1):
	## VER: 2015-04-20, v1.0

	sketch = _sketch(sketch)
	if is_number(curve):
		if curve in sketch.geometry.keys():
			curve = sketch.geometry[curve]
		else:
			raise Exception('*** No such geometry with id =' + str(curve))

	if is_geometry(curve) == False:
		raise Exception('*** A geometry is required.')

	if is_location(loc1) == False:
		raise Exception('*** location of end1 is required.')

	locs = vertice_locs_of_geometry(sketch,curve)
##	print fnln(),'loc1=',loc1
##	print fnln(),'locs=',locs
	locs = loc_unselect(locs,loc1)
##	print fnln(),'locs=',locs
	if len(locs) != 1:
		raise Exception('*** Fail to get another end.')
	else:
		loc2 = locs[0]

	return loc2

def apply_adaptive_mesh(objs=None,cells=None,faces=None, elements=None, region=None, setname=None, insts=None,
	frequency=3, freq=None,frequence=None,sweep=2, solid_time=None, fluid_time=None, step='step1',controls=None):
	## VER: 2016-08-31, v1.5
	## objs should be from instance, not from part
	## frequency表示remesh的频率：多少个增量步就remesh一次。如果frequency=1, 则每个增量步都要remesh
	## sweep    表示remesh的强度：也就是每次remesh要进行多少次sweep来完成。这也说明，单元必须是扫略生成的。
	## 本质上需要set作为input region
	## Reference: adaptive_mesh_control()
	## frequency相当于几天才洗一次衣服(solid_time)，而sweep相当于每次洗衣服要漂洗几次(fluid_time)。
	## solid_time越短，而fluid_time越长，则流动性增强

	## ALE需要在各个step分别设置，不会继承。
##	control = adaptive_mesh_control(predictor='previous', curvature=0.05, weight=(0.5,0,0.5), order='first')  ## weight=(volumetric,laplacian,equipptential)
##	apply_adaptive_mesh(step='step1',region=powder_elems,frequence=2,sweep=1, controls=control)
##	apply_adaptive_mesh(step='step2',region=powder_elems,frequence=3,sweep=1, controls=control)
##	apply_adaptive_mesh(step='step3',region=powder_elems,frequence=4,sweep=1, controls=control)


	## Error info:
	## button, 仅仅die接触的区域自适应时: YIELD STRESS IS TOO LOW, THE CAP WOULD BE IN TENSION SPACE WHEN PB=0.75000, COHESION= 3.8400, BETA=56.300, R=0.77000

	## Example
##	set_element_shape(powder, objs=powder.faces, technique=SWEEP)  ## 可能仍然有些区域无法用sweep方法。
##	mesh_part(powder,esize=0.5)  ## origin: 0.2			## 同时使用SWEEP和ALE时，esize不能小于0.5.
##	apply_adaptive_mesh(elements=powder_A1.elements)	;changing


	## example:
	## apply_adaptive_mesh(powder_s_A1.faces)
##	apply_adaptive_mesh(elements=powder_s_A1.elements)

	## Example:
##	choose_element_type(powder)
##	set_element_shape(powder, objs=_part(powder).faces, technique=SWEEP)
##	mesh_region(powder,esize=0.8)
##
##	adaptive_mesh_control()
##	apply_adaptive_mesh(elements=_inst(powder_A1).elements)	;changing

	if is_number(freq):
		frequency = freq
	elif is_number(frequence):
		frequency = frequence
	elif is_int(solid_time):
		frequency = solid_time

	if is_int(fluid_time):
		sweep = fluid_time

	region_done = False
	if type_of(region) == 'STR':
		setname = region
		region = None
	elif type_of(region) in ['SET','REGION']:
		region_done = True
	elif region not in empty:
		objs = region
		region = None

	if not region_done:
		if insts not in empty:
			insts = real_insts(insts)

		if setname in empty:
			objs = get_real_input(cells,faces,objs, elements)

##			stop1()
			if objs not in empty:
				region = create_set(p=a,objs=objs,setname='ALEarea',check_name=True)
				setname = name_of_set(region)

			elif insts not in empty:
				region = insts_to_region(insts)	 ## 此时insts可能没有mesh

		else:
			if insts not in empty:
				poi = insts[0]
			else:
				poi = a

			if setname not in poi.sets.keys():
				raise Exception('*** No such setname= ' + repr(setname) + ' in ' + poi.name)

			region = inst.sets[setname]

	if region in empty:
		raise Exception('*** set like region is required.')


	step = check_step(step)

	if controls not in empty and controls not in _m.adaptiveMeshControls.keys():
		raise Exception('*** error in adative mesh control name')

	if controls in empty and _m.adaptiveMeshControls.keys() not in empty:
		controls = _m.adaptiveMeshControls.keys()[0]   ;please_check

	_m.steps[step].AdaptiveMeshDomain(region=region, controls=controls, frequency=frequency,meshSweeps=sweep)

##	>>> step1 = _m.steps['step1']
##	>>> step1.adaptiveMeshDomains.keys()
##	['step1']
##	>>>

	return

apply_ALE = apply_adaptive_mesh

def apply_BC_on_RP_2D(inst,name=None,RP=None, U1=UNSET,U2=UNSET,UR3=UNSET,Ux=None,Uy=None,amplitude=UNSET,stepname='Initial',modifys=(),deactive_step=None):
	## VER: 2015-04-23, v1.4

	## Example
##	apply_BC_on_RP_2D(tpunch_A1,U1=0,UR3=0,stepname='step1')
##	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1',modifys=('step2','U2','top_move2'))

	## 以下是变相的用分步来实现动作曲线
##	apply_BC_on_RP_2D(tpunch_A1,U2=-dip,stepname='step1',modifys=('step2','U2',-PV))
##	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step1',modifys=('step2','U2',-PV))


	if Ux != None:
		U1 = Ux
	if Uy != None:
		U2 = Uy

	inst = check_pias(inst)

	if name in empty:
		name = 'fix_RP_' + inst.name
	name = new_key(_m.boundaryConditions.keys(),name)

##	print fnln(),modifys

	if RP in empty:
		if len(inst.referencePoints.values()) == 0:		## 这要求RP是建在部件中的，不是建在assembly的。
			create_RP(inst.part)	## 得到的是部件的reference Point，而使用的是实例的reference point
		RP = inst.referencePoints.values()[0]

	if is_RP(RP) == False:
		raise Exception('*** reference point is required.')

	RP = (RP,)	## 这要求RP是键在部件中的，不是建在assembly的。
	region1=regionToolset.Region(referencePoints=RP)

	stepname = check_step(stepname)

##	exist = False
##	if name in _m.boundaryConditions.keys():
##		exist = True

	fix_status,DOFs = get_fix_status({'U1':U1,'U2':U2,'UR3':UR3})
##	print2('fix_status=',fix_status)
##	print2('amplitude=',amplitude)
##	raise Exception

	if name not in _m.boundaryConditions.keys():
		_m.DisplacementBC(amplitude=amplitude, createStepName=stepname, distributionType=UNIFORM,
			fieldName='', localCsys=None, name=name, region=region1,
		    u1=fix_status['U1'], u2=fix_status['U2'], ur3=fix_status['UR3'])

##		raise Exception
	else:
		modifys = []
		for dof,value in fix_status.items():
			if value not in empty:
				modifys.append((stepname,dof,value))

	add_BC_status(insts=inst,name=name,DOFs=DOFs)
##	if debug == True:
##		print2('name=',name)
##		print2('modifys=',modifys)
##		print2('exist=',exist)
##		raise Exception

	if modifys not in empty:
		modifys = totable(modifys)
		print fnln(),'modifys=',modifys
		for item in modifys:
			if type_of(item) not in ['TUPLE','LIST']:
				raise Exception('**** element in modifys should be a tuple or a list, format: stepname, dof, value')
			if len(item) != 3:
				raise Exception('**** There should be three items: stepname, dof, value')

			stepname, dof, value = item
			stepname = check_step(stepname)

			if type_of(value) == 'STR' and value in _m.amplitudes.keys():
				if len(DOFs) != 1:
					raise Exception('**** Please specify the amplitude for only on dof.')

				if dof in ['U1',U1,'u1','Ux']:
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, u1=1.0, amplitude=value)
				elif dof in ['U2',U2,'u2', 'Uy']:
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, u2=1.0, amplitude=value)
				elif dof in ['UR3','ur3', UR3]:
					_m.boundaryConditions[name].setValuesInStep(stepName=step1, ur3=1.0, amplitude=value)

##				_m.boundaryConditions[name].setValuesInStep(stepName=stepname, amplitude=value)

			elif type_of(value) in ['INT','FLOAT']:
				if dof in ['U1',U1,'u1','Ux']:
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, u1=value)
				elif dof in ['U2',U2,'u2', 'Uy']:
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, u2=value)
				elif dof in ['UR3','ur3', UR3]:
					_m.boundaryConditions[name].setValuesInStep(stepName=step1, ur3=value)

##	print '---> fix_status=',fix_status

	if type_of(deactive_step) == 'STR':
		deactive_step = check_step(deactive_step)
		_m.boundaryConditions[name].deactivate(deactive_step)

	a.regenerate()
	print fnln(),'--->Created displacement fix:',name

	return name

def apply_bodyforce(name='',comp1=0,comp2=0,comp3=0,cells='',step='step1'):
	## VER: 2010-06-22

	if cells == '':
		force_type = 'Gravity'
	else:
		force_type = 'Bodyforce'

	step = check_step(step)

	if cells == '':
		_m.Gravity(name=name, createStepName=step, comp1=comp1,comp2=comp2,comp3=comp3,distributionType=UNIFORM, field='')
	else:
		region = []
		if type_of(cells) == 'STR':
			region = set2region(cells)
		elif type_of(cells) == 'LIST':
			if type_of(cells[0]) == 'cells':
				region = list2region(cells,region_type='set')

		_m.BodyForce(name=name,createStepName=step, comp1=comp1,comp2=comp2,comp3=comp3,region=region)

	print '--->',force_type,name,'was applied',', comp1=',comp1,', comp2=',comp2,', comp3=',comp3
	print ' '

	return

def apply_rail_fix():
##	VER: ('VER: 2012-07-20, v1.0')

	insts = find_mdb_insts('rail')

	faces = faces_of_insts(insts,z=MIN)
	apply_disp_fix(name='fix_rail_bot',faces=faces)

	return

def apply_boltload(name,force=1000,ndir='z',faces='',step='step1'):
##	VER: ('VER: 2016-10-28, v1.8')	## 如果是模态分析，则无法加载预紧力。

	global options

	antype = get_antype()
	if antype != 'stress':
		print '**antype=',antype,'. No bload will be applied.'
		return

	seq = get_SN(_m.loads,2)
	_lineno = lineno_and_codes()[-2]
	name = '_' + seq + '_' + name + '_' + str(_lineno)

	name = new_key(_m.loads,name)

	if ndir == 'x':
		a.DatumAxisByPrincipalAxis(principalAxis=XAXIS)
	elif ndir == 'y':
		a.DatumAxisByPrincipalAxis(principalAxis=YAXIS)
	elif ndir == 'z':
		a.DatumAxisByPrincipalAxis(principalAxis=ZAXIS)

	datumAxis = a.datums[max(a.datums.keys())]

	step = check_step(step)

	region = []
	if faces != '' and type_of(faces) == 'STR':
		faces_seq = set2sequence(faces)
		region = set2region(faces)
	elif type_of(faces) == 'LIST':
		if type_of(faces[0]) == 'faces':
			faces_seq = list2sequence(faces)
			region = list2region(faces,region_type='set')   ;please_check

	_m.BoltLoad(name=name, createStepName=step, region=region, magnitude=force, boltMethod=APPLY_FORCE,
	    datumAxis=datumAxis)

	## boltMethod: A SymbolicConstant specifying the type of bolt load. Possible values are APPLY_FORCE, ADJUST_LENGTH, and FIX_LENGTH.
	## The default is APPLY_FORCE.

	pre_stress = int(round(force/get_area(faces_seq)))
	globals()['pre_stress'] = pre_stress
	add2my_globals('pre_stress')

	print '--->BoltLoad',name,'was applied, force=',force,'N at first analysis step:',step
	print '--->**pretension pre_stress=',pre_stress,'MPa'
	print ' '
	options.append('Boltload: ' + name)

	return

##def apply_CF(name='CF-1',edges=None,vertices=None,CF1=0,CF2=0,CF3=0,step='step1'):
##	## VER: 2013-12-05, v1.0
##
##	name = new_key(_m.loads.keys(), name)
##	step = check_step(step)
##
##	if edges not in empty:
##		vertices = vertices_of_objs(edges)
##
##	if vertices in empty:
##		raise Exception('*** vertices are required.')
##
##	vertice = tolist(vertices)
##	num = len(vertices)
##
##	region = list2region(vertices)
##	_m.ConcentratedForce(name=name, createStepName='step1',
##	    region=region, cf1=CF1/num, cf2=CF2/num, cf3=CF3/num, distributionType=UNIFORM, field='',
##	    localCsys=None)
##
##	print '--->Applied concentrated force, CF1=',CF1, ', CF2=', CF2, ', CF3=',CF3
##
##	return name

def apply_clamp_fix(clamp_edge='long+',clamps=None,clamp_fix_area=None):
##	VER: ('VER: 2012-11-06, v1.4')

	clamps = real_insts(clamps)
	if clamps in empty:
		clamps = find_mdb_insts('clamp')

	if clamp_fix_area in empty:
		clamp_fix_area = globals()['clamp_fix_area']

	if '+' not in clamp_edge and '-' not in clamp_edge:
		clamp_edge = clamp_edge + '+'

	if clamp_fix_area == 'bot':
		faces = faces_of_insts(insts=clamps,z=MIN)
		apply_disp_fix('fix_clamp_bot',faces=faces,Ux=0,Uy=0,Uz=0)

	elif clamp_fix_area == 'top+bot':
		faces = faces_of_insts(insts=clamps,z=MIN)
		apply_disp_fix('fix_clamp_bot',faces=faces,Ux=0,Uy=0,Uz=0)

		faces = faces_of_insts(insts=clamps,z=MAX)
		apply_disp_fix('fix_clamp_top',faces=faces,Ux=0,Uy=0,Uz=0)

	elif clamp_fix_area == 'side':  ##与clamp_bot_fix比较，边框的变形挠度较小，边框应力略大。
		if clamp_edge == 'long+':
			loc = _xmax(clamps[0],z=MAX)
			faces = faces_of_insts(insts=clamps,x=loc)
		elif clamp_edge == 'long-':
			loc = _xmin(clamps[0],z=MAX)
			faces = faces_of_insts(insts=clamps,x=loc)
		elif clamp_edge == 'short+':
			loc = _ymax(clamps[0],z=MAX)
			faces = faces_of_insts(insts=clamps,y=loc)
		elif clamp_edge == 'short-':
			loc = _ymin(clamps[0],z=MAX)
			faces = faces_of_insts(insts=clamps,y=loc)

		apply_disp_fix('fix_clamp_side',faces=faces,Ux=0,Uy=0,Uz=0)		;please_check

	elif 'cover+side' in clamp_fix_area and clamp_shape == 'Z':
		apply_disp_fix('fix_clamp_cover',faces='f_clamp_cover_area', Uy=0,Uz=0)

		if clamp_edge == 'long+':
			loc = _xmax(clamps[0])
			faces = faces_of_insts(insts=clamps,x=loc)
		elif clamp_edge == 'long-':
			loc = _xmin(clamps[0])
			faces = faces_of_insts(insts=clamps,x=loc)
		elif clamp_edge == 'short+':
			loc = _ymax(clamps[0])
			faces = faces_of_insts(insts=clamps,y=loc)
		elif clamp_edge == 'short-':
			loc = _ymin(clamps[0])
			faces = faces_of_insts(insts=clamps,y=loc)

		if clamp_edge == 'long+' or clamp_edge == 'long-':
			apply_disp_fix('fix_clamp_symm',faces=faces,Ux=0)
		elif clamp_edge == 'short+' or clamp_edge == 'short-':
			apply_disp_fix('fix_clamp_symm',faces=faces,Uy=0)

	return

def apply_force(name='CF-1',edges=None, vertices=None,nodes=None,RP=None, CF1=0,CF2=0,CF3=0,stepname='step1',average=True):
	## VER: 2014-06-29, v1.4, apply concentrated force
	## apply_CF使用本函数。

##	vertice = vertice_select('shaft_A1',y=(MIN1,_ymin('botbush')),x=MAX)  ## You can highlight the vertice
##	apply_force(name='pointforce',vertices=vertice,CF1=-force,stepname='step2')

	stepname = check_step(stepname)

	if type_of(name) != 'STR':
		raise Exception('*** load name is requied.')

##	_lineno = lineno_and_codes()[-2]
##	seq = get_SN(_m.loads,2)
##	name = '_' + seq + '_' + name + '_' + str(_lineno)
##	name = new_key(_m.loads,name)

	name = formatted_name(_m.loads,name)

	if edges not in empty:
		vertices = vertices_of_objs(edges)

	region = None

	if RP not in empty:
		RP = feature_to_obj(RP)

	objs = get_real_input(vertices,nodes,RP)
	if type_of(objs) == 'STR':
		objs = set2objs(objs)
	elif type_of(objs) == 'SET':
		region = objs
	else:
		objs = tolist(objs)

	if objs in empty:
		raise Exception('*** Objects are required.')

	parent = get_parent(objs[0])
	if type_of(parent) == 'PART':
		raise Exception('*** objs should be come from instances, not from part.')

##	obj_type = type_of(objs[0])
##	region = list2region(objs,region_type='set')
	if region in empty:
		region = create_set(objs=objs)

	if average == True:
		CF1 = CF1/len(objs)
		CF2 = CF2/len(objs)
		CF3 = CF3/len(objs)

	if CF1 == CF2 == CF3 == 0:
		raise Exception('*** None zero CF is required.')

	_m.ConcentratedForce(name=name, createStepName=stepname,
		region=region, cf1=CF1, cf2=CF2, cf3=CF3, distributionType=UNIFORM, field='', localCsys=None)

	print '--->Applied concentrated force, loadname=',name,', value=',(CF1,CF2,CF3),', average=',average

	return name

##apply_CF = apply_force

def apply_surface_convection(name, faces,h=30, T_air=20, step='step1',prop=None,unit='SI'):
	## VER: 2015-03-20, v1.6, K_hc = 1e-3
	## default: h = 30W/(m2*K) (标准单位制） = 30e-3 (毫米单位制)
	## 在dynamic implicit中无法进行热分析。

	## example:
##	faces = face_select(anvil_A1, x=(50, MAX),radius=anvil_OD/2)
##	apply_surface_convection('conv_anvil',faces=faces,h=hc, T_air=Tair)

	step = check_step(step)
	name = new_key(_m.interactions,name)

	if h in _m.interactionProperties.keys():
		prop = h

	if prop not in empty and prop not in _m.interactionProperties.keys():
		raise Exception('*** prop not in _m.interactionProperties.keys() yet.')

	if unit == 'SI' and is_number(h):
		h = h/1000

	region  = create_surface(objs=faces)

	if prop in empty:
		_m.FilmCondition(name=name, createStepName=step,
		    surface=region, definition=EMBEDDED_COEFF, filmCoeff=h,
		    filmCoeffAmplitude='', sinkTemperature=T_air, sinkAmplitude='')

		print '--->Applied convection: h=',h,', environment Temp =',T_air, ', step=', step

	else:
		_m.FilmCondition(name=name, createStepName=step,
		    surface=region, definition=PROPERTY_REF, interactionProperty=prop,
		    sinkTemperature=T_air, sinkAmplitude='')

##	mdb.models['draw'].FilmCondition(name='Int-5', createStepName='draw',
##	    surface=region, definition=PROPERTY_REF,
##	    interactionProperty='Heat convection', sinkTemperature=20.0,
##	    sinkAmplitude='', sinkDistributionType=UNIFORM, sinkFieldName='')

		print '--->Applied convection: prop=',prop,', environment Temp =',T_air, ', step=', step

	print  ' '

	return

def apply_frame_bolt_load_BC():

##	VER: ('VER: 2012-07-18, v1.0')

	insts = find_mdb_insts('bolt')

	faces = faces_of_insts(insts=insts, z=MAX) + faces_of_insts(insts=insts, z=MIN)
	apply_disp_fix(name='bolt_fix',faces=faces, Ux=0,Uy=0,Uz=0)

	faces = faces_of_insts(insts=insts, z=_zmin(frL), exterior=False)
	apply_boltload('boltload1',faces=faces,force=bload,step='step1')

	return

def unset2zero(value):
	## VER: 2014-05-04, v1.0

	if value == UNSET:
		value = 0

	return value

def apply_gravity(name='Gravity',Gx=0,Gy=0,Gz=0,insts=None,step='step1'):
##	VER: 2015-05-15, v1.8, to apply acceleration

	## Example: apply_gravity(Gy=-9800)
	## apply_gravity()
	## apply_gravity(Gy=-9800,insts='PART2-1')   ## 其中PART2 orphan mesh part.

	step = check_step(step)

	if Gx==Gy==Gz==0:
		if model_shape() == THREE_D:
			Gz = -9800   ## Movement of movable part, contrary to ansys
		else:
			Gy = -9800
	else:
		if model_shape() != THREE_D:
			if is_number(Gy) == False:
				raise Exception('*** Gy is rquired.')

	name = formatted_name(_m.loads, name)

	if insts not in empty:
		insts = real_insts(insts)

##		print fnln(),'insts=',poi_names(insts)

##	raise Exception

	if insts in empty:	## whole model
		if model_shape() == THREE_D:
			_m.Gravity(name=name, createStepName=step, comp1=Gx,comp2=Gy,comp3=Gz,distributionType=UNIFORM, field='')
		else:
			_m.Gravity(name=name, createStepName=step, comp2=Gy, distributionType=UNIFORM, field='')
	else:
		region = insts_to_region(insts,info='gravity')
		if model_shape() == THREE_D:
			_m.Gravity(name=name, createStepName=step, comp1=Gx,comp2=Gy,comp3=Gz, distributionType=UNIFORM, field='', region=region)
		else:
			_m.Gravity(name=name, createStepName=step, comp2=Gy,distributionType=UNIFORM, field='', region=region)

	print '--->Applied gravity in the model, load name=Gravity, Gx=',Gx,', Gy=',Gy,', Gz=',Gz
	print ' '

	return name

def apply_gravity_body_force(insts,dir='-y',step='step1',mm_unit=True):
	## VER: 2014-07-01, v1.0, the force will not applied for mass point
	## 密度的单位是吨/mm3，所以，标准单位密度要乘以*KE，否则施加重力载荷将会导致一开始就不收敛。(类似于一开始就施加一个非常大的加速度。)

##>>> get_mats(ashaft_A1)
##{'ashaft_A1': {'Steel_WMoCrV': ['set_Steel_WMoCrV']}}

##>>> set1 = carbide_A1.sets['set_H10F']
##>>> type_of(set1)
##'SET'
##>>>

	step = check_step(step)
	dir = dir.lower()
	if '-' in dir:
		g = -9.8
	else:
		g = 9.8
	if mm_unit == True:
		g = g*1000

	insts = real_insts(insts)
	for inst in insts:
		dict1 = get_mats(inst)
		mats = dict1[inst.name]
		for mat in mats.keys():
			density = get_density(mat)
			force = density*g   ## result: N/m3 for m unit and N/mm3 for mm unit

			for set1 in mats[mat]:
				region = check_set(set1,inst)
				name = new_key(_m.loads,'gravity_1')

				if 'x' in dir:
					_m.BodyForce(name=name, createStepName=step, region=region, comp1=force)
				elif 'y' in dir:
					_m.BodyForce(name=name, createStepName=step, region=region, comp2=force)
				elif 'z' in dir:
					_m.BodyForce(name=name, createStepName=step, region=region, comp3=force)

	return


def apply_heat_flux(name,objs=None,cells=None, faces=None, vertices=None, power=None, power_unit='W', surface_flux=0, body_flux=0, amplitude=None, step='step1'):

##	VER: ('VER: 2012-07-17, v1.5')	## surface_flux in W/m^2, body_flux in W/m^3, objs in LIST or setname. K_sflux = 1e-3
	## bodyHeatFlux:体热通量, 负数为流出，正数为流入。

	step = check_step(step)
	name = new_key(_m.loads,name)

	print name,': surface_flux=',surface_flux
	if surface_flux > 1:
		print fnln_fnln(),'******surface_flux=',surface_flux
		error_record(name + ': surface_flux=' + str(surface_flux))

	if cells not in empty:
		objs = cells
	elif faces not in empty:
		objs = faces

	if type_of(objs) == 'STR':
		objs = set2objs(objs)
	elif type_of(objs) in ['cells','faces','vertices']:
		objs = [objs]

	if type_of(objs) != 'LIST':
		raise Exception('******objects list or setname is needed. ')
	elif objs[0].instanceName == None:
		raise Exception('******objects should be selected from instance')

	obj_type0 = type_of(objs[0])
	if type_of(power) in ['FLOAT','INT'] and power != 0:
		if power_unit == 'W':
			if obj_type0 == 'cells':
				volume = get_volume(objs)
				body_flux = power/volume
			elif obj_type0 == 'faces':
				area = get_area(objs)
				surface_flux = power/area
			elif obj_type0 == 'vertices':
				raise Exception('Error power unit (W) for vertices, it should be W/m-3')

		elif power_unit == 'W/m-3':
			if obj_type0 in ['cells','vertices']:
				body_flux = power*1e-9		## W/m-3 -> W/mm-3
			else:
				raise Exception('power in W/m-3 is provided, but obj_type0 is not cells or vertices.')

		elif power_unit == 'W/m-2':
			if obj_type0 != 'faces':
				if obj_type0 == 'cells':
					print '****You can select one side of faces of these cells as power region.'
				raise Exception('power in W/m-2 is provided, but obj_type0 is not faces.')
			surface_flux = power

	region = list2region(objs,region_type='set')  ;please_check
	if obj_type0 == 'cells' and body_flux != 0:
		_m.BodyHeatFlux(name=name, createStepName=step, region=region, magnitude=body_flux)
	elif obj_type0 == 'faces' and surface_flux != 0:
		_m.SurfaceHeatFlux(name=name, createStepName=step, region=region, magnitude=surface_flux)		## surface_flux < 0: flow out
	elif obj_type0 == 'vertices' and body_flux > 0:
		_m.ConcentratedHeatFlux(name=name, createStepName=step, region=region, magnitude=body_flux)

	print '--->Applied',obj_type0,'type heat flux, name=',name,', surface_flux=',surface_flux,', body_flux=',body_flux,', step=',step
	print ' '

	return

def apply_load_BC(clamp_fix_area='bot',BC_only=False,symm_only=False):

	## VER: ('VER: 2016-10-29, v2.4')	## bload

	global has_bload, BC_status

	if _step('step1').procedureType in [FREQUENCY]:		## 模态分析的自由度是stress，但不施加载荷
		BC_only = True

	if BC_status.keys() in empty:
		BC_status_initiate()
##		for inst in a.instances.keys():
##			if inst not in BC_status.keys():
##				BC_status[inst] = {}

	faces = faces_of_insts(x=_xmin(lam_A1))
	apply_disp_symm('x',faces=faces)

	faces = faces_of_insts(y=_ymin(lam_A1))
	apply_disp_symm('y',faces=faces)

	write_global_variables(var_file_full, symmetry)

	if symm_only == True:
		return

	if BC_only == False:
		apply_gravity(step='step1')

	if has_frame == True and BC_only == False:
		if load_side == 'top':
			faces = faces_of_cut(lam_A1,x=(0,top_lip_tipx),y=(0,top_lip_tipy),z=MAX)
			apply_pressure('pressure_top',faces=faces,magnitude=press_Pa)

			if load_on_frame == True:
				faces = zmax_faces(frL_A1) + zmax_faces(frS_A1)
				apply_pressure('pressure_on_frame',faces=faces,magnitude=press_Pa)

		elif load_side == 'bot':
			faces = faces_of_cut(lam_A1,x=(0,bot_lip_tipx),y=(0,bot_lip_tipy),z=_zmin(lam_A1,x=MID,y=MID))
			apply_pressure('pressure_bot',faces=faces,magnitude=press_Pa)

			if load_on_frame == True:
				faces = zmin_faces(frL_A1) + zmin_faces(frS_A1)
				apply_pressure('pressure_on_frame',faces=faces,magnitude=press_Pa)

	if has_mount_clamp == True:
		if clamp_fix_area == 'bot':
			faces = faces_of_insts(insts=find_mdb_insts('clamp'),z=MIN)
			apply_disp_fix('clamp_bot_fix',faces=faces,Ux=0,Uy=0,Uz=0)

		elif clamp_fix_area == 'side':  ##与clamp_bot_fix比较，边框的变形挠度较小，边框应力略大。
			if 'long_edge' in support_option:
				faces = faces_of_insts(insts=find_mdb_insts('clamp'),x=MAX)
				apply_disp_fix('clamp_xmax_fix',faces=faces,Ux=0,Uy=0,Uz=0)	;please_check

			elif 'short_edge' in support_option:
				faces = faces_of_insts(insts=find_mdb_insts('clamp'),y=MAX)
				apply_disp_fix('clamp_ymax_fix',faces=faces,Ux=0,Uy=0,Uz=0)	;please_check

		elif clamp_fix_area == 'mix':
			if 'long_edge' in support_option:
				faces = faces_of_insts(insts=find_mdb_insts('clamp'),x=MAX)
				apply_disp_fix('clamp_xmax_fix',faces=faces,Ux=0)	;please_check

				faces = faces_of_insts(insts=find_mdb_insts('clamp'),z=MIN)
				apply_disp_fix('clamp_bot_fix',faces=faces,Ux=0,Uy=0,Uz=0)

			elif 'short_edge' in support_option:
				faces = faces_of_insts(insts=find_mdb_insts('clamp'),y=MAX)
				apply_disp_fix('clamp_ymax_fix',faces=faces,Uy=0)	;please_check

				faces = faces_of_insts(insts=find_mdb_insts('clamp'),z=MIN)
				apply_disp_fix('clamp_bot_fix',faces=faces,Ux=0,Uy=0,Uz=0)

		if bload > 0 and has_bload == False:
			has_bload = True

		if BC_only == False:
			if has_frame == True and (bload > 0 or has_bload == True):
				divide(clamp,z=_zmid(clamp))
				faces = faces_of_insts(find_mdb_insts('clamp'),z=MID,exterior=False)

				apply_boltload('boltload',faces=faces,force=bload,step='step1')

			else:
				print fnln_fnln(),'****has_bload=',has_bload,', bload=',bload
				print 'No bolt load was applied.'

##		if has_dam == True:
##			faces = faces_of_insts(find_mdb_insts('dam_A'),z=MAX)
##			apply_disp_fix(name='Fix_dam_top',faces=faces, Ux=0,Uy=0,Uz=0)

	if has_rail == True or has_mount_brail == True:
		faces = faces_of_insts(find_mdb_insts('rail'),z=MIN)
		apply_disp_fix(name='Fix_rail_bot', faces=faces,Ux=0,Uy=0,Uz=0)

	if has_mount_bolt == True:
		faces = faces_of_cut('bolt_A1',z=MAX) + faces_of_cut('bolt_A2',z=MAX) + faces_of_cut('bolt_A1',z=MIN) + faces_of_cut('bolt_A2',z=MIN)
		apply_disp_fix(name='bolt_fix', faces=faces,Ux=0,Uy=0,Uz=0)

		faces = faces_of_cut('rail_A1',x=MIN) + faces_of_cut('rail_A1',x=MAX) + faces_of_cut('rail_A2',x=MIN) + faces_of_cut('rail_A2',x=MAX)
		apply_disp_fix(name='rail_fix',faces=faces,Ux=0,Uy=0,Uz=0)

		if has_bload == True and BC_only == False:
			faces = face_select('bolt_A1',z=_zmin(frL),exterior=False)
			apply_boltload('boltload1',faces=faces,force=bload,step='step1')

			faces =face_select('bolt_A2',z=_zmin(frL),exterior=False)
			apply_boltload('boltload2',faces=faces,force=bload,step='step1')

	return

def apply_mat_etype(p,region1,mat,etype=C3D8R):
	## VER: 2009-12-27

	a = _m.rootAssembly
	if len(region1) > 0:
		if str(etype)[0:4] == 'C3D8':
			eshape = 'hex'
			elemType1 = mesh.ElemType(elemCode=etype, elemLibrary=STANDARD, secondOrderAccuracy=ON,
			    kinematicSplit=AVERAGE_STRAIN, hourglassControl=DEFAULT)
			elemType2 = mesh.ElemType(elemCode=C3D6, elemLibrary=STANDARD)
			elemType3 = mesh.ElemType(elemCode=C3D4, elemLibrary=STANDARD)

		elif str(etype)[0:5] == 'C3D20':
			eshape = 'hex'
			elemType1 = mesh.ElemType(elemCode=etype, elemLibrary=STANDARD)
			elemType2 = mesh.ElemType(elemCode=C3D15, elemLibrary=STANDARD)
			elemType3 = mesh.ElemType(elemCode=C3D10M, elemLibrary=STANDARD)

		elif etype == SC8R:
			eshape = 'shell'
			elemType1 = mesh.ElemType(elemCode=etype, elemLibrary=STANDARD, secondOrderAccuracy=ON,
			    hourglassControl=DEFAULT)
			elemType2 = mesh.ElemType(elemCode=SC6R, elemLibrary=STANDARD)
			elemType3 = mesh.ElemType(elemCode=UNKNOWN_TET, elemLibrary=STANDARD)

		sec_name = mat + '_' + eshape
		p.SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE, region=region1,
			sectionName=sec_name, thicknessAssignment=FROM_SECTION)
		p.setElementType(regions = region1, elemTypes=(elemType1, elemType2, elemType3))
		a.regenerate()
		print '--->Applied as',mat,', element type:',etype

	else:
		print fnln_fnln(),'****** Empty region1, not applied material',mat

	return

def apply_mat_ids(part,ids):
	## VER: 2014-12-04, v1.0
	## After scale part, reset the material property

	part = check_part(part)
	if type_of(ids) != 'DICT':
		raise Exception('*** An ids dict is required.')

	if len(part.cells) > 0:
		obj_type = 'cells'
	elif len(part.faces) > 0:
		obj_type = 'faces'
	elif len(part.edges) > 0:
		obj_type = 'edges'
	else:
		raise Exception('*** Error obj_type')

	for mat,nums in ids.items():
		objs = []
		for num in nums:
			if obj_type == 'cells':
				obj = part.cells[num]
			elif obj_type == 'faces':
				obj = part.faces[num]
			elif obj_type == 'edges':
				obj = part.edges[num]

			if obj not in objs:
				objs.append(obj)

		set_mat(part,objs=objs,mat=mat)

	return

def apply_pressure(name='pressure',MPa=None, Pa=None, pressure=None, amplitude=UNSET, magnitude=1, edges=None, faces=None,elements=None, nodes=None,
	step=None, surface=None, create_step='step1',step_modifys=(), deactive_step=None,expression=''):
	## VER: ('VER: 2016-11-12, v3.4')
	## Possible Error:
	## Type Error: region; Found Region, expecting Surface.  (In GUI operation: Select surfaces for the load by angle)
	## 对于2D模型，edges就是faces

	global options

	## Example
##	apply_pressure('load_top',elements=top_elems, MPa=8500,create_step='step3')

##	edges = edge_select(carbide_A1,radius=carbide_OD/2.)
##	edges = unselect(carbide_A1.edges,edges)
##	apply_pressure('pressing',MPa=pressure, faces=edges, create_step='step2')

##	faces = face_select('carbide_A1',y=MAX)
##	apply_pressure('pressure',faces=faces,Pa=10,step_modifys=('step2',5000))

	if is_number(pressure):
		Pa = pressure		## Default to be Pa in unit

	unit = ''
	if type_of(Pa) in ['INT','FLOAT']:
		MPa = Pa*1e-6
		unit = 'Pa'

	if amplitude in empty:
		if type_of(Pa) in numerics:
			MPa = Pa/1e6

		if type_of(MPa) in numerics:
			magnitude = MPa

		if type_of(magnitude) not in numerics:
			raise Exception('*** magnitude is required to be numerical value.')

		amplitude = UNSET

	else:
		if type_of(amplitude) != 'STR':
			raise Exception('*** amplitude curve name should be provided.')

		if amplitude not in _m.amplitudes.keys():
			raise Exception('*** Error amplitude name',amplitude)

		if type_of(magnitude) not in numerics:
			raise Exception('*** magnitude should be numerical.')

	faces = get_real_input(edges, faces)

	region = None
	if faces not in empty:
		type1 = type_of(faces)
		if type1 == 'STR':
			region = set2region(faces,region_type='surface')
		else:
			if type1 in ['faces','edges']:
				faces = [faces]
##				region = list2region(faces,region_type='surface')

			if type_of(faces) in ['LIST','TUPLE']:
				if type_of(get_poi(faces[0])) == 'PART' or type_of(get_poi(faces[-1])) == 'PART':
					raise Exception('******faces from instance is required, not part.')
##				region = list2region(faces,region_type='surface')
				region = create_surface(objs=faces, info='pressure')

	elif elements not in empty:
		if type_of(elements) == 'elements':
			elements = [elements]

		elif type_of(elements) == 'DICT':
			elements = labels_dict_to_elements(elements)

		if type_of(elements) in ['LIST','TUPLE']:
			region = list2region(elements,region_type='surface')	;please_check

	elif nodes not in empty:
		nodes = tolist(nodes)
		region = create_surface(nodes=nodes)

	elif surface not in empty:
		region = check_surface(surface)

	if region in empty:
		raise Exception('**** Fail to get the pressure region.')

	if step not in empty:
		create_step = step
	create_step = check_step(create_step)

	if deactive_step == 'next':
		deactive_step = get_next_step(create_step)

	step_type = type_of(_m.steps[create_step])
	if step_type == 'FrequencyStep':
		print fnln_fnln(),'**no pressure was applied for the modal frequency extract step.'
		return

	name = formatted_name(_m.loads,name)

##	print fnln(),'magnitude=',magnitude
##	raise Exception

	if region not in empty:
		if step_type in ['STEADYSTATEMODALSTEP','STEADYSTATEDIRECTSTEP']:
			_m.Pressure(name=name, createStepName=create_step,
			    region=region, distributionType=UNIFORM, field='', magnitude=magnitude + 0j,  amplitude=UNSET)
##			    region=region, distributionType=UNIFORM, field='', magnitude=1+0j,  amplitude=UNSET)

			print '--->Applied pressure loading in steady state',step_type,'create_step: magnitude =',magnitude

		else:
			if expression not in empty and expression in _m.analyticalFields.keys():
				_m.Pressure(createStepName=create_step, distributionType=FIELD, field=expression, magnitude=magnitude, name=name, region=region)

			else:
				_m.Pressure(createStepName=create_step, distributionType=UNIFORM, field='', magnitude=magnitude, amplitude=amplitude, name=name, region=region)

##			_m.Pressure(name='Load-1', createStepName='pressing',
##			    region=region, distributionType=UNIFORM, field='', magnitude=100.0, amplitude=UNSET)

		a.regenerate()

	else:
		print fnln_fnln(),'******apply_pressure() failed.'

	if type_of(step_modifys) in ['TUPLE','LIST'] and len(step_modifys) > 0:   ## 不能用DICT，因为dict的item顺序不定
		if type_of(step_modifys[0]) not in ['TUPLE','LIST']:
			step_modifys = (step_modifys,)   ## only one item

		for item in step_modifys:
			stepname = check_step(item[0])

			if len(item) == 2:
				if not is_number(item[1]):
					raise Exception('*** A pressure value is required.')

				if unit == 'Pa':
					value = item[1]/1e6
				else:
					value = item[1]
				_m.loads[name].setValuesInStep(stepName=stepname, magnitude=value)

			elif len(item) == 3:
				if is_number(item[1]) and item[2] in _m.amplitudes.keys():
					if unit == 'Pa':
						value = item[1]/1e6
					else:
						value = item[1]
					_m.loads[name].setValuesInStep(stepName=stepname, magnitude=value, amplitude=item[2])

	if type_of(deactive_step) == 'STR' and deactive_step in _m.steps.keys():
		_m.loads[name].deactivate(deactive_step)

	return name

def apply_pressure_on_frame(side=None,step='step1'):

	## VER: ('VER: 2012-07-18, v1.0')

	if side in empty:
		side = load_side

	if side == 'back':
		side = 'bot'
	elif side == 'front':
		side = 'top'

	frame_insts = find_mdb_insts('frS','frL')
	if side == 'top':
		faces = faces_of_insts(insts=frame_insts,z=MAX)
	elif side == 'bot':
		faces = faces_of_insts(insts=frame_insts,z=MIN)

	apply_pressure('pressure_on_frame',faces=faces,magnitude=press_Pa)

	return

def apply_pressure_on_lam(side=None,step='step1',Xinsts=None):
	## VER: ('VER: 2012-10-31, v1.5')

	if side in empty:
		side = load_side

	if side == 'back':
		side = 'bot'
	elif side == 'front':
		side = 'top'

	lam_insts = find_mdb_insts('lam')
	Xinsts = real_insts(Xinsts)
	if Xinsts in empty:
		if has_frame == True:
			Xinsts = find_mdb_insts('frL','frS')
		else:
			Xinsts = find_mdb_insts('clamp')

	faces = []
	if side == 'top':
		for inst in lam_insts:
			faces = faces + get_uncover_faces(inst,Xinsts=Xinsts,z=MAX)
	elif side == 'bot':
		for inst in lam_insts:
			faces = faces + get_uncover_faces(inst,Xinsts=Xinsts,z=_zmin(inst,x=MID,y=MID))

	apply_pressure('press_' + load_side,magnitude=press_Pa*KE,faces=faces,step=step)  ###???****

	return

def apply_radiation(name,faces='',emiss=0.84,T_air=40, step='step1'):
	## VER: 2010-09-17, v1.0
	 ## Example:
	 ##	apply_radiation('top_radiation','f_p1_top',emiss=0.84, T_air=40, step='step1')

	step = check_step(step)

	face_set = ''
	type1 = type_of(faces)
	if faces != '' and type1 == 'STR':
		face_set = faces
		faces = set2region(faces)
	elif type1 == 'LIST':
		faces = list2region(faces,region_type='surface')
	elif type1 == 'SEQUENCE':
		faces = regionToolset.Region(side1Faces=faces)

	_m.RadiationToAmbient(name=name, createStepName=step,
	    surface=faces, radiationType=AMBIENT, distributionType=UNIFORM, field='',
	    emissivity=emiss, ambientTemperature=T_air, ambientTemperatureAmp='')

	print '--->Applied surface radiation to air: emissivity=',emiss,', environment Temp =',T_air, ', step=', step
	print ' '

	return

def check_mm_unit():
	## VERP 2014-04-11, v1.6

	global mm_unit

	if odb_file_title not in mm_unit.keys():
		vpnow = get_vpnow()
		dpo = vpnow.displayedObject
		if type_of(dpo) != 'ODB':
			raise Exception('*** Odb viewport is required.')

		display = vpnow.odbDisplay

		current_setting = current_variable_setting()

		mm_unit0 = ''
		if 'S' in odb_main_vars():
			dg = dg_now()
			current_leaf = dg['leaf']

			leaf = dgo.Leaf(leafType=DEFAULT_MODEL)  ## show all, and automatically fietview
			vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

			plot_variable('Mises')
			max0 = abs(display.contourOptions.autoMaxValue)
			min0 = abs(display.contourOptions.autoMinValue)

		##	print fnln(),'max0=',max0

			if max(max0,min0) > 1e5:
				mm_unit0 = False

			if mm_unit0 in empty:
				plot_variable('U')
				max0 = abs(display.contourOptions.autoMaxValue)
				min0 = abs(display.contourOptions.autoMinValue)

				please_check
				if max(max0,min0) > 1000:
					mm_unit0 = False

			vpnow.odbDisplay.displayGroup.replace(leaf=current_leaf)
			plot_variable(setting=current_setting)
			apply_view_location(dg['locs'])

		if mm_unit0 in empty:
			mm_unit0 = True

		mm_unit[odb_file_title] = mm_unit0

	return mm_unit[odb_file_title]

def create_circle(sketch,center=(0,0),radius=None,diameter=None, point1=None,ndir=None):
	## VER: 2016-08-10, v1.3

	## Example: 创建一个圆环
##	s2 = create_base_sketch('s_case')
##	create_circle(s2,center=(0,0),radius = steel_ID/2)
##	create_circle(s2,center=(0,0),radius = steel_OD/2)
##	sketch_to_shellpart(s2,partname='case')

	## create_circle('s1',center=points[0], radius=5, ndir='z')

	if is_number(diameter):
		radius = diameter/2

	sketch = check_sketch(sketch)
	if type_of(center) == 'vertices':
		center = center.coords

	if is_location(center) == False:
		raise Exception('*** center location is required for 3D point.')

	if len(center) == 3:
		if type_of(ndir) != 'STR':
			raise Exception('*** ndir of datum plane is required.')

		center = threeD_to_sketch_points(center, ndir=ndir)

	if radius in empty and point1 in empty:
		raise Exception('*** radius or point1 is required.')

	if type_of(radius) in numerics:
		point1 = (center[0] + radius, center[1])

	circle = sketch.CircleByCenterPerimeter(center=center, point1=point1)

	x1,y1 = center
	x2,y2 = point1

	x3 = (x1+x2)/2 + 1
	y3 = (y1+y2)/2 + 1
	loc_text = (x3,y3)

	sketch.RadialDimension(curve=circle,textPoint=loc_text)

	return circle  ## return the circle object

function_labels['create_arc'] = 'arc','circle','tangent','radius','center'
def create_arc(sketch,center,point1=(),point2=(),angle1=None, angle2=None, radius=None, quarter=None, angle=None, direction=COUNTERCLOCKWISE):
	## VER: 2016-05-19, v1.3
	## two methods: center + 2ends; 2ends + midpoint
##	arc1 = sketch.geometry.values()[-1]   ## 尽量减少这种方式的引用，而是用id。否则，可能会非正常退出。

	## Example:
	## point1,point2,arc1 = create_arc(s,center=(0,0),point1=(0.0, -9.76), point2=(9.76, 0.0), direction=COUNTERCLOCKWISE)
	## quarter:代表第几象限

##	create_arc(s1,center=(0,2*ejector_R),radius=ejector_R,angle=360)

	## Example:
##	point1,point2,arc1 = create_arc(s1,center=(0,ejector_R),radius=ejector_R,quarter=4)  ## 此时, arc的底部为(0,0)
##	s1.FixedConstraint(entity=arc1)


	## bot punch
##	create_arc(s1,center=(0,ejector_R),radius=ejector_R,quarter=4)
##	bias_cut_sketch(s1,y=ejector_circle_depth,side='+')
##	loc = find_loc(s1,x=MAX)
##
##	connect_points(s1,loc,ytilt(ejector_depth - ejector_circle_depth, ejector_tangent_angle),{'x':ejector_OD/2.0},{'dx':0.5})
##
##	loc1 = find_loc(s1,y=MAX,groupX=MIN)
##	round_sketch_corner(s1,loc=loc1,radius=ejector_land_R)

##>>> s1.geometry.values()[-1].getVertices()
## 结果是起点，终点和圆点三个数值。如果是圆，则可能是两个点。但不管怎样，最后一个点都是圆心。
##(mdb.models['Model-1'].sketches['sk_ejector'].vertices[3], mdb.models['Model-1'].sketches['sk_ejector'].vertices[4], mdb.models['Model-1'].sketches['sk_ejector'].vertices[5])
##>>>

	global arc_center, last_arc

	sketch = check_sketch(sketch)

	if quarter in empty:
		if angle == 90:
			quarter = 1
		elif angle == 180:
			quarter = 12
		elif angle == 270:
			quarter == 123
		elif angle == 360:
			quarter = 1234

	if point1 not in empty and point2 not in empty:
		sketch.ArcByCenterEnds(center=center, point1=point1, point2=point2, direction=direction)
		## 这种方法建立的弧线(非1/4或半圆)，很可能会出错，因为点的精确度不够（图纸上的尺寸仅仅是参考值，已经四舍五入了）。
		##最好还是先建立1/4或半圆，然后切割。

	elif type_of(radius) in numerics:
		if type_of(quarter) == 'INT':
			pt1 = (center[0] + radius, center[1])
			pt2 = (center[0], center[1] + radius)
			pt3 = (center[0] - radius, center[1])
			pt4 = (center[0], center[1] - radius)

			direction = COUNTERCLOCKWISE

			## 90 deg
			if quarter == 1:
				point1,point2 = pt1, pt2
			elif quarter == 2:
				point1,point2 = pt2, pt3
			elif quarter == 3:
				point1,point2 = pt3, pt4
			elif quarter == 4:
				point1,point2 = pt4, pt1

			## 180 deg
			elif quarter == 12:
				point1,point2 = pt1, pt3
			elif quarter == 23:
				point1,point2 = pt2, pt4
			elif quarter == 34:
				point1,point2 = pt3, pt1
			elif quarter == 41 or quarter == 14:
				point1,point2 = pt4, pt2
			elif quarter == 1234:
				point1 = pt1
				point2 = pt1

			sketch.ArcByCenterEnds(center=center, point1=point1, point2=point2, direction=direction)

		elif angle1 not in empty and angle2 not in empty:
			x0,y0 = center
			x1 = round(radius*cos(angle1/180*pi),6)
			y1 = round(radius*sin(angle1/180*pi),6)
			x1 = x1 + x0
			y1 = y1 + y0
			point1 = (x1,y1)

			x2 = round(radius*cos(angle2/180*pi),6)
			y2 = round(radius*sin(angle2/180*pi),6)
			x2 = x2 + x0
			y2 = y2 + y0
			point2 = (x2,y2)

			sketch.ArcByCenterEnds(center=center, point1=point1, point2=point2, direction=COUNTERCLOCKWISE)

##	print sketch.geometry.values()[-1].getVertices()

	## arc object
##	arc1 = sketch.geometry.values()[-1]   ## 尽量减少这种方式的引用，而是用id。否则，可能会非正常退出。
##	sketch.autoDimension(objectList=(arc1,))
##	id = sketch.geometry.keys()[-1]

	locs = (point1,point2)

	arc_center = sketch.vertices.values()[-1].coords	;please_check
	last_arc = sketch.geometry.values()[-1]

##	start,end,arc_center这三个点就保存在arc.getVertices()中。
##	return locs,last_arc   ## loc中，start, end   逆时针顺序

	return point1,point2,last_arc

def area_of_partial_circle(R,depth):
	## VER: 2013-11-04, v1.0
	## 获得一个圆冠的面积，该圆冠的深度为depth，半径为R。当depth=R时，圆冠为半圆。

	cosA = (R-depth)/R
	sinA = sqrt(1 - cosA*cosA)

	A = acos((R-depth)/R)

	area = A*R*R - R*(R-depth)*sinA

	area = round(area,3)

	area0 = round(pi*R*R,3)
	print 'area of full circle is',area0

	return area

def area_shape(faces,poi=None):
	## VER: 2011-01-28, v1.1

	faces,poi = check_faces(faces,poi)
	area1 = get_area(faces)

	x1,x2,y1,y2,z1,z2 = objs_space(faces)
	Az = (x2 - x1)*(y2 - y1)
	Ax = (y2 - y1)*(z2 - z1)
	Ay = (x2 - x1)*(z2 - z1)
	if Ax > 1e-6:
		area = Ax
	elif Ay > 1e-6:
		area = Ay
	elif Az > 1e-6:
		area = Az

	if abs(area1 - area) < 1e-6:
		shape = 'axis_plane_rectangle'
	else:
		shape1 = face_shape(faces[0])
		if shape1 == 'axis_plane':
			shape = 'axis_plane_irregular'
		else:
			shape = shape1

	return shape

def scale_part(part,newpart_name,scale=None,D1=None,D2=None,H1=None,H2=None,L1=None,L2=None):
	## VER: 2014-07-30, v1.1

	if part not in _m.parts.keys():
		raise Exception('*** partname is required.')

	part = check_part(part)
	partname = part.name

	if type_of(newpart_name) != 'STR':
		raise Exception('*** newpart_name is required.')

	newpart_name = new_key(_m.parts.keys(), newpart_name)

	## cannot round the scale!
	if type_of(D1) in numerics and type_of(D2) in numerics:
		scale = D2/D1
	elif type_of(H1) in numerics and type_of(H2) in numerics:
		scale = H2/H1
	elif type_of(L1) in numerics and type_of(L2) in numerics:
		scale = L2/L1

	if type_of(scale) not in numerics:
		raise Exception('*** scale is required.')

	mat_ids = get_mat_ids(part)

	_m.Part(name=newpart_name, objectToCopy=part, compressFeatureList=ON, scale=scale)

	if mat_ids not in empty:
		apply_mat_ids(newpart_name,mat_ids)

	get_current_model()

	return newpart_name

def screen():
	## VER: 2014-06-10, v1.0 to print back to screen in case of print to file errors.

	sys.stdout = screen_output
	return

function_labels['side1_faces_to_pair'] = 'contact','interact','tie','find_contacts','mate'
def side1_faces_to_pair(side1_faces,side2_inst, side1_inst=None,search_or_find='search', gap=None, fix='_', refined_insts='_', refined=None,force_create=False):
	## VER: ('VER: 2016-10-25, v4.5')
	## reference: mate_faces_in_inst()

	## Example:
##	faces = side1_faces_to_pair(faces1,'pad1',refined=1)

	global contact_pairs,msfaces_trace, msfaces_determined
	## caller = get_msface_and_msregion

	add_to_process()

	if is_pia(side1_faces):
		side1_faces, side2_inst = side2_inst, side1_faces

	side2_inst = check_inst(side2_inst)
	if side1_inst in empty:
		side1_inst = get_poi(side1_faces)
	side1_inst = check_inst(side1_inst)

	print fnln_fnln(),'base=',side1_inst.name,'and mate=',side2_inst.name,', search_or_find=',search_or_find

	if refined not in empty:
		refined_insts = refined

	refined_insts = totext(refined_insts)
	if refined_insts == '1':
		refined_insts = side1_inst.name
	elif refined_insts == '2':
		refined_insts = side2_inst.name
	elif refined_insts == '12':
		refined_insts = side1_inst.name + '+' + side2_inst.name

	print '**start side1_faces_to_pair========='
	time1 = time.time()

##	if type_of(side1_inst) != 'PINSTANCE' or type_of(side2_inst) != 'PINSTANCE':
##		raise Exception('Instance is required.')  ## ********

	print fnln(),'refined_insts=',refined_insts
	print fnln(),'side1_inst=',side1_inst.name
	print fnln(),'side2_inst=',side2_inst.name

##	raise Exception

	if gap not in empty:
		force_create = True

	type1 = type_of(side1_faces)
	if type1 == 'STR' and side1_faces not in empty:   ## from find_contacts()
		face_set = side1_faces
		side1_faces = set2objs(face_set,side1_inst)
	elif type1 == 'faces':
		side1_faces = [side1_faces]

	if side1_faces in empty:
		raise Exception('******Empty side1_faces for ' + side1_inst.name)

	space1 = objs_space(side1_faces)
	space2 = poi_space(side2_inst)
	cross = cross_of_spaces(space1,space2)
	if cross['no_cross'] == True and force_create == False:
		side2_faces = []
		print 'No cross between side1_faces and',side2_inst.name
		msfaces_trace.append(get_traceback()[-2:] + ['No cross between side1_faces and side2_inst=' + side2_inst.name])
		return side1_faces,side2_faces

	ndir = face_ndir(side1_faces[0])
	x0,y0,z0 = side1_faces[0].pointOn[0]

	if ndir not in bending_dirs:				## 对于ndir in ['x','y','z','slope']才有意义。
		nx0,ny0,nz0 = facing_dir(side1_faces[0],ndir=ndir)
		nx0 = -nx0;	ny0 = -ny0;	nz0 = -nz0

	ao_tu1 = AV_shape(side1_faces[0])
	if len(side1_faces) > 1:
		ao_tu = AV_shape(side1_faces[-1])
		if ao_tu != ao_tu1:
			raise Exception('side1_faces的凹凸不一，无法找到side2_faces。需要提供side2_faces才能建立接触对。')

	if ao_tu1 == 'U':
		ao_tu2 = 'A'
	elif ao_tu1 == 'A':
		ao_tu2 = 'U'
	elif ao_tu1 == 'flat':
		ao_tu2 = 'flat'
	else:
		ao_tu2 = 'unknow'

	if ndir == 'slope':		##???****
		search_or_find = 'find'

	print ' '
	print fnln_fnln(),'base=',side1_inst.name,'and mate=',side2_inst.name,', search_or_find=',search_or_find

	## 查找side2_faces
	if search_or_find == 'search':
		## 第一关：对于ndir in ['x','y','z']，先进行朝向(法向)的排除(很大相同朝向的面也将被选入)
		if ndir in ['x','y','z']:  ##根据base_face的朝向、offset、和range来选择。
##			x1,x2,y1,y2,z1,z2 = objs_space(side1_faces)
			x1,x2,y1,y2,z1,z2 = objs_space(side1_faces)
			## 查找side2_faces
			if force_create == False and gap in empty:
				print fnln_fnln(),'ndir=',ndir
				if ndir == 'x':
					side2_faces = faces_of_cut(side2_inst,ndir=ndir,nx=nx0,ny=ny0,nz=nz0,x=x0,y=(y1,y2),z=(z1,z2))	## 只选offset=x0，且朝向相符的面。
				elif ndir == 'y':
					side2_faces = faces_of_cut(side2_inst,ndir=ndir,nx=nx0,ny=ny0,nz=nz0,x=(x1,x2),y=y0,z=(z1,z2))	## 只选offset=y0，且朝向相符的面。
				elif ndir == 'z':
					side2_faces = faces_of_cut(side2_inst,ndir=ndir,nx=nx0,ny=ny0,nz=nz0,x=(x1,x2),y=(y1,y2),z=z0)	## 只选offset=z0，且朝向相符的面。

				msfaces_trace.append(get_traceback()[-2:] + ['side1_'+side1_inst.name,objs_num(side1_faces), 'side2_' + side2_inst.name,objs_num(side2_faces),'search_or_find=',search_or_find, 'refined=',refined_insts,'fix=',fix])

				if len(side2_faces) == 0:
					print fnln_fnln(),'side2_faces is empty'
					return side1_faces,side2_faces

			else:	## force_create=True or gap not in empty
				if ndir == 'x':
					side2_faces = face_select(side2_inst,ndir=ndir,nx=nx0,ny=ny0,nz=nz0,y=(y1,y2),z=(z1,z2))	## 不限offset=x0，且朝向相符的面。
				elif ndir == 'y':
					side2_faces = face_select(side2_inst,ndir=ndir,nx=nx0,ny=ny0,nz=nz0,x=(x1,x2),z=(z1,z2))	## 不限offset=y0，且朝向相符的面。
				elif ndir == 'z':
					side2_faces = face_select(side2_inst,ndir=ndir,nx=nx0,ny=ny0,nz=nz0,x=(x1,x2),y=(y1,y2))	## 不限offset=z0，且朝向相符的面。

				if len(side2_faces) == 0:
					print fnln_fnln(),'side2_faces is empty'
					return side1_faces,side2_faces

				side2_faces = refine_side2_faces_ndir(side1_faces,side2_faces,force_create=force_create,gap=gap)

				msfaces_trace.append(get_traceback()[-2:] + [side1_inst.name + '_side1',objs_num(side1_faces), side2_inst.name + '_side2',objs_num(side2_faces),'search_or_find=',search_or_find, 'refined=',refined_insts,'fix=',fix])

			if side1_inst.name in refined_insts or side2_inst.name in refined_insts:
				side1_faces,side2_faces = refine_faces_pair_inplane(side1_faces,side2_faces,refined_insts=refined_insts)

			if side2_faces in empty or side1_faces in empty:
				print fnln_fnln(),'side1_faces or side2_faces is empty after refine_faces_pair_inplane()'
				return side1_faces,side2_faces

##			raise Exception

		elif ndir == 'slope':
			side2_faces = find_slope_faces(side2_inst,ndir=ndir,nx=nx0,ny=ny0,nz=nz0)
			if len(side2_faces) == 0:
				print fnln_fnln(),'side2_faces is empty'
				return side1_faces,side2_faces

			space_b0 = objs_space(side1_faces)
			space_m0 = objs_space(side2_faces)
			cross = cross_of_spaces(space_b0,space_m0)

			if cross['no_cross'] == True:
				print fnln_fnln(),'******For',side2_inst.name,": cross['no_cross'] == True, no mate faces."
				side2_faces = []
				return side1_faces,side2_faces
			else:
				side2_faces = face_select(side2_inst,faces=side2_faces,x=cross['cross_x'],y=cross['cross_y'],z=cross['cross_z'])
				if side1_inst.name not in fix: ## refine
					side1_faces = face_select(side1_inst,faces=side1_faces,x=cross['cross_x'],y=cross['cross_y'],z=cross['cross_z'])

				if side1_faces in empty or side2_faces in empty:
					return side1_faces,side2_faces

				space_b1 = objs_space(side1_faces)
				space_m1 = objs_space(side2_faces)
				cross = cross_of_spaces(space_b1,space_m1)

				if cross['no_cross'] == True:
					print fnln_fnln(),'******For',side2_inst.name,": cross['no_cross'] == True, no mate faces."
					side2_faces = []
					return side1_faces,side2_faces

		else:
			side2_faces = face_select(side2_inst,ao_tu = ao_tu2)		## 根据ao_tu选择side2_faces

			if len(side2_faces) == 0:
				print fnln_fnln(),'side2_faces is empty'
				return side1_faces,side2_faces

			cross = cross_of_faces_and_faces(side1_faces, side2_faces)
			if cross['no_cross'] == True:
				print '**No cross. cross=',cross
				side2_faces = []
				return side1_faces,	side2_faces

			msfaces_trace.append(get_traceback()[-2:] + [side1_inst.name + '_side1',objs_num(side1_faces), side2_inst.name + '_side2',objs_num(side2_faces),'search_or_find=',search_or_find, 'refined=',refined_insts,'fix=',fix])

			side2_faces = face_select(side2_inst,faces=side2_faces, space=cross['cross_space'])		## 根据cross选择side2_faces
			if len(side2_faces) == 0:
				print fnln_fnln(),'side2_faces is empty.'
				return side1_faces,side2_faces

			## Refine
			cross = cross_of_faces_and_faces(side1_faces, side2_faces)
			if cross['no_cross'] == True:
				print '**No cross. cross=',cross
				side2_faces = []
				return side1_faces,	side2_faces

			if side1_inst.name not in fix:
				side1_faces = face_select(side1_inst,faces=side1_faces, space=cross['cross_space'])
				if len(side1_faces) == 0:
					print fnln_fnln(),'side1_faces is empty after refine.'
					return side1_faces,side2_faces

			msfaces_trace.append(get_traceback()[-2:] + [side1_inst.name + '_side1',objs_num(side1_faces), side2_inst.name + '_side2',objs_num(side2_faces),'search_or_find=',search_or_find, 'refined=',refined_insts,'fix=',fix])

##		elif ndir == 'cylindrical':
##			axis1,center1 = center_axis_of_cylind_face(side1_faces[0])
##			mates = []
##			for face in side2_faces:
##				axis2,center2 = center_axis_of_cylind_face(face)
##				if is_parallel_vector(axis1,axis2):
##					mates.append(face)
##			side2_faces = mates
##			return side1_faces,side2_faces   ##???****

	else:	  ## find method
		shape1 = area_shape(side1_faces)
		cross = cross_of_faces_and_inst(side1_faces,side2_inst)
		print 'force_create=',force_create
		if cross['no_cross'] == True and force_create == False:
			print fnln_fnln(),'******In',side2_inst.name,": no mate faces."
			print 'cross=',cross
			return side1_faces,[]	##???****
		else:
			print 'side1_inst=',side1_inst.name,', side2_inst=',side2_inst.name
			if len(cross['touch_dir']) == 1 and shape1 == 'axis_plane_rectangle':
				if side1_inst.name not in fix:
					side1_faces = face_select(side1_inst,faces=side1_faces,x=cross[0]['range'], y=cross[1]['range'], z=cross[2]['range'])

		check_num = len(side1_faces)

		msfaces_trace.append(get_traceback()[-2:] + [side1_inst.name + '_side1',objs_num(side1_faces), 'side2_inst', side2_inst.name,'search_or_find=',search_or_find, 'refined=',refined_insts,'fix=',fix])

		side2_faces = []
		found = False

		i = 0
		faces1_new = []
		none_num = 0
		for face1 in side1_faces:
			i = i + 1

			pointOn = face1.pointOn[0]
			seeds = [pointOn]
			seeds = face_seeds(side1_inst,face1)

			for seed in seeds:
				face2 = face_at(side2_inst,seed)

				if type_of(face2) == 'faces':
					x1,y1,z1 = face1.getNormal()
					x2,y2,z2 = face2.getNormal()
					if (PK(x1,x2) == 0 and PK(y1,y2) == 0 and PK(z1,z2) == 0) or \
						(PK(x1,-x2) == 0 and PK(y1,-y2) == 0 and PK(z1,-z2) == 0):
						found = True
						if face1 not in faces1_new:
							faces1_new.append(face1)
						if face2 not in side2_faces:
							side2_faces.append(face2)
				else:
					none_num += 1

			if verify == 'yes' and i == check_num and len(side2_faces) == 0:
				print fnln_fnln(),'******Search in',side2_inst.name,': verify failed, no side2_face found in side1_faces_to_pair() with search_or_find=',search_or_find
				if shape1 == 'axis_plane_rectangle':
					search_or_find = 'search'
					print 'But area_shape = axis_plane_rectangle, turn to search method in side1_faces_to_pair()'

				break

		if none_num >=20:
			print fnln_fnln(),'****Too much of None returned by findAt()'

		if len(faces1_new) != len(side1_faces) and len(faces1_new) > 0:
			side1_faces = faces1_new

	if len(side2_faces) > 0:
		print fnln_fnln(),'Search in',side2_inst.name,': Found',len(side2_faces),'mate faces, search_or_find=',search_or_find

	if len(side1_faces) > 0 and len(side2_faces) > 0:
		msfaces_determined = True

	msfaces_trace.append(get_traceback()[-2:] + [side1_inst.name + '_side1',objs_num(side1_faces), side2_inst.name + '_side2',objs_num(side2_faces),'msfaces_determined=',msfaces_determined])

	time2 = time.time()
	print '**end side1_faces_to_pair========='
	print 'run time=',time2 - time1
	print ' '

	return side1_faces, side2_faces

def assembly_module():
	## VER: 2012-10-19, v1.0

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.setValues(mesh=OFF)
	vpnow.assemblyDisplay.meshOptions.setValues(meshTechnique=OFF)

	return

def average_and_dev(list1):
	## VER: 2015-07-24, v1.0

##	>>> list2 = 16.166, 16.183, 16.168, 16.276, 16.283, 16.298, 16.289, 16.225
##	>>> average_and_dev(list2)
##	['average_and_dev', 4139] avg= 16.236 , dev= 0.05722 ,dev_ratio= 0.35
##	(16.236, 0.05722, 0.35)
##	>>>

	num = len(list1)
##	num1 = num
	if num > 30:
		num1 = num
	else:
		num1 = num - 1

	avg = sum(list1)/num

	dev = 0
	for i in range(num):
		dev = dev + (list1[i] - avg)**2

	avg = smart_round(avg)
	dev = smart_round(sqrt(dev/num1))
	dev_ratio = round(abs(dev/avg)*100,2)

	print fnln(),'avg=',avg,', dev=',dev,',dev_ratio=',dev_ratio

	return avg, dev,dev_ratio

def average_density(inst=None):
	## VER: 2014-12-30, v1.3

	insts = []
	deforms = []
	for inst in oa.instances.values():
		if inst.type == DEFORMABLE_BODY:
			deforms.append(inst)
			if 'powder' in inst.name.lower():
				insts.append(inst)
			elif 'H10POW' in inst.elements[0].sectionCategory.name:
				insts.append(inst)

	if insts in empty and len(deforms) == 1:
		insts = deforms

##	inst = check_odb_inst(inst)
	step_name,frame,time1 = current_step_frame_time()
##	density = odb.steps.values()[-1].frames[-1].fieldOutputs['DENSITY'].values
##	print fnln(),'frame=',frame
	density = odb.steps[step_name].frames[frame].fieldOutputs['DENSITY'].values

	values = []
	for value in density:
##		if value.instance == inst:
		if value.instance in insts:  ## value.instance is object,not instance name
			values.append(value.data)

	values = _sort(values)[10:-10]		## 删除10个单元最大的值。
	average = round(sum(values)/len(values)*1e9,3)

	return average

def average_density_vs_time(insts=None,step=None):
	## VER: 2014-12-30, v1.1

	## Example: average_density_vs_time(insts='POWDER_A1')
	## example: average_density_vs_time()

	insts = tolist(insts)
	if insts in empty:
		insts = oa.instances.values()

	insts = real_odb_insts(insts)

	insts1 = []
	deforms = []
	for inst in insts:
		if inst.type == DEFORMABLE_BODY:
			deforms.append(inst)
			if 'powder' in inst.name.lower():
				insts1.append(inst)
			elif 'H10POW' in inst.elements[0].sectionCategory.name:
				insts1.append(inst)

	if insts1 in empty and len(deforms) == 1:
		insts1 = deforms

	if insts1 in empty:
		raise Exception('*** powder instances required.')

	insts = insts1

	if step in empty:
		step = -1

	step = check_odb_step(step)

	results = []
	for id in range(len(step.frames)):
		set_step_and_frame(step=step,frame=id)
		time1 = step.frames[id].frameValue
		density = step.frames[id].fieldOutputs['DENSITY'].values

		values = []
		for value in density:
			if value.instance in insts:  ## value.instance is object,not instance name
				values.append(value.data)

		values = _sort(values)[10:-10]		## 删除10个单元最大的值。
		average = round(sum(values)/len(values)*1e9,3)

		results.append((time1,average))

	variable = 'DENSITY'
	data_type = DENSITY

	screen()
	filename = '_xydata_' + variable + '_' + odb_file_title + '_1.txt'
	filename = check_file_name(filename,format='TXT')
	print 'xydata filename=',filename	##  D:/JYQ/A0212/_xydata_S_C6_A0212_rotary_initialV150_10_4.txt
	sys.stdout = open(filename,'w')  ## save 1

	for time1, data1 in results:
		print time1, '   ', data1
	screen()

	name = new_key(session.xyPlots.keys(),'xyplot-1')
	xyp = session.XYPlot(name)
	chartName = xyp.charts.keys()[0]
	chart = xyp.charts[chartName]
	xQuantity = visualization.QuantityType(type=TIME)
	yQuantity = visualization.QuantityType(type=data_type)

	print 'xQuantity=',xQuantity
	print 'yQuantity=',yQuantity

##	raise Exception
	xy1 = xyPlot.XYDataFromFile(fileName=filename, xField=1,
	    yField=2, contentDescription=variable, yValuesLabel=variable, axis1QuantityType=xQuantity, axis2QuantityType=yQuantity, )
	c1 = session.Curve(xyData=xy1)
	chart.setValues(curvesToPlot=(c1, ), )
	vpnow.setValues(displayedObject=xyp)

##	raise Exception

## GUI:
##>>> chart = session.charts.values()[-1]
##>>> axis_data = chart.axes2[0].axisData

	chart = get_current_chart()

	text2 = ' (Avg., g/cc)'
	update_axis2(chart,text2)

	refresh()
	save_image()

	return results

function_labels['average_xdist'] = 'gap','node','distance'
def average_xdist(nodes1,nodes2):
	## VER: 2016-09-06, v1.0

##	>>> nodes1 = node_select(p1,x=MAX,err=0.1)
##	['cliCommand', 1, 'node_select', 51960] 534 nodes are selected by node_select().
##	>>> nodes2 = node_select(p1,x=MIN,err=0.1)
##	['cliCommand', 1, 'node_select', 51960] 531 nodes are selected by node_select().
##	>>> average_xdist(nodes1,nodes2)
##	15.7904
##	>>>

	x1 = average_xloc(nodes1)
	x2 = average_xloc(nodes2)

	dist = abs(x2 - x1)
	dist = round(dist,4)

	return dist

function_labels['average_ydist'] = 'gap','node','distance'
def average_ydist(nodes1,nodes2):
	## VER: 2016-09-06, v1.0

##	>>> nodes1 = node_select(p1,x=MAX,err=0.1)
##	['cliCommand', 1, 'node_select', 51960] 534 nodes are selected by node_select().
##	>>> nodes2 = node_select(p1,x=MIN,err=0.1)
##	['cliCommand', 1, 'node_select', 51960] 531 nodes are selected by node_select().
##	>>> average_xdist(nodes1,nodes2)
##	15.7904
##	>>>

	y1 = average_yloc(nodes1)
	y2 = average_yloc(nodes2)

	dist = abs(y2 - y1)
	dist = round(dist,4)

	return dist

function_labels['average_zdist'] = 'gap','node','distance'
def average_zdist(nodes1,nodes2):
	## VER: 2016-09-06, v1.0

##	>>> nodes1 = node_select(p1,x=MAX,err=0.1)
##	['cliCommand', 1, 'node_select', 51960] 534 nodes are selected by node_select().
##	>>> nodes2 = node_select(p1,x=MIN,err=0.1)
##	['cliCommand', 1, 'node_select', 51960] 531 nodes are selected by node_select().
##	>>> average_xdist(nodes1,nodes2)
##	15.7904
##	>>>

	z1 = average_zloc(nodes1)
	z2 = average_zloc(nodes2)

	dist = abs(z2 - z1)
	dist = round(dist,4)

	return dist

def average_xloc(nodes):
	## VER: 2016-09-06, v1.0

##	>>> nodes = node_select(p1,x=MAX,err=0.1)
##	['exterior_nodes', 24725] shape= 3D
##	---> 485 exterior nodes
##	['cliCommand', 1, 'node_select', 51597] 485 nodes are selected by node_select().
##	>>> average_xloc(nodes)
##	7.925724

	nodes = tolist(nodes)
	locs = []
	for node in nodes:
		loc = node.coordinates
		locs.append(loc[0])

	avg = sum(locs)/len(locs)
	avg = round(avg,6)

	return avg

def average_yloc(nodes):
	## VER: 2016-09-06, v1.0
	## to avoid err in measurement in GUI

	nodes = tolist(nodes)
	locs = []
	for node in nodes:
		loc = node.coordinates
		locs.append(loc[1])

	avg = sum(locs)/len(locs)
	avg = round(avg,6)

	return avg

def average_zloc(nodes):
	## VER: 2016-09-06, v1.0

	nodes = tolist(nodes)
	locs = []
	for node in nodes:
		loc = node.coordinates
		locs.append(loc[2])

	avg = sum(locs)/len(locs)
	avg = round(avg,6)

	return avg

def average_shrinkage(inst=None,low=0.02,high=0.98,C1=2.505,th=14.44,for_green=False):
	## VER: 2016-09-14, v1.9

##	>>>average_shrinkage(for_green=False)   ## refresh()时，用此数据。为LE云图的中间值
##	(-0.2007, 14.13, 2.81)
##	>>>average_shrinkage(for_green=True)
##	(0.1901, 14.13, 2.81)
##	>>>real_shrinkage()
##	(0.1901, 14.13, 2.81)

##	>>> average_shrinkage(th=14.28, C1=2.78)
##	['average_shrinkage', 4426] *** (low, mid, high) means volume percentage since element volume EVOL available.
##	['average_shrinkage', 4451] Below is simple average and get deviation.
##	['average_and_dev', 4214] avg= -0.1939 , dev= 0.01364 ,dev_ratio= 7.03
##
##	['average_shrinkage', 4456] By volume fraction, average shrinkage = -0.2004
##	['shrinkage_to_density_with_PEG', 18708] relative density= 0.525851042929
##	0.1899   ## Engineering design reference: 19%
##	>>>

##	>>> average_shrinkage()
##	['average_shrinkage', 4414] *** (low, mid, high) means volume percentage since element volume EVOL available.
##	['average_shrinkage', 4439] Below is simple average and get deviation.
##	['average_and_dev', 4214] avg= -0.1939 , dev= 0.01364 ,dev_ratio= 7.03
##
##	['average_shrinkage', 4444] By volume fraction, average shrinkage = -0.2004
##	-0.2004
##	>>> real_shrinkage(0.2004, th=14.28, C1=2.78)
##	['shrinkage_to_density_with_PEG', 18692] relative density= 0.525851042929
##	0.1899
##	>>>

	if not (0.01 <= low <= 0.5):
		raise Exception('*** low is between 0.05 and 0.5')

	if not (0.5 <= high <= 0.99):
		raise Exception('*** high is between 0.5 and 0.95')

	if inst in empty:
		inst = oa.instances.keys()[0]

	inst = check_odb_inst(inst)
	insts = [inst]

	step_name,frame,time1 = current_step_frame_time()
##	density = odb.steps[step_name].frames[frame].fieldOutputs['DENSITY'].values
	LE = odb.steps[step_name].frames[frame].fieldOutputs['LE'].values

	vol_available = False
	if 'EVOL' in odb.steps[step_name].frames[frame].fieldOutputs.keys():
		IVOLs = odb.steps[step_name].frames[frame].fieldOutputs['EVOL'].values
		vol_available = True

	values = []
	vols = []

	num = len(LE)
	mass = 0
	LE_vol = []

	for value in LE:
		if value.instance in insts:  	## value.instance is object,not instance name
			shrinkage = value.maxPrincipal
			values.append(shrinkage)

			if vol_available:
				label = value.elementLabel
				vol = IVOLs[label-1].data
			else:
				vol = 'NA'

			vols.append(vol)
			LE_vol.append((shrinkage,vol))

	LE_vol = sorted(LE_vol, key=lambda item: item[0])
	if vol_available == False:   ## 此时low, high仅代表数据量，不代表体积. mid_LE != average
##		print ' '
		print fnln(),'*** (low, mid, high) means elements percentage since element volume EVOL not available.'
		low_index = int(num*low + 0.5)
		mid_index = int(num*0.5 + 0.5)	## 简单地取中间数位置的密度为中位数。此时，中位数不等于平均数。
		high_index = int(num*high + 0.5)

		low_LE = LE_vol[low_index][0]
		mid_LE = LE_vol[mid_index][0]
		high_LE = LE_vol[high_index][0]

		values = _sort(values)		## 数值排序
##		values = values[10:-10]		## 删除10个单元最大的值。
		average = round(sum(values)/len(values)*1e9,2)

		mass = 'NA'
		volume = 'NA'

	else:	## 此时的low, high代表体积分数，此时mid_density = average
##		print ' '
		print fnln(), '*** (low, mid, high) means volume percentage since element volume EVOL available.'
		fraction = 0
		vol_all = sum(vols)
		low_LE = 0
		mid_LE = 0
		high_LE = 0
		average = 0

		for i in range(num):  ## low, high, mid就代表了体积分数
			shrinkage, vol = LE_vol[i]
			fraction = fraction + vol/vol_all
			average = average + shrinkage*vol/vol_all

			if fraction > low and low_LE == 0:
				low_LE = shrinkage
			if fraction > 0.5 and mid_LE == 0:
				mid_LE = shrinkage
			if fraction > high and high_LE == 0:
				high_LE = shrinkage

		average = round(average,4)
##		print fnln(),'average=',average
		volume = round(vol_all,1)

	## 计算标准差 standard deviation
	print fnln(),'Below is simple average and get deviation.'
	avg,dev,ratio = average_and_dev(values)

##	print 'avg,dev,ratio=',avg,dev,ratio
	print ' '
	print fnln(),'*** After offset, by volume fraction, average shrinkage =',abs(average)

##	result = average
##	if is_numbers(C1,th):
##		print fnln(),'th=',th
##		raise Exception
##	th0 = th
##	C10 = C1
##	fields = (('theoretical density:',str(th)),('sinter loss C1:',str(C1)))
##	th,C1 = getInputs(fields=fields, label=str(fnln_fnln()) + ': Need density_th and sintering loss for real shrinkage')
##	if C1 != None:
##		C1 = float(C1)
##	if th != None:
##		th = float(th)

	print fnln(),'Before asking:',(th,C1)
	table1 = (('theoretical density:',th),('sinter loss C1:',C1))
	th,C1 = GUI_inputs(table1,'Need density_th and sintering loss for real shrinkage')
	print fnln(),'After asking:',(th,C1)

	result = average
	if for_green == True:
		result = real_shrinkage(average,th=th,C1=C1,offset=-0.3)

##	print ' '
##	print fnln(),'*** Before density offset, by volume fraction, real average shrinkage =',result

	return result,th,C1

def gongjijin(base,top,ratio=0.1):
	## base: 住房公积金基数(与上一年度的总收入有关,13薪在12月份发时第二年基数提高，但12月份不享受税率优惠)
	## top: 住房公积金封顶数

	if is_numbers(base,top) == False:
		raise Exception('*** base or top should be number.')

	## 住房公积金超限补助
	refund = (base - top)*ratio
	if refund < 0:
		refund = 0

	return refund

function_labels['GUI_inputs'] = 'get input','user input','GUI','window','parameters','default'
def GUI_inputs(keys=(),info='',title=''):
	## VER: 2017-06-22, v1.4
	## 注意info中有多行时，可以用\n来换行。
	## title不能有多行，为窗口本身的标题

##	>>> GUI_inputs(('var1',('var2',5),'var3'))
##	['GUI_inputs', 5410] inputs= ['', 5.0, '']
##	['', 5.0, '']
##	>>>

##	>>> GUI_inputs(('var1','var2','var3'))
##	['GUI_inputs', 5410] inputs= ['', '', '']
##	['', '', '']
##	>>>

##	>>> GUI_inputs('jobnum:')
##	['GUI_inputs', 5327] inputs= a1
##	'a1'
##	>>>

##	>>> refresh(text='OB06,side1')
##	['update_xyplot_viewport', 79880] odb_file_full_name = A0282_compact_PFH1314.odb
##	['GUI_inputs', 5252] inputs= ['compact_OB06', 'sinter, side1']
##	run hide_datum() or show_datum() for datum display options.
##	>>>

##	path1,note1 = GUI_inputs([('file path',odb_file_full_name),('note',text)],title='Create xyplot annotations',info='Text to show in the xyplot:')
##	if len(path1) > 0:
##		create_xyplot_annotation(viewport=viewport,text=path1, xloc=40, yloc=20)
##	if len(note1) > 0:
##		create_xyplot_annotation(viewport=viewport,text=note1, xloc=40, yloc =10)

##	>>> GUI_inputs(['axis'])
##	['GUI_inputs', 5148] inputs= ['y']
##	['y']
##	>>> GUI_inputs('axis')
##	['GUI_inputs', 5148] inputs= ['y']
##	['y']
##	>>>

##	axis = GUI_inputs(('axis','z'),info='pressing axis')

##	text = 'steps: '
##	for i in range(len(_m.steps)):
##		text = text + str(i) + '-' + _m.steps.keys()[i] + ','
##	text = text[:-1]
##	axis,finish_step = GUI_inputs([('pressing axis','z'),'finish step num without ejection'],info=text)
##	try:
##		finish_step = int(finish_step)
##	except:
##		finish_step = None

##	keys = totable(keys)
	if type_of(keys) == 'STR':
		keys = [keys]

	if type_of(keys) not in ['LIST','TUPLE','DICT']:
		raise Exception('*** variables are required.')

	if type_of(keys) == 'DICT':
		keys = keys.items()

##	print fnln(),'keys=',keys
	newlist = []
	for key in keys:
		if type_of(key) == 'STR':
			newlist.append((key,''))
		elif type_of(key) in ['LIST','TUPLE']:
			list1 = key
			if type_of(list1[0]) == 'STR':
				if len(list1) == 1:
					newlist.append((list1[0],''))
				elif len(list1) == 2:
					newlist.append((list1[0],list1[1]))

##		if len(key) == 1:
##			newlist.append((key[0],''))
##		elif len(key) > 1:
##			newlist.append((key[0],key[1]))
	keys = totuple(newlist)

##	print fnln(),'keys=',keys
	values0 = []
	for item in keys:
##		print 'item=',item
		values0.append(item[1])

	fields = []
	for text1,value1 in keys:
		fields.append((str(text1),str(value1)))
	fields = totable(fields)

	inputs = getInputs(fields=fields, label=str(info),dialogTitle=title)
##	inputs = getInputs(fields=fields, label=str(fnln_fnln()) + ': ' + info)
##	print fnln(),'inputs=',inputs
	if inputs[0] == None:
		inputs = values0
	else:
		newlist = []
		for item in inputs:
			try:
				item1 = float(item)
				newlist.append(item1)
			except:
				newlist.append(item)
		inputs = newlist

	if len(inputs) == 1:
		inputs = inputs[0]

	print fnln(),'inputs=',inputs

	return inputs


def ymax_faces(poi, x=None, z=None):

	## VER: ('VER: 2012-06-20, v1.1')	## 只要面的法线为y方向，即使该面是倾斜的，也是可以选中的。

	poi = check_pias(poi)
	faces = faces_of_cut(poi, y=MAX, x=x, z=z)

	return faces

def back_run(num=1):
	## VER: 2014-11-20, v1.0

	batch_file(num)
	batch_run()

	print '--->Back running, click job->results to see the results, and open *.sta file for running status.'

	return

def backup(list1):
	## 2011-11-17, v1.0  列表的备份，不是引用。

	list1 = tolist(list1)
	list2 = eval(repr(list1))

	return list2

def body_obj(poi):
	## VER: 2014-12-23, v1.0
	## can be used to creat a set of the poi.
	## caller: such as: part_to_rigid_body()

	poi = check_poi(poi)
	if len(poi.cells) > 0:
		objs = poi.cells
	elif len(poi.faces) > 0:
		objs = poi.faces
	elif len(poi.edges) > 0:
		objs = poi.edges
	elif len(poi.elements) > 0:
		objs = poi.elements
	else:
		raise Exception('*** Fail to get the base objects.')

	return objs

def batch_divide(parts=(),cutter='',axis='x',offsets=(),d=0,indices=(), cells=None,x=None,y=None,z=None,poiRefX=(),poiRefY=(),poiRefZ=(),xParts=(),xLocs=()):
	## VER: ('VER: 2013-01-07, v2.9')	## parts or cells are divided through.
	## 例如：batch_divide([clamp,lam],y=[_ymin(clamp) + differ/2, _ymax(clamp) - differ/2])   ## parts和offsets都是一个list

	global _divide_num

	if parts not in empty:
		parts = real_parts(parts)
		if parts in empty:
			print 'No parts to divide'
			return
	else:
		parts = _m.parts.values()

	if type_of(cutter) == 'PART':
		parts = unselect(parts,cutter)

	xParts = real_parts(xParts)
	if xParts not in empty:
		parts = unselect(parts,xParts)

	part_names = []
	for part in parts:
		part_names.append(part.name)

	if is_empties(poiRefX,poiRefY,poiRefZ) == False:
		x1,x2,y1,y2,z1,z2 = real_space(parts[0],poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ,empty2space=True)
		if poiRefX not in empty:
			x = [x1,x2]
		elif poiRefY not in empty:
			y = [y1,y2]
		elif poiRefZ not in empty:
			z = [z1,z2]

	if x not in empty and y in empty and z in empty:
		axis = 'x'
		offsets = x
	if y not in empty and x in empty and z in empty:
		axis = 'y'
		offsets = y
	if z not in empty and x in empty and y in empty:
		axis = 'z'
		offsets = z

	if type_of(offsets) == 'STR':      ##provided vertice setname
		setname = offsets
		poi = poi_with_setname(setname)

		if axis == 'x':
			offsets = set2locx(setname,poi)
		elif axis == 'y':
			offsets = set2locy(setname,poi)
		elif axis == 'z':
			offsets = set2locz(setname,poi)
	else:
		offsets = tolist(offsets)

	if d != 0:
		for i in range(len(offsets)):
			offsets[i] = offsets[i] + d

	xLocs = tolist(xLocs)
	if xLocs not in empty:
		offsets = unselect(offsets,xLocs)

	print ' '
	print fnln_fnln(), 'Performing batch divide for',part_names,'in',axis,', offsets=',offsets

	i = 0
	for part in parts:
		i = i + 1
		if i >=2:
			print ' '
		_divide_num = 0
		for offset in offsets:
			divide(part,axis=axis,offset=offset,cells=cells)

	return

def batch_divide_in_x(part,y=None,z=None):
	## VER: 2014-09-11, v1.0

	part = check_part(part)
	vertices = vertice_select(part,x=(MIN1,MAX1),y=y,z=z)
	locs = []
	for pt in vertices:
		loc = pt.pointOn[0]
		if loc[0] not in locs:
			locs.append(loc[0])
	locs.sort()

	batch_divide(part,x=locs)

	return

def batch_divide_in_y(part,x=None,z=None):
	## VER: 2014-09-11, v1.0

	part = check_part(part)
	vertices = vertice_select(part,y=(MIN1,MAX1),x=x,z=z)
	locs = []
	for pt in vertices:
		loc = pt.pointOn[0]
		if loc[1] not in locs:
			locs.append(loc[1])
	locs.sort()

	batch_divide(part,y=locs)

	return

def batch_divide_in_z(part,x=None,y=None):
	## VER: 2014-09-11, v1.0

	part = check_part(part)
	vertices = vertice_select(part,z=(MIN1,MAX1),x=x,y=y)
	locs = []
	for pt in vertices:
		loc = pt.pointOn[0]
		if loc[2] not in locs:
			locs.append(loc[2])
	locs.sort()

	batch_divide(part,z=locs)

	return

def correct_range(xranges):
	## VER: 2014-12-10, v1.0
	## caller: objs_space()，先枚举，然后排除。

	xranges = tolist(xranges)
	if len(xranges) == 1:
		v10 = v20 = xranges[0]
	elif len(xranges) == 2:
		v10,v20 = xranges
	elif len(xranges) == 3:
		v1,v2,v3 = xranges
		if abs(v2-v1) < abs(v3-v2):   ## v1,v2 mixed.
			v20 = v3
			if abs(v2 - v1) < 2e-4:
				num1 = get_float_num(v1)
				num2 = get_float_num(v2)
				if num1 < num2:
					v10 = v1
				elif num1 > num2:
					v10 = v2
				else:
					v10 = v1
			else:
				v10 = v1
		else:
			v10 = v1
			if abs(v3-v2) < 2e-4:
				num2 = get_float_num(v2)
				num3 = get_float_num(v3)
				if num2 < num3:
					v20 = v2
				elif num2 > num3:
					v20 = v3
				else:
					v20 = v3
			else:
				v20 = v3

	elif len(xranges) == 4:
		v1,v2,v3,v4 = xranges

		if abs(v2 - v1) < 2e-4:
			num1 = get_float_num(v1)
			num2 = get_float_num(v2)
			if num1 < num2:
				v10 = v1
			elif num1 > num2:
				v10 = v2
			else:
				v10 = v1
		else:
			v10 = v1

		if abs(v4-v3) < 2e-4:
			num3 = get_float_num(v3)
			num4 = get_float_num(v4)
			if num3 < num4:
				v20 = v3
			elif num3 > num4:
				v20 = v4
			else:
				v20 = v4
		else:
			v20 = v4

	else:
		raise Exception('*** Error possible ranges.')

	return [v10,v20]

def count_sketch_geometry(sketch):
	## VER: 2013-06-18, v1.0
	## results such as: {'regular_line': 1, 'regular_arc': 2, 'construction_line': 2}

	sketch = check_sketch(sketch)

	counts = {}
	for geometry in sketch.geometry.values():   ## including construction lines
		type1 = type_of(geometry)
		if type1 not in counts.keys():
			counts[type1] = 1
		else:
			counts[type1] += 1

##	prettyPrint(counts)
##	print ' '

	return counts


def coupling_faces_to_point(name='Coupling_1', faces=(),control_point=None, coupling_type=DISTRIBUTING, Ux=ON,Uy=ON,Uz=ON,UR1=ON,UR2=ON,UR3=ON,U1=None,U2=None,U3=None,local_csys=None):
	## VER: ('VER: 2015-07-07, v2.1')	##可以是两个inst的面couple在一起（某个方向的自由度的邦定)
	## control_point can be vertices or reference points
	## coupling is one kind of constraint, in interaction module.
	## coupling type: kinematic, continuum distributing, structural distributing
	## Note: coupling is applied for all steps.
	## both the faces and point are need to need to convert to region
	## control point不能是datum point?
	## couplingType: DISTRIBUTING-允许耦合面的变形(推荐)；KIMEMATIC-耦合面不变形，相当于刚体约束。
	## 考虑到可能的旋转效果，耦合点最好在面心

	## Example
##	csys = create_RP(shaft_A1,loc=((x12+x2)/2, 0, 0), name='bear_center',csys_type=CYLINDRICAL,axial_dir='x')
##	faces = face_select(shaft_A1,radius=shaft_D2/2)
##	point = point_at(shaft_A1,loc=((x12+x2)/2, 0, 0))
##	coupling_faces_to_point('shaft_coupling',faces=faces,control_point=point,U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, local_csys=csys)

## Example
##		point = vertice_select(raf_A1,x=KPx(raf_A1,'A2'),y=MAX,z=KPz(raf_A1,'A2',dz=-tape_thick - frm_thick))
##		faces = faces_of_insts([lam_A1,raf_A1],x=KPx(raf_A1,'A2'),z=(KPz(lam_A1) - tape_thick - frm_thick,KPz(lam_A1) + glass_thick))
##		coupling_faces_to_point('lef_coupling',point,faces)

##a = mdb.models['Model-1'].rootAssembly
##a.ReferencePoint(point=(0.0, 0.0, 0.0))   ## create the reference point
##session.viewports['Viewport: 1'].view.fitView()
##a = mdb.models['Model-1'].rootAssembly
##r1 = a.referencePoints
##refPoints1=(r1[231], )
##region1=a.Set(referencePoints=refPoints1, name='m_Set-19')   ## create set for referencePoints
##a = mdb.models['Model-1'].rootAssembly
##s1 = a.instances['ashaft_A1'].faces
##side1Faces1 = s1.findAt(((228.666667, -160.98786, -23.786765), ), ((207.333333,
##    -118.920239, 18.280864), ))
##region2=a.Surface(side1Faces=side1Faces1, name='s_Surf-10')
##mdb.models['Model-1'].Coupling(name='Constraint-5', controlPoint=region1,
##    surface=region2, influenceRadius=WHOLE_SURFACE, couplingType=DISTRIBUTING,
##    weightingMethod=UNIFORM, localCsys=None, u1=ON, u2=ON, u3=ON, ur1=ON,
##    ur2=ON, ur3=ON)

	if U1 != None:
		Ux = U1

	if U2 != None:
		Uy = Ux

	if U3 != None:
		Uz = U3

	if Ux not in [ON, OFF]:
		raise Exception('Ux should be ON or OFF')

	if Uy not in [ON, OFF]:
		raise Exception('Uy should be ON or OFF')

	if Uz not in [ON, OFF]:
		raise Exception('Uz should be ON or OFF')

	## coupling all DOFs to RP and then apply_disp_fix() to RP for specific DOF.
	type1 = totext(coupling_type).upper()
	if type1 == 'DISTRIBUTING':
		coupling_type = DISTRIBUTING
		Ux=Uy=Uz = ON  ## 强制要求，不能更改
	elif type1 == 'KINEMATIC':
		coupling_type = KINEMATIC   ## 默认
	elif type1 == 'STRUCTURAL':    ## 没有这种形式?
		coupling_type = STRUCTURAL
		Ux=Uy=Uz = ON

	faces = tolist(faces)
	if faces in empty:
		raise Exception('******faces are required.')

	if type_of(faces[0]) != 'faces':
		raise Exception('******faces are required.')

	pois = get_pois(faces)
	inst_names = poi_names(pois)

	if type_of(control_point) == 'SET':
		region1 = control_point
	elif type_of(control_point) == 'STR' and control_point in a.sets.keys():
		region1 = a.sets[control_point]
	else:
		RP = None
		if control_point in a.features.keys():
			RP = feature_to_obj(control_point)
		elif type_of(control_point) == 'referencePoints':
			RP = control_point

		if RP not in empty:
			region1 = create_set(name='RP_coupling',objs=RP,check_name=True)
		else:
			raise Exception('*** error control_point.')

##	else:
##		control_point = tolist(control_point)
##		if len(control_point) > 1:
##			control_point = [control_point[0]]
##		region1 = create_set(name='RP_coupling',objs=control_point,check_name=True)	## if 该点不在面上，可能会存在力矩的问题。

	## region2 can be surface or nodal region
	region2 = create_surface(objs=faces)

	if type_of(name) != 'STR':
		raise Exception('******Error coupling name.')

	name = formatted_name(_m.constraints,name)

	_m.Coupling(name=name, controlPoint=region1,
	    surface=region2, influenceRadius=WHOLE_SURFACE, couplingType=coupling_type,
	    weightingMethod=UNIFORM, localCsys=local_csys, u1=Ux, u2=Uy, u3=Uz, ur1=UR1, ur2=UR2, ur3=UR3,adjust=True)

	print '--->Coupling constraint',name,'was applied. Ux=',Ux,', Uy=',Uy,', Uz=',Uz,', UR1=',UR1,', UR2=',UR2,',UR3=',UR3
##	print 'leading control point is from:',get_poi(control_point).name
	print 'slave surface is from:',inst_names[0]
	print ' '

	return name

def USM_dimensions():
	## VER: 2015-11-30, v1.0

	## Height, top
	H1 = distance_of_odb_nodes([1296, 1167], dir='z')
	H2 = distance_of_odb_nodes([1299, 1170], dir='z')
	H3 = distance_of_odb_nodes([48, 1727], dir='z')
	H4 = distance_of_odb_nodes([1504, 22333], dir='z')
	H5 = distance_of_odb_nodes([1949, 1844], dir='z')
	H6 = distance_of_odb_nodes([1951, 62], dir='z')
	H7 = distance_of_odb_nodes([1125, 760], dir='z')
	H8 = distance_of_odb_nodes([1129, 764], dir='z')
	H = (H1 + H2 + H3 + H4 + H5 + H6 + H7 + H8)/8
	H = round(H,3)

	## Length in y, top
	L1 = distance_of_odb_nodes([20310, 65], dir='y')
	L2 = distance_of_odb_nodes([20519, 2061], dir='y')
	L3 = distance_of_odb_nodes([1408, 1091], dir='y')
	L4 = distance_of_odb_nodes([1294, 31], dir='y')
	LT = L1 + L2 + L3 + L4

	## Length in x, top
	L1 = distance_of_odb_nodes([1631, 42], dir='x')
	L2 = distance_of_odb_nodes([1727, 1369], dir='x')
	L3 = distance_of_odb_nodes([2021, 1138], dir='x')
	L4 = distance_of_odb_nodes([66, 1124], dir='x')
	LT = LT + L1 + L2 + L3 + L4
	LT = round(LT/8,3)

	print fnln(),'Insert height =', H
	print fnln(),'Insert top length =', LT

	## Length in y, bot
	L1 = distance_of_odb_nodes([1166, 766], dir='y')
	L2 = distance_of_odb_nodes([35, 769], dir='y')
	L3 = distance_of_odb_nodes([1514, 1836], dir='y')
	L4 = distance_of_odb_nodes([1511, 61], dir='y')
	LB = L1 + L2 + L3 + L4

	## Length in x, bot
	L1 = distance_of_odb_nodes([36, 48], dir='x')
	L2 = distance_of_odb_nodes([1174, 1498], dir='x')
	L3 = distance_of_odb_nodes([752, 1848], dir='x')
	L4 = distance_of_odb_nodes([757, 1846], dir='x')
	LB = LB + L1 + L2 + L3 + L4
	LB = round(LB/8,3)

	print fnln(),'Insert bot length =', LB

	return

function_labels['valid_BCs'] = 'valid','boundary Conditions','suppressed'
def valid_BCs():
	## VER: 2016-12-20, v1.0

##	>>> valid_BCs()
##	['die', 'ejector', 'punch']
##	>>>

	BCs = []
	for BC in _m.boundaryConditions.values():
		if BC.suppressed == False:
			BCs.append(BC.name)

	return BCs

def value2set(value):
	## VER: 2014-05-05, v1.0

	if value not in [UNSET,SET]:
		value = SET

	return value

function_labels['apply_disp_fix'] = 'displacement','BC','Boundary condition','movement'
def apply_disp_fix(name,objs=(), region=None, cells=None, faces=None,edges=None,vertices=None,
	referencePoints=None, RP=None, nodes=None, node_labels=None, elements=None, xEdges=None,rots=None,
	inst=None, side=None, U1=None,u1=None, Ux=None, U2=None,u2=None, Uy=None, U3=None,u3=None,
	Uz=None,ur1=None, UR1=None,ur2=None, UR2=None, ur3=None, UR3=None,amplitude=None,local_csys=None,
	fix_all=None,step=None, create_step=None,stepname=None, step_modifys=(), deactive_step=None):
	## VER: 2017-10-24, v2.7, use set-like region

	## 对于2D part, only have Ux, Uy, and UR3 dof

##	create_RP('wire',loc=vertices[0],name='RP')
##	apply_disp_fix('wire_xfix',RP='wire_A1', Ux=0,UR3=0)

##	>>> nodes_x0=(3633,6173)
##	>>> nodes_y0=(406,349)
##	>>> apply_disp_fix(name='BC_x',nodes=nodes_x0,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
##	['apply_disp_fix', 5396] --->Created displacement fix: _01_BC_x_1
##	'_01_BC_x_1'
##	>>> apply_disp_fix(name='BC_y',nodes=nodes_y0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)
##	['apply_disp_fix', 5396] --->Created displacement fix: _02_BC_y_1
##	'_02_BC_y_1'
##	>>>

	## amplitude可以不加，如果加,不要加错
##	apply_disp_fix(name='pin',region=set_pin)   ## 全约束
##	apply_disp_fix(name='ejector',region=set_ejector) ## 全约束
##
##	apply_disp_fix(name='die',region=set_die,	step_modifys=
##		[('step2','u3',-5.811,'amp_lowpressing'),  ## 走PV
##		('step3','u3',0) ])
##
##	if punch_found == True:
##		apply_disp_fix(name='punch',region=set_punch, step_modifys =
##			[('step1','u3',-2,'amp_underfilling'),    ## underfilling
##			('step2','u3',-5.811,'amp_lowpressing'),  ## PV
##			('step3','u3',-0.5,'amp_uppressing')  ])  ## OB

##	apply_disp_fix(name='die',region=set_die,step_modifys=[('step2','u3',-5.811,'amp_lowpressing'),
##		('step3','u3',0,'amp_uppressing') ])  ## 走PV
##		('step3','u3',0) ])  ## 走PV

##	apply_disp_fix(name='die',region=set_die,step_modifys=[('step1','U3',-2),('step2','u3',-5.811,'amp_lowpressing'),	('step3','u3',0) ])


##	create_cylind_csys()
##	faces = face_select('case_A1',D=case_OD4)
##	apply_disp_fix('fix_sect4',faces=faces,U1=0,step='step2',local_csys='csys_1')


##	>>> apply_disp_fix(name='BC_x',nodes=[5,13],Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)   ## provide node labels
##	['apply_disp_fix', 5070] --->Created displacement fix: _01_BC_x_1
##	'_01_BC_x_1'
##	>>>

	## succeed
##	faces = face_select(carbide_A1,y=MIN)
##	_m.DisplacementBC(name='y_fix', region=faces, u2=SET, createStepName='Initial' )

	## apply_disp_fix(name='RP_fix',referencePoints=plate_A1,fix_all=True)

##	nodes = node_select(anvil_A1,x=0,z=0,exterior=False) + node_select(blank_A1,x=0,z=0,y=(MIN1,MAX),exterior=False)
##	apply_disp_fix('fix_center',nodes=nodes, Ux=0,Uz=0,step='step1',deactive_step='step4')

	if type_of(name) != 'STR':
		raise Exception('*** BC name is required.')

	if name in _m.boundaryConditions.keys():
		raise Exception('*** BC name has been existed. please use a new name.')

	name = formatted_name(_m.boundaryConditions,name)

	if RP not in empty:
		referencePoints = RP

	if rots == 0:
		UR1=UR2=UR3=0

	create_step = get_real_input(create_step,stepname,step)
	if create_step in empty:
		create_step = 'Initial'

	create_step = check_step(create_step)
	if deactive_step == 'next':
		deactive_step = get_next_step(create_step)

	if create_step == _m.steps.keys()[-1] or len(_m.steps) <=2:
		deactive_step = None

	if local_csys not in empty:
		local_csys = feature_to_datum(local_csys)   ##使用参考坐标系
##	print fnln(),'local_csys=',local_csys
##	print fnln(),'type_of(csys)=',type_of(local_csys)
##	stop1()

	if node_labels not in empty:
		nodes = node_labels

	if region in empty:
		if nodes not in empty:
			if is_numbers(nodes):   ## node labels
				nodes = tolist(nodes)
				if inst in empty:
					inst = a.instances.keys()[0]
				inst = check_inst(inst)
				new_list = []
				for label in nodes:
					new_list.append(inst.nodes[label-1])
				nodes = new_list

			if type_of(nodes) in ['LIST','TUPLE','SEQUENCE']:
				objs = nodes
			elif type_of(nodes) == 'nodes':
				objs = [nodes]
			elif type_of(nodes) == 'DICT':
				objs = labels_dict_to_nodes(nodes)

		if is_inst(referencePoints):
			inst = check_inst(referencePoints)
			if len(inst.referencePoints) > 0:	## 这样的RP是在part模块建立的。否则属于a.referencePoints
				referencePoints = inst.referencePoints.values()[0]
			else:
				referencePoints = create_RP(inst)
	##		else:
	##			raise Exception('*** No reference point for inst ' + inst.name +' yet.')

		if objs in empty:
			objs = get_real_input(objs,cells,faces,edges,vertices,referencePoints,elements,nodes)

	##	raise Exception
		if type_of(objs) == 'STR':
			objs = set2objs(objs,p=inst)

		objs = tolist(objs)
		p0 = get_parent(objs[0])
		if type_of(p0) == 'PART':
			raise Exception('*** objs should be come from instance, not from part.')

		region = create_set(objs=objs, setname=name,check_name=True,info='fix')

	u1 = get_real_input(U1,u1,Ux)
	u2 = get_real_input(U2,u2,Uy)
	u3 = get_real_input(U3,u3,Uz)
	ur1 = get_real_input(ur1,UR1)
	ur2 = get_real_input(ur2,UR2)
	ur3 = get_real_input(ur3,UR3)

	DOF = get_real_input(u1,u2,u3,ur1,ur2,ur3)
	if DOF in empty:
		fix_all = True

	if fix_all == True:
		u1=u2=u3=ur1=ur2=ur3=0

	DOFs = []
	if create_step == 'Initial':
		## 以下错误
##		_m.DisplacementBC(name=name, createStepName='Initial',
##		    region=region, u1=SET, u2=UNSET, u3=UNSET, ur1=UNSET, ur2=UNSET, ur3=UNSET,
##		    amplitude=UNSET, distributionType=UNIFORM, fieldName='', localCsys=None)

		_m.DisplacementBC(name=name, region=region, u1=SET, createStepName='Initial',localCsys=local_csys)   ## 要简洁，千万不要把其他DOF也加进来。
		BC = _m.boundaryConditions[name]
		DOFs.append('u1')

		if u2 not in empty:
			BC.setValues(u2=SET)
			DOFs.append('u2')
		if u3 not in empty:
			BC.setValues(u3=SET)
			DOFs.append('u3')
		if ur1 not in empty:
			BC.setValues(ur1=SET)
			DOFs.append('ur1')
		if ur2 not in empty:
			BC.setValues(ur2=SET)
			DOFs.append('ur2')
		if ur3 not in empty:
			BC.setValues(ur3=SET)
			DOFs.append('ur3')

		if u1 in empty:
			BC.setValues(u1=UNSET)
			DOFs.remove('u1')

	else:
		if amplitude in empty:
			amplitude = UNSET

		if amplitude != UNSET and amplitude not in _m.amplitudes.keys():
			raise Exception('*** Incorrect amplitude.')

		if u1 not in empty:
			if type_of(amplitude) != 'STR':
				_m.DisplacementBC(name=name, region=region, u1=u1, createStepName=create_step,localCsys=local_csys)
			else:
				_m.DisplacementBC(name=name, region=region, u1=1, amplitude=amplitude, createStepName=create_step,localCsys=local_csys)
		else:
			_m.DisplacementBC(name=name, region=region, u1=0, createStepName=create_step,localCsys=local_csys)

##a = mdb.models['Model-1'].rootAssembly
##r1 = a.referencePoints
##refPoints1=(r1[218], )
##region = a.Set(referencePoints=refPoints1, name='Set-20')
##datum = mdb.models['Model-1'].rootAssembly.datums[219]
##mdb.models['Model-1'].DisplacementBC(name='BC-6', createStepName='Initial',
##    region=region, u1=SET, u2=UNSET, u3=SET, ur1=UNSET, ur2=UNSET, ur3=UNSET,
##    amplitude=UNSET, distributionType=UNIFORM, fieldName='', localCsys=datum)


		BC = _m.boundaryConditions[name]

		if u2 not in empty:
			BC.setValues(u2=u2,amplitude=amplitude)
		if u3 not in empty:
			BC.setValues(u3=u3,amplitude=amplitude)
		if ur1 not in empty:
			BC.setValues(ur1=ur1,amplitude=amplitude)
		if ur2 not in empty:
			BC.setValues(ur2=ur2,amplitude=amplitude)
		if ur3 not in empty:
			BC.setValues(ur3=ur3,amplitude=amplitude)

		if u1 in empty:
			BC.setValues(u1=UNSET)

	if type_of(step_modifys) in ['TUPLE','LIST'] and len(step_modifys) > 0:   ## 不能用DICT，因为dict的item顺序不定
		if type_of(step_modifys[0]) not in ['TUPLE','LIST']:
			step_modifys = (step_modifys,)   ## only one item

		for item in step_modifys:
			stepname = check_step(item[0])

			dof1 = None
			if len(item) == 2:
				value = item[1]
				if not is_number(value):
					raise Exception('*** a value is required.')

				dof1 = DOFs[0]
				magnitude1 = value
				amplitude1 = FREED

			elif len(item) == 3:
				if is_number(item[1]) and item[2] in _m.amplitudes.keys():
					dof1 = DOFs[0]
					magnitude1 = item[1]
					amplitude1 = item[2]
				elif is_dof(item[1]) and is_number(item[2]):
					dof1 = item[1]
					magnitude1 = item[2]
					amplitude1 = FREED   ## instantaneous
				else:
					raise Exception('*** incorrect input of the modification.')

			elif len(item) == 4:
				if is_dof(item[1]) and is_number(item[2]) and item[3] in _m.amplitudes.keys():
					dof1 = item[1]
					magnitude1 = item[2]
					amplitude1 = item[3]

			else:
				raise Exception('*** incorrect input of the modification.')

			print fnln(),'stepname=',stepname
			print fnln(),'magnitude=',magnitude1
			print fnln(),'amplitude=',amplitude1
##			stop1()

			if is_dof(dof1):
				dof1 = totext(dof1).lower()
				if dof1 == 'u1':
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, u1=magnitude1, amplitude=amplitude1)
				elif dof1 == 'u2':
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, u2=magnitude1, amplitude=amplitude1)
				elif dof1 == 'u3':
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, u3=magnitude1, amplitude=amplitude1)
				elif dof1 == 'ur1':
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, ur1=magnitude1, amplitude=amplitude1)
				elif dof1 == 'ur2':
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, ur2=magnitude1, amplitude=amplitude1)
				elif dof1 == 'ur3':
					_m.boundaryConditions[name].setValuesInStep(stepName=stepname, ur3=magnitude1, amplitude=amplitude1)

	if type_of(deactive_step) == 'STR':
		deactive_step = check_step(deactive_step)
		_m.boundaryConditions[name].deactivate(deactive_step)

	a.regenerate()
	print fnln(),'--->Created displacement fix:',name

	return name

def apply_disp_symm(name='',dir1='x',region=None,faces=None,edges=None,nodes=None,step='Initial'):
	## VER: ('VER: 2017-08-07, v3.0')
	## region hear should be a set-like region

	global symmetry, BCs, BC_status

##	apply_disp_symm('xsym')
##	apply_disp_symm('zsym')

##	apply_disp_symm('xsym',faces=faces_of_insts(x=0))
##	apply_disp_symm('zsym',faces=faces_of_insts(z=0))

##	faces = face_select(powder_A1,x=0)
##	set1 = create_set(name='sym_powder_x',faces=faces)
##	_m.XsymmBC(createStepName='Initial', name='sym_powder_x', region=set1)

##	nodes1 = node_select(powder_A1,x=0)
##	nodes2 = node_select(die_A1,x=0)
##	nodes3 = node_select(bpunch_A1,x=0)
##	nodes4 = node_select(corepin_A1,x=0)
##	apply_disp_symm('x',name='sym_x',nodes=nodes1 + nodes2 + nodes3 + nodes4)

	## Example:
##	apply_disp_symm('z',faces=faces_of_insts(z=0))

	## 以下成功，所以，region为objs list
##	region = faces_of_insts(x=_xmin(carbide_A1))
##	_m.XsymmBC(createStepName='step1', name='BC-1', region=region)
##
##	region = faces_of_insts(z=_zmax(carbide_A1))
##	_m.XsymmBC(createStepName='step1', name='BC-2', region=region)

##	print fnln(),faces[0]
##	print fnln(),carbide_A1.faces[4]
##	raise Exception

	## Example:
##	apply_disp_symm('x',nodes=xnodes)

	dir1 = dir1.lower()
	step = check_step(step)

	if BC_status.keys() in empty:
		BC_status_initiate()

	if name.lower() in ['xsym','symx']:
		dir1 = 'x'
	if name.lower() in ['ysym','symy']:
		dir1 = 'y'
	if name.lower() in ['zsym','symz']:
		dir1 = 'z'

	if dir1 not in ['x','y','z']:
		raise Exception('*** sym direction should be x, y, or z')

	if (region,faces,edges,nodes) == (None,None,None,None):
		shape = model_shape()
		if shape == THREE_D:
			if dir1 == 'x':
				faces = faces_of_insts(x=0)
			elif dir1 == 'y':
				faces = faces_of_insts(y=0)
			else:
				faces = faces_of_insts(z=0)

		if faces in empty:
			raise Exception('*** No objs to apply the symmetric BC.')

	if name in empty:
		name = dir1.upper() + '_sym'

##	_lineno = lineno_and_codes()[-2]
##	seq = get_SN(_m.boundaryConditions,2)
##	name = '_' + seq + '_' + name + '_' + str(_lineno)

	name = new_key(_m.boundaryConditions,name)

	insts = None
	if region in empty:
		if faces not in empty:
			if type_of(faces) == 'STR':
				faces = set2objs(faces)
			faces = tolist(faces)

			if type_of(get_poi(faces[0])) == 'PART' or type_of(get_poi(faces[-1]))=='PART':
				raise Exception('****** Require objs from instance, not part.')
			region = create_set(faces=faces)  ## a set like region, not surface like region
			insts = poi_names_of_objs(faces)

		elif edges not in empty:
			if type_of(edges) == 'STR':
				edges = set2objs(edges)
			edges = tolist(edges)

			if type_of(get_poi(edges[0])) == 'PART' or type_of(get_poi(edges[-1]))=='PART':
				raise Exception('****** Require objs from instance, not part.')
			region = create_set(edges=edges)
			insts = poi_names_of_objs(edges)

		elif nodes not in empty:
			if type_of(nodes) in ['TUPLE','LIST']:
				if type_of(nodes[0]) == 'faces':
					region = nodes
					insts = poi_names_of_objs(nodes)
				elif type_of(nodes[0]) == 'nodes':
					region = list2region(nodes,region_type='set')
					insts = poi_names_of_objs(nodes)

			elif type_of(nodes) == 'DICT':
				dict1 = nodes
				nodes = labels_dict_to_nodes(dict1)
				region = list2region(nodes,region_type='set')
				insts = poi_names_of_objs(nodes)

##	print fnln(),region
##	stop1()

	if region in empty:
		raise Exception('*** a set like region is required.')

	if dir1 == 'x':
		_m.XsymmBC(createStepName=step, name=name, region=region)   ## region is a object list

	elif dir1 == 'y':
		_m.YsymmBC(createStepName=step, name=name, region=region)

	elif dir1 == 'z':
		_m.ZsymmBC(createStepName=step, name=name, region=region)

##	add_BC_status(name=name, inst_names=insts, DOFs = dir1)

	a.regenerate()

	print ' '

	return name

def create_xsym(name='',region=None,faces=None,edges=None,nodes=None,step='Initial'):
	## VER: 2016-09-02, v1.0

	name = apply_disp_symm(name=name,dir1='x',region=region,faces=faces,edges=edges,nodes=nodes,step=step)

	return name

def create_ysym(name='',region=None,faces=None,edges=None,nodes=None,step='Initial'):
	## VER: 2016-09-02, v1.0

	name = apply_disp_symm(name=name,dir1='y',region=region,faces=faces,edges=edges,nodes=nodes,step=step)

	return name

def create_zsym(name='',region=None,faces=None,edges=None,nodes=None,step='Initial'):
	## VER: 2016-09-02, v1.0

	name = apply_disp_symm(name=name,dir1='z',region=region,faces=faces,edges=edges,nodes=nodes,step=step)

	return name



def banquan():
	## VER: 2009-1-14, v1.0
	return 'J-I-A-N-G Y-U-Q-I, 2009-2016'

def batch_run(batch=None):
	## VER: 2015-03-27, v1.4
	## 结合batch_file()使用。二者都是在cae命令窗口中运行。batch_run()会弹出新的dos窗口。

	import os

	if batch in empty:
		if 'bat_file' in globals().keys():
			batch = bat_file
		else:
			batch = 1

	if is_number(batch):
		batch_file(batch)
		batch_run()
	else:
		try:
			batch1 = search_file(batch)
			if os.path.isfile(batch) == True:
				os.startfile(batch)
		except:
			raise Exception('*** Error batch file.')

	return

function_labels['BC_of_inst_in_dir'] = 'BC','inst','displacement','dof'
def BC_of_inst_in_dir(inst,dir):
	## VER: 2016-12-26, v1.0

##	>>> BC_of_inst_in_dir('die_A1','z')
##	step= 1 , dir= u3 , dof= 0.0
##	step= 2 , dir= u3 , dof= -20.0
##	step= 3 , dir= u3 , dof= 0.0
##	[0, 0, -20.0, 0, 0]
##	>>>
##	>>> BC_of_inst_in_dir('punch_A1','z')
##	step= 1 , dir= u3 , dof= -25.0
##	step= 2 , dir= u3 , dof= -20.0
##	step= 3 , dir= u3 , dof= -0.759
##	step= 4 , dir= u3 , dof= 0.4
##	[0, -25.0, -20.0, -0.759, 0]
##	>>> BC_of_inst_in_dir('ejector_A1','z')
##	step= 1 , dir= u3 , dof= 0.0
##	[0, 0, 0, 0, 0]
##	>>>

	inst = check_inst(inst)
	inst_name = inst.name

	if len(_m.steps) == 1:
		raise Exception('*** No step created yet.')

	if is_number(dir):
		if dir == 1:
			dir = 'u1'
		elif dir == 2:
			dir = 'u2'
		elif dir == '3':
			dir = 'u3'
		else:
			raise Exception('*** dir should be 1,2,3,x,y, or z')
	elif type_of(dir) == 'STR':
		dir = dir.lower()
		if dir == 'x':
			dir = 'u1'
		elif dir == 'y':
			dir = 'u2'
		elif dir == 'z':
			dir = 'u3'
		else:
			raise Exception('*** dir should be 1,2,3,x,y, or z')
	else:
		raise Exception('*** dir should be 1,2,3,x,y, or z')

	BCs = valid_BCs()  ## BC names
	newlist = []
	for BC in BCs:
		setting = settings_of_BC(BC)
		if inst_name in setting['insts']:
			newlist.append(BC)
	BCs = newlist

	disps = [0]*len(_m.steps)
	for step in range(len(_m.steps))[1:]:
		for BC in BCs:
			setting = settings_of_BC(BC)
			if step in setting.keys():
				dict1 = setting[step]
##				print 'step=',step,', dir=',dir,', dof=',dict1[dir]
				if dir in dict1.keys():
					if dict1[dir] != 0:
						disps[step] = dict1[dir]

	if disps != [0]*len(_m.steps):
		for i in range(len(disps))[:-1]:
			disp = disps[i]
			if disp != 0:
				for j in range(len(disps))[i+1:]:
					disp1 = disps[j]
					if disp1*disp < 0:
						disps[j] = 0	## remove the ejection actions

	return disps

def BC_status_initiate():
	## VER: 2013-05-27, v1.0

	all_DOFs = ['x','y','z','UR1','UR2','UR3']
	for inst in a.instances.keys():
		if inst not in BC_status.keys():
			BC_status[inst] = {}
			for item in all_DOFs:
				BC_status[inst][item] = []

	return


def bias_cut1(part,pass_point1=(),cut_sides=['+y','+x'], angle_with_X=None,angle_with_Y=None,angle_with_Z=None,x=None,y=None,z=None, datum=()):
	## VER: 2013-12-09, v1.1

	if datum not in empty:
		points, ndir, offset = datum
	else:
		part = check_part(part)
		x,y,z = real_xyz(part,x,y,z)
		points, ndir, offset = get_cutting_section(pass_point1=pass_point1, cut_sides=cut_sides, angle_with_X=angle_with_X, angle_with_Y=angle_with_Y, angle_with_Z=angle_with_Z, x=x, y=y, z=z)

	section_cut(part,ndir=ndir,offset=offset,points=points, depth=2*abs(offset), grow_trend=FORWARD)

	return

def blank_cae(cae_name,model_name=None):
	## VER: 2014-09-05, v1.2

	global build_model

	build_model = True

	if type_of(cae_name) != 'STR':
		raise Exception('*** cae_name is required.')

##	current_cae = get_cae_file_title()
##	refresh()
	close_all_odbs()

	if have_running_job == False:
		Mdb()
	else:
		get_current_model()

		if model_name in empty:
			model_name = current_model_name

		if model_name == current_model_name:
			if len(_m.parts) not in empty:  	## existed cae, may created saveAs
				temp_name = new_key(mdb.models.keys(),model_name)
				mdb.Model(name=temp_name, modelType=STANDARD_EXPLICIT)
				switch_model(model_name=temp_name)

				del mdb.models[model_name]
				mdb.models.changeKey(fromName=temp_name, toName=model_name)
		else:
			mdb.Model(name=model_name, modelType=STANDARD_EXPLICIT)

	try:
		mdb.saveAs(pathName=cae_name)
	except:
		mdb.save()

##	global_var_initiate()	;please_check
##	refresh()
	get_current_model()

##	print fnln(),'jobnum=',jobnum
	save_user_data(jobnum)
##	raise Exception

	return

def create_part_sketch(p,ndir='z',offset=0,name='temp_sketch1',sketch_right=None,
	simple_sketch=None,pshape='3D',ptype='deformable'):
	## 2016-10-21, v2.6. offset是法线方向上datum_plane距离原点的距离。重名的sketch将被不被覆盖。
	## 草图不存在ndir的正负说法。datum sketch中含有partname和datum的信息。

	if type_of(p) == 'STR' and p not in _m.parts.keys():
		p = blank_part(p,pshape=pshape,ptype=ptype)
	p = check_part(p)

	name = new_key(_m.sketches.keys(),name)
	if name[0] == '_':
		print fnln_fnln(),'name=',name
		raise Exception('*** a stand alone sketch cannot star with _')

	ndir == ndir.lower()
	if len(ndir) == 2:
		if ndir[1] in ['x','y','z']:  ## 例如ndir = '+x'
			ndir = ndir[1]
		else:
			error_info(['ndir',ndir],'*** Error ndir')

	print fnln(),'ndir=',ndir
	print fnln(),'offset=',offset
	print fnln(),'simple_sketch=',simple_sketch
	if ndir == 'x':
		origin = (offset,0,0)
	elif ndir == 'y':
		origin = (0,offset,0)
	elif ndir == 'z':
		origin = (0,0,offset)
	else:
		raise Exception('ndir should be x,y,or z')

	if simple_sketch not in empty:   ## sketch已经创建，但不附属于某个part, 即non-associated sketch
		simple_sketch = check_sketch(simple_sketch)
		please_check   ## 如果生长错误，需要检查下面语句是否需要
		## 此时的part可能已经有几何了，所以基于part定义更好。★
##		if len(simple_sketch.vertices) > 0:
##			x10,x20,y10,y20 = space_of_sketch(simple_sketch)
##			print fnln(),'x10,x20)=',(x10,x20)   ##  (-14.3, -13.0)
##			sketch_right = x20   ;有时出错，改成x20+100后正确，或干脆不指定sketch_right也正确(对create_std_module()中生长inner_wall时)
##			sketch_right = x20 + 100	;changing

	print fnln(),'ndir=',ndir
##	stop1()

##	print 'origin=',origin
##	print 'offset=',offset

	## '-y'与'+y'是一样的。
##	print fnln_fnln(),'ndir=',ndir
	datum_plane = create_datum_plane_by_offset(p,ndir,offset)		## 不管正负,这里的ndir只要一个字符
	print fnln(),'sketch_right=',sketch_right
##	raise Exception
	right_edge = right_edge_of_datum_plane(p,ndir=ndir,sketch_right=sketch_right)				## 不管正负，这里的ndir只要一个字符
##	stop1()
##	raise Exception

	if ndir == 'y':
		side = SIDE2
	else:
		side = SIDE1

	t = p.MakeSketchTransform(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=side, sketchOrientation=RIGHT, origin=origin)
	sketch = _m.ConstrainedSketch(name=name, sheetSize=500, gridSpacing=10, transform=t)

##	print 't.matrix()=',t.matrix()

	sketch.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
	sketch.setPrimaryObject(option=STANDALONE)

	if type_of(simple_sketch) == 'sketch':
		sketch.retrieveSketch(sketch=simple_sketch)

	## sketch是不存在ndir的正负的。datum_plane和right_edge均属于具体的某个part.
	sketch1 = {'sketch':sketch, 'partname': p.name, 'datum_plane':datum_plane, 'right_edge':right_edge, 'ndir':ndir,     ## 这里的ndir只要一个字符
				  'side':side, 'origin':origin, 'offset':offset, 'name':name, 'transform':t, 't.matrix': t.matrix()}

	return sketch1   ## 返回的是包含有所有信息的sketch变量，不只是sketch的名字。


def create_base_sketch(name='temp_sketch1',sketch_plane='xoy',ndir=None,offset=0,sheetSize=200, gridSpacing=5,origin=None,return_sketch=True):
	## VER: 2014-09-10, v1.3
	## 其实可以通过ndir_of_sketch()来获得sketch的ndir
	## default to return sketch object
	## 一个ndir != 'z'的sketch被copy之后，得到的新的sketch的ndir总是z方向的。
	## 注意，不要把s1.geometry.values()[-1]赋给某个变量，因为会出现引用错误，导致异常退出。

	## Example:
##	sketch1 = create_base_sketch('temp_sketch1')
##	poly_lines_in_sketch(sketch1,expression='H=4,V=-1.5,H=-1.5,V=-3,H=1.5,V=-1.5,H=-4',closed=True)

	## Example:
	## s1 = create_base_sketch(ndir='x')   结果得到一个ndir='x'的sketch plane

##	global _m, a

	global poly_sketch

	name = new_key(_m.sketches.keys(),name)

	if name[0] == '_':
		print fnln_fnln(),'name=',name
		raise Exception('*** a stand alone sketch cannot star with _')

	if ndir in empty:
		sketch_plane = totext(sketch_plane).lower()
		if 'x' in sketch_plane and 'y' in sketch_plane:
			ndir = 'z'
		elif 'y' in sketch_plane and 'z' in sketch_plane:
			ndir = 'x'
		elif 'x' in sketch_plane and 'z' in sketch_plane:
			ndir = 'y'

	ndir = ndir.lower()

	matrix = get_sketch_transform(ndir=ndir,origin=origin,offset=offset)

##	x = [1,0,0]
##	y = [0,1,0]
##	z = [0,0,1]
##
##	if ndir == 'x':
##		origin = (offset,0,0)
##	elif ndir == 'y':
##		origin = (0,offset,0)
##	elif ndir == 'z':
##		origin = (0,0,offset)
##
##	if ndir == 'x':  ## yoz
##		matrix = y + z + x + list(origin)
##	elif ndir == 'y':	## xoz
##		z = [0,0,-1]  ## ndir=y时，z3=-z2
##		matrix = x + z + y + list(origin)
##	elif ndir == 'z':	## xoy
##		matrix = x + y + z + list(origin)
##	matrix = totuple(matrix)

	## transform:
##	 ndir = 'x'时：matrix() = (0, 1, 0,   0, 0, 1,    1, 0, 0,   offset, 0, 0)   ## format: y,z,x,x-offset
##	 ndir = 'y'时：matrix() = (1, 0, 0,   0, 0, -1,   0, 1, 0,   0, offset, 0)   ## format: x,-z,y,y-offset     注意其中的z=(0,0,-1)
##	 ndir = 'z'时，matrix() = (1, 0, 0,   0, 1, 0,    0, 0, 1,   0, 0, offset)   ## format: x,y,z,z-offset

##	print 'ndir=',ndir
##	print 'matrix=',matrix

##	session.viewports['Viewport: 1'].setValues(displayedObject=None)
##	s = mdb.models['Model-1'].ConstrainedSketch(name='__profile__',
##	    sheetSize=200.0)
##	g, v, d, c = s.geometry, s.vertices, s.dimensions, s.constraints
##	s.setPrimaryObject(option=STANDALONE)
##	mdb.models['Model-1'].ConstrainedSketch(name=name, objectToCopy=s)
##	mdb.models['Model-1'].sketches.changeKey(fromName='__profile__',
##	    toName=name)
##	s.unsetPrimaryObject()


####	s = _m.ConstrainedSketch(name='__profile__', sheetSize=200.0)
######	sketch = _m.ConstrainedSketch(name='__profile__', sheetSize=200, gridSpacing=gridSpacing, transform=matrix)
####	s.setPrimaryObject(option=STANDALONE)
####	_m.ConstrainedSketch(name=name, objectToCopy=s)
####	_m.sketches.changeKey(fromName='__profile__', toName=name)
####	s.unsetPrimaryObject()
##	sketch = _m.sketches[name]

##	sketch = _m.ConstrainedSketch(name=name, sheetSize=sheetSize, gridSpacing=gridSpacing, transform=matrix)

	sketch = _m.ConstrainedSketch(name=name, sheetSize=sheetSize, transform=matrix)
	sketch1 = {'sketch':sketch, 'ndir':ndir, 'origin':origin, 'offset':offset, 'name':name, 'transform':matrix, 'matrix':matrix}

	sketch.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
	sketch.setPrimaryObject(option=STANDALONE)   ## sand-alone and then able to add to a part sketch.(but this only affect the GUI operation.)
	print '--->Created simple blank sketch, name=',name,', ndir=',ndir

	if return_sketch == True:
		sketch1 = sketch1['sketch']

	poly_sketch = name

	return sketch1

def bolt_outside(partname,inst_name='',ndir='z',center0=(0,0,0),D=30,rectL=36,thick=3,mat=''):
	## VER: 2010-02-23

	p0 = blank_part(partname)
	if inst_name == '':
		inst_name = partname + 'A'
	if mat == '':
		mat = 'Steel'
	mat = mat + '_solid'

	radius = D/2
	half_rect = rectL/2
	x0 = center0[0];	y0 = center0[1];	z0 = center0[2]

	if ndir == 'x':
		x1 = 0;		x2 = thick
		y1 = -half_rect;		y2 = half_rect
		z1 = -half_rect;		z2 = half_rect
	elif ndir == 'y':
		x1 = -half_rect;		x2 = half_rect
		y1 = 0;		y2 = thick
		z1 = -half_rect;		z2 = half_rect
	elif ndir == 'z':
		x1 = -half_rect;		x2 = half_rect
		y1 = -half_rect;		y2 = half_rect
		z1 = 0;		z2 = thick

	x1,x2,y1,y2,z1,z2 = tospace((x1,x2),(y1,y2),(z1,z2))
	create_block(p0,(x1,x2),(y1,y2),(z1,z2))
	drill_hole(p0,ndir,center0=(0,0,0),D=D,depth=thick)

	if ndir == 'x':
		divide(p0,'y',0)
		divide(p0,'z',0)
		pt01 = (x1,0,0)
		pt02 = (x2,0,0)
		corner1 = (x2,y2,z2)
		corner2 = (x2,y2,z1)

	elif ndir == 'y':
		divide(p0,'x',0)
		divide(p0,'z',0)
		pt01 = (0,y1,0)
		pt02 = (0,y2,0)
		corner1 = (x1,y2,z2)
		corner2 = (x2,y2,z2)

	elif ndir == 'z':
		divide(p0,'x',0)
		divide(p0,'y',0)
		pt01 = (0,0,z1)
		pt02 = (0,0,z2)
		corner1 = (x1,y2,z2)
		corner2 = (x2,y2,z2)

	divide_by3points(p0,pt01,pt02,corner1)
	divide_by3points(p0,pt01,pt02,corner2)

	if center0 != (0,0,0):
		move_part(p0,dx=x0,dy=y0,dz=z0)
	else:
		a.Instance(dependent=ON, name=inst_name, part=p0)
		p0A = a.instances[inst_name]

	cells = tolist(p0.cells)
	p0.SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE, region=cells,
		sectionName=mat, thicknessAssignment=FROM_SECTION)

	return

def bolt_tie(bolt_top,bolt_bot,subs=[1,2,3,4]):
	## VER: 2010-03-25

	print '  '
	print 'Creating',len(subs),'bolt ties......'
	bolts = []
	topname = bolt_top.name
	botname = bolt_bot.name
	ties = []
	for num1 in subs:
		top = topname + str(num1)
		bot = botname + str(num1)
		top = inst_of_pre(top)[0]
		bot = inst_of_pre(bot)[0]
		tiename = 'tie_bolt' + str(num1)
		ties.append(tiename)
		s2s_tie(tiename,top,bot,mfaces='pin_end')

	print '--->Created',len(subs),'ties:',ties

	return

def boolean_cut(inst,cutters=(),newpart_name='',csys_KP='', del_cutters=False):
	## VER: 2016-08-12, v1.9, inst will be regenerated
	## 例如PDC中，用一个interface部件去divide另一个部件，变成两个cell。

	## Example:
	## boolean_cut(bear_A1,cutters=shaft,newpart_name='bear',del_cutters=False)
	## boolean_cut(case,cutters=stamp,del_cutters=False)
##	boolean_cut('PDC', cutters='interface-1', del_cutters=True)
##	boolean_cut(part,cutters=ball1,del_cutters=True)   ## part和ball1都是part，动作完成后没有新的instance生成。


	inst = check_poi(inst)

	if type_of(inst) == 'PART':
		part = inst
		insts = insts_of_part(part)
		if insts in empty:
			inst = new_instance(part)  ## 临时生成的instance
			del_cutters = True
		else:
			inst = insts[0]
			newpart_name = inst.partName

	inst = check_inst(inst)

	if is_part(cutters):
		insts = insts_of_part(cutters)
		if insts in empty:
			cutters = new_instance(cutters)
		else:
			cutters = insts
	cutters = real_insts(cutters)
	if cutters in empty:
		raise Exception( '****Instances are needed to use as cutter')

	oldinst_name = inst.name
	oldpart_name = inst.partName

	if newpart_name == '':
		newpart_name = oldpart_name

	if newpart_name == oldpart_name:
		tempName = 'tempPart'
	else:
		tempName = newpart_name
	tempName = new_key(_m.parts,tempName)

	cutter_names = []
	for inst1 in cutters:
		cutter_names.append(inst1.name)

	if del_cutters == True:
		action = DELETE
	else:
		action = SUPPRESS

	a.InstanceFromBooleanCut(name=tempName, instanceToBeCut=inst, 		## inst is the obj list,not name list
	    cuttingInstances=totuple(cutters), originalInstances=action)

##	raise Exception

	## inst将消失
##	del a.features[tempName + '-1']
	del_insts(tempName + '-1')

	if action == SUPPRESS:
		for key1 in cutter_names:
			a.features[key1].resume()

	cutted = True

	if cutted == True:
		if newpart_name == oldpart_name:
			del_parts(oldpart_name)

		rename(tempName,newpart_name)
		update_part(newpart_name)

		print '--->',oldinst_name,'was boolean cutted by',cutter_names,', newpart name=',newpart_name,', del_cutters=',del_cutters

	a.regenerate()
	vpnow = get_vpnow()

	return newpart_name

boolean_divide = boolean_cut

def zmin_faces(poi,x=None,y=None):
	## VER: ('VER: 2012-06-20, v1.1')

	poi = check_pias(poi)
	faces = faces_of_cut(poi, z=MIN, x=x,y=y)

	return faces

def box_select(objs,x=(),y=(),z=(),space=(),err=0.1):
	## VER: 2015-06-19, v1.2
	## err=0.1 is suitable for plane or near-plane
	## box_select() not correct for element select.
	## May be error for deformed element part, use element_select() instead

##	>>> elems = box_select(p1.elements, x=(-1,-10))  ## p1 is an imported element part, deformed shape. Fast in element selection.
##	>>> len(elems)
##	0

##	vertice = vertice_at('Cap_A1',loc=centroid)
##	vertices = box_select(_inst('Cap_A1').vertices,x=centroid[0],y=centroid[1],z=centroid[2])

##	>>> nodes3 = node_select(p,x=MAX)
##	---> 961 nodes are selected by box_select().
##	---> 9 nodes are selected by node_select().
##	>>> nodes2 = box_select(p.nodes,x=MAX)
##	---> 961 nodes are selected by box_select().
##	>>>

##	>>> p = _inst('Cap_A1')
##	>>> vertices = box_select(p.vertices,x=MIN)  ## 有时，比vertice_select()更高效准确,当点的位置精细到小数点6位时，vertice_select()可能选不中
##	---> 1 vertices are selected by box_select(), err= 0.1

	if is_poi(objs):
		raise Exception('*** objs is required.')

	if space not in empty:
		x1,x2,y1,y2,z1,z2 = space
		x = (x1,x2)
		y = (y1,y2)
		z = (z1,z2)

	x10,x20,y10,y20,z10,z20 = space_by_box(objs)
	seq = list2sequence(objs)

	if x in ['min','MIN',MIN]:
		x = x10
	elif x in ['max','MAX',MAX]:
		x = x20
	elif x in ['mid','MID',MID]:
		x = (x10+x20)/2

	if y in ['min','MIN',MIN]:
		y = y10
	elif y in ['max','MAX',MAX]:
		y = y20
	elif y in ['mid','MID',MID]:
		y = (y10+y20)/2

	if z in ['min','MIN',MIN]:
		z = z10
	elif z in ['max','MAX',MAX]:
		z = z20
	elif z in ['mid','MID',MID]:
		z = (z10+z20)/2

	if is_number(x):
		x = (x,x)
	if is_number(y):
		y = (y,y)
	if is_number(z):
		z = (z,z)

	xmin=xmax=None
	ymin=ymax=None
	zmin=zmax=None

	if is_location(x):
		xmin,xmax = x[0]-err,x[1]+err
	if is_location(y):
		ymin,ymax = y[0]-err,y[1]+err
	if is_location(z):
		zmin,zmax = z[0]-err,z[1]+err

##	print fnln(),'zmin,zmax=',(zmin,zmax)
	objs1 = []
	if x not in empty and y not in empty and z not in empty:
		objs1 = seq.getByBoundingBox(xMin=xmin,xMax=xmax,yMin=ymin,yMax=ymax,zMin=zmin,zMax=zmax)
	else:
		if x not in empty and y not in empty:
			objs1 = seq.getByBoundingBox(xMin=xmin,xMax=xmax,yMin=ymin,yMax=ymax)
		elif y not in empty and z not in empty:
			objs1 = seq.getByBoundingBox(yMin=ymin,yMax=ymax,zMin=zmin,zMax=zmax)
		elif x not in empty and z not in empty:
			objs1 = seq.getByBoundingBox(xMin=xmin,xMax=xmax,zMin=zmin,zMax=zmax)
		else:
			if x not in empty:
				objs1 = seq.getByBoundingBox(xMin=xmin,xMax=xmax)
			elif y not in empty:
				objs1 = seq.getByBoundingBox(yMin=ymin,yMax=ymax)
			elif z not in empty:
				objs1 = seq.getByBoundingBox(zMin=zmin,zMax=zmax)

	if len(objs1) == 0:
		objs1 = []

##	if objs1 not in empty:
##		type1 = type_of(objs1[0])
##		print '--->',len(objs1),type1,'are selected by box_select(), err=',err
##	else:
##		print '*** No object selected, err=', err

	return objs1

def brief_file_name(name):
	## VER: 2015-04-07, v1.3

	locs = []
	for i in range(len(name)):
		char = name[i]
		if char in [' ','_','-']:
			locs.append(i)
##		if len(locs) == 4:
##			break

##	print fnln(),'len(locs)=',len(locs)
	total = len(locs)
	if locs not in empty:
		name1 = name[:locs[0]]

		num2 = min(4,total)
		name2 = name[locs[-num2]:]
		if name2.startswith(name1) == False:
			name1 = name1 + name2
		else:
			name1 = name2
	else:
		name1 = name
		if len(name1) > 25:
			name1 = name1[:25]

	return name1

def brief_name(inst):
	## VER: 2011-02-26, v1.1

	type1 = type_of(inst)
	if type1 == 'STR':
		name = inst
	elif type1 == 'PINSTANCE':
		name = inst.name
	else:
		raise Exception('******Instance is required, instead of ' + type1 + '. line=7120, brief_name()')

	if name[-3:] == '_A1':
		name = name[:-3]

	return name

def cal_axial_pressure():
	## VER: 2014-04-09, v1.0

	RF = get_result(instance='TPUNCH_A1',variable='RF')
	RF = RF[1]

	if 'green_section' not in globals().keys():
		raise Exception('*** green_section is required.')

	pressure = round(RF/green_section, 1)

	print fnln(),'RF=',RF
	print fnln(),'green_section=',green_section
	print fnln(), 'RF/green_section =',pressure

	return pressure

def call_line_history(tb):
	## VER: 2013-03-28, v1.1

	if type_of(tb) != 'LIST':
		raise Exception('****list of line instance is required.')

	trace = []
	for lineinfo in tb:
		trace = trace + [lineinfo.frame_name, lineinfo.command_lineno]

	return trace

def fnln_fnln():
	## VER: 2013-11-17, v1.1
	## results, such as: ['refresh', 17344, 'myprint', 24712]

	## common structure, copy to such as: fnln(),caller_fnln(),caller_name(),
	info = get_traceback()
	info = info[:-2]
	if len(info) >= 4:
		info = info[-4:]

	if info[0] == '<module>' and info[1] == 1:
		info[0] = 'cliCommand'

	## End of common structure

	return info
fnln12 = fnln_fnln

def fnln23():
	## VER: 2015-04-28, v1.2
	## 当前函数为1, caller = 2, caller的caller=3

	info = get_traceback()
	info = info[:-2]
	if len(info) >= 6:
		info = info[-6:-2]

	if info[0] == '<module>' and info[1] == 1:
		info[0] = 'cliCommand'

	return info

def fnln234():
	## VER: 2015-04-28, v1.2
	## 当前函数为1, caller = 2, caller的caller=3

	info = get_traceback()
	info = info[:-2]
	if len(info) >= 8:
		info = info[-8:-2]

	if info[0] == '<module>' and info[1] == 1:
		info[0] = 'cliCommand'

	return info


def caller_trace():
	## VER: 2014-01-17, v1.0
	## callers and linenos.

	trace = get_traceback()[:-4]

	return trace

def caller_fnln():
	## VER: 2014-03-31, v1.3
	## 结果形式如：['collect_and_write_results', 5690]

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()
##	trace = get_traceback()
##	print fnln(),'trace=',trace
##	caller = trace[:-4][-2:]
##	stop1()
##	raise Exception

####	caller = get_traceback()[:-4][-2:]
	## 假如结果为[]，说明该语句位于主程序中，而不是位于某个函数中。

##	caller = fnln_fnln()[:2]

	## common structure, copy to such as: fnln(),caller_fnln(),caller_name(),
	info = get_traceback()
	info = info[:-2]
	if len(info) >= 4:
		info = info[-4:]

	if info[0] == '<module>' and info[1] == 1:
		info[0] = 'cliCommand'

	## End of common structure

	caller = info[:2]

	return caller

def ln():
	## VER: 2012-08-21, v1.2
	## 获得所在行的行号。this_lineno

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

	trace = get_traceback()[:-2]   ## 去除本行的行号记录['this_lineo',xxx]
	lineno = trace[-1]

	return lineno

function_labels['cae_coords_of_nodes'] = 'profile', 'node','location','cae','file','coordinate','axis','sort','output','print','write','flatness','straightness'
def cae_coords_of_nodes(nodes=None,poi=None,axis='xy',axis1=1,axis2=2,sort=None,filename='_coords_nodes.txt',factor=1):
	## VER: 2016-06-08, v1.5

##	>>> cae_coords_of_nodes(nodes=nodes1,axis='yx',sort=True,filename='_side1.txt')
##	--->Coordinates of nodes has been written to Z:/A0279/sintering/results/_side1.txt.txt
##	>>>
##	>>> cae_coords_of_nodes(nodes=nodes1,axis='xy',sort=True,filename='_side3.txt')
##	--->Coordinates of nodes has been written to C:/FEM/A0282 new triangle verify/results/_side3.txt.txt
##	>>>

##	nodes1 = node_select(p1,z=_zmid(p1)-0.5,x=(-4.9,4.9),err=0.1,poiRefY=(MAX,-2))
##	radius_of_fit_nodes(nodes1,axis='xy')
##	>>> cae_coords_of_nodes(nodes1,axis='xy',filename='_BG_266_surface_nodes')  ## Then use software ORIGIN to get the fit radius manually for double check
##	--->Coordinates of nodes has been written to Z:/A0267_USM_B104_R60/sintering/results/_BG_266_surface_nodes.txt
##	>>>

##	Polynomial Regression for BG266surfacen_coordy:
##	Y = A + B1*X + B2*X^2    ## Y=7.67837 + 7.06741E-4*X + 0.00761*X^2
##
##	Parameter	Value	Error
##	------------------------------------------------------------
##	A	7.67837	1.64973E-4
##	B1	7.06741E-4	3.0363E-5
##	B2	0.00761	1.3274E-5
##	------------------------------------------------------------
##
##	R-Square(COD)	SD	N	P
##	------------------------------------------------------------
##	0.99988	6.39384E-4	44	<0.0001
##	------------------------------------------------------------

	if axis not in empty and type_of(axis) == 'STR':
		axis1 = axis[0]
		axis2 = axis[1]
		sort = axis1

	if is_poi(nodes):
		nodes,poi = poi,nodes
		poi = check_poi(poi)

	if type_of(nodes) == 'STR':
		nodes = set2objs(p=poi,setname=nodes)

	nodes = tolist(nodes)

	if axis1 not in empty and sort in empty:
		sort = axis1

	if sort in ['x',1]:
		nodes = nodes_sort_byx(nodes)
	elif sort in ['y',2]:
		nodes = nodes_sort_byy(nodes)
	elif sort in ['z',3]:
		nodes = nodes_sort_byz(nodes)

	results1 = []
	results2 = []
	for node in nodes:
		x,y,z = node.coordinates
		if axis1 in ['x',1]:
			results1.append(x)
		elif axis1 in ['y',2]:
			results1.append(y)
		elif axis1 in ['z',3]:
			results1.append(z)

		if axis2 in ['x',1]:
			results2.append(x)
		elif axis2 in ['y',2]:
			results2.append(y)
		elif axis2 in ['z',3]:
			results2.append(z)

	if results1 in empty:
		results1 = results2

	coord_list = []
	for i in range(len(results1)):
		coord_list.append((results1[i],results2[i]*factor))

	if filename not in empty:
		list_to_txt_lines(coord_list,filename)
	##	dir1 = make_dir('results')
	##	file1 = open(dir1 + '/' + filename,'w')

##		print '--->Coordinates of nodes has been written to',dir1 + '/' + filename

##	if filename[-4:] != '.txt':
##		filename = filename + '.txt'
##
##
##	coord_list = []
##	print >>file1,'coord_' + str(axis1),'         coord_' + str(axis2)
##	for i in range(len(results1)):
##		coord_list.append((results1[i],results2[i]*factor))
##		print >>file1,results1[i],'   ',
##		if results2 not in empty:
##			print >>file1,results2[i]*factor
##		else:
##			print >>file1,' '
##
##	file1.close()

##	print '--->Created global varialbe coord_list'

	return coord_list

def cancel_job(prefix=None,postfix=None):
	## VER: 2013-09-09, v1.0

	if prefix in empty and postfix in empty:
		raise Exception('** prefix or postfix of jobname is required.')

	canceled = False
	jobname1 = ''
	if prefix not in empty:
		for jobname in mdb.jobs.keys():
			if jobname.startswith(prefix) == True:
				jobname1 = jobname
				mdb.jobs[jobname].kill()
				del mdb.jobs[jobname]
				canceled = True
				break
	elif postfix not in empty:
		for jobname in mdb.jobs.keys():
			if jobname.endswith(postfix) == True:
				jobname1 = jobname
				mdb.jobs[jobname].kill()
				del mdb.jobs[jobname]
				canceled = True
				break

	print '---> Canceled job',jobname1

	return 	canceled

def cell_at(p,loc=(),dx=0,dy=0,dz=0):
	## VER: 2014-08-05, v1.2, if not found,returns None

	p = check_poi(p)

	point = (loc[0]+dx, loc[1]+dy, loc[2]+dz)
	cell = p.cells.findAt(coordinates = point, printWarning=False)
	if cell != None:
		cell = p.cells[cell.index]

	return cell

def cell_select(p, x=(),y=(),z=(), groupX=None,groupY=None,groupZ=None,space=(),cells=(),setname=None,mat=None,mark_select=True,RP=None,tryone = False, printResult=True):
	## VER: 2014-11-26, v2.5	## result type: list

	global slow_call

	locals1 = eval(repr(locals()))
	inputs = get_inputs(locals1)

	p = check_poi(p)
	time1 = time.time()
	if len(space) == 6:
		x1,x2,y1,y2,z1,z2 = space
	else:
		x,y,z = real_xyz(p,x,y,z)
		x1,x2,y1,y2,z1,z2 = tospace(x,y,z)

	if type_of(cells) == 'STR':
		setname = cells

	if setname not in empty:
		cells = set2objs(p,setname)

	elif type_of(mat) == 'STR':
		cells = objs_of_material(p,mat)

	if cells in empty:
		cells = list(p.cells)

##	if x in empty and y in empty and z in empty and space in empty:
##		return tolist(cells)

	if RP not in empty:
		x0 = y0 = z0 = 0
		type1 = type_of(RP)
		if type1 == 'vertices':
			x0,y0,z0 = RP.pointOn[0]
		elif type1 == 'TUPLE':
			x0,y0,z0 = RP

		if x1 not in [_max,_min]:
			x1 = x1 + x0
		if x2 not in [_max,_min]:
			x2 = x2 + x0
		if y1 not in [_min,_max]:
			y1 = y1 + y0
		if y2 not in [_min,_max]:
			y2 = y2 + y0
		if z1 not in [_min,_max]:
			z1 = z1 + z0
		if z2 not in [_min,_max]:
			z2 = z2 + z0

	x = (x1,x2)
	y = (y1,y2)
	z = (z1,z2)

	if type_of(p) == 'PINSTANCE':
		if p.name in insts_space.keys():
			cross = cross_of_spaces((x1,x2,y1,y2,z1,z2),insts_space[p.name],mark_select=mark_select)
##			print 'cross=',cross
			if cross['no_cross'] == True:
				return []

	myCells = []
	for cell in cells:
		x01,x02,y01,y02,z01,z02 = objs_space(cell)
		if not meet_search_range((x01,x02),(x1,x2),mark_select=mark_select):  ## 实际是mark_select参数在meet_search_range()函数中没有用上，是一个闲置参数。
##			print (x01,x02),(x1,x2),'not meet in x'
			continue
		if not meet_search_range((y01,y02),(y1,y2),mark_select=mark_select):
			continue
		if not meet_search_range((z01,z02),(z1,z2),mark_select=mark_select):
			continue

		myCells.append(cell)
		if tryone == True:
			break

	cells = myCells
##	print fnln(),'len(cells)=',len(cells)
##	raise Exception

	if len(cells) > 0:
		if groupX not in empty or groupY not in empty or groupZ not in empty:
			space = objs_space(cells)
			if groupX not in empty:
				groupX = real_xyz_in_space(space,x=groupX)
				cells = cell_select(p=p,cells=cells,x=groupX)

			elif groupY not in empty:
				groupY = real_xyz_in_space(space,y=groupY)
				cells = cell_select(p=p,cells=cells,y=groupY)

			elif groupZ not in empty:
				groupZ = real_xyz_in_space(space,z=groupZ)
				cells = cell_select(p=p,cells=cells,z=groupZ)

	if printResult == True:
		print p.name,':',len(myCells),'cells selected, called by',this_and_caller(to_print=False)[:2],', inputs=',inputs

	if time.time() - time1 >= 0.1:
		slow_call.append(get_traceback())

	return cells

def cell_select_by_container(p,x=(),y=(),z=(),space=()):
	## VER: ('VER: 2012-08-29, v1.1')

	p = check_pias(p)
	if len(space) == 6:
		space = sort_space(space)
		x1,x2,y1,y2,z1,z2 = space
		x = (x1,x2)
		y = (y1,y2)
		z = (z1,z2)
	else:
		x,y,z = real_xyz(p,x,y,z)
		x1,x2,y1,y2,z1,z2 = tospace(x,y,z)

	space1 = poi_space(p)

	temp_part = temp_part_of_poi(p)
	if x not in empty and x != space1[0:2]:
		divide(temp_part,x=x1)
		divide(temp_part,x=x2)
	if y not in empty and y != space1[2:4]:
		divide(temp_part,y=y1)
		divide(temp_part,y=y2)
	if z not in empty and z != space1[4:6]:
		divide(temp_part,z=z1)
		divide(temp_part,z=z2)

	cells = []
	temp_part = _m.parts[temp_part]
	for cell in temp_part.cells:
		pointOn_f = temp_part.faces[cell.getFaces()[0]].pointOn[0]		;please_check('换做cell的某个face的pointOn如何?')
		if contain((x1,x2,y1,y2,z1,z2),pointOn_f,mark_select=True) == False:
			continue

		pointOn_e = temp_part.edges[cell.getEdges()[-1]].pointOn[0]		;please_check('换做cell的某个face的pointOn如何?')
		if contain((x1,x2,y1,y2,z1,z2),pointOn_e,mark_select=True) == False:
			continue

		pointOn_p = temp_part.vertices[cell.getVertices()[1]].pointOn[0]		;please_check('换做cell的某个face的pointOn如何?')
		if contain((x1,x2,y1,y2,z1,z2),pointOn_p,mark_select=True) == False:
			continue

		pointOn = cell.pointOn[0]
		centroid = centroid_of_cell(cell,temp_part)

		if contain((x1,x2,y1,y2,z1,z2),centroid,mark_select=False) == True:
			cell0 = p.cells.findAt(coordinates = pointOn, printWarning=False)		## 注意pointOn优先
			if cell0 != None:
				cell0 = p.cells[cell0.index]
				if cell0 not in cells:
					cells.append(cell0)
			else:
				cell0 = p.cells.findAt(coordinates = centroid, printWarning=False)	## centroid可能不在cell内部，故可能有误。
				if cell0 != None:
					cell0 = p.cells[cell0.index]
					if cell0 not in cells:
						cells.append(cell0)

	del_parts(temp_part)

	print p.name,':',len(cells),'cells are selected.'

	return cells

def cell_select_by_face(p, x=(),y=(),z=(), space=(),cells=(),setname=None,mat=None,mark_select=False,RP=None,tryone = False):
	## VER: ('VER: 2012-12-11, v2.1')	## result type: list

	locals1 = eval(repr(locals()))
	inputs = get_inputs(locals1)

	if len(space) == 6:
		x1,x2,y1,y2,z1,z2 = space
	else:
		x,y,z = real_xyz(p,x,y,z)
		x1,x2,y1,y2,z1,z2 = tospace(x,y,z)

	if type_of(cells) == 'STR':
		setname = cells
	elif type_of(mat) == 'STR':
		setname = mat

	if setname not in empty:
		cells = set2objs(p,setname)

	if cells in empty:
		cells = list(p.cells)
		reselect = True
	else:
		reselect	= False

	if x in empty and y in empty and z in empty and space in empty:
		return tolist(cells)

	if RP not in empty:
		x0 = y0 = z0 = 0
		type1 = type_of(RP)
		if type1 == 'vertices':
			x0,y0,z0 = RP.pointOn[0]
		elif type1 == 'TUPLE':
			x0,y0,z0 = RP

		if x1 not in [_max,_min]:
			x1 = x1 + x0
		if x2 not in [_max,_min]:
			x2 = x2 + x0
		if y1 not in [_min,_max]:
			y1 = y1 + y0
		if y2 not in [_min,_max]:
			y2 = y2 + y0
		if z1 not in [_min,_max]:
			z1 = z1 + z0
		if z2 not in [_min,_max]:
			z2 = z2 + z0

	x = (x1,x2)
	y = (y1,y2)
	z = (z1,z2)
	space = x1,x2,y1,y2,z1,z2

	if type_of(p) == 'PINSTANCE':
		if p.name in insts_space.keys():
			cross = cross_of_spaces((x1,x2,y1,y2,z1,z2),insts_space[p.name],mark_select=mark_select)
			if cross['no_cross'] == True:
				return []

	if reselect == True:
		newlist = []
		for cell in cells:
			if cross_of_cell_and_space(p,cell,(x1,x2,y1,y2,z1,z2),mark_select=mark_select) == True:
				newlist.append(cell)
				if tryone == True:
					break
		cells = newlist

	print p.name,':',len(cells),'cells selected, Parameters=',inputs,', called by',this_and_caller(to_print=False)[:2]

	return cells

def vertice_to_cells(p,loc=(),point=None,dx=0,dy=0,dz=0):
	## VER: 2015-07-06, v1.2

	## Example:
##	cells =vertice_to_cells('cylind',vertice[0])

	p = check_poi(p)

	if type_of(point) == 'vertices':
		loc = point.pointOn[0]
	elif type_of(loc) == 'vertices':
		loc = loc.pointOn[0]

	if is_location(loc) == False:
		raise Exception('*** loc is required.')

	point = (loc[0]+dx, loc[1]+dy, loc[2]+dz)

	pt1 = point_at(p,loc=point)
	if type_of(pt1) != 'vertices':
		raise Exception('No vertice at point location. ')

	cells = []

	cell = cell_at(p,loc=point)
	if cell != None and cell not in cells:
		cells.append(cell)

	cell = cell_at(p,loc=(point[0] - _nearby,point[1],point[2]))
	if cell != None and cell not in cells:
		cells.append(cell)

	cell = cell_at(p,loc=(point[0] + _nearby,point[1],point[2]))
	if cell != None and cell not in cells:
		cells.append(cell)

	cell = cell_at(p,loc=(point[0],point[1] - _nearby,point[2]))
	if cell != None and cell not in cells:
		cells.append(cell)

	cell = cell_at(p,loc=(point[0],point[1] + _nearby,point[2]))
	if cell != None and cell not in cells:
		cells.append(cell)

	cell = cell_at(p,loc=(point[0],point[1],point[2] - _nearby))
	if cell != None and cell not in cells:
		cells.append(cell)

	cell = cell_at(p,loc=(point[0],point[1],point[2] + _nearby))
	if cell != None and cell not in cells:
		cells.append(cell)

	return cells

def center_axis_of_cylind_face(face):
	## VER: 2014-07-15, v1.3		This method creates a Feature object and a DatumAxis object along the axis of a cylinder or cone.

	radius = get_radius(face)
	if not is_number(radius):
##		raise Exception('A cylindrical face is required.')
		return [None,None]

	poi = get_poi(face)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	datum1 = poi.DatumAxisByCylFace(face=face)
	datum_axis = poi.datums[datum1.id]
	vector = datum_axis.direction
	vector = positive_vector(vector)

	center = datum_axis.pointOn
	center = round_loc(center,6)
##	vector = round_loc(vector,6)

	return center,vector,datum_axis

##axis_of_cylindrical_face = center_axis_of_cylind_face

def center_axis_of_poi(poi,x=None,y=None,z=None,radius=None,diameter=None,endface=False):
	## VER: 2014-07-20, v1.1

	poi = check_poi(poi)

	x,y,z = real_xyz(poi,x,y,z)

	center = None
	if is_numbers(x) or is_numbers(y) or is_numbers(z):
		edges = edge_select(poi,x=x,y=y,z=z,edir='circular')
		if edges not in empty:
			center,axis = center_axis_of_circle(edges[0])

##		faces = face_select(poi,x=x,y=y,z=z)
##		print fnln(),len(faces)
##		if faces not in empty:
##			edges = faces_to_edges(faces)
##			edges = edge_select(poi,edges=edges,edir='circular')
##			print fnln(),len(edges)
##			if edges not in empty:
##				center = circular_center(edges[0])
##				normal = get_normal(faces[0])
##				axis = create_datum_axis(poi,point1=center, vector=normal)
##				raise Exception

	else:
		faces = face_select(poi,x=x,y=y,z=z, radius=radius,diameter=diameter,ndir='cylindrical')
		if faces not in empty:
			center,vector,axis = center_axis_of_cylind_face(faces[0])

	if center in empty:
		raise Exception('*** Fail to find the center and axis.')

	return center, axis

def cells_to_index(cells):
	## VER: 2014-12-04, v1.0

	cells = tolist(cells)

	ids = []
	for cell in cells:
		id = cell.index
		if id not in ids:
			ids.append(id)

	return ids


def center_axis_of_circle(edge):
	## VER: 2014-07-20, v1.0

	edge = tolist(edge)
	edge = edge[0]

##	print type_of(edge)
	if type_of(edge) != 'edges':
		raise Exception('*** an circular edge is required.')

	edir = edge_dir(edge)
	print 'edir=',edir
	if edir != 'circular':
		raise Exception('*** an circular edge is required.')

	poi = get_poi(edge)
	center = circular_center(edge)
	loc1,loc2,loc3 = locs_of_edge(edge,(0, 0.4, 0.8))
	datum_plane = create_datum_plane_by_3points(poi,loc1,loc2,loc3)
	vector = datum_plane.normal
	axis = create_datum_axis(poi,point1=center, vector=vector)

	return center,axis

function_labels['centroid_H'] = 'PV, OB, AB, PFH, PH', 'powder compaction'
def centroid_H(poi):
	## VER: 2016-08-05, v1.0
	## 获取重心到底部的高度，用于压型参数PV,OB计算。
	## called by:square_insert_compaction()

	x0,y0,z0 = poi_centroid(poi)
	H = z0 - _zmin(poi)
	H = round(H,4)

	return H

def centroid_of_cell(cell,poi=None):

##	VER: ('VER: 2012-08-27, v1.0')	## 单个face，有face.getCentroid()，但是当cell没有cell.getCentroid()

	if poi in empty:
		poi = get_poi(cell)

	sequence = poi.cells[cell.index:cell.index+1]

	if type_of(poi) == 'PINSTANCE':
		poi = a

	prop = poi.getMassProperties(regions=sequence)
	centroid = prop['volumeCentroid']

	return centroid

function_labels['powder_properties'] = 'powder compaction','sintering','grade','density','sinter loss','shrinkage','database'
def powder_properties(grade='060',sinter_loss=None,C1=None,density_th=None):
	## VER: 2017-02-16, v1.5

##	>>> powder_properties('060')
##	{'sinter_loss': 2.505, 'density_th': 14.44, 'filling_density': 3.24, 'shrinkage': 0.19}
##	>>>

	sinter_loss0=None
	if is_number(sinter_loss):
		sinter_loss0 = sinter_loss
	elif is_number(C1):
		sinter_loss0 = C1

	density_th0 = None
	if is_number(density_th):
		density_th0 = density_th

	sinter_loss = None
	density_th = None

	if grade in ['028','H6FF']:
		portp = '028DPS'
		lot = 3001
		site = 'Coventry'
		date = 2014
		account = [913, 921]	## bearing application
		WC = '93.5%'
		Co = '6%'
		others = 'Cr3C2 = 0.3%, VC = 0.2%'

		hall_flow = 36
		pressure = 399	## MPa
		furnace_pressure = 50	## Bar (vacuum if 0 or NA)
		sinter_temp = 1450
		CoM = 5.48	## %	min=4.8, max=5.6
		Hc = 30		## KA/m	min=25, max=30
		Hardness = 1837	## Hv30	min=1800, max=1900, mean=1850
		HRa = (93.2, 94)	## (min, max)

		apparent_density = 3.33
		density_th = 14.87	## g/cc	min=14.75, max=14.91
		sinter_loss = 3.469
		shrinkage = 0.19


	elif grade in ['040','H6F']:
		lot = 2089
		site = 'Coventry'
		portp = '040DRB'
		account = [919,915, 926, 921]	## RTB
		WC = '93.7%'
		Co = '6%'
		others = 'Cr3C2 = 0.3%'

		apparent_density = 3.24
		density_th = 14.89	## min=14.84, max=15.00
		sinter_loss = 2.27	## 2.511
		shrinkage = 0.19

		hall_flow = 36.6
		pressure = 195	## MPa
		furnace_pressure = 50	## Bar (vacuum if 0 or NA)
		sinter_temp = 1450
		CoM = 5.53	## %	min=5.0, max=5.6
		Hc = 25	## min=22, max=25
		Hardness = 1813	## Hv30	min = 1725, max=1825, mean=1775
		HRa = (92.8,93.6) ## (min,max)

	elif grade in ['054', 'PN90']:
		site = 'Coventry'
		date = 2014
		portp = '054CPS'
		product = 'PN90'	## RTB棒料
		account = [923, 916]	## metal forming tools
		WC = '90.2%'
		Co = '9%'
		others = 'Cr3C2 = 0.45%, VC = 0.35%'

		apparent_density = 3.14
		sinter_loss = 2.212	## %
		density_th = 14.47	## min=14.44, max=14.60
		shrinkage = 0.19

		hall_flow = 37.0
		pressure = 192	## MPa
		furnace_pressure = 50	## Bar (vacuum if 0 or NA)
		CoM = 7.95	## %	## min=7, max=8
		Hc = 36.5	## kA/m	min = 36, max=42
		Hardness = 1925	## HV30	min=1875, max=2025, mean=1950

	elif grade in ['060','H10F']:
		product = 'H10F'
		site = 'Coventry'
		lot = 9954
		portp = '060DUS'
		account = [916]
		WC = '89.5%'
		Co = '10%'
		others = 'Cr3C2 = 0.5%'

		hall_flow = 36
		pressure = 181	## MPa
		sinter_temp = 1410
		furnace_pressure = 'Vacuum'
		CoM = 8.54	## min=7.8, max=8.8
		Hc = 20.3
		Hardness = 1583 	## Hv30, min=1550, max=1650, mean=1600

		apparent_density = 3.2	## or 3.2, 3.17, 3.24
		sinter_loss = 2.50		## 不同批次会不同，例如：2.4, 2.42, 2.45, 2.505, 2.52, 2.57(060DUS, triangle insert, A0279, A0282), 2.601, 2.61 (sinter loss)
		density_th = 14.44		## or 14.46, 14.45, min=14.4, max=14.56 (triangle insert: 14.44 in Mexico)
		shrinkage = 0.19		##19%对应1.2346, 王春：截面方向一般用1.24, 高度方向一般用1.245
								## Triangle insert in Mexico: 0.185 (81.5%)

	elif grade in ['074','AM70']:	## AM70
		site = 'Coventry'
		date = 2013
		portp = '074DUS'
		product = 'AM70'

		apparent_density = 3.05  ## g/cm^3，在3.10附近波动
		sinter_loss = 2.75   ## % 有数据为2.757   Raymundo=2.81
		density_th = 14.10  ## g/cm^3, 在14.10附近波动
		shrinkage = 0.19

		hall_flow = 39   ## s/25cm^3
		pressure = 234		## MPa
		sinter_temp = 1410  ## degC
		CoM = 9   ## %
		Hc = 17.7  ## kA/m
		Hardness = 1525   ## Hv30
		applications = 'insert for PU Mexico, such as triangle insert for Carmex'

	elif grade in ['503','W2B']:
		site = 'West Branch'
		date = 2016
		portp = '503DPSM'   ## 503系列全是回收粉。
		product = 'W2B'

		apparent_density = 3.1  ## g/cm^3
		density_th = 14.28  ## g/cm^3
		sinter_loss = 2.78   ## %
		shrinkage = 0.1935    ## 207MPa压时为18.63%

		hall_flow = 37.2   ## s/25cm^3, flow rate
		pressure = 159		## MPa
		sinter_temp = 1455  ## degC
		CoM = 5.91   ## %
		Hc = 24.17  ## kA/m
		Hardness = 1558   ## Hv30,  Ra=91.6
		composition = 'Co=5.93wt%, Ni=3.05wt%, TiC=0.64wt%, Tac=0.87wt%, Cr3C2=0.71wt%, NbC=0.26%, WC=88.54wt%'
		applications = 'metal cutting. insert for PU Mexico, B102-B105, USM, by Ulises'

	if sinter_loss in empty or density_th in empty:
		raise Exception('*** Fail to get the grade properties.')

	if density_th0 not in empty:
		density_th = density_th0

	if sinter_loss0 not in empty:
		sinter_loss = sinter_loss0

	dict1 = {}
	dict1['density_th'] = density_th
	dict1['sinter_loss'] = sinter_loss
	dict1['shrinkage'] = shrinkage
	dict1['filling_density'] = apparent_density

	return dict1

def poi_centroid(poi):
	## VER: 2016-08-25, v1.2
	## 在整个part为均一材料的情况下，体心就是质心 mass centroid

##	Mass properties:
##	  Volume: 1157.14
##	  Volume centroid: 4.43e-015,3.48e-015,22.43
##	  Mass: 9.08e-006
##	  Center of mass: 4.43e-015,3.48e-015,22.43
##	  Moment of inertia about the center of mass (Ixx, Iyy, Izz, Ixy, Iyz, Izx): 3.45e-004,3.45e-004,6.57e-004,-1.43e-019,-3.73e-020,-1.20e-019

	poi = check_pias(poi)
	sequence = poi.cells[:]

	if type_of(poi) == 'PINSTANCE':
		poi = a

	if len(sequence) > 0:
		prop = poi.getMassProperties(regions=sequence)
	else:
		prop = poi.getMassProperties()

	centroid = prop['volumeCentroid']	;please_check('要不要round到6位?')
	if centroid[0] in empty:
		centroid = prop['areaCentroid']

	return centroid

def get_volume_centroid(objs=None,insts=None):
	## VER: ('VER: 2014-09-13, v1.4')	## 单个face，有face.getCentroid()，但是当cell没有cell.getCentroid()

	## Example:
	## cells = cell_select(cshaft_A1,x=bearing_x)
	## centroid = get_volume_centroid(cells)   ## (220.5, 0, 0)

##>>> get_mass_centroid(a)
##(35.039466, 235.69806, 7569.2525)
##>>> get_volume_centroid(a)
##(43.52627, 136.537557, 7547.487003)
##>>>

	if (objs,insts) == (None,None):
		dpo = get_dpo()
		if type_of(dpo) == 'PART':
			objs = dpo
		elif type_of(dpo) == 'ASSEMBLY':
			objs = a
		else:
			raise Exception('*** objs required to get the mass centroid.')

	if is_poi(objs):
		poi = check_poi(objs)
		sequence = poi.cells[:]
		if len(sequence) == 0:
			print '*** Cells are required to get the volume centroid.'
			return (None,None,None)

	elif type_of(objs) == 'ASSEMBLY':
		sequence = None
		poi = a
		for inst in a.instances.values():
			if len(inst.cells) > 0:
				seq = inst.cells[:]
				if sequence in empty:
					sequence = seq
				else:
					sequence = sequence + seq
	elif insts not in empty:
		insts = real_insts(insts)
		poi = a
		sequence = None
		for inst in insts:
			if len(inst.cells) > 0:
				seq = inst.cells[:]
				if sequence in empty:
					sequence = seq
				else:
					sequence = sequence + seq

	else:
		poi = get_poi(objs)

		type1 = type_of(objs)
		if type1 == 'cells':
			sequence = poi.cells[objs.index:objs.index+1]
		elif type1 == 'SEQUENCE':
			sequence = objs
		else:
			sequence = list2sequence(objs,poi)

		if type_of(sequence[0]) != 'cells' or type_of(sequence[-1]) != 0:
			raise Exception('*** cell sequence are required.')

	if type_of(poi) == 'PINSTANCE':
		poi = a

	prop = poi.getMassProperties(regions=sequence)
	x,y,z = prop['volumeCentroid']   ## If failed, then (None,None,None)，例如对于2D part

	if is_numbers(x,y,z):
		x = round(x,6)
		y = round(y,6)
		z = round(z,6)

		if PK(x,0) == 0:
			x = 0
		if PK(y,0) == 0:
			y = 0
		if PK(z,0) == 0:
			z = 0

	return x,y,z

get_volume_center = get_volume_centroid

def get_mass_centroid(objs=None,insts=None):
	## VER: ('VER: 2014-09-13, v1.2')	## 单个face，有face.getCentroid()，但是当cell没有cell.getCentroid()

	## Example:
	## cells = cell_select(cshaft_A1,x=bearing_x)
	## centroid = get_volume_centroid(cells)   ## (220.5, 0, 0)

##>>> get_mass_centroid(insts=(palm_A1,stand_A1))
##(23.75954, 357.533987, 387.951799)
##>>>

##>>> get_mass_centroid(a)
##(35.039466, 235.69806, 7569.2525)
##>>> get_volume_centroid(a)
##(43.52627, 136.537557, 7547.487003)
##>>>

	if (objs,insts) == (None,None):
		dpo = get_dpo()
		if type_of(dpo) == 'PART':
			objs = dpo
		elif type_of(dpo) == 'ASSEMBLY':
			objs = a
		else:
			raise Exception('*** objs required to get the mass centroid.')

	if is_poi(objs):
		poi = check_poi(objs)
		sequence = poi.cells[:]
		if len(sequence) == 0:
			print '*** Cells are required to get the volume centroid.'
			return (None,None,None)

	elif type_of(objs) == 'ASSEMBLY':
		sequence = None
		poi = a
		for inst in a.instances.values():
			if len(inst.cells) > 0:
				seq = inst.cells[:]
				if sequence in empty:
					sequence = seq
				else:
					sequence = sequence + seq
	elif insts not in empty:
		insts = real_insts(insts)
		poi = a
		sequence = None
		for inst in insts:
			if len(inst.cells) > 0:
				seq = inst.cells[:]
				if sequence in empty:
					sequence = seq
				else:
					sequence = sequence + seq

	else:
		poi = get_poi(objs)

		type1 = type_of(objs)
		if type1 == 'cells':
			sequence = poi.cells[objs.index:objs.index+1]
		elif type1 == 'SEQUENCE':
			sequence = objs
		else:
			sequence = list2sequence(objs,poi)

		if type_of(sequence[0]) != 'cells' or type_of(sequence[-1]) != 0:
			raise Exception('*** cell sequence are required.')

	if type_of(poi) == 'PINSTANCE':
		poi = a

	prop = poi.getMassProperties(regions=sequence)
	x,y,z = prop['centerOfMass']   ## If failed, then (None,None,None)，例如对于2D part

	if is_numbers(x,y,z):
		x = round(x,6)
		y = round(y,6)
		z = round(z,6)

		if PK(x,0) == 0:
			x = 0
		if PK(y,0) == 0:
			y = 0
		if PK(z,0) == 0:
			z = 0

	return x,y,z

get_mass_center = get_mass_centroid

def centroid_of_face(face):
	## VER: 2012-08-29, v1.0

	if type_of(face) != 'faces':
		raise Exception('one face is required.')

	return faces.getCentroid()[0]

def centroid_of_faces(faces):
	## VER: ('VER: 2012-08-17, v1.1')	## 单个face，有face.getCentroid()，但是当cell没有cell.getCentroid()

	type1 = type_of(faces)
	if type1 == 'faces':
		return faces.getCentroid()[0]
	elif type1 == 'SEQUENCE':
		sequence = faces
		poi = get_poi(faces)
	elif type1 in ['PART','PINSTANCE']:
		poi = faces
		sequence = poi.faces[:]
	else:
		sequence = list2sequence(faces)
		poi = get_poi(faces)

	prop = poi.getMassProperties(regions=sequence)   ## Edges没有此数据: areaCentroid, volumeCentroid
	centroid = prop['areaCentroid']

	return centroid

def chamfer_edges(part,edges=None,length=1,tilt=None,corner_angle=90,x=None,y=None,z=None,edir=None):
	## VER: 2016-04-16, v1.4. length相当与切除块的直角三角形的直角边,tilt相当于斜边。
	## 如果edges为多条，则同时对多条edges进行操作。如果edges对应多个corner，则同时对这些corner进行chamfer
	## 对二维模型不适用。用bias_cut()

##	mid = revolve_sketch_to_part(sketch=s1,partname='mid',angle=90)
##	edges = edge_select(mid,y=MIN,diameter='bigger')
##	chamfer_edges(mid,edges=edges,length=mid_chamfer)

	if length == 0:
		print fnln(),'*** No chamfer for edges for length=0'
		return

	if type_of(edges) == 'PART':
		part,edges = edges,part

	part = check_part(part)
	print fnln(),'type_of(part)=',type_of(part)

	if edges in empty:
		edges = edge_select(part,x=x,y=y,z=z,edir=edir)
	edges = totuple(edges)

	if type_of(tilt) in numerics:
		length = tilt*sqrt(1/(2*(1-cos(corner_angle*pi/180))))

	part.Chamfer(length=length, edgeList=edges)

	clear_empty_sets(part)

	print '--->Created chamfer_edges for',part.name, ', length=',length

	return

def set_element_type(parts=None,setname='',cells=(),etype=C3D8R,hour_glass=ENHANCED, meshed=True,antype='',solver=''):
	## use totegher with set_element_shape()
	## VER: ('VER: 2017-03-29, v3.0')	## 即使没有mesh，也可以设置etype。超弹性材料并不一定要用hour_glass，尤其是面积很大，或畸形并不是很严重时。

	## Example:
##	set_element_type(setname='EVA',etype='hybrid')
##	set_element_type(setname='Rubber',etype='hybrid')
##	set_element_type(setname='Silic',etype='hybrid')
##
##	set_element_type(setname='EVA2',etype='hybrid')
##	set_element_type(setname='Rubber2',etype='hybrid')		##双玻组件，clamp安装方式
##	set_element_type(setname='Silic2',etype='hybrid')
## set_element_type(setname='FRP',etype='hybrid',hour_glass='enhanced')

	parts = real_parts(parts)

	if antype in empty:  ## Dynamic, Explicit的antype为stress
		antype = get_antype()

	if solver in empty: ## Dynamic, Explicit的solver为explicit
		solver = get_solver()

	type1 = type_of(cells)
	if type1 == 'STR' and cells not in empty:
		setname = cells
		cells = []
	elif type1 == 'PART':
		parts = [cells]
	elif type1 == 'cells':
		cells = [cells]

	if parts in empty:
		if setname not in empty:
			parts = parts_by_set(setname)

		elif cells not in empty:
			parts = get_pois(cells)

	if setname in empty and cells not in empty and len(parts) > 1:
		raise Exception('Confused cells info. Cells are from different parts.')

	if etype == 'hybrid':
		if antype == 'stress':
			etype = C3D8RH
		elif antype == 'thermal_stress':
			etype = C3D8RHT

	if hour_glass == 'default':
		hour_glass = DEFAULT
	elif hour_glass == 'enhanced':	##变形很严重，象沙漏一样，都快断了。
		hour_glass = ENHANCED

	please_check('双玻情形，对收敛有帮助。')
	print fnln(),'**etype=',etype,', Hourglass =',hour_glass

	if str(etype)[0:4] == 'C3D8':
		eshape = 'hex'
		elemType1 = mesh.ElemType(elemCode=etype, elemLibrary=STANDARD, secondOrderAccuracy=ON,
		    kinematicSplit=AVERAGE_STRAIN, hourglassControl=hour_glass, distortionControl=DEFAULT)

		if antype == 'stress':
			elemType2 = mesh.ElemType(elemCode=C3D6, elemLibrary=STANDARD, distortionControl=DEFAULT)
			elemType3 = mesh.ElemType(elemCode=C3D4, elemLibrary=STANDARD, distortionControl=DEFAULT)
		elif antype == 'thermal_stress':
			elemType2 = mesh.ElemType(elemCode=C3D6T, elemLibrary=STANDARD, distortionControl=DEFAULT)
			elemType3 = mesh.ElemType(elemCode=C3D4T, elemLibrary=STANDARD, distortionControl=DEFAULT)

	elif str(etype)[0:5] in 'C3D10':
		eshape = 'tet'
		if solver == 'explicit':
			elemType1 = mesh.ElemType(elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT)
			elemType2 = mesh.ElemType(elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT)
			elemType3 = mesh.ElemType(elemCode=C3D10M, elemLibrary=EXPLICIT)

	elif str(etype)[0:5] == 'C3D20':
		eshape = 'hex'
		elemType1 = mesh.ElemType(elemCode=etype, elemLibrary=STANDARD, distortionControl=DEFAULT)

		if antype == 'stress':
			elemType2 = mesh.ElemType(elemCode=C3D15, elemLibrary=STANDARD, distortionControl=DEFAULT)
			elemType3 = mesh.ElemType(elemCode=C3D10M, elemLibrary=STANDARD, distortionControl=DEFAULT)
		elif antype == 'thermal_stress':
			elemType2 = mesh.ElemType(elemCode=UNKNOWN_WEDGE, elemLibrary=STANDARD)
			elemType3 = mesh.ElemType(elemCode=C3D10MT, elemLibrary=STANDARD)

	elif etype == SC8R:
		eshape = 'shell'
		elemType1 = mesh.ElemType(elemCode=etype, elemLibrary=STANDARD, secondOrderAccuracy=ON,
		    hourglassControl=hg)
		elemType2 = mesh.ElemType(elemCode=SC6R, elemLibrary=STANDARD)
		elemType3 = mesh.ElemType(elemCode=UNKNOWN_TET, elemLibrary=STANDARD)

	elif antype == 'thermal':
		elemType1 = mesh.ElemType(elemCode=DCC3D8, elemLibrary=STANDARD)
		elemType2 = mesh.ElemType(elemCode=DC3D6, elemLibrary=STANDARD)
		elemType3 = mesh.ElemType(elemCode=DC3D4, elemLibrary=STANDARD)

##	print 'parts=',poi_names(parts)
##	print 'setname=',setname
##
##	raise Exception

	setted = False
	if len(parts) > 0:
		for part in parts:
			if meshed == True:
				stats = mesh_status(part)
				if stats[1] == False:
					print fnln_fnln(), '****',part.name + ' has not been meshed yet, set_element_type() failed.'
					continue

			if setname not in empty:
				cells = set2objs(setname,part)
			else:
				cells = tolist(part.cells)

			if cells not in empty:
				part.setElementType(regions = cells, elemTypes=(elemType1, elemType2, elemType3))
				setted = True
			else:
				continue

			area = 'All'
			if len(cells) != len(part.cells):
				area = 'Some'

			a.regenerate()
			print fnln_fnln(),'--->',part.name,':',area,'cells',
			if setname != '':
				print '(setname= ' + setname + ')',
			print 'set_element_type=',etype

			print ' '

	if setted == False:
		print fnln_fnln(),'******No cells was found with setname=',setname,', set_element_type() failed.'
		error_record('set_element_type: no cells')
		print ' '

	return

function_labels['change_journal'] = 'findAt','index','compressed','mask'
def change_journal(journal):
	## 2016-11-11, v1.0

	if journal == 'findAt':   ## COORDINATE, INDEX, and COMPRESSEDINDEX ，对于orphan mesh，自动使用index，例如：face4Elements1 = f1[20:21]+f1[22:24]+...
		session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE)
	##	session.journalOptions.setValues(replayGeometry=INDEX, recoverGeometry=INDEX)
	else:  ## default = COMPRESSEDINDEX
		session.journalOptions.setValues(replayGeometry=COMPRESSEDINDEX, recoverGeometry=COMPRESSEDINDEX)

	return

def change_key_name(obj,oldname,newname):
	## VER: 2013-03-28, v1.0

	type1 = type_of(obj)
	changed = False
	if type1 in ['PART','PINSTANCE']:
		if type_of(oldname) != 'STR':
			raise Exception('**** oldname is required.')

		if type_of(newname) != 'STR':
			raise Exception('***** newname is required.')

	if type1 == 'PART':
		if oldname not in _m.parts.keys():
			raise Exception('**** No such oldname = ' + oldname)

		if newname in _m.parts.keys():
			raise Exception('**** newname ' + newname + ' already exists. oldname ' + oldname + ' will not change.' )

		try:
			_m.parts.changeKey(fromName=oldname,toName=newname)
			_m.parts[newname].regenerate()
			changed = True
		except:
			print fnln_fnln(),'**** Fail to change name'

##		_m.regenerate()

	elif type1 == 'PINSTANCE':
		if oldname not in a.instances.keys():
			raise Exception('**** No such oldname = ' + oldname)

		if newname in a.instances.keys():
			raise Exception('**** newname ' + newname + ' already exists. oldname ' + oldname + ' will not change.' )

		try:
			a.features.changeKey(fromName=oldname,toname=newname)
			changed = True
		except:
			print fnln_fnln(),'**** Fail to change name'

		a.regenerate()

	elif type1 == 'DICT':
		if oldname not in obj.keys():
			raise Exception('**** No such oldname = ' + oldname)

		if newname in obj.keys():
			raise Exception('**** ' + newname + ' already exists. oldname ' + oldname + ' will not change.' )

		value1 = obj[oldname]
		obj[newname] = value1

		del obj[oldname]
		changed = True

	return changed


def change_module(module_name=None,renew=True):

	## VER: ('2012-10-11, v2.3')		## 动作：update_space or collect space.

	global BC_status

	refresh()

	dpo = get_dpo()
	type1 = type_of(dpo)

	if module_name == None:
		if type1 == 'ODB':
			module_name = 'Visulization'
		elif type1 == 'ASSEMBLY':
			module_name = 'ASSEMBLY'
		elif type1 == 'PART':
			module_name = 'PART'

	if module_name in empty:
		module_name = 'another'

	module_name = module_name.upper()

	print ' '
	print '============================**** Change to ' + module_name + ' Module ****=================================='
	print ' '

	clear_datum_points()

##	print 'type_of(dpo)=',type_of(dpo)

	if type_of(dpo) in ['ASSEMBLY','PART','None']:
		if sorted(a.instances.keys()) != sorted(insts_space.keys()):
			renew = True

		update_insts_space(renew=renew)

	if 'LOAD' in module_name:
		if BC_status.keys() in empty:
			BC_status_initiate()

##		for inst in a.instances.keys():
##			if inst not in BC_status.keys():
##				BC_status[inst] = {}

	if 'LOAD' in module_name or 'MESH' in module_name:
		global contacts_num
		list_contacts()
		contacts_num = len(conts)
		write_global_variables(inp_file_title + '.vars',contacts_num)

	return

def check_entity(obj,obj_type,error_stop=True):
	## VER: 2012-11-15, v1.0

	if type_of(obj_type) != 'STR':
		obj,obj_type = obj_type,obj

	obj1 = 'NA'
	type1 = type_of(obj)
	if type1 == obj_type:
		obj1 = obj
	elif type1 in ['LIST','TUPLE'] and obj not in empty:
		if type_of(obj[0]) == obj_type:
			obj1 = obj[0]

	if obj1 == 'NA':
		if error_stop == True:
			raise Exception('Error obj_type=',type1)
		else:
			obj1 = obj

	return obj1

def check_faces(faces,p=None):
	## 2011-01-28, v1.0, 对face sequence也有效

	if type_of(faces) in ['PART','PINSTANCE']:
		faces,p = p,faces

	type1 = type_of(faces)
	if p not in empty and type1 == 'STR':
		faces = set2objs(faces,p)
	elif type1 == 'faces':
		faces = [faces]

	if p in empty or type_of(p) == 'STR':
		p = get_poi(faces)

	return faces,p

def new_key(name,list1=None,new_inst=False,new_part=False,force_new_key=True,num_prefix=''):
	## VER: ('VER: 2012-11-14, v2.1')
	## 例如：part = new_key(name='_temp',new_part=True)

	## Example:
##	exist_files = get_files_in_dir(path,extension=format)
##	name = new_key(exist_files,name)

	## name = new_key(_m.boundaryConditions.keys(),name)

	if type_of(list1) == 'STR':
		name,list1 = list1,name
	elif type_of(name) == 'LIST':
		name,list1 = list1,name

	if new_part == True:  ## 可以不提供list1
		list1 = _m.parts.keys() + a.instances.keys()   ## 名字不能与既有的partname 和 instance名相同。
		force_new_key = True
	elif new_inst == True:	## 可以不提供list1
		list1 = _m.parts.keys() + a.instances.keys()
		num_prefix = '_A'
		force_new_key = True

	if type_of(list1) in ['DICT','REPOSITORY']:
		list1 = list1.keys()

	if type_of(list1) != 'LIST':
		raise Exception('****** A key list or a dictionary object is required.')

##	print fnln_fnln(),'current list=',list1
	if name in list1 and force_new_key == False:
		print name,'already existed in the key list and force_new_key = False'
		return name

	if name not in list1:
		return name
	else:
		##>>> '34'.isdigit()
		##True
		##>>>

		name0 = name
		if name[-2:].isdigit():
			prefix = name[:-2]
			num = int(name[-2:])
		elif name[-1].isdigit():
			prefix = name[:-1]
			num = int(name[-1])
		else:
			prefix = name
			num = 1

		num_prefix0 = prefix[-1]
		if num_prefix not in empty and num_prefix0 not in num_prefix:
			prefix = prefix + num_prefix

		name = prefix + str(num + 1)
		while name in list1:
			num = num + 1
			name = prefix + str(num + 1)

		return name

	return name

def check_facing_dir(faces,ndir=None,nx=None,ny=None,nz=None,exterior=True):
	## VER: ('VER: 2016-11-08, v1.2')

	faces = tolist(faces)
	if faces in empty:
		return []

	if exterior == True:
		poi = get_poi(faces[0])
		pshape = part_shape(poi)[1]

		if 'solid' in pshape:
			faces1 = []
			for face in faces:
				if len(face.getCells()) == 1:
					faces1.append(face)
			faces = faces1

	if ndir != None:
		faces1 = []
		for face in faces:
			ndir1 = face_ndir(face)
			if ndir != face_ndir(face):
				if ndir == 'cylindrical or conical' and ndir1 in ['cylindrical','conical']:
					faces1.append(face)
				else:
					continue
			else:
				faces1.append(face)
		faces = faces1

	if not (nx==ny==nz==None):  ## it will be slow when many non-plane exists.
		faces1 = []
		for face in faces:
			nx0,ny0,nz0 = facing_dir(face)
			if nx != None and nx != nx0:
				continue
			if ny != None and ny != ny0:
				continue
			if nz != None and nz != nz0:
				continue
			faces1.append(face)
		faces = faces1


	return faces

def check_file_name(file_name='_xydata.txt',sub_folder='', format='TXT'):
	## VER: 2014-07-07, v1.1

	path = ''
	file_name = real_dir(file_name)  ## file_name的最后一位不会是'/'
	if '/' in file_name:
		loc = file_name.rfind('/')
		path = file_name[:loc]
		file_name = file_name[loc+1:]
		sub_folder = ''

	if path in empty:
		path = get_work_dir()
		if sub_folder not in empty:
			path = path + '/' + sub_folder

##	print fnln(),'path=',path

	if not os.path.exists(path):
		os.makedirs(path)

	exist_files = get_files_in_dir(path,extension=format)

	loc = file_name.rfind('.')
	if loc > 0:
		file_name = file_name[:loc]

	loc = file_name.rfind('/')
	if loc > 0:
		file_name = file_name[loc + 1:]

	file_name = new_key(exist_files,file_name)
	file_name = path + '/' + file_name

	file_name = real_dir(file_name)
	file_name = file_name + '.' + totext(format).lower()

	return file_name

##def check_fix_extend(p1,p2,fix='_',refined_insts='_',force_create=False):
##	## VER: ('VER: 2012-07-15, v1.1')	## p1优先为master_inst, p2为slave_inst ???
##	## incomming, default: fix='_',refined_insts='_'   (下划线)
##
##	if type_of(fix) != 'STR':
##		raise Exception("parameter refined_insts should be a string, such as 'lam_A1,cell_A1'")
##
##	if type_of(refined_insts) != 'STR':
##		raise Exception("parameter refined_insts should be a string, such as 'lam_A1,cell_A1'")
##
##	p1 = check_inst(p1)
##	p2 = check_inst(p2)
##
##	## 只提供部分名字
##	partial = fix
##	if partial[0] == '-':	##中划线
##		partial = partial[1:]
##
##	print fnln(),'partial=',partial
##
##	if partial in p1.name and partial not in p2.name:	## _和-存在于inst的名字中的可能性很大
##		partial = p1.name
##	elif partial in p2.name and partial not in p1.name:
##		partial = p2.name
##	elif partial in ['m','master']:
##		partial = p1.name
##	elif partial in ['s','slave']:
##		partial = p2.name
##	elif partial == 'ms':
##		partail = p1.name + ',' + p2.name
##
##	print fnln(),'partial=',partial
##
####	raise Exception
##
##	if fix[0] == '-':
##		fix = '-' + partial
##	else:
##		fix = partial
##
##	if fix == '-' + p1.name:
##		fix = p2.name
##	elif fix == '-' + p2.name:
##		fix = p1.name
##	elif fix in ['both','all']:
##		fix = p1.name + ',' + p2.name
##	elif force_create == True:
##		fix = p1.name + ',' + p2.name
##
##	## 只提供部分名字
##	partial = refined_insts
##	if partial[0] == '-':
##		partial = partial[1:]
##
##	if partial in p1.name and partial not in p2.name:
##		partial = p1.name
##	elif partial in p2.name and partial not in p1.name:
##		partial = p2.name
##	elif partial in ['m','master']:
##		partial = p1.name
##	elif partial in ['s','slave']:
##		partial = p2.name
##	elif partial == 'ms':
##		partail = p1.name + ',' + p2.name
##
##	if refined_insts[0] == '-':
##		refined_insts = '-' + partial
##	else:
##		refined_insts = partial
##
##	if refined_insts == '-' + p1.name:
##		refined_insts = p2.name
##	elif refined_insts == '-' + p2.name:
##		refined_insts = p1.name
##	elif refined_insts in ['both','all']:
##		refined_insts = p1.name + ',' + p2.name
##
##	please_check
##	if p1.name in fix and p1.name in refined_insts:
##		refined_insts = modify_string(refined_insts,p1.name)	## fix优先
####		raise Exception('Confusing: ' + p1.name + 'in both fix and refined_insts')
##
##	if p2.name in fix and p2.name in refined_insts:
##		refined_insts = modify_string(refined_insts,p2.name)	## fix优先
####		raise Exception('Confusing: ' + p2.name + 'in both fix and refined_insts')
##
##	return fix, refined_insts

def check_func(func):
	## VER: 2017-03-08, v1.1

	if type_of(func) == 'STR':
		try:
			func = eval(func)
		except:
			raise Exception(str(ln()) + '******No such function name= ' + repr(func))

	if type_of(func) != 'FUNCTION':
		raise Exception(str(ln()) + '******No such function name= ' + repr(func))

	return func

def check_in_contact(contact_name,mfaces,sfaces,xEdges_m=[],xEdges_s=[],force_create=False):

	## VER: ('VER: 2012-07-15, v2.7')

	global contact_pairs, msfaces_determined, collect_edges

	add_to_process()

##	print fnln(),type_of(mfaces)
	master_inst = get_poi(mfaces)
	slave_inst = get_poi(sfaces)

##	raise Exception

	if 'collect_edges' not in globals().keys():
		collect_edges = None

	pair1 = {}
	pair1['name'] = contact_name
	if contact_name[5:9].lower() == 'tie_':   ##收集sfaces的ext_edges信息，并扣除xEdges_s。避免共用edge情况
		pair1['type'] = 'tie'
		if len(sfaces) > 100 and collect_edges == None:
			collect_edges = False

		if collect_edges in [True,None]:
			edges = exterior_edges(faces=sfaces,poi=slave_inst)
			if edges in empty:
				raise Exception('******Failed to get the exterior edges.')
			edges = unselect(edges,xEdges_s)
			pair1['slave_ext_edges'] = edges
		else:
			pair1['slave_ext_edges'] = []

	elif contact_name[5:9].lower() == 'int_':
		pair1['type'] = 'interact'
		pair1['slave_ext_edges'] = []

	pair1['master'] = master_inst.name
	pair1['slave'] = slave_inst.name
	pair1['instances'] = [master_inst.name, slave_inst.name]
	pair1['mfaces'] = mfaces
	pair1['sfaces'] = sfaces
##	print 'master_inst=',repr(master_inst)
	pair1['parts'] = [master_inst.partName,slave_inst.partName]
##	raise Exception

	if pair1['slave_ext_edges'] not in empty:
		create_set(slave_inst,objs=pair1['slave_ext_edges'],name=contact_name + '_slave_ext_edges')

	existed = False
	create = True
	if len(contact_pairs) > 0:
		print '===>'

		for pair in contact_pairs:
			if (master_inst.name in pair['instances']) and (slave_inst.name in pair['instances']):
				existed_faces = pair['mfaces'] + pair['sfaces']
				if have_common(mfaces,existed_faces) and have_common(sfaces,existed_faces):
					print fnln_fnln(),'******face pair existed. This',pair1['type'],'will not be created.'
					print ' '
					existed = True
					create = False
					break

	if not existed:
		contact_pairs.append(pair1)

		if pair1['type'] == 'tie':
			for pair in contact_pairs:
				if pair['type'] == 'tie':
					common_edges = get_common(pair1['slave_ext_edges'],pair['slave_ext_edges'])
					if len(common_edges) > 0 and pair1['master'] != pair['master']:
						faces = pair1['sfaces'] + pair['sfaces']
						setname = new_key(a.sets.keys(),'_Err_common_edges')
						create_set(objs=faces,name='_Err_common_edges')
						print ' '
						print fnln_fnln(),'******Warning: Two ties have common slave edges, high-lighted in setname=',setname,', slave_inst=',slave_inst.name
						print 'Ties names are:',"pair['name']=",pair['name'],", pair1['name']=",pair1['name']
						print ' '
						error_record('check_in_contact: common slave edges')

	msfaces_determined = False

	return create

def check_in_seeding(p,edges=[],force_seed=False,size=None,num=None,num1=''):
	## VER: 2010-02-09, v1.3

	global seeded_edges, seeding_seq

	p = check_part(p)

	if p.name not in seeded_edges.keys():
		seeded_edges[p.name]={}
		seeded_edges[p.name]['esize'] = []
		seeded_edges[p.name]['enum'] = []

	if p.name not in seeding_seq.keys():
		seeding_seq[p.name] = 1
	else:
		seeding_seq[p.name] += 1
	seq = seeding_seq[p.name]

	edges1 = []
	if size not in empty:
		size1 = str(size)
		loc1 = size1.find('.')
		if loc1 > 0:
			size1 = size1[:loc1] + 'p' + size1[loc1+1:]
		for edge in edges:
			if edge in seeded_edges[p.name]['enum']:
				if force_seed == False:
					create_set(p,objs=edge, name='_' + str(seq) + '_err_seed_size=' + size1,check_name=True)
					print fnln_fnln(),'******' + str(seq) + ': Confused seeding: One edge in ' + p.name + ' has been assigned enum seeding, but now re-assign esize seeding.'
					error_record('confuse_seed, seq=' + str(seq))
					continue
				else:
					print fnln_fnln(),'******' + str(seq) + ': force_seed=True, previous enum seeding will be replaced by esize seeding.'
					del_edges_seed(p,edge)
					edges2 = []
					for edge1 in seeded_edges[p.name]['enum']:
						if edge1 != edge:
							edges2.append(edge1)
					seeded_edges[p.name]['enum'] = edges2

			edges1.append(edge)

		if len(edges1) > 0:
			info = get_traceback()
			for i in range(len(info)):
				if type_of(info[i]) == 'STR' and 'seed' in info[i]:
					line_num = info[i - 1]
					break

			seeded_edges[p.name]['esize'] = seeded_edges[p.name]['esize'] + edges1
			if num1 == '':
				setname = '_' + str(seq) + '_seed_esize=' + size1 + '_' + str(line_num)
			else:
				setname = '_' + str(seq) + '_seed_enum=' + str(num1) + '_' + str(line_num)
			create_set(p,objs=edges1,name=setname,check_name=True)

	elif num not in empty:
		for edge in edges:
			if edge in seeded_edges[p.name]['esize']:
				if force_seed == False:
					create_set(p,objs=edge, name='_' + str(seq) + '_err_seed_num=' + str(num),check_name=True)
					print fnln_fnln(),'******' + str(seq) + ': Confused seeding: One edge in ' + p.name + ' has been assigned esize seeding, but now re-assign enum seeding.'
					error_record('confuse_seed, seq=' + str(seq))
					continue
				else:
					print fnln_fnln(),'******' + str(seq) + ': force_seed=True, previous esize seeding will be replaced by enum seeding.'
					del_edges_seed(p,edge)
					edges2 = []
					for edge1 in seeded_edges[p.name]['esize']:
						if edge1 != edge:
							edges2.append(edge1)
					seeded_edges[p.name]['enum'] = edges2

			edges1.append(edge)

		if len(edges1) > 0:
			info = get_traceback()
			for i in range(len(info)):
				if type_of(info[i]) == 'STR' and 'seed' in info[i]:
					line_num = info[i - 1]
					break

			seeded_edges[p.name]['enum'] = seeded_edges[p.name]['enum'] + edges1
			setname = '_' + str(seq) + '_seed_enum=' + str(num) + '_' + str(line_num)
			create_set(p,objs=edges1,name=setname,check_name=True)

	if len(edges1) == 0:
		print fnln_fnln(),'******Seeding failed. command#=',seq

	return edges1

def check_ia(inst):
	## VER: 2013-07-22, v1.0

	if inst in empty:   ## default to be assembly
		inst = a

	if inst == a:
		result = inst
	elif type_of(inst) == 'PINSTANCE':
		result = inst
	elif inst in a.instances.keys():
		result = a.instances[inst]
	else:
		raise Exception('**** inst or assembly is required.')

	return result

def check_inst(inst):

	## VER: ('VER: 2012-07-24, v1.6')

	if inst in a.instances.keys():
		inst = a.instances[inst]

	if type_of(inst) != 'PINSTANCE' or inst not in a.instances.values():
		print fnln_fnln(),'**type_of(inst)=',type_of(inst)
		raise Exception('*** Invalid instance. Instance is required.')

	return inst

def check_pia(p):
	## VER: 2015-09-06, v1.1

	if is_part(p):
		p = check_part(p)
	elif is_inst(p):
		p = check_inst(p)
	elif type_of(p) == 'ASSEMBLY':
		p = a
	else:
		raise Exception('*** part, inst, or assembly is required.')

	return p

def check_odb():
	## VER: ('VER: 2012-07-03, v1.0')

	try:
		globals()['odb']

		##存在odb变量，下面检查此odb是否彼odb.
		if globals()['odb'] != get_dpo():
			refresh()
	except:
		## 尚不存在odb变量
		refresh()

	return

def check_odb_inst(inst,no_empty=True,force_list=False):
	## VER: ('VER: 2015-12-09, v1.2')

##	>>> p = check_odb_inst('p00')
##	>>> p
##	session.openOdb(r'Z:/A0256-USM insert/BU_A0256_USM_finemesh_2_offset025.odb').rootAssembly.instances['green_A1']
##	>>>

	type1 = type_of(inst)   ##已经提供inst，检查确认。

	if type1 == 'ODBINSTANCE':
		if force_list == True:
			inst = [inst]
		return inst

	if type_of(inst) == 'STR':
		inst = inst.upper()
		if inst == 'P00':    ## 代名词
			inst = oa.instances.keys()[0]

	inst = real_odb_insts(inst)

	if force_list == False:
		if inst in empty and no_empty == True:
			raise Exception('******no such odb instance.')

		elif len(inst) == 1 and type1 == 'STR':  ##提供inst名，进行确认。
			inst = inst[0]

	return inst   ## inst object

check_odb_instance = check_odb_inst

def check_odb_part(list1,no_empty=True,force_list = False):

	## VER: ('VER: 2012-03-31, v1.0')

	parts = None
	if list1 in odb.parts.values():
		parts = list1
	elif list1 in odb.parts.keys():
		parts = odb.parts[list1]

	if parts not in empty:
		if force_list == True:
			parts = tolist(parts)
	else:
		parts = real_parts(list1)
		if force_list == False:
			if parts in empty and no_empty == True:
				raise Exception('******parts is empty or no such parts.')

	return parts

def check_part(part):
	## VER: ('VER: 2012-10-24, v1.7')

	if part in _m.parts.keys():
		part = _m.parts[part]

	if type_of(part) != 'PART' or part not in _m.parts.values():
		print fnln_fnln(),'**type_of(part)=',type_of(part)
		raise Exception('*** Invalid part, part is required.')

	return part

def check_pias(pois,no_empty=True,force_list=False):
	## VER: ('VER: 2016-03-23, v1.9')	## 结果为part, instance, or rootAssembly.
	## results: real_parts, or real instances. If pois is provided as assembly, will return assembly.

##	>>> check_pias('case')
##	mdb.models['Model-1'].parts['case']
##	>>> check_pias('case_A1')
##	mdb.models['Model-1'].rootAssembly.instances['case_A1']
##	>>> check_pias(a)
##	mdb.models['Model-1'].rootAssembly
##	>>>

	if is_part(pois):
		pois = [check_part(pois)]
	elif is_instance(pois):
		pois = [check_inst(pois)]
	elif type_of(pois) == 'ASSEMBLY':
		pois = [a]
	else:
		pois0 = real_parts(pois)
		if pois0 in empty:
			pois0 = real_insts(pois)
		pois = pois0

	if no_empty == True and pois in empty:
		raise Exception('****** poi is empty or no such poi.')

	if force_list == False:
		pois = pois[0]

##	type1 = type_of(pois)   ##已经提供pois，检查确认。
##
##	if type1 == 'STR':
##		if pois in _m.parts.keys():
##			pois = _m.parts[pois]
##		elif pois in a.instances.keys():
##			pois = a.instances[pois]
##		type1 = type_of(pois)
##
##	if type1 in ['PART','PINSTANCE','ASSEMBLY']:
##		if force_list == True:
##			pois = [pois]
##		return pois
##
##	poi = real_parts(pois)
##	if poi in empty:
##		poi = real_insts(pois)
##
##	if force_list == False:
##		if poi in empty and no_empty == True:
##			raise Exception('****** poi is empty or no such poi.')
##
##		elif len(poi) == 1 and type1 == 'STR':
##			poi = poi[0]

	return pois

def check_poi(poi):
	## VER: 2014-01-13, v1.0
	## either part or instance, not assembly
	## reference: get_poi(), check_pia()

	poi = check_pias(poi)
	if type_of(poi) not in ['PART','PINSTANCE']:
		raise Exception('*** part or instance is required.')

	return poi

def check_radius_ndir(obj):
	## VER: 2014-07-15, v1.0

	curvature = get_curvature(obj)
	radius = get_radius(obj)

	if type_of(obj) == 'edges':
		dir1 = edge_dir(obj)
		shape = edge_shape(obj)
	elif type_of(obj) == 'faces':
		dir1 = face_ndir(obj)
		shape = face_shape(obj)

	print ' '
	print 'curvature=',curvature
	print ''
	print 'radius=',radius
	print 'edir or ndir=',dir1
	print 'shape=',shape

	return


def check_script_file(name):
	## VER: 2017-07-28, v1.5
	## do not create a new cae with the name
	## inp_file_title is obtained at the begining through get_inp_file_title() at main procedure

	global script_file_full, inp_file_title

	if name.endswith('.py.py'):
		name = name[:-3]

	if name[-3:] != '.py':
		name = name + '.py'

##	script_file = get_file_name()
	script_file_full = get_file_name()
	inp_file_title = script_file_full[:-3]

##	if script_file != name:
	if name not in script_file_full:
		print ' '
		print fnln_fnln(),'Script file = ',script_file_full
		print fnln_fnln(),'In check_script_file(),name =',name

		raise Exception('*** file name is not same as assigned name in main')

##	script_file_full = name

	global_var_initiate()

	return name

def check_set(set1,pia=None):
	## VER: 2014-07-01, v1.0, the returned set is a set-like region

	if type_of(set1) in ['PART','PINSTANCE','ASSEMBLY']:
		set1,pia = pia, set1

	if type_of(set1) == 'SET':
		return set1
	elif type_of(set1) != 'STR':
		raise Exception('*** set name is required.')

	if pia not in empty:
		pia = check_pias(pia)

	if pia in empty:
		pia = a

	if type_of(pia) == 'PART':
		if set1 not in pia.sets.keys():
			raise Exception('*** No such set name ' + set1 + ' in ' + pia.name)
		set1 = pia.sets[set1]
	else:
		if set1 in pia.sets.keys() :
			set1 = pia.sets[set1]
		elif set1 in a.sets.keys():
			set1 = a.sets[set1]
		elif set1 in a.allInternalSets.keys():
			set1 = a.allInternalSets[set1]
		else:
			raise Exception('*** fail to get the set region.')

	return set1


def check_sketch(sketch):
	## VER: 2014-09-08, v1.5  Result: 不再含有ndir and offset信息。dict类型的sketch会转化为纯sketch。
	## return sketch object

	if sketch in _m.sketches.values():
		sketch1 = sketch
	elif sketch in _m.sketches.keys():
		sketch1 = _m.sketches[sketch]
	else:
		if type_of(sketch) == 'DICT' and 'sketch' in sketch.keys():		## 这种sketch是create_part_sketch()的返回值
			sketch1 = sketch['sketch']
		else:
			print fnln_fnln(), '*** sketch=',sketch
			raise Exception('******No such sketch =' + totext(sketch))

	return sketch1   ## 不再含有ndir and offset信息。


def check_loc(loc1,loc2,base=None):
	## VER: 2014-01-09, v1.1

	float1 = get_float_num(loc1)
	float2 = get_float_num(loc2)

	if type_of(base) == 'STR':
		base = base.lower()

	if float1 > float2:
		loc1,loc2 = loc2,loc1

	loc = loc1
	if abs(loc1 - loc2) > 1e-3:   ## gap greater than 1um
		if base == 'min' and loc2 < loc1:
			loc = loc2
		elif base == 'max' and loc2 > loc1:
			loc = loc2

	return loc

def check_space(space1,space2):
	## VER: 2014-05-05, v1.2

	x1,x2,y1,y2,z1,z2 = space1
	x10,x20,y10,y20,z10,z20 = space2

	x1,x2 = _sort(x1,x2)
	y1,y2 = _sort(y1,y2)
	z1,z2 = _sort(z1,z2)

	x10,x20 = _sort(x10,x20)
	y10,y20 = _sort(y10,y20)
	z10,z20 = _sort(z10,z20)

	x1 = check_loc(x1,x10,base='min')
	x2 = check_loc(x2,x20,base='max')
	y1 = check_loc(y1,y10,base='min')   ## consider edges of a sphere and faces of a sphere
	y2 = check_loc(y2,y20,base='max')
	z1 = check_loc(z1,z10,base='min')
	z2 = check_loc(z2,z20,base='max')

	return x1,x2,y1,y2,z1,z2

def is_step(step1):
	## VER: 2016-10-28, v1.0

	try:
		name = check_step(step1)
		result = True
	except:
		result = False

	return result

def _step(step1):
	## VER: 2016-10-29, v1.0

##	>>> _step(1).procedureType
##	HEAT_TRANSFER
##	>>>

	step1 = check_step(step1)
	step1 = _m.steps[step1]

	return step1

def check_step(step='step1'):
	## VER: ('VER: 2016-04-01, v2.5')	## 假如step不存在，不会自动创建该step
	## steps的key是按照创建的顺序排列的，不是按照名称来排序的。
	## for mdb, not for odb
	## reference: check_odb_step()
	## for odb, use: get_step_frame_time()

	## Example
##	>>> _m.steps.keys()
##	['Initial', 'ALE', 'step1', 'step2']
##	>>>
##	>>> check_step('step1')  ## step1 existed in _m.steps.keys()
##	'step1'
##	>>> check_step('step2')
##	'step2'

	if type_of(step) == 'STR':
		if step in ['first','last','initial'] and _m.steps.keys() not in empty:
			steps = _m.steps.keys()
			if step == 'initial':
				if steps[0] == 'Initial':
					return 'Initial'
				else:
					raise Exception('No Initial step in the model.')

			if step == 'first':
				if steps[0] != 'Initial':
					return steps[0]
				else:
					if len(steps) > 1:
						return steps[1]
					else:
						raise Exception('First step is not defined.')

			if step == 'last':
				if steps[-1] != 'Initial':
					return steps[-1]
				else:
					raise Exception('Last step is not defined.')

		elif step not in _m.steps.keys():  ## steps的key是按照创建顺序排列的，而不是按照字母顺序排列的。
			if len(_m.steps) == 1 and _m.steps.keys()[0] == 'Initial':
				raise Exception('*** No step created yet.')

			steps_seq = get_steps_sequence()  ## get the creating sequence
			if step == 'step1' and len(steps_seq) >= 2:
				step = _m.steps.keys()[1]
			elif step == 'step2' and len(steps_seq) >= 3:
				step = _m.steps.keys()[2]
			elif step == 'step3' and len(steps_seq) >= 4:
				step = _m.steps.keys()[3]
			elif step == 'step4' and len(steps_seq) >= 5:
				step = _m.steps.keys()[4]
			else:
				raise Exception(step + ' is not defined.')

	elif step in _m.steps.values():
		step = step.name

	elif type_of(step) == 'INT':
		stepnum = step
		if abs(stepnum) > len(_m.steps):
			raise Exception('*** No enough steps.')

		if stepnum == 0:
			step = _m.steps.keys()[0]
		elif stepnum > 0:
			if stepnum < len(_m.steps):
				step = _m.steps.keys()[stepnum ]  ## check_step(1)的结果是第一个载荷步，不是Initial
			elif stepnum == len(_m.steps):
				step = _m.steps.keys()[stepnum - 1]
			else:
				raise Exception('*** stepnum exceeds current step numbers.')

		elif stepnum < 0:
			step = _m.steps.keys()[stepnum]

	return step	## result is the step name

def check_stress(variable='Mises'):

	## VER: ('VER: 2012-05-04, v1.1')

	vpnow = get_vpnow()
	vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))

	print 'variable=',variable
	plot_variable(variable)

	result = edel()

	print 'Now show the original contour by plot(0)...'
	plot(0)
	print ' '

	return	result

def check_surface(surf1,poi=None):
	## VER: 2014-08-26, v1.0

	if is_part(poi):
		poi = check_part(poi)
	else:
		poi = a

	if surf1 in poi.surfaces.keys():
		surf1 = poi.surfaces[surf1]

	if surf1 not in poi.surfaces.values():
		raise Exception('*** Error surface.')

	return surf1  ## surface object

def check_values(*values):
	## VER: 2014-08-11, v1.2
	## 位置精确到小数点第5位。但用x0 = int(x0*1e6)/1e6 形式更好更准（坐标）

	values0 = values
	type1 = type_of(values)
	values = tolist(values)
	if type_of(values) == 'LIST':
		list1 = []
		for i in range(len(values)):
			value1 = values[i]
			if type_of(value1) in numerics:
				value1 = round(values[i],6)
				num1 = get_float_num(value1)
				if num1 >= 5:
					value5 = round(value1,5)	;please_check   ## 5, or 6 ?
					value4 = round(value1,4)

					if get_float_num(value4) in [0,1,2,3]:	## get_flaot_num(317.0) = 0
						list1.append(value4)	;please_check
					else:
						list1.append(value5)	;please_check
				else:
					list1.append(value1)
			else:
				list1.append(value1)

	if type1 in numerics:
		result = list1[0]
	elif values in empty:
		result = values0
	elif type1 == 'TUPLE':
		result = totuple(list1)
	else:
		result = list1

	return result


def check_viewport(viewport):
	## VER: 2014-04-18, v1.3

	if type_of(viewport) == 'STR':
		if viewport not in session.viewports.keys():
			raise Exception('**** Error viewport_name = ' + viewport)
		viewport = session.viewports[viewport]

	if type_of(viewport) != 'VIEWPORT' or viewport not in session.viewports.values():
		raise Exception('**** viewport not exists. viewport = ' + repr(viewport))

	dpo = viewport.displayedObject
	if type_of(dpo) in ['PART','ASSEMBLY','sketch']:
		viewport_type = 'MDB'
	elif type_of(dpo) == 'ODB':
		viewport_type = 'ODB'
	elif type_of(dpo) == 'XYPLOT':
		viewport_type = 'XYPLOT'
	else:
		if dpo == None:
			viewport_type = 'empty'
		else:
			viewport_type = type_of(viewport)

	return viewport_type, viewport

def check_xyplot(name):
	## VER: 2014-08-08, v1.0

	if type_of(name) == 'STR':
		if name in session.xyPlots.keys():
			xyplot = session.xyPlots[name]
		else:
			xyplot = session.XYPlot(name)
	elif name in session.xyPlots.values():
		xyplot = name
	else:
		raise Exception('*** xyplot name is required.')

	return xyplot

def circular_center(edge):
	## VER: 2014-07-20, v2.4

	if type_of(edge) != 'edges':
		raise Exception('****** An edge is required.')

	poi = get_poi(edge)

	ndir,offset = ndir_and_offset_of_curve(edge)
	if ndir not in ['x','y','z']:
		raise Exception('ndir of curve is not x,y or z. Fail to get the circular center.')

	sketch1 = edges_to_sketch(edge,ndir=ndir,offset=offset)
	center = sketch1['sketch'].geometry[2].getVertices()[-1].coords
	center = convert_loc(center,ndir=ndir,offset=offset)
	del _m.sketches[sketch1['name']]	## 临时的sketch

	center = round_loc(center)

	return center

function_labels['circular_divide'] = 'divide','partition','circular','radial'
def circular_divide(p,ndir, center=(),D=16, radius=None, cells=None, ref_face=None,faces=None):
	## VER: ('VER: 2017-08-11, v2.6')	## 应该在move_part之前进行。
	## reference: divide_by_face()

	## cut or divide均是逆着：若ndir='x',则center的x值应该取最大值。其他方向也如此。
	## Example:
	## circular_divide(anvil,ndir='x',x=x1,y=0,z=0,D=shaft_D1 + 2*alum_thick)
	## 必须保证在center的地方可以选择到面，或者有面。

	## 例如，仅仅circular_divide 3D部件中的某些面（对cell不divide)：
	## circular_divide(nib,ndir='y',faces=faces, radius=3.5)

	## 下面的例子对3D部件的cell也divide了。
	## circular_divide(nib,ndir='y',radius=3.5)

	## 注意：每对一个cell进行partition之后，其他未被partition的cell和face的index会重新分配，假如定义了一个变量指向了一个cell，则之后指向会改变。


	get_current_model()

	p = check_part(p)

	if ndir not in ['x','y','z']:
		raise Exception('*** axial dir should be in x, y, or z')

	x1,x2,y1,y2,z1,z2 = poi_space(p)
	if ndir == 'x':
		offset = x2 + 10
	elif ndir == 'y':
		offset = y2 + 10
	elif ndir == 'z':
		offset = z2

	datum_plane, right_edge = datum_plane_and_right_axis(p, offset=offset, ndir=ndir)
	s = datum_plane_to_blank_sketch(datum_plane, right_edge=right_edge)
##	print s.name

##	side = SIDE1
##	if ndir == 'y':
##		side = SIDE2   ## 有时会出错，即使ndir='y'
##	else:
##		side = SIDE1

	if radius in empty:
		radius = D/2.0

	objs = get_real_input(cells, faces)
	if type_of(objs) == 'STR':
		objs = set2objs(objs, p)
	objs = tolist(objs)
	if objs in empty:
		if len(p.cells) > 0:
			objs = p.cells   ## 优先取cells
		elif len(p.faces) > 0:
			objs = p.faces

	if objs in empty:
		raise Exception('*** cells or faces are required to be partition.')

	obj_type = type_of(objs[0])
##	print fnln(),obj_type
##	raise Exception

	if center in empty:
		if ref_face in empty:
			faces1 = face_select(p,ndir='cylindrical',diameter='bigger')  ## 如果不给定参考圆柱面，那么选择半径最大的那个圆柱面
			if faces1 in empty:
				faces1 = face_select(p,ndir='conical')

			if faces1 not in empty:
				ref_face = faces1[0]
			else:
				raise Exception('*** no cylindrical face, please specify the radial cut center, i.e., a point that axis pass through.')

	if ref_face not in empty:
		ndir0 = face_ndir(ref_face)
		if ndir0 not in ['cylindrical', 'conical']:
			raise Exception('*** a cylindrical face is required.')
		else:
			center,vector,axis0 = center_axis_of_cylind_face(ref_face)

	if center in empty:
		raise Exception('*** fail to get the axis center')

	center = list(center)

	print fnln(),'radius=',radius
	print fnln(),'center=',center  ## center在ndir方向的坐标值不要紧。
##	raise Exception

	## conver 3D points to sketch points
	x0,y0 = threeD_to_sketch_points(center,ndir)
	s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + radius, y0))

	faces0 = tolist(p.faces)
	try:
		p.ShellExtrude(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=SIDE1,
		    sketchOrientation=RIGHT, sketch=s, depth=3.0, flipExtrudeDirection=OFF)
	except:
		p.ShellExtrude(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=SIDE2,
		    sketchOrientation=RIGHT, sketch=s, depth=3.0, flipExtrudeDirection=OFF)

##	raise Exception

	face1 = unselect(p.faces, faces0)
	face1 = face1[0]   ## face1 index will be changed after partition.
	face_pointOn = face1.pointOn[0]

	## 可以在这里停止，然后界面下操作partition cell by extend face

	pointOns = []
	for obj in objs:
		loc = obj.pointOn[0]
		pointOns.append(loc)

##	print pointOns
##	print obj_type
##	raise Exception

	num = 0
	for i in range(len(pointOns)):
		loc = pointOns[i]
		face1 = p.faces.findAt(coordinates=face_pointOn)
		if obj_type == 'cells':
			try:
				p.PartitionCellByExtendFace(extendFace=face1, cells=p.cells.findAt((loc, )))
				p.regenerate()
				num = num + 1
			except:
				pass
		elif obj_type == 'faces':
			try:
				p.PartitionFaceByExtendFace(extendFace=face1, faces=p.faces.findAt((loc, )))
				p.regenerate()
				num = num + 1
			except:
				pass

	print fnln(),'--->',num,obj_type, 'are circular divided.'

##	raise Exception
##	if obj_type == 'cells':
##		try:
##			p.PartitionCellByExtendFace(extendFace=face1, cells=list2sequence(objs))
##			print '--->',p.name,'was divided cells by extend face'
##		except:
##			print fnln(),'***Fail to circular divide the cells.'
##			pass
##	elif obj_type == 'faces':
##		try:
##			p.PartitionFaceByExtendFace(extendFace=face1, faces=list2sequence(objs))
##			print '--->',p.name,'was divided cells by extend face'
##			print fnln(),'***Fail to circular divide the faces.'
##		except:
##			pass

	face2 = face_at(p,loc=face_pointOn)
	p.RemoveFaces(faceList = tolist(face2), deleteCells=False)
	p.regenerate()

	get_current_model()

	return


def circular_divide1(p,ndir, center=(),x=None,y=None,z=None,D=16, radius=None, cells=None, faces=None, only_face=False):
	## VER: ('VER: 2013-09-23, v2.1')	## 应该在move_part之前进行。
	## cut or divide均是逆着：若ndir='x',则center的x值应该取最大值。其他方向也如此。
	## Example:
	## circular_divide(anvil,ndir='x',x=x1,y=0,z=0,D=shaft_D1 + 2*alum_thick)
	## 必须保证在center的地方可以选择到面，或者有面。

	p = check_part(p)

	if ndir not in ['x','y','z']:
		raise Exception('*** axial dir should be in x, y, or z')

	if radius in empty:
		radius = D/2

	if cells in empty:
		cells = tolist(p.cells)
	elif type_of(cells) == 'STR' and cells not in empty:
		cells = set2objs(cells,p)

	if len(p.cells) == 0:
		only_face = True

	if is_location(center) == False:
		if center in empty:
			center = [None,None,None]
		else:
			center = tolist(center)

		if len(center) != 3:
			raise Exception('*** x,y,z coordinations are required.')

		x,y,z = real_xyz(p,x,y,z)
		if center[0] in empty:
			if type_of(x) in numerics:
				center[0] = x
			else:
				center[0] = 0

		if center[1] in empty:
			if type_of(y) in numerics:
				center[1] = y
			else:
				center[1] = 0

		if center[2] in empty:
			if type_of(z) in numerics:
				center[2] = z
			else:
				center[2] = 0

	print 'center=',center
	x,y,z = center

	raise Exception

	## 已经确定具体的x,y,z值
	faces = tolist(faces)
	if faces in empty:
		if 'x' in ndir:
			faces = faces_of_cut(p,x=x,y=(y + radius, y - radius), z=(z + radius, z - radius))
		elif 'y' in ndir:
			faces = faces_of_cut(p,x=(x + radius, x - radius), y=y, z=(z + radius, z - radius))
		elif 'z' in ndir:
			faces = faces_of_cut(p,x=(x + radius, x - radius), y=(y + radius, y - radius), z=z)

	if len(faces) == 0:
		raise Exception('No faces selected to divide.')

	if ndir == 'x':
		offset = faces[0].pointOn[0][0]
		x = offset
	elif ndir == 'y':
		offset = faces[0].pointOn[0][1]
		y = offset
	elif ndir == 'z':
		offset = faces[0].pointOn[0][2]
		z = offset

	center = (x,y,z)
	print 'center=',center
	normal = faces[0].getNormal()

##	raise Exception

	## divide_dir的方向不影响到对面的剖分
	divide_dir = -normal[0],-normal[1],-normal[2]   ## divide_dir与normal的方向相反。逆着面的法向剖分
	divide_dir = create_datum_axis_by_2points(p,divide_dir)
	## A straight Edge or DatumAxis object specifying the extrude divide_dir. line must be perpendicular to the plane formed by edges
	## 例如：divide_dir= ({'direction': (1.0, 0.0, 0.0), 'pointOn': (0.5, 0.0, 0.0)})  ## type_of(divide_dir) = 'DATUMAXIS'

	## conver 3D points to sketch points
	x0,y0 = threeD_to_sketch_points(center,ndir)

	## create blank sketch
	sketch1 = create_part_sketch(p,ndir=ndir,offset=offset,name='temp_sketch1')

	s = sketch1['sketch']
	datum_plane1 = sketch1['datum_plane']
	right_edge1 = sketch1['right_edge']

	## draw lines
	s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + radius, y0))

	## face divide
	try:
		p.PartitionFaceBySketch(sketchUpEdge=right_edge1, faces=faces, sketch=s)
		print '--->faces are circular divided.'
	except:
		print '** No face was divided.'   ## 可能已经存在该线

##	raise Exception
	edges0 = faces_to_edges(faces)
	edges0 = edge_select(p,edges=edges0, radius=radius)
	if len(edges0) == 0:
		print fnln(),'*** No edges to make the partition.'
		return

	if only_face == False:  ## divide cells also
		## find edges
		if 'x' in ndir:
			edges = edge_select(p,x=x, y=(y + radius, y - radius), z=(z + radius, z - radius), radius = radius)
		elif 'y' in ndir:
			edges = edge_select(p,x=(x + radius+0.1, x - radius-0.1), y=y, z=(z + radius+0.1, z - radius-0.1), radius = radius)
		elif 'z' in ndir:
			edges = edge_select(p,x=(x + radius, x - radius), y=(y + radius, y - radius), z=z, radius = radius)

		## circular divide	对体的剖分与sketch无关（与right edge无关)
		result = None
		if len(edges) == 0:
			print '*** No edges was found for the partition'

##		raise Exception

		try:
			result = p.PartitionCellByExtrudeEdge(line=divide_dir, cells=cells, edges=edges, sense=FORWARD)
			print 'divide_direction =', '-' + ndir[-1]
			## FORWARD表示沿着divide_dir的方向剖分，而不是坐标轴的正方向。
			## 如果出错，则可能是从最小值端开始剖分。应该从最大值端开始剖分。

		except:
			if 'x' in ndir:
				edges1 = edge_select(p,x=x+0.1)  ##从最小值端开始剖分
			elif 'y' in ndir:
				edges1 = edge_select(p,y=y+0.1)
			elif 'z' in ndir:
				edges1 = edge_select(p,z=z+0.1)

##			raise Exception

			if edges1 not in empty:
				edge1 = edges1[0]
				try:
					result = p.PartitionCellBySweepEdge(sweepPath=edge1, cells=cells, edges=edges)
					print 'divide_direction =', '+' + ndir[-1]
				except:
					print fnln(),'*** Not divided.'
##					raise Exception

		if result not in empty:
			print '--->Performed circular divide for',p.name
##		raise Exception

	return

def circular_space_of_face(face):
	## 2013-9-12, v1.1  获取完整的圆柱面的空间。
	## use objs_space() instead

	if type_of(face) != 'faces':
		raise Exception('face is required.')

	radius = get_radius(face)
	space = objs_space(face)

	if is_number(radius) == False:
		return space

	vector,vector1,center = center_axis_of_cylind_face(face)
	if vector not in xdir and vector not in ydir and vector not in zdir:
		return space

	x1,y1,z1 = center
##	if vector in xdir:
	if vector == 'x':
		space = space[0],space[1],y1 - radius, y1 + radius, z1 - radius, z1 + radius
##	elif vector in ydir:
	elif vector == 'y':
		space = x1 - radius, x1 + radius, space[2],space[3], z1 - radius, z1 + radius
##	elif vector in zdir:
	elif vector == 'z':
		space = x1 - radius, x1 + radius, y1 - radius, y1 + radius, space[4],space[5]

	return space

def circular_space_of_faces(faces):
	## VER: 2012-12-20, v1.0

	faces = tolist(faces)
	xmin,xmax,ymin,ymax,zmin,zmax = objs_space(faces)

	if is_cylind_faces(faces) == False:
		return xmin,xmax,ymin,ymax,zmin,zmax
	else:
		axises = []
		for face in faces:
			center,vector,axis = center_axis_of_cylind_face(face)
			if axis not in axises:
				axises.append(axis)

				x1,x2,y1,y2,z1,z2 = circular_space_of_face(face)
				xmin = min(xmin,x1)
				xmax = max(xmax,x2)
				ymin = min(ymin,y1)
				ymax = max(ymax,y2)
				zmin = min(zmin,z1)
				zmax = max(zmax,z2)

	return xmin,xmax,ymin,ymax,zmin,zmax

def clear_datum_axis(*poa):
	## VER: 2014-06-26, v1.0
	## 可能会把某个instance给删除了。

	get_current_model()

	poa = tolist(poa)
	if poa in empty:
		poa = _m.parts.values()
		poa.append(a)
	else:
		poa = check_pias(poa,force_list=True)

	for p in poa:
		if type_of(p) == 'PINSTANCE':
			p = p.part

		features = p.features.values()
		features.reverse()

		for feature in features:
			obj = feature_to_obj(feature)
			if type_of(obj) == 'DATUMAXIS':
				try:
					p.deleteFeatures((feature.name, ))
				except:
					pass

	a.regenerate()

	return

def clear_datum_points(*poa):
	## VER: 2011-11-29, v1.0

	poa = tolist(poa)
	if poa in empty:
		poa = _m.parts.values()
		poa.append(a)
	else:
		poa = check_pias(poa,force_list=True)

	for p in poa:
		if type_of(p) == 'PINSTANCE':
			p = p.part

		features = p.features.values()
		features.reverse()

		ids = []
		for feature in features:
			if 'Datum pt-' in feature.name:
				ids.append(feature.name)
			else:
				break

		if len(ids) > 0:
			del_features(p,key_list=ids)

	a.regenerate()

	return

def clear_empty_sets(*parts):
	## VER: 2011-12-12, v1.0, 包括section assignment。在进行诸如hex_cut，bias_cut等之后，可能会存在空的set。

	parts = tolist(parts)
	parts = real_parts(parts)

	for part in parts:
		for setname in part.sets.keys():
			objs = set2objs(part,setname)
			if objs in empty:
				del part.sets[setname]
				print fnln_fnln(),'Setname',setname,'deleted.'

		for section in part.sectionAssignments:
			sectionName = section.sectionName
			setname = section.region[0]
			cells0 = set2objs(part,setname,internal=True)	## 原有材料
			if cells0 in empty:
				i = get_sequence_index(part.sectionAssignments,section)
				del part.sectionAssignments[i]
				print fnln_fnln(),'Original material section',sectionName,'deleted.'

	return

def clear_model_settings(prefield=True,BC=True,load=True,tie=True,interact=True,steps=True):
	## VER: 2015-01-15, v1.4
	## sets and surfaces will be kept if created based on instance mesh, otherwise, will be deleted.
	## caller: import_initial_state()

	if prefield == True:
		for name in _m.predefinedFields.keys():
			del _m.predefinedFields[name]

	if BC == True:
		for name in _m.boundaryConditions.keys():	## step related
			del _m.boundaryConditions[name]

	if load == True:
		for name in _m.loads.keys():	## step related
			del _m.loads[name]

	if tie == True:
		for name in _m.constraints.keys():	## step related
			del _m.constraints[name]

	if interact == True:
		for name in _m.interactions.keys():   ## step related
			del _m.interactions[name]

	if steps == True:
		for step in _m.steps.keys():
			if step != 'Initial':
				del _m.steps[step]

	for inst in a.instances.values():
		shape1 = part_shape(inst)[1]
		sets = []
		for set1 in inst.sets.keys():
			type1 = type_of_set(inst,set1)
			if shape1.endswith('solid') and type1 not in ['cells','elements']:
				sets.append(set1)
			elif shape1.endswith('shell') and type1 not in [ 'faces','elements']:
				sets.append(set1)
			elif type1 == 'vertices':
				sets.append(set1)

		if sets not in empty:
			part1 = inst.part
			part1.deleteSets(setNames=tuple(sets))

	if a.sets.keys() not in empty:
		a.deleteSets(setNames=totuple(a.sets.keys()))
		a.regenerate()

	return

def remove_repeated_items(list1):
	## VER: 2012-12-26, v1.0

	## Example:
##	nodals = remove_repeated_items(nodals)
##	integration_points = remove_repeated_items(integration_points)


	type1 = type_of(list1)
	if type1 not in ['TUPLE','LIST']:
		raise Exception('tuple or list is required.')

	newlist = []
	for item in list1:
		if item not in newlist:
			newlist.append(item)

	if type1 == 'TUPLE':
		list1 = tuple(newlist)
	else:
		list1 = newlist

	return list1

def clear():
	## VER: 2016-08-28, v1.0

	Mdb()
	refresh()

	return

def clear_user_data():
	## VER: 2013-11-14, v1.0

	_m.setValues(description='')

	return

def clear_xyDataObjects():

	## VER: ('VER: 2012-06-05, v1.0')

	for key in session.xyDataObjects.keys():
		del session.xyDataObjects[key]

	print '--->Now session.xyDataObjects.keys() is empty.'

	return

def clear_xyPlots():

	## VER: ('VER: 2012-05-28, v1.0')

	for key in session.xyPlots.keys():
		del session.xyPlots[key]

	print '--->Now session.xyPlots.keys() is empty.'

	return

def close_all_odbs():
	## VER: ('VER: 2012-05-08, v1.0')

	if len(session.odbs) > 0:
		for odbfile in session.odbs.keys():
			session.odbs[odbfile].close()

		print '--->All odbs are closed.'

	return

close_odbs = close_all_odbs

def close_odb(odb_file):
	## VER: 2013-05-03, v1.4

	if type_of(odb_file) != 'STR':
		raise Exception('**** odb_file name is required.')

	if odb_file[-4:] != '.odb':
		odb_file = odb_file + '.odb'

	if len(session.odbs) > 0:
		for file_name in session.odbs.keys():
			if file_name.count(odb_file) > 0:
				session.odbs[file_name].close()
				break

##	print odb_file,'is closed.'
##	print ' '

	return

def coaxial(move_face,fix_face,flip=ON):
	## VER: 2012-11-16, v1.1. move_face类似于source，fix_face类似于target。慎用flip=OFF

	move_face = check_entity(move_face,'faces')
	fix_face = check_entity(fix_face,'faces')

	poi1 = get_poi(move_face)
	poi2 = get_poi(fix_face)
	if poi1 == poi2:
		raise Exception('move_face and fix_face cannot come from the same instance.')

	poi1.ConvertConstraints()
	poi2.ConvertConstraints()

	try:
		a.Coaxial(movableAxis=move_face,fixedAxis=fix_face,flip=flip)
	except:
		a.Coaxial(movableAxis=fix_face,fixedAxis=move_face,flip=flip)

	poi1.ConvertConstraints()
	poi2.ConvertConstraints()

	print 'coaxial: 根据动静关系,动=',poi1.name,',静=',poi2.name
	print '如果不满意，可以改变move_face和fix_face的位置，或用move_instance()来实现'

	return

def collect_new_key(base_dict, dict2):
	## VER: ('VER: 2012-07-14, v1.0')

	if type_of(base_dict) != 'DICT':
		raise Exception('base_dict is required.')

	if type_of(dict2) != 'DICT':
		raise Exception('One dict is required to collect info from.')

	for key1 in dict2.keys():
		if key1 not in base_dict.keys():
			base_dict[key1] = dict2[key1]

	return base_dict

def collect_odb_insts_space(odb_file_title=None):

	## VER: ('VER: 2012-04-26, v1.1')

	global insts_space, odb_insts_space

	vpnow = get_vpnow()
	if odb_file_title in empty:
		if type_of(vpnow.displayedObject) == 'ODB':
			odb_file_title = vpnow.displayedObject.analysisTitle
		elif 'odb_file_title' in globals().keys():
			odb_file_title = globals()['odb_file_title']

	if type_of(odb_file_title) == 'ODB':
		odb_file_title = odb_file_title.analysisTitle

	if type_of(odb_file_title) != 'STR':
		raise Exception('odb or odb_file_title is required.')

##	refresh(match_cae_odb=True)
	refresh()
	update_insts_space(renew=True)

	odb_insts_space = {}
	odb_insts_space['odb_file_title'] = odb_file_title
	for inst_name,value in insts_space.items():
		if inst_name != 'cae_file_title':
			odb_insts_space[inst_name.upper()] = value

	print fnln_fnln(),'--->Updated spaces for all odb instances.'

	plot(odb_file_title + '.odb')

	return

def collect_results(stepname, *lists):
	## VER: 2013-05-09, v1.1
	## Example:
	## collect_results('step1',['model','U'],['Steel_EN24T','Mises','S1'],['H15F','Mises','S1'])

	if stepname not in odb.steps.keys():
		raise Exception('**** Error stepname=' + repr(stepname))

	output_list = []

	for list1 in lists:
		if type_of(list1) not in ['LIST','TUPLE']:
			continue

		name = list1[0]
		if type_of(name) == 'ODBINSTANCE':
			name = name.name

		if type_of(name) == 'STR':
			name = name.upper()
			for variable in list1[1:]:
				if type_of(variable) in numerics:
					result = [name,variable]
				else:
					if name in oa.instances.keys():
						result = get_result(stepname=stepname, instance=name,variable=variable)
					else:
						result = get_result(stepname=stepname, setname=name,variable=variable)
				output_list = output_list + result

	return output_list

function_labels['collect_and_write_results'] = 'output','file','postprocessing','txt','summary','res2file','post'
def collect_and_write_results(list1,steps=()):
	## VER: 2017-07-28, v2.5	使用tuple的好处是结果顺序与要求的顺序一致。
	## Example:

##	global res
##	res = ('var','mid_gap','case_round1','interference','pressure'),('case_A1','S1','S12','U1'),('mid_A1','S1','U1'),('nib_A1','U1')
##	## job完成后，
##	## post()
##	## res2file(res)

##	_results_disp = {'punch_A1':('S1','Mises','U3')}
##	collect_and_write_results(_results_disp)

##	global res
##	res = ('name+data','pressure','pad_length','pad_width','pad2short1','pad2long','silicone_thick'), ('LAM_A1','U','S1'), ('mat_silic2','Mises','S1')
##	file1 = script_path() + '_res.py'
##	line_print(file1,'res =',res)
##	line_print(file1,'## current inp =',inp_file_title)
##	line_print(file1,' ')

##	dict4 = {'vars':('inter_bot','inter_top','force'), 'surf_pocketint_int3':('S1','U2'),'carbide_A1':'U2'}
##	dict4 = ('vars','inter_bot','inter_top','force'),('surf_pocketint_int3','S1','U2'),('carbide_A1','U2')
##	res2file(dict4,steps=[1,2])

##	create_job()
##	submit()
##	wait()
##	collect_and_write_results('pressing',['model','U'],['ANVIL_A1','Mises','PEEQ','S1'], ['BLANK_A1','Mises','PEEQ','S1'])

##	Example:
##	collect_and_write_results({'VARS':'pressure','model':'U','LAM_A1':('Mises','U','S1'), 'PAD1.SET_SILIC2':('Mises','S1')})
##	E7_wangyf_frameless_3800                           step=step1  run_time  3.6min  pressure  3800 //  PAD1.SET_SILIC2_Mises  0.6851    PAD1.SET_SILIC2_S1  0.4305    LAM_A1_Mises  66.5560   LAM_A1_U  15.3750   LAM_A1_S1  77.3170   MODEL_U  15.3750   elem_num  31638 LAM_A1  30438 PAD1  300  PAD2  300  PAD3  300  PAD4  300  mats_num  4    insts_num  5    comp  CNDNT43
##	collect_and_write_results({'values':pressure,'model':'U','LAM_A1':('Mises','U','S1'), 'pad1.set_silic2':('Mises','S1')})
##	E7_wangyf_frameless_3800                           step=step1  run_time  3.6min  3800 //  PAD1.SET_SILIC2_Mises  0.6851    PAD1.SET_SILIC2_S1  0.4305    LAM_A1_Mises  66.5560   LAM_A1_U  15.3750   LAM_A1_S1  77.3170   MODEL_U  15.3750   elem_num  31638 LAM_A1  30438 PAD1  300  PAD2  300  PAD3  300  PAD4  300  mats_num  4    insts_num  5    comp  CNDNT43

	global jobnum

	refresh()

	if type_of(list1) == 'DICT':
		newlist = []
		for key,v in list1.items():
			list0 = [key]
			v = tolist(v)
			for item in v:
				list0.append(item)
			tuple0 = tuple(list0)
			newlist.append(tuple0)
		list1 = newlist

	list1 = totable(list1)
	for item in list1:
		if type_of(item) != 'TUPLE' or len(item) <2:
			raise Exception('*** a table is required, like a tuples list.')
		if type_of(item[0]) != 'STR':
			print fnln(),'item=',item
			raise Exception('*** item request should start with a string, such as step, vars, values, instname, setname, surface name.')

	if steps in empty:
		steps = []
	steps = tolist(steps)

	newlist = []
	for item in list1:
		if item[0].upper() == 'STEP':
			if steps in empty:
				steps.append(item[1])
		else:
			newlist.append(item)

	list1 = newlist

	if steps in empty:
		steps.append(odb.steps.keys()[-1])
	else:
		newlist = []
		for step1 in steps:
			step11 = check_odb_step(step1)
			newlist.append(step11.name)
		steps = newlist

	dpo = get_dpo()
	if type_of(dpo) != 'ODB':
		try:
			open_odb(inp_file_title)
		except:
			raise Exception('*** An odb viewport is required to collect the results.')

##	if 'step' not in dict1.keys():
##		stepname = odb.steps.keys()[-1]
##	else:
##		stepname = dict1['step']
##		step1 = check_odb_step(stepname)
##		stepname = step1.name

	output_list = []

	runtime = get_runtime()
	runtime = round(runtime,1)
##	prefix = get_jobnum_and_runtime(stepname=stepname)
##	suffix = get_output_list_others()

	prefix = [odb_file_title]
	suffix = ['runtime=' + str(runtime) + 'min']

##	print fnln(),'prefix=',prefix
##	raise Exception

	datas = []
	odb_fields = []
	i = 0
	for item in list1:
		i = i + 1
		key0 = item[0]
		key = key0.upper()
		if key == 'FUNC' or key in ['VALUE','VALUES','CONSTANTS','DATA','DATA ONLY'] or key in ['VAR', 'VARS','NAME+DATA','NAMES']:
			datas.append(item)
		else:
			if 	i == 1 and odb_file_title in myglobals.keys() and key0 in myglobals[odb_file_title].keys() and key not in oa.instances.keys():
				item1 = ['VARS'] + tolist(item)
				item1 = tuple(item1)
				datas.append(item1)
			else:
				odb_fields.append(item)


##		 or key0 in myglobals[odb_file_title].keys():
##			if key0 in myglobals[odb_file_title].keys() and key not in oa.instances.keys():
##			else:
##		else:

##	print fnln(),'odb_fields=',odb_fields
##	raise Exception

	values0 = []
	vars0 = []
	results0 = []
	main_vars = odb_main_vars()

	for item in datas:
		key1 = item[0]
		values = item[1:]

		print fnln(),'item=',item
		print fnln(),'values=',values

		key = key1.upper()

		if key == 'FUNC':  ## 运行无参数的函数，取其返回值
			values = tolist(values)
			for name in values:
				result = eval(name + '()')
				values0 = values0 + [name, result]

		elif key in ['VALUE','VALUES','CONSTANTS','DATA','DATA ONLY']:  ## 不保存变量名
			values = tolist(values)
			values0 = values0 + values

		elif key in ['VAR', 'VARS','NAME+DATA','NAMES']:	## 保存全局变量名和值
			values = tolist(values)
##			print fnln(),'values=',values
##			raise Exception
			for name in values:
##				if type_of(name) == 'STR' and name in globals().keys():
				if type_of(name) == 'STR':
					if odb_file_title in myglobals.keys():
					 	if name in myglobals[odb_file_title].keys():
							vars0 = vars0 + [name,myglobals[odb_file_title][name]]
					elif name in globals().keys():
						vars0 = vars0 + [name,globals()[name]]

	for stepname in steps:## keyname = instances, sets, or surfaces
		results0.append('//'+stepname)

		for item in odb_fields:
			key = item[0].upper()
			values = item[1:]

##			print fnln(),'values=',values
##			raise Exception

			if type_of(values) == 'STR':   ## key:values的形式
				if values in variable_dict.keys() or values in main_vars:
					variable = values

					if key not in oa.instances.keys():
						if key in odb.parts.keys() and key + '_A1' in oa.instances.keys():
							key = key + '_A1'

					if key in oa.instances.keys():
						result = get_result(stepname=stepname, instance=key,variable=variable, value_loc='',save=False,scale=1)
					elif key in oa.surfaces.keys():
						result = get_result(stepname=stepname, surface=key,variable=variable, value_loc='',save=False,scale=1)
					else:  ## 无法根据odb part知道其oa instances。所以，如果不是oa instance，则认为是setname
						result = get_result(stepname=stepname, setname=key,variable=variable, value_loc='',save=False,scale=1)

					results0 = results0 + result
##					else:
##						vars0 = vars0 + [key, values]
			else:
##					if type_of(values) not in ['LIST', 'TUPLE']:
##						continue

##				print fnln(),'values=',values
##				raise Exception

				for var in values:  ## variables list
					value_loc = ''
					save = False
					scale = 1

##					print fnln(),'=========var=',var
##					raise Exception
##						print ' '
					if type_of(var) in numerics:
##						output_list = output_list + [key, var]
						vars0 = vars0 + [key, var]
						continue
					elif type_of(var) == 'TUPLE':  ## not preferred.
						if len(var) == 2:
							variable,value_loc = var	;please_check
						elif len(var) == 3:
							variable,value_loc,other = var	;please_check
							if type_of(other) in numerics:
								scale = other
							else:
								save = other
					elif type_of(var) == 'STR':
						if var not in variable_dict.keys() and var not in main_vars:
##							output_list = output_list + [key, var]
							vars0 = vars0 + [key, var]
							continue
						else:
							variable = var

					if type_of(variable) == 'STR':
						if key not in oa.instances.keys():
							if key in odb.parts.keys() and key + '_A1' in oa.instances.keys():
								key = key + '_A1'

##							print fnln(),'variable=',variable
						if key in oa.instances.keys():
							result = get_result(stepname=stepname, instance=key,variable=variable,value_loc=value_loc,save=save,scale=scale)
						elif key in oa.surfaces.keys():
##							print fnln(),'surface=',key,', variable=',variable,', value_loc=',value_loc
##							raise Exception
							result = get_result(stepname=stepname, surface=key,variable=variable, value_loc=value_loc,save=save,scale=scale)
						else:
							result = get_result(stepname=stepname, setname=key,variable=variable,value_loc=value_loc,save=save,scale=scale)

##						output_list = output_list + result
						results0 = results0 + result
##						print fnln(),'resuls0=',results0
					else:
						print fnln(),'*** ',variable,'is not valid variable.'
##		print fnln(),'results0=',results0


##	output_list = prefix + output_list + suffix
	output_list = prefix + values0 + vars0 + results0 + suffix

	computer_name = os.environ['COMPUTERNAME']

	if jobnum.lower() not in odb_file_title:
		locs = locs_of_substring(odb_file_title,'_')
		if len(locs) >=2:
			jobnum = odb_file_title[locs[0]+1:locs[1]]
		else:
			locs1 = locs_of_substring(odb_file_title,' ')
			if len(locs1) >=2:
				jobnum = odb_file_title[locs1[0]+1:locs1[1]]
			else:
				if len(locs) == 1 and len(locs1) == 1:
					list1 = _sort(locs[0],locs1[0])
					jobnum = odb_file_title[list1[0]+1:list1[1]]

	result_file = '_' + jobnum + '_results' + '_' + computer_name[:3] + '.txt'
	result_file = make_dir('results') + '/' + result_file
	list_to_txt_line(result_file,output_list)
	print ' '

	if 'script_file_dir' in globals().keys():
		shutil.copy(result_file,script_file_dir)

	return output_list

res2file = collect_and_write_results

def get_computer_name():
	## VER: 2014-07-30, v1.0

	import os
	computer_name = os.environ['COMPUTERNAME']

	return computer_name

def collect_space_of_curved_faces(*setnames):
	## VER: 2011-11-15, v1.1

	global fdict_space, fdict_collected

	time1 = time.time()
	print 'Collecting space of bending faces in assembly...'

	setnames = tolist(setnames)

	fdict_space = {}
	for part in _m.parts.values():
		print 'part=',part.name
		fdict = {}

		for name in setnames:
			for set1 in part.sets.keys():
				if name in set1:
					faces = set2objs(part,set1)
					if type_of(faces[0]) != 'faces':
						continue

					for face in faces:
						fdict[face.index] = objs_space(face)

		fdict_space[part.name] = fdict

	for inst in a.instances.values():
		print 'inst=',inst.name
		fdict = {}
		partname = inst.partName
		dx,dy,dz = inst.getTranslation()

		for name in setnames:
			for set1 in inst.sets.keys():
				if name in set1:
					faces = set2objs(inst,set1)
					if type_of(faces[0]) != 'faces':
						continue

					for face in faces:
						x1,x2,y1,y2,z1,z2 = fdict_space[partname][face.index]
						fdict[face.index]	= x1+dx,x2+dx,y1+dy,y2+dy,z1+dz,z2+dz

		fdict_space[inst.name] = fdict

	fdict_collected = True

	time2 = time.time()
	print 'Elapsed time=',round(time2 - time1,1)
	print ' '

	return

def pia_of_set(set1):
	## VER: 2014-06-06, v1.0
	## Reference: type_of_set(), name_of_set(), pia_of_set()

	if type_of(set1) != 'SET':
		raise Exception('*** set like region is required.')

	pia = get_parent(set1)

	return pia

function_labels['pick_dg'] = 'obj','light','dg','displayGroup','leaf'
def pick_dg():
	## VER: 2016-11-22, v1.1
	## 获得最近手工创建的displayGroup，例如选择4个节点，组成两条线，以便通过vector_angle_of_4nodes()计算角度。

	## 方法：create display group->nodes->pick from viewport->edit selection->pick one or two nodes->Done
	##       ->add selection->pick another one or two points->Done ->Save selection as->OK->查rpy文件，有编号。
	##      至少需要一个Add selection，否则不会以pick1,pick2...的形式保存在rpy文件中。

##	>>> pick_dg()
##	pick1= mdb.models['Model-1'].parts['powder'].faces.findAt((13.573044, 0.490798, 9.660945),)
##	pick2= mdb.models['Model-1'].parts['powder'].faces.findAt((9.752949, -2.890961, 27.755842),)
##
##	[mdb.models['Model-1'].parts['powder'].faces.findAt((13.573044, 0.490798, 9.660945),), mdb.models['Model-1'].parts['powder'].faces.findAt((9.752949, -2.890961, 27.755842),)]
##	>>>

##	>>> pick_dg()
##	pick1= [mdb.models['Model-1'].parts['powder'].nodes[1984], mdb.models['Model-1'].parts['powder'].nodes[2261]]
##	pick2= [mdb.models['Model-1'].parts['powder'].nodes[6831], mdb.models['Model-1'].parts['powder'].nodes[6942]]
##
##	[[mdb.models['Model-1'].parts['powder'].nodes[1984], mdb.models['Model-1'].parts['powder'].nodes[2261]], [mdb.models['Model-1'].parts['powder'].nodes[6831], mdb.models['Model-1'].parts['powder'].nodes[6942]]]
##	>>>

	dpo = get_dpo()
	if type_of(dpo) not in ['PART','ASSEMBLY']:
		print '** Please set the viewport as part or assembly type.'
		return []

	file1 = open(get_rpy()).readlines()  ## 注意每一行的最末字符是结束符，是看不见的符号。

	num = 0
	start0 = None
	end0 = None
	for i in range(len(file1) -1, -1, -1):
		num += 1
		if num > 300:  ## 仅搜索不多于300行。
			break

		line = file1[i]
		if 'leaf = dgm.LeafFrom' in line and line[-2] == ')' and '#' not in line:
			end0 = i-1
			for j in myrange(end0,i-10,-1):
				if 'p = mdb.models[' in file1[j] and '#' not in file1[j]:
					start0 = j
					break
			if start0 != None:
				break

	start = None
	end = end0

	if end0 == None:  ## end=end0
		print '*** Please save the displayGroup by Save Selection As...'
		return []

##	print 'end=',end + 1
	for j in myrange(end,end-30,-1):
		line = file1[j]
		if 'pick1 =' in line and line[-2] == 's' and '#' not in line:
			for k in myrange(j,j-10,-1):
				if 'p = mdb.models[' in file1[k] and '#' not in file1[k]:
					start = k
					break
			if start != None:
				break

	try:
		del globals()['pick1']
		del globals()['pick2']
		del globals()['pick3']
		del globals()['pick4']
	except:
		pass

	if start != None:  ## found pick1
		for i in myrange(start,end):
			line = file1[i]
			code = line[:-1].strip()
			if code[0] == '#' or code.startswith('cliCommand') or code.startswith('session.viewports'):
				print '*** Please save the displayGroup by Save Selection As...'
				return []

	if not file1[end].startswith('pick'):	## without Add selection
		haspick = False
		start = start0
	else:
		haspick = True
		if start == None:
			raise Exception('*** Fail to find the start line.')

	for i in myrange(start,end):
		line = file1[i]
		code = line[:-1].strip()
		print 'code=',code
		exec(code)   ## create local variables

	results = []
##	print 'Usually, for a node or element sequence: [index:label]'
##	print ' '
##	print 'lineno in rpy:'
##	print 'start=',start + 1
##	print 'end=',end + 1

	if haspick == True:
		try:
			pick1 = tolist(pick1)
			if len(pick1) == 1:
				pick1 = pick1[0]
			globals()['pick1'] = pick1

			pick2 = tolist(pick2)
			if len(pick2) == 1:
				pick2 = pick2[0]
			globals()['pick2'] = pick2

			pick3 = tolist(pick3)
			if len(pick3) == 1:
				pick3 = pick3[0]
			globals()['pick3'] = pick3

			pick4 = tolist(pick4)
			if len(pick4) == 1:
				pick4 = pick4[0]
			globals()['pick4'] = pick4

		except:
			pass

		if 'pick1' in globals().keys():
			print 'pick1=',repr(pick1)
			results.append(pick1)

		if 'pick2' in globals().keys():
			print 'pick2=',repr(pick2)
			results.append(pick2)

		if 'pick3' in globals().keys():
			print 'pick3=',repr(pick3)
			results.append(pick3)

		if 'pick4' in globals().keys():
			print 'pick4=',repr(pick4)
			results.append(pick4)
		print ' '

	else:
		code = file1[end]
		loc = code.find('=')
		var = code[:loc].strip()
		objs = eval(var)

		objs = tolist(objs)
		if len(objs) == 1:
			objs = objs[0]

		results = [objs]
		globals()['pick1'] = objs
		print 'pick1=',repr(objs)
		print  ' '

	return results

function_labels['PK'] = 'compare','value','greater','smaller','equal'
def PK(value1,value2,err=1e-5):
	## VER: ('2014-07-11, v1.5')		## 相当于填写 value1___value2之间的关系符号。结果为：>, <，或0
	## 在几何方面，认为一个点的位置精确到1e-5, 第六位小数点是浮动的。

#### >>> PK(1.000001,1.000002)
##0
##>>>

##	if abs(value1 - value2) <= 2e-6:
##		result = 0
##	elif value2 - value1 > 2e-6:
##		result = '<'
##	elif value1 - value2 > 2e-6:
##		result = '>'

	value1 = round(value1,5)
	value2 = round(value2,5)

##	if debug1 == True:
##		print fnln(),'value1=',value1
##		print fnln(),'value2=',value2


	if abs(value1 - value2) <= err:
		result = 0
	elif value2 - value1 > err:
		result = '<'
	elif value1 - value2 > err:
		result = '>'
	else:
		print fnln(),'value1=',value1
		print fnln(),'value2=',value2
		raise Exception('*** Error for comparison.')

	return result

def contact_divide(cutter,becutter=[],dirs=['x','y']):
	## VER: 2010-04-27

	if dirs in ['x','y','z']:
		dirs = [dirs]

	if dirs != [] and type_of(dirs) == 'LIST':
		for dir1 in dirs:
			divide_bypart(cutter,dir1,becutter)

	return

def contact_faces_of_insts(insts=None,parts=None,mate_insts=None):
	## VER: 2010-02-14, v1.1

	global contact_pairs

	parts = real_parts(parts)
	insts = real_insts(insts)
	mate_insts = real_insts(mate_insts)

	if parts not in empty:
		insts = insts_of_parts(parts)

	if insts in empty:
		insts = a.instances.values()

	if mate_insts in empty:
		mate_insts = a.instances.values()

	faces = []
	for inst in insts:
		for mate_inst in mate_insts:
			if mate_inst.name == inst.name:
				continue
			for pair in contact_pairs:
				if inst.name not in pair['instances'] or mate_inst.name not in pair['instances']:
					continue
				if pair['master'] == inst.name:
					faces = faces + pair['mfaces']
				elif pair['slave'] == inst.name:
					faces = faces + pair['sfaces']

	newlist = []
	for face in faces:
		if face not in newlist:
			newlist.append(face)
	faces = newlist

	print '--->',len(faces),'contact faces are selected in contact_faces_of_insts().'

	return faces

def contact_select(name=None,prefix=None,master=None,slave=None,x=None,y=None,z=None,type=None):
	## VER: 2011-06-22, v1.0

	if type_of(slave) == 'PINSTANCE':
		slave = slave.name

	if type_of(master) == 'PINSTANCE':
		master = master.name

	if name not in empty:
		for contact in contact_pairs:
			if contact['name'] == name:
				contacts = [contact]
				break
	else:
		contacts = contact_pairs

	if prefix not in empty:
		newlist = []
		for contact1 in contacts:
			if contact1['name'].startswith(prefix) == True:
				newlist.append(contact1)
		contacts = newlist

	if master not in empty:
		newlist = []
		for contact1 in contacts:
			if contact1['master'] == master:
				newlist.append(contact1)
		contacts = newlist

	if slave not in empty:
		newlist = []
		for contact1 in contacts:
			if contact1['slave'] == slave:
				newlist.append(contact1)
		contacts = newlist

	if type not in empty:
		newlist = []
		for contact1 in contacts:
			if contact1['type'] == type:
				newlist.append(contact1)
		contacts = newlist

	if x!= None or y!= None or z != None:
		newlist = []
		for contact1 in contacts:
			pointOn = contact1['mfaces'][0].pointOn[0]
			if x!=None and PK(x,pointOn[0]) != 0:
				continue

			if y!=None and PK(y,pointOn[1]) != 0:
				continue

			if z!=None and PK(z,pointOn[2]) != 0:
				continue

			newlist.append(contact1)

		contacts = newlist

	names = []
	for contact in contacts:
		names.append(contact['name'])

	print fnln_fnln(),'--->Found',len(names),'contacts:',names

	return names

def contact_sets(interact,locinfo,master_inst,slave_inst,mfaces='',sfaces='',prop = 'Frictionless',step='step1'):
	## VER: 2010-05-13

	mface1 = []
	sface1 = []
	step = check_step(step)

	if type_of(interact) == 'STR':
		interact.lower()

	if interact not in ['interact','tie']:
		raise Exception('Contact = interact or tie? Please specify. line=861, contact_sets()')
		error_record('contact_sets()')		## **********

	if type_of(mfaces) != 'STR' or type_of(sfaces) != 'STR':
		raise Exception('Setname required for contact_sets(). Otherwise, use s2s_interact_std or s2s_tie instead. line=3977, conact_sets()')
		error_record('contact_sets()')    ## **********

	if mfaces != '' and sfaces != '':
		mface1.append(mfaces)
		sface1.append(sfaces)

	elif mfaces not in empty and sfaces in empty:
		setname = mfaces
		for name in master_inst.sets.keys():
			if name.count(setname) > 0:
				mface1.append(name)
				sface1.append('')

	elif mfaces in empty and sfaces not in empty:
		setname = sfaces
		for name in slave_inst.sets.keys():
			if name.count(setname) > 0:
				mface1.append('')
				sface1.append(name)

	if len(mface1) > 0:
		for i in range(len(mface1)):
			if i > 0:
				locinfo1 = locinfo + str(i)
			else:
				locinfo1 = locinfo

			if interact == 'interact':
				s2s_interact_std(locinfo1,master_inst,slave_inst,mfaces=mface1[i],sfaces=sface1[i],prop=prop,step=step)
			elif interact == 'tie':
				s2s_tie(locinfo1,master_inst,slave_inst,mfaces=mface1[i],sfaces=sface1[i])

	return

def contacts_of_inst(inst):
	## VER: 2012-12-21, v1.0, 可用于del inst前，先将其接触对删除。

	inst = check_inst(inst)

	ints = []
	for name in _m.interactions.keys():
		found = False
		master = _m.interactions[name].master[0]
		objs = objs_of_internal_set(master)
		for obj in objs:
			inst1 = get_poi(obj)
			if inst1 == inst:
				found = True
				ints.append(name)
				break

		if found == False:
			slave = _m.interactions[name].slave[0]
			objs = objs_of_internal_set(slave)
			for obj in objs:
				inst1 = get_poi(obj)
				if inst1 == inst:
					found = True
					ints.append(name)
					break

	ties = []
	for name in _m.constraints.keys():
		found = False
		master = _m.constraints[name].master[0]
		objs = objs_of_internal_set(master)
		for obj in objs:
			inst1 = get_poi(obj)
			if inst1 == inst:
				found = False
				ties.append(name)
				break

		if found == False:
			slave = _m.constraints[name].slave[0]
			objs = objs_of_internal_set(slave)
			for obj in objs:
				inst1 = get_poi(obj)
				if inst1 == inst:
					found = True
					ties.append(name)
					break

	print 'Found',len(ints),'interactions and',len(ties),'ties for',inst.name

	return ints,ties

def contacts_of_pois(pois,printResult=True):
	## VER: 2013-03-04, v1.3

	global conts

	if 'conts' not in globals().keys():
		list_contacts()

	if len(conts) == 0:
		print fnln_fnln(),'**No contact created yet.'
##		return {}
		return []

	pois = tolist(pois)
	pois = check_pias(pois,force_list=True)

	clist = {}
	if type_of(pois[0]) == 'PART':
		for num,contact in conts.items():
			inside = True
			for part in pois:
				if part.name + '_A' not in contact['name']:
					inside = False
					break

			if inside == True:
				if contact['brief'] not in clist.keys():
					clist[contact['brief']] = [num]
				else:
					clist[contact['brief']].append(num)

	elif type_of(pois[0]) == 'PINSTANCE':
		for num,contact in conts.items():
			inside = True
			for inst in pois:
				if inst.name not in contact['name']:
					inside = False
					break

			if inside == True:
				if contact['brief'] not in clist.keys():
					clist[contact['brief']] = [num]
				else:
					clist[contact['brief']].append(num)

	names = poi_names(pois)
	if len(pois) == 1:
		names = names[0]
	cont_insts = len(clist)

	inst_num = 0
	cont_num = 0
	for k,v in clist.items():
		inst_num += 1
		cont_num += len(v)

	result = [names,str(cont_num) + '/' + str(inst_num)]

	if printResult == True:
		if clist not in empty:
			for k,v in sort_by_key(clist):
				print k,'=',v
				for num in v:
					if k[:3] == 'int':
						print str(num).rjust(3),'=',dict_interacts[num]
					elif k[:3] == 'tie':
						print str(num).rjust(3),'=',dict_ties[num]
				print ' '

			print '**Run cshow(num) to see detailed contact in the viewport.'
			print ' '
		else:
			print 'No contacts for',poi_names(pois)

	return result

def contain(space,loc,mark_select = False):
##	VER: ('VER: 2012-08-28, v1.0')	## 用于判断一个点是否位于一个三维空间内部。

	if len(loc) == 6:
		space,loc = loc,space

	x,y,z = loc
##	space = sort_space(space)		## space的排序工作在调用函数中进行，不要在这里进行。

	inside = True
	if mark_select == False:
		if PK(x,space[0]) in ['<',0]:
			return False
		elif PK(x,space[1]) in ['>',0]:
			return False
		elif PK(y,space[2]) in ['<',0]:
			return False
		elif PK(y,space[3]) in ['>',0]:
			return False
		elif PK(z,space[4]) in ['<',0]:
			return False
		elif PK(z,space[5]) in ['>',0]:
			return False

	elif mark_select == True:
		if PK(x,space[0]) == '<':
			return False
		elif PK(x,space[1]) == '>':
			return False
		elif PK(y,space[2]) == '<':
			return False
		elif PK(y,space[3]) == '>':
			return False
		elif PK(z,space[4]) == '<':
			return False
		elif PK(z,space[5]) == '>':
			return False

	return inside

def contraction_to_shrinkage(contraction):
	## VER: 2015-06-15, v1.0

##	>>> contraction_to_shrinkage(0.805)
##	16.318
##	>>> contraction_to_shrinkage(80.5)
##	16.318
##	>>> contraction_to_shrinkage(1.2)
##	16.667
##	>>> contraction_to_shrinkage(0.2)
##	16.667
##	>>>

	if contraction > 10:
		contraction = contraction/100

	if contraction > 1:   ## greenL/sinterL, contraction factor
		green_L = contraction
		sinter_L = 1
	elif contraction > 0.5:
		green_L = 1 - contraction + 1
		sinter_L = 1
	else:
		green_L = contraction + 1
		sinter_L = 1

	shrinkage = (green_L - sinter_L)/green_L*100
	shrinkage = smart_round(shrinkage)

	return shrinkage

def convert_constraint():
	## VER: 2011-04-02, v1.1

	for inst in a.instances.values():
		inst.ConvertConstraints()

	return

def convert_loc(loc=(),x=None,y=None,z=None,ndir='y',offset=None):
	## VER: 2012-11-26, v1.0  sketch与poi之间的转换: 已知sketch的loc，求poi的loc；或已知poi的loc，求sketch的loc

	if loc in empty:
		if type_of(z) in numerics and ndir == 'y':
			z = -z

		output = []
		if x not in empty:
			output.append(x)
		if y not in empty:
			output.append(y)
		if z not in empty:
			output.append(z)

		output = tuple(output)

	else:
##		print 'loc=',loc
		if len(loc) == 2: ## from 2D to 3D
			axis1,axis2 = loc
			if ndir == 'y':
				axis2 = -axis2   ## z3=-z2

			if offset in empty:
				output = axis1,axis2
			else:
				if ndir == 'x':
					output = offset,axis1,axis2
				elif ndir == 'y':
					output = axis1,offset,axis2
				elif ndir == 'z':
					output = axis1,axis2,offset

		elif len(loc) == 3:  ## from 3D to 2D
			x,y,z = loc
			if ndir == 'x':
				output = y,z
			elif ndir == 'y':
				output = x,-z
			elif ndir == 'z':
				output = x,y
		else:
			raise Exception('location is required.')

	return output

def odb_coords_by_cae(setname,inst_name='green_A1',rotate_reference='DIM_SMALLR_X', axis1='x',axis2='z',step_name='step1',frame=-1,prefix='DIM_'):
	## VER: 2015-07-03, v1.1

	## Example: odb_coords_by_cae('dim_bot_arc')
	## odb_coords_by_cae('dim_top_arc',rotate_reference='dim_bigR_x')
	## odb_coords_by_cae('dim_top_arc',rotate_reference='dim_bigR_x',frame=0)

	inst_name = inst_name.upper()
	setname = setname.upper()
	rotate_reference = rotate_reference.upper()

	partname = import_part_from_odb(odb_file_title,inst_name=inst_name, part_name='p1',step_name=step_name,frame=frame,prefix=prefix)
	instname = new_instance(partname)

##	raise Exception

	if rotate_reference not in empty:
		nodes = set2objs(poi=instname,setname=rotate_reference)
		angle = vector_angle(start=nodes[0],end=nodes[1],axis='x')
		rotate_instances(instname,angle_y=angle)

##	raise Exception

	filename = '_' + odb_file_title[0:2] + '_' + setname + '_' + step_name + '_frame' + str(frame)
	filename = modify_string(filename,'-','_')
	filename = filename + '_' + str(axis1) + str(axis2)
	filename = filename + '_bycae'

	cae_coords_of_nodes(poi=instname,nodes=setname,axis1=axis1,axis2=axis2,filename=filename)

	return

def odb_coords_by_xydata(nodes=None,axis1=0,axis2=3,set1=None,set2=None,set3=None,sort=None,step=-1,frame=-1,real_coord=False,filename=None):
	## VER: 2015-12-08, v1.7，缺陷：只能获得坐标的两个值
	## reference: odb_coords_by_cae()

##	>>> oa.instances.keys()
##	['green_A1']
##	>>> p1 = oa.instances.values()[0]
##	>>> len(p1.nodes)
##	176748
##	>>>

	## Example:
	## odb_coords_by_xydata(nodes='dim_length_mid',set1='dim_bot_arc',set2='dim_top_arc', axis1='x',axis2='z')
##	results = odb_coords_by_xydata(nodes='dim_arc_ymax',axis1='x',axis2='y',sort='x',frame=-1)
##	>>> results[0]
##	[-5.12491035461426, 8.03115940093994, 0]
##	>>>

##	>>> results = odb_coords_by_xydata(nodes='dim_arc_ymax',axis1='x',axis2='y',sort='x',frame=-1,real_coord=True)
##	--->Coordinates of nodes has been written to Z:/A0256-USM insert/results/_BT_dim_arc_ymax_x_y_xydata.txt
##	>>> results[0]
##	[-5.12491035461426, 8.03115940093994, 0.275909125804901]
##	>>>

	set_step_and_frame(step=step,frame=frame)

	if axis1 == 1:
		axis1 = 'x'
	elif axis1 == 2:
		axis1 = 'y'
	elif axis1 == 3:
		axis1 = 'z'
	axis1.lower()
	if axis1 not in ['x','y','z']:
		raise Exception('*** axis1 should be x,y or z')

	if axis2 == 1:
		axis2 = 'x'
	elif axis2 == 2:
		axis2 = 'y'
	elif axis2 == 3:
		axis2 = 'z'
	axis2.lower()
	if axis2 not in ['x','y','z']:
		raise Exception('*** axis2 should be x,y or z')

	plane = axis1 + axis2
	if 'x' not in plane:
		axis3 = 'x'
	elif 'y' not in plane:
		axis3 = 'y'
	elif 'z' not in plane:
		axis3 = 'z'

	if nodes in empty:
		nodes = []
	else:
		if type_of(nodes) == 'STR':
			if filename in empty:
				filename = '_' + odb_file_title[0:3] + nodes
			nodes = odb_node_set_to_nodes(nodes)

		nodes = tolist(nodes)
		if is_numbers(nodes):
			nodes = get_odb_nodes_by_labels(inst=oa.instances.keys()[0],node_labels=nodes)

	nodes1=[]
	if set1 not in empty:
		nodes1 = odb_node_set_to_nodes(set1)

	nodes2 = []
	if set2 not in empty:
		nodes2 = odb_node_set_to_nodes(set2)

	nodes3 = []
	if set3 not in empty:
		nodes3 = odb_node_set_to_nodes(set3)

	nodes = nodes + nodes1 + nodes2 + nodes3

	if sort == 'x':
		nodes = nodes_sort_byx(nodes)
	elif sort == 'y':
		nodes = nodes_sort_byy(nodes)
	elif sort == 'z':
		nodes = nodes_sort_byz(nodes)

	labels = nodes_to_model_node_labels(nodes)
##	print fnln(),'nodes labels=',labels

	datax = xydata_of_nodes(nodes,variable='COOR1')
	datay = xydata_of_nodes(nodes,variable='COOR2')
	dataz = xydata_of_nodes(nodes,variable='COOR3')

	if axis1 == 'x':
		data1 = datax
	elif axis1 == 'y':
		data1 = datay
	elif axis1 == 'z':
		data1 = dataz

	if axis2 == 'x':
		data2 = datax
	elif axis2 == 'y':
		data2 = datay
	elif axis2 == 'z':
		data2 = dataz

	if axis3 == 'x':
		data3 = datax
	elif axis3 == 'y':
		data3 = datay
	elif axis3 == 'z':
		data3 = dataz

	results = []
	valuex = []
	valuey = []
	for i in range(len(data1)):
		results.append(tolist(data1[i][1]))  ## data[i][0]是True distance
		valuex.append(tolist(data1[i][1]))

	for i in range(len(data1)):
		results[i].append(data2[i][1])
		valuey.append(data2[i][1])

		if real_coord == True:
			results[i].append(data3[i][1])

##	print fnln(),results[0]
##	raise Exception

	if filename in empty:
		filename = '_coords_' + odb_file_title

	if filename[-4:0] == '.txt':
		filename = filename[0:-4]

	if axis1 not in empty:
		filename = filename + '_' + str(axis1)

	if axis2 not in empty:
		filename = filename + '_' + str(axis2)

	filename = filename + '_xydata'
	filename = filename + '.txt'

	dir1 = make_dir('results')
	file1 = open(dir1 + '/' + filename,'w')

##	print >>file1,'coord' + str(axis1),'               coord' + str(axis2),'               coord' + str(axis3)
	for i in range(len(results)):
		for j in range(len(results[i])):
			print >> file1,results[i][j],'    ',
		print >> file1,' '

	file1.close()

	print '--->Coordinates of nodes has been written to',dir1 + '/' + filename

	return	results

def coplanar(face1,face2):
	## VER: 2011-05-23, v1.1

	ndir1 = face_ndir(face1)
	ndir2 = face_ndir(face2)

	refine = False
	if ndir1 == ndir2 and ndir1 in ['x','y','z']:
		x10,x20,y10,y20,z10,z20 = objs_space(face1)
		x1,x2,y1,y2,z1,z2 = objs_space(face2)

		if ndir1 == 'x' and PK(x10,x1) == 0:
			refine = True
		elif ndir1 == 'y' and PK(y10,y1) == 0:
			refine = True
		elif ndir1 == 'z' and PK(z10,z1) == 0:
			refine = True

	return refine

def copy_file(file1,target_dir='',target_name=''):
	## VER: 2017-04-12, v1.1

	## Example:
	## copy_file('BT_A0232_fric005_steel_chamfer45_RA11_drawing.inp','inp')   ## 在当前工作目录下建立新的子目录
##	>>> copy_file('abaqus_plugins/ker_BJ.py')  ## 拷贝子目录的文件到当前目录
##	>>>
##	>>> shutil.copy('abaqus_plugins/ker_BJ.py','ker_BJ.py')  ## target只有文件名而没有路径，则为当前路径

	if os.path.isfile(file1):
		if target_name in empty:
			target_name = file1
			loc = target_name.rfind('/')
			if loc > 0:
				target_name = target_name[loc + 1:]

		if target_dir == '':
			target = target_name
		else:
			if os.path.isdir(target_dir) == False: ## 在子目录下没有此目录
				if target_dir != '':
					target_dir = real_dir(target_dir)  ## target_dir的最后一位如果是'/'，将被去除
					os.mkdir(target_dir)

			target = target_dir + '/' + target_name
			target = real_dir(target)

		shutil.copy(file1,target)

	else:
		raise Exception('*** Error file1, or not existed.')

	return

def copy_files(sourceDir, targetDir,copy_sub=True, exts=(), KB_max=None, MB_max=None):
	## VER: 2013-06-27, v1.5. Dont' use os.system()!!! (已被淘汰)
	## 在sourceDir当前目录下的文件，不建立其目录；子目录下的文件，也相应建立其子目录名称。
	## copy_files(r'M:\Abaqus\Axxxx',r'T:\Modelling\backup',MB_max=50,exts='odb')

	## Example
##	copy_files('T:\Transfer\Steven','T:\Transfer\Test11',copy_sub=True, MB_max=50, exts=['.cae','.inp'])

##>>> os.system("copy E:\test1\A105B-version.cae F:\test2")
##1
##>>> os.system("copy E:\\test1\\A105B-version.cae F:\\test2")  ## success
##0
##>>> os.system("copy E:/test1/A105B-version.cae F:/test2")  ## Error
##1
##>>>

	if 'first_copy' not in globals().keys():
		first_copy = True
	else:
		first_copy = False

	sourceDir = real_dir(sourceDir)
	targetDir = real_dir(targetDir)

##	print2('sourceDir=',sourceDir)
##	print2('targetDir=',targetDir)
	print 'sourceDir=',sourceDir

	exts = tolist(exts)
	for i in range(len(exts)):
		ext = exts[i]
		if type_of(ext) != 'STR':
			raise Exception('*** Error file extension')

		ext = ext.lower()
		if ext[0] == '.':
			ext = ext[1:]
		exts[i] = ext

##	print 'exts=',exts
##	raise Exception

	if copy_sub == True and sourceDir in targetDir:
		if sourceDir.count('/') < targetDir.count('/'):
			raise Exception('**** copy_sub=True, so cannot copy all files and sub-directory to the sub-directory of sourceDir')

	for file in os.listdir(sourceDir):
		sourceF = sourceDir + '/' + file
		targetF = targetDir + '/' + file

		## 1
##		print2 ('sourceF=',sourceF)			## sourceF= C:/A0195/test1/A105b-version updated-6.9-1.cae
##		print2 ('targetF=',targetF)			## targetF= E:/test2/A105b-version updated-6.9-1.cae
##		print2 ('targetDir=',targetDir)		## targetDir= E:/test2
##		print2 (os.path.isfile(sourceF))	## True
##		print2 (os.path.exists(targetF))    ## False
##		print2 (os.path.exists(targetDir))  ## False
##		os.makedirs(targetDir)              ## Create successfully

##		raise Exception

		if os.path.isfile(sourceF) == True:
			size0 = os.path.getsize(sourceF)

			loc = file.rfind('.')
			if loc != -1:
				ext = file[loc + 1:]
				ext = ext.lower()
			else:
				ext = None

			to_copy = False
			if not os.path.exists(targetF):
				if targetF.lower() == 'thumbs.db':
					continue
				if type_of(KB_max) in numerics and bit2KB(size0) > KB_max:
					continue
				if type_of(MB_max) in numerics and bit2MB(size0) > MB_max:
					continue
				if exts not in empty and ext not in exts:
					continue
				to_copy = True

			else:
				size1 = os.path.getsize(targetF)  ## target file may exist.
				if size0 != size1:
					to_copy = True

			if to_copy == True:
				if not os.path.exists(targetDir):
					os.makedirs(targetDir)
					print ' '
					print 'created folder:',targetDir

				print 'copying',sourceF,

				## 1
				command = "copy " + sourceF + ' ' + targetDir
				sourceF1 = modify_string(sourceF,'/','\\')
				targetDir1 = modify_string(targetDir,'/','\\')

##				sourceF1 = 'r"' + sourceF1 + '"'    ## Error
##				targetDir1 = 'r"' + targetDir1 + '"'  ## Error
				command = 'copy ' + sourceF1 + ' ' + targetDir1
				result = os.system(command)

				if result != 0:
					shutil.copy2(sourceF,targetDir)   ## No return result (连同最后更新时间也拷贝)
##					shutil.copy(sourceF,targetDir)   ## No return result

				if os.path.isfile(targetF):
					print ', OK'
				else:
					print ', Fail'

		elif os.path.isdir(sourceF) == True and copy_sub == True:   ## 遇到文件夹则重复调用。
##			num, dict1 = my_walk(sourceF)
			dict1 = my_walk(sourceF)
			num = len(dict1['sub_dirs']) + len(dict1['files'])
			if num > 0:  ## 非空
				copy_files(sourceF, targetF, copy_sub=copy_sub, exts=exts, KB_max=KB_max, MB_max=MB_max)

	return

def copy_insts(insts=[],dx=0,dy=0,dz=0,x1=None,x2=None,y1=None,y2=None,z1=None,z2=None):
	## 2011-11-03, v1.3

	global _m, a

	print ' '
	print '**Copying insts...'

	insts = real_insts(insts)
	if insts in empty:
		insts = a.instances.values()

	if x1 != None and x2 != None:
		dx = x2 - x1

	if y1 != None and y2 != None:
		dy = y2 - y1

	if z1 != None and z2 != None:
		dz = z2 - z1

	if len(insts) == len(a.instances.values()):
		num = 'All'
	else:
		num = len(insts)

	names = []
	new_insts = []
	for inst in insts:
		new_inst_name = duplicate_inst(inst)
		names.append(new_inst_name)

		new_inst = a.instances[new_inst_name]
		new_insts.append(new_inst)

##		globals()[text2varname(new_inst_name,poi_type='instance')] = new_inst

	new_insts = totuple(names)
	print 'new_insts=',insts
##	a.translate(instanceList=new_insts, vector=(dx,dy,dz))
	a.translate(instanceList=new_insts, vector=(dx,dy,dz))
	a.regenerate()  ## assembly changed.

	print '--->**',num,'instances are copied together, dx=',dx,', dy=',dy,', dz=',dz
	print '    new instances=',names

	return names

def copy_material(mat,newname,density=None,modulus=None,CTE=None,plastic=None):
	## VER: 2014-11-25, v1.0

	if mat not in _m.materials.keys():
		raise Exception('*** material not existed: ' + mat)

	newname = new_key(_m.materials.keys(),newname)
	_m.Material(name=newname, objectToCopy=_m.materials[mat])
	_m.HomogeneousSolidSection(material=newname, name=newname + '_sec', thickness=1.0)

	if density not in empty:
		set_density(newname,density)

	if modulus not in empty:
		set_modulus(newname,modulus)

	if CTE not in empty:
		set_CTE(newname,CTE)

	if plastic not in empty:
		set_plastic(newname,plastic)

	return


def copy_model(from_name=None,to_name='Model-2',new_from_name=''):
	## VER: 2015-03-19, v1.4
	## can use for restart analysis and keep the previous model.

	## Example: in HPHT case
##	copy_model(to_name='restart',new_from_name='prefield')
##	clear_model_settings()
##	import_initial_state(odb_title1)


	if from_name in empty:
		from_name = current_model_name

	if from_name not in mdb.models.keys():
		raise Exception('**** Error source model for copy from.')

	if type_of(new_from_name) == 'STR':
		mdb.models.changeKey(fromName=from_name, toName=new_from_name)
		from_name = new_from_name
		refresh()

	if to_name in mdb.models.keys():
		del mdb.models[to_name]

##	to_name = new_key(mdb.models.keys(),to_name)

	mdb.Model(name=to_name, objectToCopy=mdb.models[from_name])
	switch_model(to_name)
	mdb.save()

	refresh()
##	get_current_model()

##	update_mdb_vars()

	return to_name

def copy_part(p1,newpart_name,mirror_axis=None,mirror_plane=None,scale=None,mirror_x=None,mirror_y=None,mirror_z=None,dx=0,dy=0,dz=0,
	x1=None,x2=None,y1=None,y2=None,z1=None,z2=None,change_setname=False,instance=False,compress=OFF):
	## VER: 2015-04-02, v3.0, 例如，边框长边由2个clamp变成3个clamp，此时可以设change_setname=False
	## reference: scale_part():将得到存几何体，没有材料属性等。
	## if compress = ON: will get geometry only, 材料属性的设置将消失。

	## example:
##	copy_part('anvil','anvil2',mirror_x=0)
##	copy_part('anvil','anvil3',mirror_z=0)
##	copy_part('anvil2','anvil4',mirror_z=0)

	global default_plot, local_csys, _m, a

	p1 = check_part(p1)

	newpart_name = new_key(newpart_name,new_part=True)
	x1,y1,z1 = real_xyz(p1,x1,y1,z1)
	x2,y2,z2 = real_xyz(p1,x2,y2,z2)

	if is_number(scale) and scale != 1.0:
		compress = ON
	else:
		scale = None

	if scale not in empty:
		mat_ids = get_mat_ids(p1)

	if x1 not in empty and x2 not in empty:
		dx = x2 - x1

	if y1 not in empty and y2 not in empty:
		dy = y2 - y1

	if z1 not in empty and z2 not in empty:
		dz = z2 - z1

	if mirror_x not in empty:
		mirror_axis = 'x'
		dx = 2*mirror_x
	elif mirror_y not in empty:
		mirror_axis = 'y'
		dy = 2*mirror_y
	elif mirror_z not in empty:
		mirror_axis = 'z'
		dz = 2*mirror_z

	if type_of(mirror_axis) == 'STR':
		mirror_axis = mirror_axis.lower()
	if type_of(mirror_plane) == 'STR':
		mirror_plane = mirror_plane.lower()

	if mirror_plane == XZPLANE or mirror_plane == 'xoz' or mirror_plane == 'zox':
		mirror_axis = 'y'
	elif mirror_plane == XYPLANE or mirror_plane == 'xoy':
		mirror_axis = 'z'
	elif mirror_plane == YZPLANE or mirror_plane == 'yoz':
		mirror_axis = 'x'

	if mirror_axis not in empty or mirror_plane not in empty:
		if mirror_axis not in ['x','y','z']:
			raise Exception('Error mirror_axis, should be x, y, or z')

	if mirror_axis == None:
		if scale not in empty:
			_m.Part(name = newpart_name,objectToCopy=p1, compressFeatureList=compress,scale=scale)
		else:
			_m.Part(name = newpart_name,objectToCopy=p1, compressFeatureList=OFF)
	elif mirror_axis == 'x':
		_m.Part(name = newpart_name, objectToCopy=p1, compressFeatureList=compress, mirrorPlane=YZPLANE)
	elif mirror_axis == 'y':
		_m.Part(name = newpart_name, objectToCopy=p1, compressFeatureList=compress, mirrorPlane=XZPLANE)
	elif mirror_axis == 'z':
		_m.Part(name = newpart_name, objectToCopy=p1, compressFeatureList=compress, mirrorPlane=XYPLANE)

##	globals()[text2varname(newpart_name,poi_type='part')] = _m.parts[newpart_name]
	p2 = _m.parts[newpart_name]

	if scale not in empty and mat_ids not in empty:
		apply_mat_ids(p2,mat_ids)

	if mirror_axis != None:
		print '--->New part named',newpart_name,'was created by mirror from part',p1.name, 'in',mirror_axis
		print 'Begin to mirror sets from',p1.name,'to',p2.name,'......'
		for setname in p1.sets.keys():
			if setname in mat_lib:
				mirror_set(p1,setname=setname,p2=p2,mirror_axis=mirror_axis, mirror_plane=mirror_plane,mat=setname)
			else:
				mirror_set(p1,setname=setname,p2=p2,mirror_axis=mirror_axis, mirror_plane=mirror_plane)

	if change_setname == True:
		change_part_setname(p2,p1.name,p2.name)

	if dx != 0 or dy != 0 or dz != 0:
		move_part(p2,dx=dx,dy=dy,dz=dz)
		p2 = _m.parts[newpart_name]

	get_current_model()

	local_csys[p2.name] = [0,0,0]

	if 'temp' not in p2.name:
		default_plot = p2
	update_part(p2.name)

	if instance == True:
		new_instance(p2)

	return newpart_name

def import_part_from_cae(caename, partname):
	## VER: 2014-07-11, v1.0

	## Example:
##	import_part_from_cae('part-342.cae','cutEdge')	;changing
##	import_part_from_cae('imported/_part-342.cae','cutEdge')	;changing

	caename = real_dir(caename)
	if '.cae' not in caename:
		caename = caename + '.cae'

	print fnln(),'caename =',caename
	current_models = mdb.models.keys()
	current_model = get_current_model()

	new_model = new_key(mdb.models.keys(), 'Model-1')

	mdb.openAuxMdb(caename)   ## success or fail
	try:
		mdb.copyAuxMdbModel(fromName='source', toName='source')
	except:
		mdb.copyAuxMdbModel(fromName='Model-1', toName='source')
	mdb.closeAuxMdb()

	import_model = unselect(mdb.models.keys(),current_models)[0]

	import part
	import assembly
	import material
	import section
	import interaction

	_m.Part(partname, mdb.models[import_model].parts[partname])
	p1 = _m.parts[partname]

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=p1)

	get_current_model()

	return

def copyright():
	## VER: 2009-1-14, v1.0
	return 'J-I-A-N-G Y-U-Q-I, 2009-2016'

def copy_sketch(sketch,newname='temp_sketch1'):
	## VER: 2013-05-18, v1.0

	global _m, a

	sketch = check_sketch(sketch)
	newname = new_key(_m.sketches.keys(),newname)
	_m.ConstrainedSketch(name=newname, objectToCopy=sketch)

	return newname

def corner_divide(p,ndir='z',setname='',x1='',x2='',y1='',y2='',z1='',z2='',line_num=1,ucells=()):
	## VER: 2010-04-26

	if x1==x2==y1==y2==z1==z2=='':
		line_num = 2

	x = (x1,x2)
	y = (y1,y2)
	z = (z1,z2)

	if x1 == '' and x2 == '':
		x = ()
	elif x1 != '' and x2 == '':
		x = (x1,0)
	elif x1 =='' and x2 != '':
		x = (0,x2)

	if y1 == '' and y2 == '':
		y = ()
	elif y1 != '' and y2 == '':
		y = (y1,0)
	elif y1 == '' and y2 != '':
		y = (0, y2)

	if z1 == '' and z2 == '':
		z = ()
	elif z1 != '' and z2 == '':
		z = (z1,0)
	elif z1 == '' and z2 != '':
		z = (0,z2)

	if ucells != () and type_of(ucells) == 'TUPLE':
		ucells = vertice_to_cells(p,loc=ucells)
	elif type_of(ucells) == 'STR':
		ucells = set2objs(ucells,p)

	if ucells != ():
		create_set(p,objs=ucells,name='ucells')
##		print '890: len(ucells)=',len(ucells)
##		print ucells

	if setname in empty:
		setname = 'hole_nearby'
		cells = cell_select_by_container(p,x,y,z)
##		print 'len(cells)=',len(cells)
##		print 'len(ucells)=',len(ucells)
		if ucells != ():
			cells = unselect(cells,ucells)
		create_set(p,objs=cells,name=setname)
	else:
		cells = set2objs(p,setname)

	x01,x02,y01,y02,z01,z02 = objs_space(p,cells)

	if x == ():
		x = (x01,x02)
	if y == ():
		y = (y01,y02)
	if z == ():
		z = (z01,z02)

	x1,x2 = x
	y1,y2 = y
	z1,z2 = z

	if ndir == 'z':
		line1_p1 = (x1,y1,z1)
		line1_p2 = (x1,y1,z2)
		line1_p3 = (x2,y2,z2)

		if line_num == 2:
			line2_p1 = (x1,y2,z1)
			line2_p2 = (x1,y2,z2)
			line2_p3 = (x2,y1,z2)

	cells = set2objs(setname,p)
	divide_by3points(p,line1_p1,line1_p2,line1_p3,cells=cells)

	if line_num == 2:
		cells = set2objs(setname,p)
		divide_by3points(p,line2_p1,line2_p2,line2_p3,cells=cells)

##	print 'line_num=',line_num

	return


def cover(space1,space2):
	## VER: 2011-05-24, v1.2

	space1 = tolist(space1)
	space2 = tolist(space2)

	x1 = space1[0:2]
	y1 = space1[2:4]
	z1 = space1[4:6]

	x2 = space2[0:2]
	y2 = space2[2:4]
	z2 = space2[4:6]

	if cross_of_ranges(x1,x2)['range'] != tolist(x2):
		return False

	if cross_of_ranges(y1,y2)['range'] != tolist(y2):
		return False

	if cross_of_ranges(z1,z2)['range'] != tolist(z2):
		return False

	return True

def create_1_bolt(partname=None,D=10,L=30):
	## VER: 2010-01-29, v1.2

	if partname in empty:
		partname = 'bolt'

	partname = blank_part(partname)
	pin = _m.parts[partname]

	cylinder_grow(pin,ndir='z',OD=D,L=L)
	divide(pin,x=0)
	divide(pin,y=0)

	KP_set(pin,name='O1')
	KP_set(pin,loc=(0,0,L),name='O2')

	set_mat(pin,mat='Rigid',subset='_bolt')

	faces = face_select(pin,ndir='circular')
	create_set(pin,objs=faces,name='fm_bolt_stud')

	print '--->Created one 1_bolt, name=',partname,', D=',D, ', L=',L

	return

def create_C_clamp_with_rubber(clamp_length, clamp_thick, rubber_thick, clamp_depth, mouth_height,rubber_mat='Rubber',name=None,global_var=True,cut_sides=True):

	## VER: ('VER: 2012-08-30, v1.4')

	if name == None:
		name = 'clamp'

	clamp_height = mouth_height + 2*(rubber_thick + clamp_thick)

	partname = blank_part(name)
	clamp = _m.parts[partname]

	create_block(clamp,(0,clamp_depth + rubber_thick + clamp_thick),(0,clamp_length),(0,clamp_height))
	hex_cut(clamp,x=(0,clamp_depth),z=(clamp_thick + rubber_thick, clamp_thick + rubber_thick + mouth_height))

	batch_divide(clamp,z=(clamp_thick,clamp_thick + rubber_thick, clamp_height - clamp_thick, clamp_height - clamp_thick - rubber_thick))
	batch_divide(clamp,x=(clamp_depth, clamp_depth + rubber_thick))

	set_mat(clamp,mat='Al_6061')

	cells = cell_select_by_container(clamp,x=(0,clamp_depth + rubber_thick),z=(clamp_thick, clamp_height - clamp_thick))
	cross_set_mat(clamp,cells=cells,mat=rubber_mat)		;please_check

	faces = faces_of_cut(clamp,z=clamp_height - clamp_thick - rubber_thick)
	create_set(clamp,faces=faces,name='f_clamp_inner_top')

	faces = faces_of_cut(clamp,z=clamp_thick + rubber_thick)
	create_set(clamp,faces=faces,name='f_clamp_inner_bot')

	faces= faces_of_cut(clamp,x=clamp_depth)
	create_set(clamp,faces=faces,name='f_clamp_inner_side')

	if global_var == True:
		write_global_variables(var_file_full,clamp_length, clamp_thick, rubber_thick, clamp_depth)

	if cut_sides == True:
		bias_cut(clamp,cut_sides='+x',x=clamp_depth)

	print fnln_fnln(),'clamp_thick=',globals()['clamp_thick']

	return

def input_treats_list(randomize=False):
	## VER: 2013-05-08, v2.4, to creat DOE table
	## in the DOE table, each column is a levels_list, each row is a treat settings.
	## example of DOE_table:
##	[[1.4, 1.4, 1.4], [1.6, 1.4, 1.4], [1.4, 1.6, 1.4], [1.6, 1.6, 1.4], [1.4, 1.4, 1.6], [1.6, 1.4, 1.6], [1.4, 1.6, 1.6], [1.6, 1.6, 1.6], [1.33182, 1.5, 1.5], [1.66818, 1.5, 1.5], [1.5, 1.33182, 1.5], [1.5, 1.66818, 1.5], [1.5, 1.5, 1.33182], [1.5, 1.5, 1.66818], [1.5, 1.5, 1.5], [1.5, 1.5, 1.5], [1.5, 1.5, 1.5], [1.5, 1.5, 1.5], [1.5, 1.5, 1.5], [1.5, 1.5, 1.5]]

	global DOE_factors,DOE_table,full_seq

	"""start: A系列3因子响应曲面设计
    outer_wall_thick  inner_wall_thick  base_thick
1   1.4            1.4              1.4
2   1.6            1.4              1.4
3   1.4            1.6              1.4
4   1.6            1.6              1.4
5   1.4            1.4              1.6
6   1.6            1.4              1.6
7   1.4            1.6              1.6
8   1.6            1.6              1.6
9   1.33182        1.5              1.5
10  1.66818        1.5              1.5
11  1.5            1.33182          1.5
12  1.5            1.66818          1.5
13  1.5            1.5              1.33182
14  1.5            1.5              1.66818
15  1.5            1.5              1.5
16  1.5            1.5              1.5
17  1.5            1.5              1.5
18  1.5            1.5              1.5
19  1.5            1.5              1.5
20  1.5            1.5              1.5
	"""

	py_file,handler_line,lines = get_function_info(input_treats_list)

	DOE = []
	found = False
	for i in range(len(lines))[handler_line-1:]:
		line = lines[i].strip()

		if line in empty:
			continue

		if '"""start' in line:
			found = True
			continue

		if found == True:
			if '"""' in line:
				break

			line = modify_string(line,'\t','  ')
			loc = line.find('#')
			if loc != -1:
				line = line[:loc]

			if line not in empty:
				DOE.append(line)

	DOE_factors = DOE[0].split()
##	print DOE_factors

	DOE_table = DOE[1:]
	for i in range(len(DOE_table)):
		line = DOE_table[i]
		line = line.split()

		values1 = []
		for value1 in line:
			try:
				v = eval(value1)
			except:
				v = value1

			values1.append(v)

		DOE_table[i] = values1

	if [DOE_table[0][0],DOE_table[1][0],DOE_table[2][0],DOE_table[3][0]] == [1,2,3,4]:
		for i in range(len(DOE_table)):
			DOE_table[i].pop(0)

	full_seq = range(1,len(DOE_table) + 1)

	if randomize == True:
		shuffle(DOE_table)
	else:
		shuffle(full_seq)

##	myprint(DOE_table)
	print_DOE_table()

	print 'randomize=',randomize
	print 'full_seq=',full_seq

	all_treats = []
	for i in range(len(DOE_table)):
		values = DOE_table[i]
		treat = {}
		for j in range(len(DOE_factors)):
			factor = DOE_factors[j]
			value = values[j]
			treat[factor] = value
		all_treats.append(treat)

	return all_treats

def create_density_levels(ranges=(5.5, 7, 9, 10.5),int=0.0005,out=0.001):
	## VER: 2015-05-11, v1.1

	n1,n2,n3,n4 = _sort(ranges)

	list1 = myrange(n1,n2,out)
	print len(list1),'density levels below',n2

	list2 = myrange(n2,n3,int)
	print len(list2),'density levels between',(n2,n3)

	list3 = myrange(n3,n4,out)
	print len(list3),'density levels above',n3

	if list1[-1] == list2[0]:
		list1 = list1[:-1]

	if list2[-1] == list3[0]:
		list3 = list3[1:]

	num = len(list1) + len(list2) + len(list3)
	print 'Total density levels: ',num

	list4 = list1 + list2 + list3

	return list4

function_labels['create_double_lam'] = 'frameless','lamination','glass','PV','suntech','EVA',
def create_double_lam(glass_length, glass_width, glass_thick1, glass_thick2=None, adhesive_thick=1.1, mat='EVA', name=None,global_var=False):

	## VER: ('VER: 2012-08-31, v1.5')

	if name in empty:
		if find_mdb_parts('lam') in empty:
			name = 'lam'
	else:
		name = 'Dlam'

	if glass_thick2 in empty:
		glass_thick2 = glass_thick1

	lam_thick = glass_thick1 + adhesive_thick + glass_thick2

	## lam
	partname = blank_part(name)
	lam = _m.parts[partname]  ## lam是局部变量，当move lam之后，需要重新定义lam

	create_block(lam,(0,glass_width),(0,glass_length),(0,lam_thick))	## full model
	batch_divide(lam,z=(glass_thick1, glass_thick1 + EVA_thick))
	set_mat(lam,mat='Glass')

	cells = cell_select_by_container(lam,z=(glass_thick2, glass_thick2 + EVA_thick))
	cross_set_mat(lam,cells=cells,mat=mat)

	cells = cell_select_by_container(lam,z=(MAX,lam_thick - glass_thick1))
	create_set(lam,cells=cells, name='Glass1')

	cells = cell_select_by_container(lam,z=(MIN,glass_thick2))
	create_set(lam,cells=cells, name='Glass2')

	move_part(lam,x1=MID,x2=0,y1=MID,y2=0)
	lam = _m.parts[partname]
	new_instance(lam)

	if lam.name == 'lam':
		lam_mass = get_mass(lam)
		print 'lam_thick=',lam_thick
		write_global_variables(var_file_full,lam_thick,lam_mass)

	print '--->created double glass lamination. glass_thick1=',glass_thick1,', glass_thick2=', glass_thick2

	return

function_labels['create_single_lam'] = 'PV','suntech','module','glass','lamination'
def create_single_lam(_ylength, _xlength, thick, name=None,lam_top=(None,0.4),lam_bot=(None,0.4),has_EVA_TPT=False,mat='Glass'):

	## VER: ('VER: 2012-07-24, v1.5')
	## 注意：lam_top[0]总是最靠近lam top的那一层，lam_bot[0]也总是最靠近lam bot的那一层。
	## Example:
	## create_single_lam(FRP_length, FRP_width, FRP_thick, has_EVA_TPT=False, lam_top=('EVA',0.7,'Glass',3.2), mat='FRP')
	## 结果为三层，从上至下为：Glass->EVA->FRP

	if name in empty:
		if find_mdb_parts('lam') in empty:
			name = 'lam'
	else:
		name = 'FLlam'

	lam_top = tolist(lam_top)
	if type_of(lam_top) != 'LIST':
		raise Exception('Please provide correct materials and its thickness, format=(mat1,thick1,mat2,thick2,mat3,thick3)')

	lam_bot = tolist(lam_bot)
	if type_of(lam_bot) != 'LIST':
		raise Exception('Please provide correct materials and its thickness, format=(mat1,thick1,mat2,thick2,mat3,thick3)')

	if has_EVA_TPT == True and lam_bot[0] == None :
		lam_bot = ['EVA',EVA_thick,'TPT',TPT_thick]

	loc = get_sequence_index(lam_bot,None)
	if loc != -1:
		lam_bot = lam_bot[:loc]
	print 'lam_bot=',lam_bot	## 例如：lam_bot= ['EVA', 0.8, 'TPT', 0.4]

	loc = get_sequence_index(lam_top,None)
	if loc != -1:
		lam_top = lam_top[:loc]
	print 'lam_top=',lam_top	## 例如：lam_top= []

##	raise Exception

	## lam
	partname = blank_part(name)
	lam = _m.parts[partname]

	create_block(lam,(0,_xlength),(0,_ylength),(0,thick),mat=mat)

	## 注意：lam_top[0]总是最靠近lam top的那一层，lam_bot[0]也总是最靠近lam bot的那一层。
	if len(lam_top) == 2:  ## lam_top有一层材料
		create_block(lam,ext_z=lam_top[1],mat=lam_top[0])
	elif len(lam_top) == 4: ## lam_top有两层材料
		create_block(lam, ext_z=lam_top[1],mat=lam_top[0])
		create_block(lam, ext_z=lam_top[3],mat=lam_top[2])
	elif len(lam_top) == 6:
		create_block(lam, ext_z=lam_top[1],mat=lam_top[0])
		create_block(lam, ext_z=lam_top[3],mat=lam_top[2])
		create_block(lam, ext_z=lam_top[5],mat=lam_top[4])

	print 'len(lam_bot)=',len(lam_bot)

##	raise Exception

##	globals()['debug'] = True

	if len(lam_bot) == 2:
		create_block(lam, ext_z=-lam_bot[1],mat=lam_bot[0])
	elif len(lam_bot) == 4:
		create_block(lam, ext_z=-lam_bot[1],mat=lam_bot[0])
		create_block(lam, ext_z=-lam_bot[3],mat=lam_bot[2])
	elif len(lam_bot) == 6:
		create_block(lam, ext_z=-lam_bot[1],mat=lam_bot[0])
		create_block(lam, ext_z=-lam_bot[3],mat=lam_bot[2])
		create_block(lam, ext_z=-lam_bot[5],mat=lam_bot[4])

	space = get_part_space(lam)
	lam_thick = space[5] - space[4]	;please_check('这里对lam_thick重新定义')

##	print 'space=',space
##	raise Exception

	new_instance(lam)
	dir_points(lam,dirs='z')

	create_side_sets(lam,['top','bot'])

	if lam.name == 'lam':
		lam_mass = get_mass(lam)		## full model
		print 'lam_thick=',lam_thick
		write_global_variables(var_file_full,lam_thick,lam_mass)

	print '--->created single lamination. thick=',thick, ', mat=',mat

	return

def create_I_bolt(partname='bolt',D1=12,D0=24,L=20,cap_thick=4, mat='Steel'):
	## VER: 2012-12-04, v1.5    	0表示螺帽(nut)的圆型垫片，1表示螺柱(stud), L为螺柱的长度（不含螺帽）

	partname = blank_part(partname)
	bolt = _m.parts[partname]

	cylinder_grow(bolt, ndir='z', center0=(0,0,-cap_thick), OD=D0, L=cap_thick)
	cylinder_grow(bolt, ndir='z', center0=(0,0,-cap_thick), OD=D1, L=L + 2*cap_thick)
	cylinder_grow(bolt, ndir='z', center0=(0,0,L), 			OD=D0, L=cap_thick)

	divide(bolt,x=0)
	divide(bolt,y=0)

	KP_set(bolt, (0,0,0),'O1')
	KP_set(bolt, (0,0,L),'O2')

	set_mat(bolt,mat=mat,subset='_bolt')

	faces = face_select(bolt,z=0,nz=1)
	create_set(bolt,objs=faces, name='fm_' + partname + '_cover_low')

	faces = face_select(bolt,z=L,nz=-1)
	create_set(bolt,objs=faces, name='fm_' + partname + '_cover_high')

	faces = face_select(bolt,radius=D1/2)
##	create_set(bolt,objs=faces, name='fm_bolt_D1')
	create_set(bolt,objs=faces, name='fm_' + partname + '_pin')

	print '--->Created one I_bolt, name=',partname, ', D1=', D1, ', D0=',D0,', L=',L

	return

def is_blank_model(model_name):
	## VER: 2016-11-11, v1.0

	result = False
	if model_name in mdb.models.keys():
		_m = mdb.models[model_name]
		if len(_m.parts) == 0 and len(_m.steps) == 1 and len(_m.interactions) == 0:
			result = True

	return result

function_labels['create_new_model'] = 'blank'
def create_new_model(model_name='',cae_name=None):
	## VER: 2016-11-12, v1.3
	## Is not the command Mdb(), that is, the existed models will not be deleted.

	refresh()
	if cae_name in empty:
		cae_name = get_cae_file_title()
	if cae_name[:-4] == '.cae' or cae_name[:-4] == '.odb':
		cae_name = cae_name[:-4]

	if is_blank_model(_m.name) and model_name in empty:
		model_name = _m.name
		save_mdb()
		return model_name

	else:
		if model_name in empty:
			model_name = 'Model-2'
		model_name = new_key(mdb.models.keys(),model_name)
		mdb.Model(name=model_name, modelType=STANDARD_EXPLICIT)

		switch_model(model_name=model_name)
	##	print2('model_name=',_m.name)

		mdb.saveAs(pathName=cae_name)
		global_var_initiate()
		refresh()
	##	print2('model_name=',_m.name)

	return model_name

function_labels['create_nodal_surface'] = 'nodes','element surface'
def create_nodal_surface(p, nodes=None, edges=None,side=None,name='surf_1'):
	## VER: 2014-10-14, v1.1, for 2D and 3D elements.
	## reference: create_surface(), 其中有参数elements，建立elements的surface。

	## Example:
	## create_nodal_surface('powder3', nodes=nodes, side='face2')

##	elems = element_select('powder_A1',y=MAX)
##	faces = get_an_element_face(elems,ny=1)
##	nodes = element_faces_to_nodes(faces)
##	create_nodal_surface('powder_A1', nodes=nodes)

	p = check_poi(p)
	if edges not in empty:
		nodes = node_select(p,edges=edges)

	nodes = tolist(nodes)
	nodes = remove_repeated_items(nodes)

	if name == 'surf_1':
		if type_of(p) == 'PART':
			name = 'surf_' + p.name + '_1'
		elif type_of(p) == 'PINSTANCE':
			name = 'surf_' + p.partName + '_1'

	if type_of(p) == 'PINSTANCE':
		p = a

	name = new_key(name,p.surfaces.keys())

	sides = []
	if side in empty:
		elements = nodes_to_elements(nodes)

		dict1 = {}
		for elem in elements:
			nodes0 = elem.getNodes()
			com_nodes = get_common(nodes,nodes0)

			if len(com_nodes) in [2,3]:
				com_nodes = sort_nodes(com_nodes)
				element_sides = face_and_nodes_of_element(elem)  ## for single element

				if len(com_nodes) == 2:
					node1,node2 = com_nodes
					com_nodes = [[node1,node2]]
				elif len(com_nodes) == 3:
					node1,node2,node3 = com_nodes
					com_nodes = [[node1,node2],[node2,node3],[node1,node3]]

				for edge_nodes in com_nodes:
					for side0 in element_sides.keys():
						nodes0 = element_sides[side0]  ## dict for single element

						if edge_nodes == nodes0:
							if side0 not in dict1.keys():
								dict1[side0] = []

							if elem not in dict1[side0]:
								dict1[side0].append(elem)

							break

##					raise Exception

		print fnln(),'sides=',sides

		if len(dict1.keys()) == 1:
			face = dict1.keys()[0]
			side = totext(face).lower()
			sequence = list2sequence(dict1[face])
			sides.append(side)

			exec('p.Surface(' + side + 'Elements=sequence, name=name)')

		elif len(dict1.keys()) > 1:
			seqs = ''
			print fnln(),'===len(dict1.keys())=',len(dict1.keys())
			for i in range(len(dict1.keys())):
				face = dict1.keys()[i]
				side = totext(face).lower()
				sides.append(side)
				seq = list2sequence(dict1[face])
				print 'i=',i
				print 'sides=',sides
				print 'face=',face
				exec('seq' + str(i) + ' = seq')
				seqs = seqs + side + 'Elements= seq' + str(i) + ','

			exec('p.Surface(' + seqs + 'name=name)')

	else:
		side = side.lower()
		if side not in ['face1','face2','face3','face4','face5','face6']:
			raise Exception('*** Error side info.')
		sides.append(side)

		elements = []
		for node in nodes:
			elements0 = tolist(node.getElements())
			elements = elements + elements0

		elements = remove_repeated_items(elements)
		sequence = list2sequence(elements)

		exec('p.Surface(' + side + 'Elements=sequence, name=name)')

	if sides not in empty:
		print '--->Created nodal surface, name=',name,', element faces=',sides
		surface = p.surfaces[name]
	else:
		raise Exception('*** Fail to create the surface')

	return surface


def create_odb_annotation(odb,annotation_name,text,viewport=None,xloc=None,yloc=None,fontsize=None,RP=BOTTOM_LEFT):
	## VER: 2016-05-16, v1.8

	if viewport in empty:
		viewport = session.currentViewportName
	viewport_type,viewport = check_viewport(viewport)
	if viewport_type != 'ODB':
		raise Exception('**** An odb viewport is required.')

##	annotation_name = new_key(odb.userData.annotations.keys(), annotation_name)

##	print fnln(),'viewport.name=',viewport.name
##	print fnln(),'annotation name=',annotation_name

	if viewport.name not in annotation_name:
		annotation_name = annotation_name + viewport.name

	if annotation_name in odb.userData.annotations.keys():
		del session.odbs[odb.name].userData.annotations[annotation_name]

	if xloc == None:
		xloc = annotation_xloc
	if yloc == None:
		yloc = annotation_yloc
	if fontsize == None:
		fontsize = globals()['fontsize']

	fontsize = int(fontsize)*10

	if yloc < 0 and 'BOTTOM' in totext(RP):
		raise Exception('**** yloc should > 0 because reference point is at BOTTOM.')

	fontstyle = '-*-calibri-bold-r-normal-*-*-' + str(fontsize) + '-*-*-p-*-*-*'  ## bold is better for server
##	fontstyle = '-*-arial-medium-r-normal-*-*-' + str(fontsize) + '-*-*-p-*-*-*'  ## bold is better for server
##	fontstyle = '-*-verdana-medium-r-normal-*-*-' + str(fontsize) + '-*-*-p-*-*-*'  ## bold is better for server

	annotation_name = new_key(odb.userData.annotations.keys(),annotation_name)
	t = odb.userData.Text(name=annotation_name, text=text, offset=(xloc, yloc), anchor=RP, referencePoint=RP)
	odb.userData.annotations[annotation_name].setValues(font=fontstyle)

	viewport.plotAnnotation(annotation=t)

	return annotation_name

def create_odb_node_set(nodes=(),labels=None, inst=None, name='nodeset1'):

	## VER: ('VER: 2012-04-03, v1.1')  ## 注意index比label小1

	## 假如只有一个inst，例如：create_odb_node_set(labels=(1,5,3),inst=FRL_A1,name='set2')
	## myset.nodes = (['OdbMeshNode object', 'OdbMeshNode object', 'OdbMeshNode object'], )
	## 假如有多个inst，例如: create_odb_node_set(nodes=(FRL_A1.nodes[0],FRL_A1.nodes[5],FRS_A1.nodes[3]),name='set3')
	## myset.nodes = (['OdbMeshNode object', 'OdbMeshNode object'], ['OdbMeshNode object'])
	## 可见：myset.nodes是sequence形式，其中的每个元素就是一个列表，对应一个实例。

	seq = odb_nodes_to_sequence(nodes=nodes, labels=labels, inst=inst)
	name = new_key(oa.nodeSets.keys(), name)
	oa.NodeSet(name=name,nodes=seq)

	print '--->Odb node set',name,'was created. You can retrieve the nodal results by getSubset() method of field output object, such as: stress.getSubset()'

	return

def path_from_odb_nodes(nodes,name='path1',setname=None,sort_byx=False, sort_byy=False, sort_byz=False,sort='',reverse=True,check_name=False):
	## VER: ('VER: 2015-06-24, v1.2')

	## Example: path_from_odb_nodes('dim_bot_mid',sort_byx=True)

	if type_of(nodes) == 'STR':
		name = nodes

	if type_of(nodes) == 'STR' and nodes.upper() in oa.nodeSets.keys():
		setname = nodes.upper()
		nodes = None

	if setname not in empty:
		nodes = odb_node_set_to_nodes(setname)

	if check_name == True:
		name = new_key(name,session.paths.keys())

	if sort == 'x' or sort == '+x':
		sort_byx = True
		reverse = False
	elif sort == '-x':
		sort_byx = True
		reverse = True

	if sort == 'y' or sort == '+y':
		sort_byy = True
		reverse = False
	elif sort == '-y':
		sort_byy = True
		reverse = True

	if sort == 'z' or sort == '+z':
		sort_byz = True
		reverse = False
	elif sort == '-z':
		sort_byz = True
		reverse = True

	nodes = tolist(nodes)
	if sort_byx == True:
		nodes = nodes_sort_byx(nodes,reverse=reverse)
	elif sort_byy == True:
		nodes = nodes_sort_byy(nodes,reverse=reverse)
	elif sort_byz == True:
		nodes = nodes_sort_byz(nodes,reverse=reverse)

	labels = nodes_to_model_node_labels(nodes)
##	print fnln(),'nodes labels=',labels

	name = new_key(session.paths.keys(),name)
	session.Path(name=name, type=NODE_LIST, expression=labels)
	path = session.paths[name]

##	print '--->Created path from node list, path name=',name,', (sort_byx,sort_byy,sort_byz)=', (sort_byx,sort_byy,sort_byz),', reverse=',reverse

	return path

def create_periodic_amplitude(name='Amp_1',time_span='step',freq=None,circular_freq=None,ABtable=None,magnitude=1,table_method='auto', sin_cos='sin', t0=0, A0=0):

	## VER: ('VER: 2012-06-03, v1.2')
	## N: 施加几个周期的波。

##	amp_1 = create_periodic_amplitude(name='Amp_1',freq=freq,magnitude=1)

	name = new_key(_m.amplitudes.keys(),name,force_new_key=True)
	if freq in empty and circular_freq in empty:
		raise Exception('freq or circular_freq is required.')

	if time_span == 'step' or time_span == 'STEP':
		time_span = STEP
	elif time_span == 'total' or time_span == 'TOTAL':
		time_span = TOTAL

	if time_span not in [STEP,TOTAL]:
		raise Exception('time_span should be STEP or TOTAL')

	if freq not in empty:
		circular_freq = 2*pi*freq
	elif circular_freq not in empty:
		freq = circular_freq/(2*pi)

	T = 1/freq
	T41 = T/4

	if ABtable in empty or type_of(ABtable) not in ['TUPLE','LIST']:
		if table_method != 'auto':
			raise Exception('table of time vs. amplitude is required.')
		else:
			if sin_cos == 'sin':
				ABtable = [(0,1)]
			else:
				ABtable = [(1,0)]
	else:
		if type_of(ABtable[0]) != 'TUPLE':
			raise Exception('Error table element format, should be one tuple.')
		if len(ABtable) == 1:
			raise Exception('Not enough ABtable data, only has one point')

	if magnitude != 1:
		new_table = []
		for wave in ABtable:
			A,B = wave
			elem = (A*magnitude,B*magnitude)
			new_table.append(elem)
		ABtable = new_table
		_m.PeriodicAmplitude(name=name, timeSpan=time_span,
		frequency=circular_freq, start=t0, a_0=A0, data=totuple(ABtable, open_element=False))

	print '--->Created periodic amplitude',name, ', ABtable=',ABtable
	print 'freq=',freq,', T=',T

	return name

def create_plate(partname,length=70,width=50,thick=3,mat='Steel',xspace=(),yspace=(),zspace=(),x1=None,x2=None,y1=None,y2=None,z1=None,z2=None):
	## VER: 2012-12-04, v1.1, 建立一块板，然后移到合适的位置，同时也建立instance。

	partname = blank_part(partname)
	if xspace in empty and yspace in empty:  ## default
		xspace = (0,length)
		yspace = (0,width)
	elif xspace not in empty:  ## 非空者为长度空间
		yspace = (0,width)
	elif yspace not in empty:	## 非空者为长度空间
		xspace = (0,width)

	if zspace in empty:
		zspace = (0,thick)

	create_block(partname,x=xspace,y=yspace,z=zspace)
	set_mat(partname,mat=mat)

	move_part(partname,x1=x1,x2=x2,y1=y1,y2=y2,z1=z1,z2=z2)
	new_instance(part=partname)

	return partname

def create_poi_vars(post=False):
	## VER: ('VER: 2013-09-17, v1.7')
	## 10.23 create_poi_vars()运行后不会使密度结果消失。

	global varname_to_poiname, part_vars, inst_vars, odb_part_vars, odb_inst_vars

	varname_to_poiname = {}
	part_vars = {}
	inst_vars = {}
	odb_part_vars = {}
	odb_inst_vars = {}

	if post == False:
		## update parts and instances as global variable...
		for name in _m.parts.keys():
			name1 = name

			name1 = text2varname(name1,poi_type='part')
			name1 = new_key(varname_to_poiname.keys(),name1)

##			globals()[name1] = _m.parts[name]    ## globals()[name1] is the var, name1 is the name of var, and name is the name of corresponding poi.
			varname_to_poiname[name1] = name
			part_vars[name] = name1

		for name in a.instances.keys():
			name1 = name

			please_check
##			loc = name.rfind('-')
##			if loc > 1 and loc < len(name) - 1 and name[loc+1:].isdigit() == True:
##				name1 = name[:loc] + '_A' + name[loc+1:]

			name1 = text2varname(name1,poi_type='instance')
			name1 = new_key(varname_to_poiname.keys(),name1)

##			globals()[name1] = a.instances[name]
			varname_to_poiname[name1] = name
			inst_vars[name] = name1

	else:
		for name in odb.parts.keys():
			name1 = text2varname(name,poi_type='odbpart')
			name1 = new_key(varname_to_poiname.keys(),name1)

##			globals()[name1] = odb.parts[name]
			varname_to_poiname[name1] = name
			odb_part_vars[name] = name1

		for name in oa.instances.keys():
			name1 = text2varname(name,poi_type='odbinstance')
			name1 = new_key(varname_to_poiname.keys(),name1)

##			globals()[name1] = oa.instances[name]
			varname_to_poiname[name1] = name
			odb_inst_vars[name] = name1

	return

def create_T_bolt(partname='bolt',D1=12,D0=24,L=10,cap_thick=4,mat=None):

	## VER: ('VER: 2012-07-26, v1.4')	## 0表示螺帽(nut)的圆型垫片，1表示螺柱(stud), L为螺柱的长度（不含螺帽）

	partname = blank_part(partname)
	bolt = _m.parts[partname]

	cylinder_grow(bolt, ndir='z', center0=(0,0,0),  OD=D0, L=cap_thick)
	cylinder_grow(bolt, ndir='z', center0=(0,0,-L), OD=D1, L=L + cap_thick)

	divide(bolt,x=0)
	divide(bolt,y=0)

	KP_set(bolt, (0,0,0),'O1')
	KP_set(bolt, (0,0,-L),'O2')

	if mat == None:
		set_mat(bolt,mat='Steel',subset='_bolt')
	else:
		set_mat(bolt,mat=mat,subset='_bolt')

	faces = face_select(bolt,z=0)
	create_set(bolt,objs=faces, name='fm_' + partname + '_cover')

	faces = face_select(bolt,radius=D1/2)
	create_set(bolt,objs=faces,name='fm_bolt_pin')

	print '--->Created one T_bolt, name=',partname, ', D1=', D1, ', D0=',D0,', L=',L

	return

def create_T_clamp(length=50,clamp_depth=9,height=33,thick=3,mat='Al_6061', name='clamp',global_var=True):

	## VER: ('VER: 2012-07-18, v1.9')	## 不要用Rigid材料

	width = clamp_depth + thick

	clamp_thick = thick
	clamp_height = height
	clamp_length = length
	clamp_width = width

	partname = blank_part(name)
	clamp = _m.parts[partname]

	create_block(clamp,(0,-width),(0,length),(0,-thick))
	create_block(clamp,(0,-thick),(0,length),(0,-height))

	set_mat(clamp,mat=mat)

	faces = faces_of_cut(clamp,z=-thick)
	create_set(clamp,objs=faces,name='fm_clamp_inner_top')

	faces = faces_of_cut(clamp,x=-thick)
	create_set(clamp,objs=faces, name='fm_clamp_inner_side')

	KP_set(clamp)

	if global_var == True:
		local2global(locals(),'clamp_thick','clamp_length','clamp_width','clamp_depth', 'clamp_height')
		write_global_variables(var_file_full,clamp_length)

	new_instance(partname)

	return partname

function_labels['create_tangent_circle'] = 'arc','circle','tangent','radius','center'
def create_tangent_circle(sketch,radius,tangent_line,center_x=None,center_y=None,fix_x=None,fix_y=None, center_line=None,toX=None,toY=None,toCurve=None,side=None):
	## VER: 2015-09-02, v1.6

	## Example
##	line1 = slope_construction(s1,loc=loc1,angle=90 - reduction_angle/2)
##	dict1 = create_tangent_circle(s1,radius=approach_R,center_x=10, center_y=(MAX,-bell_center_to_top),tangent_line=line1, toY=_ymax(s1))
##	connect_points(s1,loc1,dict1['start'])
##	connect_points(s1,dict1['end'],('x',nib_R))

	sketch = check_sketch(sketch)
	sketch.setPrimaryObject(option=STANDALONE)
	sketch.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	if tangent_line not in sketch.geometry.values():
		raise Exception('*** A line or curve is required for tangent.')

	if center_x == '+':
		center_x = 100
	elif center_x == '-':
		center_x = -100

	if center_y == '+':
		center_y = 100
	elif center_y == '-':
		center_y = -100

	if type_of(center_x) == 'TUPLE' and len(center_x) == 2:
		x,dx = center_x
		x = real_xy_sketch(sketch,x=x)[0]
		center_x = x + dx

	if type_of(center_y) == 'TUPLE' and len(center_y) == 2:
		y,dy = center_y
		y = real_xy_sketch(sketch,y=y)[1]
		center_y = y + dy

	circle = create_constraint_circle(sketch, radius=radius, center_x=center_x, center_y=center_y, fix_x=fix_x,fix_y=fix_y,
		center_line=center_line, tangent_line=tangent_line)

	center = circle.getVertices()[-1].coords

	curve_ids0 = totuple(sketch.geometry.keys())	## ids, 可以不连续。用过的id即使被删除了，也不会再使用。
	locs0 = locs_of_sketch_vertices(sketch)   ## [(6.27631484563018e-16, 0.0), (9.28965481714902, 5.91816281720792), (0.0, 10.25)]
##	locs_g = pointOns_of_geometry(sketch)
##	print locs0
##	print locs_g
##	raise Exception

	## 基于位置进行操作，而不是基于geometry来操作。
	new_locs,temp_curves = divide_geometry(sketch,curves=circle,cutter=tangent_line)  ## the circle is divided into two arcs
	tangent_loc = new_locs[0]
	print fnln(),'tangent_loc=',tangent_loc

	line2 = None
	vector = ()
	if (toX,toY,toCurve) != (None,None,None):	## line2用于将circle截断
		if is_number(toX):
			line2 = vertical_construction(sketch,x=toX)
		elif is_geometry(toX,sketch):   ## construction line or circle is also geometry
			line2 = toX
		elif is_number(toY):
			line2 = horizontal_construction(sketch,y=toY)
		elif is_geometry(toY,sketch):
			line2 = toY
		elif is_geometry(toCurve,sketch):
			line2 = toCurve

	end_loc = ()
	if line2 not in empty:
		line2_locs, temp_curves = divide_geometry(sketch,curves=temp_curves,cutter=line2) ## locs,ids

		curves2 = geometry_at(sketch,loc=tangent_loc,side=side)
		connected_locs = vertice_locs_of_geometry(sketch=sketch,geometry=curves2)

		con_locs = round_locs(connected_locs)
		final_locs = [tangent_loc]
		for loc in line2_locs:
			loc1 = round_loc(loc)
			if loc1 in con_locs:
				final_locs.append(loc)
				end_loc = loc
				break
		final_locs = round_locs(final_locs)
		final_locs = sort_locs(final_locs,index=0)
##		print final_locs
##		show_geometry(sketch,curves2)  ## correct, showed two curves connected at tangent_loc

		all_geom = get_connected_geometry(sketch,loc=tangent_loc)  ## Find all the geometry of the circles (4geometry)

		to_del = []
		for curve in all_geom:
			locs = vertice_locs_of_geometry(sketch=sketch,geometry=curve)
			locs = round_locs(locs)
			locs = sort_locs(locs,index=0)
			if locs != final_locs:
				to_del.append(curve)

		if to_del not in empty:
			del_geometry(sketch,curves=to_del)

	if end_loc in empty:
		raise Exception('*** Fail to get the end_loc from tangent_loc for the arc.')

	new_curves = new_geometry_of_sketch(sketch,curve_ids0)
	new_locs = new_points_of_sketch(sketch,locs0)

	dict1 = {}
	dict1['center'] = center
	dict1['start'] = tangent_loc
	dict1['end'] = end_loc
	dict1['geometry'] = new_curves  ## ids
	dict1['vertices'] = new_locs  ## locs
	dict1['tangent_loc'] = tangent_loc

	return dict1

def create_slide_property(name='slide'):
	## VER: 2014-11-17, v1.0 不能分开，但可以滑动
	## purpose: create a interact but with tie effect, so that it can activate or deactivate at specific steps.

	name = new_key(_m.interactionProperties.keys(),name)

	_m.ContactProperty(name)
	_m.interactionProperties[name].TangentialBehavior(formulation=FRICTIONLESS)
	_m.interactionProperties[name].NormalBehavior(pressureOverclosure=HARD, allowSeparation=OFF, constraintEnforcementMethod=DEFAULT)

	return name

def create_tie_property(name='tie'):
	## VER: 2014-11-13, v1.0
	## purpose: create a interact but with tie effect, so that it can activate or deactivate at specific steps.

	name = new_key(_m.interactionProperties.keys(),name)

	_m.ContactProperty(name)
	_m.interactionProperties[name].TangentialBehavior(formulation=ROUGH)  ## No sliding once contact
	_m.interactionProperties[name].NormalBehavior(pressureOverclosure=HARD, allowSeparation=OFF, constraintEnforcementMethod=DEFAULT)

	return name

def create_timepoints(times, name='TimePoints-1',factor=1):
	## VER: 2014-08-29, v1.1

	if type_of(times) == 'STR' and type_of(name) in ['TUPLE','LIST']:
		times, name = name, times

	name = new_key(_m.timePoints.keys(), name)
	if type_of(times) not in ['TUPLE','LIST']:
		raise Exception('*** timepoints are required.')

	table = []
	for time1 in times:
		timepoint = (time1*factor,)
		table.append(timepoint)

	table = remove_repeated_items(table)
	table = _sort(table)

	table = totuple(table)
	_m.TimePoint(name=name, points=table)

	return name

def create_xyplot_annotation(viewport, name='Text1', text='',xloc=80,yloc=60,font=None):
	## VER: 2017-06-07, v1.7

##	path1,note1 = GUI_inputs([('file path',odb_file_full_name),('note',text)],title='Create xyplot annotations',info='Text to show in the xyplot:')
##	print fnln(),'path1=',path1
##	print type_of(path1)
##	print len(path1)
##	if len(path1) > 0:
##		create_xyplot_annotation(viewport=viewport,name='text1',text=path1, xloc=40, yloc=20)
##	if len(note1) > 0:
##		create_xyplot_annotation(viewport=viewport,name='text2',text=note1, xloc=40, yloc =10)

	viewport_type, viewport = check_viewport(viewport)
	dpo = viewport.displayedObject

	if viewport_type != 'XYPLOT':
		raise Exception('*** XYPLOT is required.')

##	min,max = minmax_of_XYPLOT(viewport)
##	print min,max
##	raise Exception
	if text in empty:
		file_name = dpo.curves.values()[0].data.fileName
		loc = file_name.rfind('/')
		file_name = file_name[loc+1:]
##		print fnln(),file_name
		text = file_name

#	if len(viewport.annotationsToPlot) == 0:
#		text = 'Range = ' + str((min,max)) + ',   ' + text

	if font in empty or type_of(font) != 'STR':
		fontstyle = dpo.xyPlotOptions.xAxisTitleFont
	else:
		fontstyle = font

	if 'name' in vpnow.odbDisplay.__members__:
		annotation_name = new_key(odb.userData.annotations.keys(),name)
		t = odb.userData.Text(name=annotation_name, text=text, offset=(xloc, yloc), anchor=BOTTOM_LEFT, referencePoint=BOTTOM_LEFT)
		odb.userData.annotations[annotation_name].setValues(font=fontstyle, color='#0000FF')
		viewport.plotAnnotation(annotation=t)

	else: ## have xyplot, but no odb opened
##		if name in mdb.annotations.keys():
##			del mdb.annotations[name]
##		annotation_name = new_key(mdb.annotations.keys(),name)
		annotation_name = name
		t = mdb.Text(name=annotation_name, text=text, offset=(xloc, yloc), anchor=BOTTOM_LEFT, referencePoint=BOTTOM_LEFT)
		viewport.plotAnnotation(annotation=t)
		mdb.annotations[annotation_name].setValues(font=fontstyle, color='#0000FF')

	return annotation_name

def create_Z_clamp(length=50,clamp_depth=9,height=25,thick=3,U_gap=16, mat='Al_6061',name='clamp',global_var=True):

	## VER: ('VER: 2012-07-22, v1.3')

	width = clamp_depth + thick

	clamp_thick = thick
	clamp_height = height
	clamp_length = length
	clamp_width = width

	partname = blank_part(name)
	clamp = _m.parts[partname]

	create_block(clamp,(0,-width),(0,length),(0,-thick))
	create_block(clamp,(0,-thick),(0,length),(0,-height))
	create_block(clamp,(-thick,U_gap),(0,length),(-height,-height + clamp_thick))

	set_mat(clamp,mat=mat)

	drill_hole(clamp,x=U_gap/2,y=length/2,D=M8,divide_dir='y')

	circular_divide(clamp,ndir='z',center=(U_gap/2, length/2, -height),D=M8+6)

	bias_cut(clamp,x=U_gap/2,cut_sides='+x')

	edges = set2objs(clamp,'e_hole_1')
	faces = edges_to_faces(edges,ndir='z',nz=1)
	create_set(clamp,faces=faces,name='f_clamp_cover_area')

	faces = faces_of_cut(clamp,z=-thick)
	create_set(clamp,objs=faces,name='f_clamp_inner_top')

	faces = faces_of_cut(clamp,x=-thick)
	create_set(clamp,objs=faces, name='f_clamp_inner_side')

	KP_set(clamp)

	if global_var == True:
		local2global(locals(),'clamp_thick','clamp_length','clamp_width','clamp_height','clamp_depth')
		write_global_variables(var_file_full,clamp_length)

	new_instance(partname)

	return partname

def create_cell_block(cell_length=None,cell_gap=None, cell_nums=(1,1),cell_top=(None,0.4),cell_bot=(None,0.4),fill_gap=False):
	## VER: ('VER: 2012-07-16, v3.1')		## 注意，建立cell block，并不等于has_cell=True。use_part(cell)

	global has_cell

	if cell_length in empty:
		cell_length = globals()['cell_length']

	if cell_gap in empty:
		cell_gap = globals()['cell_gap']

	cell_nums = tolist(cell_nums)
	if cell_nums != [1,1] and cell_nums not in empty:
		if 0 in cell_nums:
			cell_numx = 0
			cell_numy = 0
		elif len(cell_nums) == 2:
			cell_numx = cell_nums[0]
			cell_numy = cell_nums[1]
		elif len(cell_nums) == 1:
			cell_numx = cell_numy = cell_nums[0]
	else:
		cell_numx = int(cell_array[0]/2 - 0.5)			;please_check
		cell_numy = int(cell_array[1]/2 - 0.5)

	print 'cell_numx=',cell_numx,', cell_numy=',cell_numy

	if (cell_numx == 0 or cell_numy == 0) and has_cell == True:		##没有建立cell part
		has_cell = False

	if not has_cell:
		file1 = open(var_file_full,'a')
		print >> file1,'##**** cell_parameers:'
		print >> file1,'has_cell = False'
		return

	cell_top = tolist(cell_top)
	if type_of(cell_top) != 'LIST' or len(cell_top) != 2:
		raise Exception('Please provide correct material and its thickness.')

	cell_bot = tolist(cell_bot)
	if type_of(cell_bot) != 'LIST' or len(cell_bot) != 2:
		raise Exception('Please provide correct material and its thickness.')

	partname = blank_part('cell')
	cell = _m.parts[partname]

	block_length = (cell_length + cell_gap)*cell_numx + cell_gap
	block_width = (cell_length + cell_gap)*cell_numy + cell_gap
	unit = cell_length + cell_gap

	create_block(cell,x=(0,block_length),y=(0,block_width),z=(0,cell_thick),mat='Si')

	## Other material
	if cell_top[0] not in empty:
		create_block(cell,(0,block_length), (0, block_width), z=(cell_thick, cell_thick + cell_top[1]), mat=cell_top[0])

	if cell_bot[0] not in empty:
		create_block(cell,(0,block_length), (0, block_width),z=(0,-cell_bot[1]), mat=cell_bot[0])

	create_side_sets(cell,['top','bot'])

	divide(cell,x=cell_gap)
	divide(cell,y=cell_gap)

	for i in myrange(1,cell_numx):
		divide(cell,x=i*unit)
		divide(cell,x=i*unit + cell_gap)

	for i in myrange(1,cell_numy):
		divide(cell,y=i*unit)
		divide(cell,y=i*unit + cell_gap)

	if fill_gap == False:
		hex_cut(cell,x=(0,cell_gap),z=(0,cell_thick))
		for i in range(1,cell_numx + 1):
			hex_cut(cell,x=(i*unit, i*unit + cell_gap),z=(0,cell_thick))

		hex_cut(cell,y=(0,cell_gap),z=(0,cell_thick))
		for i in range(1,cell_numy + 1):
			hex_cut(cell,y=(i*unit, i*unit + cell_gap),z=(0,cell_thick))

	else:
		cells = []
		cell_volume = cell_length*cell_length*cell_thick
		for cell0 in cell.cells:
			if get_volume(cell0) != cell_volume:
				cells.append(cell0)

		cross_set_mat(cell,cells=cells,mat='EVA')

	hex_cut(cell,x=(0,cell_gap/2))
	hex_cut(cell,y=(0,cell_gap/2))

	dir_points(cell,dirs=['x','y'])
	batch_divide(cell,x='p_cell_dirx')
	batch_divide(cell,y='p_cell_diry')

	new_instance(cell)

	file1 = open(var_file_full,'a')
	print >> file1,'##**** cell_parameers:'
	write_global_variables(file1,has_cell,cell_numx,cell_numy,cell_length,cell_thick,cell_gap)
	file1.close()

	line_print(var_file_full,' ')

	return

def create_C_clamp(length=50,width=12,height=None,thick=3,clamp2frame=0.2,mat='Al_6061'):

	## VER: ('VER: 2010-12-26, v1.0')

	width = width + thick

	clamp_thick = thick
	if height in empty:
		height = frame_height + 2*clamp_thick
	clamp_height = height
	clamp_length = length
	clamp_width = width

	bot_width = 30

	partname = blank_part('clamp')
	clamp = _m.parts[partname]

	create_block(clamp,(0,-width),(0,length),(0,-thick))
	create_block(clamp,(0,-thick),(0,length),(0,-height))
	create_block(clamp,(0,-bot_width),(0,length),(-height,-height + clamp_thick))
##	divide(clamp,x=-thick - clamp2frame)

	set_mat(clamp,mat=mat)

	faces = faces_of_cut(clamp,z=-thick)
	create_set(clamp,objs=faces,name='fm_clamp_inner_top')

	faces = faces_of_cut(clamp,z=-height + clamp_thick)
	create_set(clamp,objs=faces, name='fm_clamp_inner_bot')

	faces = faces_of_cut(clamp,z=-height)
	create_set(clamp, objs=faces, name='f_clamp_bot')

	faces = faces_of_cut(clamp,x=-thick)
	create_set(clamp, objs=faces, name='fm_clamp_inner_side')

	KP_set(clamp)

	new_instance(partname)

	local2global(locals(),'clamp_thick','clamp_length','clamp_width','clamp_height','clamp2frame')

	return	partname

def create_side_sets(part,sides=['left','right','top','bot','front','back']):
	## VER: 2011-05-19, v1.0

	part = check_part(part)
	sides = tolist(sides)

	x1,x2,y1,y2,z1,z2 = poi_space(part)

	prefix = 'f_' + part.name + '_'

	if 'left' in sides:
		faces = faces_of_cut(part,x=x1)
		create_set(part,faces=faces,name=prefix + 'left')

	if 'right' in sides:
		faces = faces_of_cut(part,x=x2)
		create_set(part,faces=faces,name=prefix + 'right')

	if 'top' in sides:
		faces = faces_of_cut(part,z=z2)
		create_set(part,faces=faces,name=prefix + 'top')

	if 'bot' in sides:
		faces = faces_of_cut(part,z=z1)
		create_set(part,faces=faces,name=prefix + 'bot')

	if 'front' in sides:
		faces = faces_of_cut(part,y=y1)
		create_set(part,faces=faces,name=prefix + 'front')

	if 'back' in sides:
		faces = faces_of_cut(part,y=y2)
		create_set(part,faces=faces,name=prefix + 'back')

	print '--->created',len(sides),'side sets'

	return

def create_simple_material(name='mat1',modulus=None, poisson=None, CTE=None, density=None,Yield=None):
	## VER: 2015-04-07, v1.0

##	for i in range(1000):  ## 生成1000种材料
##		create_simple_material(modulus=i,poisson=0.23, density=i/10)


	## Example:
##	CTE1 = density_with_PEG_to_CTE(0.5,deltaT=deltaT,C1=C1)
##	CTE2 = density_with_PEG_to_CTE(0.55,deltaT=deltaT,C1=C1)
##	CTE3 = density_with_PEG_to_CTE(0.6,deltaT=deltaT,C1=C1)
##	CTE = density_with_PEG_to_CTE(Rh1, deltaT=deltaT, C1=C1)
##
##	modulus = get_bulk_modulus(583000, 0.23)	;changing
##	mat1 = create_simple_material('mat1',modulus=modulus, poisson=0.23, CTE=CTE1)
##	mat2 = create_simple_material('mat2',modulus=modulus, poisson=0.23, CTE=CTE2)
##	mat3 = create_simple_material('mat3',modulus=modulus, poisson=0.23, CTE=CTE3)
##	mat = create_simple_material('mat',modulus=modulus, poisson=0.23, CTE=CTE)


	mat = new_key(_m.materials.keys(),name)

	_m.Material(name=mat)
	if is_numbers(modulus,poisson):
		_m.materials[mat].Elastic(table=((modulus, poisson), ))
	if is_number(CTE):
		_m.materials[mat].Expansion(table=((CTE, ), ))
	if is_number(density):
		_m.materials[mat].Density(table=((density, ), ))

	if is_number(Yield):
		_m.materials[mat].Plastic(temperatureDependency=OFF, table=((Yield,0),))

	_m.HomogeneousSolidSection(name=mat, material=mat, thickness=None)

	return mat

def create_single_cell(size=None):
	## VER: 2011-01-29, v1.8

	if size in empty:
		cell_length = 156
	else:
		cell_length = size

	cell_width = cell_length
	cell_thick = 0.18
	EVA1_thick = EVA_thick/2
	cell_gap = 2.5   ##???****

	partname = blank_part('cell')
##	cell = _m.parts[partname]

	create_block(cell,(0,cell_length),(0,cell_length),(0,cell_thick))
	batch_divide(cell,z=[cell_thick,cell_thick/2])

	create_block(cell,(0,cell_length),(0,cell_length),(cell_thick,cell_thick + EVA_thick/2))
	divide(cell,z=cell_thick + EVA1_thick/2)

	divide(cell,x=cell_length/2)
	divide(cell,y=cell_length/2)

	cells = cell_select_by_container(cell,z=(0,cell_thick))
	set_mat(cell,cells=cells,mat=Si)

	cells = cell_select_by_container(cell,z=(cell_thick, cell_thick + EVA_thick/2))
	set_mat(cell,cells=cells,mat=EVA2)  ##???****

	faces = faces_of_cut(cell,z=MAX)
	create_set(cell, objs=faces, name='fs_cell_top')

	KP_set(cell,x=cell_length/2,y=cell_length/2,z=MAX)

	if _module_type == 'U':
		move_part(cell,x1=_xmin(cell),x2=_xmid(lam) + cell_gap/2, y1=_ymid(cell),y2=_ymid(lam),z1=_zmax(cell),z2=_zmin(lam,x=MID,y=MID))
	else:
		move_part(cell,x1=_xmin(cell),x2=_xmid(lam) + cell_gap/2, y1=_ymin(cell),y2=_ymid(lam) + cell_gap/2,
			z1=_zmax(cell),z2=_zmin(lam,x=MID,y=MID))

	local2global(locals(),'cell_length','cell_thick','cell_gap')

	return

def create_circular_shell(p,ndir, center=(),D=16, L=10, ptype='deformable', radius=None, OD=None, ID=None, thick=None,temp=False, cells=None, ref_face=None,faces=None):
	## VER: ('VER: 2014-08-08, v1.0')	## 应该在move_part之前进行。
	## cut or divide均是逆着：若ndir='x',则center的x值应该取最大值。其他方向也如此。
	## Example: 	create_circular_shell('shell',ndir='y',L=punch_L, ID=shell_D,thick=0.5)

	get_current_model()

	if is_part(p):
		p = check_part(p)
	elif type_of(p) == 'STR':
		partname = blank_part(p,ptype=ptype)
		p = _m.parts[partname]

	if ndir not in ['x','y','z']:
		raise Exception('*** axial dir should be in x, y, or z')

	if center in empty:
		if ref_face in empty:
			faces1 = face_select(p,ndir='cylindrical')
			if faces1 in empty:
				faces1 = face_select(p,ndir='conical')

			if faces1 not in empty:
				ref_face = faces1[0]

	if ref_face not in empty:
		ndir0 = face_ndir(ref_face)
		if ndir0 not in ['cylindrical', 'conical']:
			raise Exception('*** a cylindrical face is required.')
		else:
			center,vector0,axis0 = center_axis_of_cylind_face(ref_face)

	if center in empty:
		center = (0,0,0)

	center = list(center)

	if temp == True:
		if len(p.vertices) > 0:
			x1,x2,y1,y2,z1,z2 = poi_space(p)
			if ndir == 'x':
				offset = x2 + 10
			elif ndir == 'y':
				offset = y2 + 10
			elif ndir == 'z':
				offset = z2
		else:
			offset = 0
	else:
		if ndir == 'x':
			offset = center[0]
		elif ndir == 'y':
			offset = center[1]
		elif ndir == 'z':
			offset = center[2]

	datum_plane, right_edge = datum_plane_and_right_axis(p, offset=offset, ndir=ndir)
	s = datum_plane_to_blank_sketch(datum_plane, right_edge=right_edge)

	if ndir == 'y':
		side = SIDE2
	else:
		side = SIDE1

	if radius in empty:
		radius = D/2.0

	if is_number(ID) and type_of(OD) not in numerics:
		if is_number(thick):
			OD = ID + 2*thick
		else:
			OD = D
	elif is_number(OD) and type_of(ID) not in numerics:
		if is_number(thick):
			ID = OD - 2*thick
		else:
			ID = D

	## conver 3D points to sketch points
	x0,y0 = threeD_to_sketch_points(center,ndir)

	obj_type = None
	if is_numbers([ID,OD]):
		s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + ID/2.0, y0))
		s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + OD/2.0, y0))
		obj_type = 'solid'
	else:
		s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + D/2.0, y0))
		obj_type = 'shell'

	if obj_type == 'solid':
		cells0 = tolist(p.cells)  		## 参考SolidRevolve, 见revolve_sketch_to_part()
		p.SolidExtrude(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=side,
		    sketchOrientation=RIGHT, sketch=s, depth=abs(L), flipExtrudeDirection=OFF)
		obj = unselect(p.cells,cells0)[0]

		pointOn = obj.pointOn[0]	## face1 index will be changed after partition.

	elif obj_type == 'shell':
		faces0 = tolist(p.faces)
		p.ShellExtrude(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=side,
		    sketchOrientation=RIGHT, sketch=s, depth=abs(L), flipExtrudeDirection=OFF)
		obj = unselect(p.faces, faces0)[0]

		pointOn = obj.pointOn[0]	## face1 index will be changed after partition.

	get_current_model()

	return obj


def create_clamp_contacts(clamps=None,prop='Frictionless'):

	## VER: ('VER: 2012-03-12, v1.8')

	if clamps in empty:
		clamps = find_mdb_insts('clamp')

	y_frms = find_mdb_insts('frL')
	x_frms = find_mdb_insts('frS')

	if y_frms in empty and x_frms in empty:  ## frm_A1 instead
		print fnln_fnln(),'******No instances of frL and frS.'

		mfaces = faces_of_cut(clamp_A1,z=_zmax(clamp_A1) - clamp_thick)
		s2s_interact_std(mfaces = mfaces, slave_inst=frm_A1,fix=clamp_A1.name)

		mfaces = faces_of_cut(clamp_A1,x=_xmax(clamp_A1) - clamp_thick)
		s2s_interact_std(mfaces = mfaces, slave_inst=frm_A1,fix=clamp_A1.name)

		return

	frms={}
	frms['x'] = x_frms
	frms['y'] = y_frms

	print ' '
	print '**Creating contacts for',poi_names(clamps),'...'

	for inst in clamps:
		normal = section_normal(inst)
		print 'normal=',normal

		mfaces = faces_of_cut(inst,z=_zmax(inst) - clamp_thick)
		find_contacts(mfaces=mfaces, prop=prop, refined_insts='both',action=clamp2frL)	;please_check

		if normal == 'y':
			mfaces = faces_of_cut(inst,x=_xmax(inst,z=MAX) - clamp_thick)
			if len(mfaces) > 0:
				find_contacts(mfaces=mfaces, mate_insts=frms[normal], action='interact',prop=prop, force_create=True, refined_insts='both')

		elif normal == 'x':
			mfaces = faces_of_cut(inst,y=_ymax(inst,z=MAX) - clamp_thick)
			if len(mfaces) > 0:
				find_contacts(mfaces=mfaces, mate_insts=frms[normal], action='interact',prop=prop, force_create=True, refined_insts='both')

	return

def create_constraint_circle(sketch, circle=None,radius=None,center_x=None,center_y=None,fix_x=None,fix_y=None,center_line=None,tangent_line=None):
	## VER: 2014-10-30, v1.0
	## reference: create_tangent_circle()

	sketch = check_sketch(sketch)

	if circle in empty and radius in empty:
		raise Exception('*** circle or radius is required.')

	center_x,center_y = real_xy_sketch(sketch,center_x,center_y)

	if center_x in empty:
		center_x = 0

	if center_y in empty:
		center_y = 0

	if type_of(radius) in numerics:
		if circle in empty:
			circle = create_circle(sketch,center=(center_x,center_y),radius=radius)
	if is_geometry(circle) == False:
		raise Exception('*** a circle is required.')

	if radius in empty:
		radius = radius_of_geometry(circle)

	center = circle.getVertices()[-1].coords
	point1 = center[0] + radius + 10, center[1] + 5

	dim1 = sketch.RadialDimension(curve=circle, textPoint=point1, radius=radius)
	constraints = [dim1]

	if is_number(center_x) and fix_x == True:
		center_line = vertical_construction(sketch,x=center_x)
		constraints.append(center_line)
	elif is_number(center_y):
		center_line = horizontal_construction(sketch,y=center_y)
		constraints.append(center_line)

	if is_geometry(center_line) and fix_y == True:
		const1 = sketch.FixedConstraint(entity=center_line)
		const2 = sketch.CoincidentConstraint(entity1=sketch.vertices.findAt(center), entity2=center_line, addUndoState=False)
		constraints = [dim1,const1,const2]

	if is_geometry(tangent_line):
		const3 = sketch.FixedConstraint(entity=tangent_line)
		constraints.append(const3)

		const4 = sketch.TangentConstraint(entity1=circle, entity2=tangent_line)
		constraints.append(const4)

	center = get_circle_center(circle)
	print fnln(),'center=',center

	objs = constraints + [circle]

	sketch.delete(objectList=totuple(objs))
	circle = create_circle(sketch,center=center,radius=radius)  ## 重新生成circle

	return circle

def create_constraint_equation(nodes1,nodes2,dof1=3,dof2=None,coeff1=1,dof=None,coeff2=-1,name='Equation-1'):
	## VER: 2015-06-23, v1.0, 约束方程, interaction模块
	## Example: Set1:DOF3 - Set2:DOF2 = 0, coeff1=1, coeff2=-2

##		nodes = set2objs('dim_smallR_y')
##		set1 = create_set(setname='eq_node1',nodes=nodes[0])
##		set2 = create_set(setname='eq_node2',nodes=nodes[1])
##		_m.Equation(name='Constraint-1', terms=((1.0, 'eq_node2', 3), (-1.0, 'eq_node1', 3)))


##	_m.Equation(name=name, terms=((1.0, 'eq_node1', 3), (-1.0, 'eq_node2', 3)))

##	create_constraint_equation(node1,node2,dof='Uz')

##	>>> create_constraint_equation(node1,node2,dof=3)
##	['create_constraint_equation', 72] --->Created constraint equation: (1, 'eq_set1', 3) (-1, 'eq_set2', 3)
##	'Equation-1'
##	>>>

	if is_number(dof):
		dof1 = dof2 = dof

	if dof1 in ['U1','Ux']:
		dof1 = 1
	elif dof1 in ['U2','Uy']:
		dof1 = 2
	elif dof1 in ['U3','Uz']:
		dof1 = 3

	if dof2 in ['U1','Ux']:
		dof2 = 1
	elif dof2 in ['U2','Uy']:
		dof2 = 2
	elif dof2 in ['U3','Uz']:
		dof2 = 3

	if dof2 in empty:
		dof2 = dof1

	if is_numbers(dof1,dof2) == False:
		raise Exception('*** dof1,dof2 should be 1,2, or 3')

	if dof1 not in [1,2,3,4,5,6]:
		raise Exception('*** dof1 should be in 1,2,3,4,5,6')

	if dof2 not in [1,2,3,4,5,6]:
		raise Exception('*** dof2 should be in 1,2,3,4,5,6')

	if type_of(nodes1) != 'STR':
		nodes1 = tolist(nodes1)
		if type_of(nodes1[0]) != 'nodes':
			raise Exception('*** nodes or node set is required.')

		set1 = new_key(a.sets.keys(),'eq_set1')
		create_set(setname=set1,nodes=nodes1)

	else:
		if nodes1 in a.sets.keys():
			set1 = nodes1
		else:
			raise Exception('*** Cannot found the set in a.sets.keys()')

	if type_of(nodes2) != 'STR':
		nodes2 = tolist(nodes2)
		if type_of(nodes2[0]) != 'nodes':
			raise Exception('*** nodes or node set is required.')
		elif len(nodes2) > 1:
			raise Exception('*** Only one node is allowd for nodes2')

		set2 = new_key(a.sets.keys(),'eq_set2')
		create_set(setname=set2,nodes=nodes2)

	else:
		if nodes2 in a.sets.keys():
			set2 = nodes2
		else:
			raise Exception('*** Cannot found the set in a.sets.keys()')

	if is_numbers(coeff1,coeff2) == False:
		raise Exception('*** coeff1 and coeff2 should be numbers.')

	name = new_key(_m.constraints.keys(),name)
	_m.Equation(name=name, terms=((coeff1, set1, dof1), (coeff2, set2, dof2)))

	print fnln(),'--->Created constraint equation:',(coeff1, set1, dof1), (coeff2, set2, dof2)

	return name

def create_construction(sketch,point1=(0,0),point2=(),x=None,y=None,angle=None,center=(),Ax=None,Ay=None,radius=None,fix=True):
	## VER: 2015-10-29, v1.4
	## default to create a vertical construction line passing through (0,0)
	## 例如ptype=axisymmetric时的2D模型，需要建立轴对称的模型和竖直对称轴。

	## Example:
##	line1 = create_construction(s1,point1=last_point,Ay=-tpunch_land_angle)

	## create_construction(sketch,point1=(0,0),angle=0)
	## create_construction(sketch,point1=(0,0),angle=90)
	## create_construction(s1,x=-1)
	## mirror_line = create_construction(sketch,x=1.0)

	s = check_sketch(sketch)

	x,y = real_xy_sketch(sketch,x=x,y=y)

	if type_of(x) in numerics and type_of(y) in numerics:
		point1 = (x,y)
	elif type_of(x) in numerics:
		point1 = (x,0)
		angle = 90
	elif type_of(y) in numerics:
		point1 = (0,y)
		angle = 0

	if angle in empty:
		if is_number(Ax):   ## angle with axis x
			if Ax > 0:
				angle = Ax
			else:
				angle = 360 - abs(Ax)
		elif is_number(Ay):
			if Ay > 0:   ## right side of axis Y
				angle = 90 - Ay
			else:
				angle = 90 + abs(Ay)

	if is_number(angle) == False:
		raise Exception('*** angle is required.')

	if type_of(point1) == 'vertices':
		point1 = point1.coords

	if type_of(point1) != 'TUPLE':
		raise Exception('** Please provide the location of point1 for the construction line.')

	print fnln(),'point1=',point1

	if point2 not in empty:
		s.ConstructionLine(point1=point1, point2=point2)
	elif center not in empty:
		s.ConstructionCircleByCenterPerimeter(center=center, point1=point1)
	elif radius not in empty:
		center = point1[0],point1[1] + radius
	elif angle not in empty:
		s.ConstructionLine(point1=point1, angle=angle)

	entity = s.geometry.values()[-1]
	if fix == True:
		s.FixedConstraint(entity=entity)

	return entity   ## 返回construction line

function_labels['create_contact_friction'] = 'friction coefficient','tie','seperate','interact','contact','property'
def create_contact_friction(friction=0.15, coeff=None,prefix='Friction',name=None,allow_separation=True):
	## VER: 2017-06-09, v1.4
	## reference: create_contact_props()

	## create_contact_friction(name='Friction',friction=0.1)

##	>>> create_contact_friction(0)
##	The interaction property "Frictionless" has been created.
##	'Frictionless'
##	>>>

	if name in empty:
		if friction > 0:
			name = prefix + '_' + str(friction)
			name = modify_string(name,'.')		## 名字中不能含有小数点
		else:
			name = 'Frictionless'

	if name in _m.interactionProperties.keys():
		del _m.interactionProperties[name]

	if is_number(coeff):
		friction = coeff

##	if name not in _m.interactionProperties.keys():
	if allow_separation == True:
		allow_separation = ON
	else:
		allow_separation = OFF   ## 只允许滑动，不允许分离。

	_m.ContactProperty(name)
	_m.interactionProperties[name].NormalBehavior(pressureOverclosure=HARD, allowSeparation=allow_separation,
	    constraintEnforcementMethod=DEFAULT)
	if friction > 0:
		_m.interactionProperties[name].TangentialBehavior(
		    formulation=PENALTY, directionality=ISOTROPIC, slipRateDependency=OFF,
		    pressureDependency=OFF, temperatureDependency=OFF, dependencies=0, table=((
		    friction, ), ), shearStressLimit=None, maximumElasticSlip=FRACTION,
		    fraction=0.005, elasticSlipStiffness=None)   ## 罚函数
	else:
		_m.interactionProperties[name].TangentialBehavior(formulation=FRICTIONLESS)

##	else:
##		print '*** friction property', name,'has been exists. Will not create again'

	return name

function_labels['create_contact_props'] = 'friction','coefficient','interact','heat convection','heat generation'
def create_contact_props(friction=0.15,allow_seperation=ON, heat_fric=None, gap_conductance = 100000,
	conduct_gap=0.1,shear_stress_limit=None, formulation = PENALTY,	constraint=DEFAULT):
	## VER: 2015-04-02, v1.6
	## usually, shear_stress_limit = yield stress / 1.732
	## 输入剪应力极限，将更容易滑动。摩擦系数的影响减弱
	## 两接触面的粘着约束可用拉格朗日乘子法正确实现
	## reference: create_contact_friction()

## Gap conductance的例子：
##	*Gap Conductance
##	10, 0
##	2, 0.01
##	0, 0.1

	gap_conductance = gap_conductance*K_hc	## 接触传热系数，标准单位：W/m2-K

	formulation = totext(formulation).lower()
	if formulation in ['penalty', 'default']:
		formulation = PENALTY
	elif 'lagrange' in formulation or 'multiplier' in formulation:
		formulation = LAGRANGE		## 适用于abaqus / standard

	constraint = totext(constraint).lower()
	if constraint == 'default':
		constraint = DEFAULT
	elif 'augmented' in constraint or 'lagrange' in constraint:
		constraint = AUGMENTED_LAGRANGE   ## 仅适用于abaqus/standard
	elif 'direct' in constraint:
		constraint = DIRECT   ## 仅适用于abaqus/standard
	elif 'penalty' in constraint:
		constraint = PENALTY

	name1 = 'Frictionless'
	_m.ContactProperty(name1)
	_m.interactionProperties[name1].TangentialBehavior(formulation=FRICTIONLESS)
	_m.interactionProperties[name1].NormalBehavior(pressureOverclosure=HARD, allowSeparation=ON, constraintEnforcementMethod=DEFAULT)

##mdb.models['Model-1'].interactionProperties['Friction + Heat conduction'].normalBehavior.setValues(
##    pressureOverclosure=HARD, allowSeparation=ON, contactStiffness=DEFAULT,
##    contactStiffnessScaleFactor=1.0, clearanceAtZeroContactPressure=0.0,
##    constraintEnforcementMethod=AUGMENTED_LAGRANGE)

	name1 = 'Friction'
	_m.ContactProperty(name1)
	_m.interactionProperties[name1].NormalBehavior(pressureOverclosure=HARD, allowSeparation=allow_seperation,
	    constraintEnforcementMethod=constraint)
	if friction > 0:
		_m.interactionProperties[name1].TangentialBehavior(
		    formulation=formulation, directionality=ISOTROPIC, slipRateDependency=OFF,
		    pressureDependency=OFF, temperatureDependency=OFF, dependencies=0, table=((
		    friction, ), ), shearStressLimit=None, maximumElasticSlip=FRACTION,
		    fraction=0.005, elasticSlipStiffness=None)

		if is_number(shear_stress_limit):
			_m.interactionProperties[name1].tangentialBehavior.setValues(shearStressLimit=shear_stress_limit)

		if constraint == PENALTY:
			_m.interactionProperties[name1].normalBehavior.setValues(
			    pressureOverclosure=HARD, allowSeparation=allow_seperation, contactStiffness=DEFAULT,
			    contactStiffnessScaleFactor=1.0, clearanceAtZeroContactPressure=0.0,
			    stiffnessBehavior=NONLINEAR, stiffnessRatio=0.01, upperQuadraticFactor=0.03, lowerQuadraticRatio=0.33333,
			    constraintEnforcementMethod=PENALTY)

	else:
		_m.interactionProperties[name1].TangentialBehavior(formulation=FRICTIONLESS)

	name1 = 'Friction + Heat generation'
	_m.ContactProperty(name1)
	_m.interactionProperties[name1].NormalBehavior(pressureOverclosure=HARD, allowSeparation=allow_seperation,
	    constraintEnforcementMethod=constraint)
	if friction > 0:
		_m.interactionProperties[name1].TangentialBehavior(
		    formulation=formulation, directionality=ISOTROPIC, slipRateDependency=OFF,
		    pressureDependency=OFF, temperatureDependency=OFF, dependencies=0, table=((
		    friction, ), ), shearStressLimit=None, maximumElasticSlip=FRACTION,
		    fraction=0.005, elasticSlipStiffness=None)
		if is_number(shear_stress_limit):
			_m.interactionProperties[name1].tangentialBehavior.setValues(shearStressLimit=shear_stress_limit)

		if constraint == PENALTY:
			_m.interactionProperties[name1].normalBehavior.setValues(
			    pressureOverclosure=HARD, allowSeparation=allow_seperation, contactStiffness=DEFAULT,
			    contactStiffnessScaleFactor=1.0, clearanceAtZeroContactPressure=0.0,
			    stiffnessBehavior=NONLINEAR, stiffnessRatio=0.01, upperQuadraticFactor=0.03, lowerQuadraticRatio=0.33333,
			    constraintEnforcementMethod=PENALTY)

	else:
		_m.interactionProperties[name1].TangentialBehavior(formulation=FRICTIONLESS)

	_m.interactionProperties[name1].ThermalConductance(
	    definition=TABULAR, clearanceDependency=ON, pressureDependency=OFF,
	    temperatureDependencyC=OFF, massFlowRateDependencyC=OFF, dependenciesC=0,
	    clearanceDepTable=((gap_conductance, 0.0), (0.0, conduct_gap)))   ## 关键字：*Gap Conductance
	_m.interactionProperties[name1].HeatGeneration(conversionFraction=1.0, slaveFraction=0.5)  ## default for heat generation

	name1 = 'Friction + Heat conduction'
	_m.ContactProperty(name1)
	_m.interactionProperties[name1].NormalBehavior(pressureOverclosure=HARD, allowSeparation=allow_seperation,
	    constraintEnforcementMethod=constraint)
	if friction > 0:
		_m.interactionProperties[name1].TangentialBehavior(
		    formulation=formulation, directionality=ISOTROPIC, slipRateDependency=OFF,
		    pressureDependency=OFF, temperatureDependency=OFF, dependencies=0, table=((
		    friction, ), ), shearStressLimit=None, maximumElasticSlip=FRACTION,
		    fraction=0.005, elasticSlipStiffness=None)
		if is_number(shear_stress_limit):
			_m.interactionProperties[name1].tangentialBehavior.setValues(shearStressLimit=shear_stress_limit)

		if constraint == PENALTY:
			_m.interactionProperties[name1].normalBehavior.setValues(
			    pressureOverclosure=HARD, allowSeparation=allow_seperation, contactStiffness=DEFAULT,
			    contactStiffnessScaleFactor=1.0, clearanceAtZeroContactPressure=0.0,
			    stiffnessBehavior=NONLINEAR, stiffnessRatio=0.01, upperQuadraticFactor=0.03, lowerQuadraticRatio=0.33333,
			    constraintEnforcementMethod=PENALTY)

	else:
		_m.interactionProperties[name1].TangentialBehavior(formulation=FRICTIONLESS)

	_m.interactionProperties[name1].ThermalConductance(
	    definition=TABULAR, clearanceDependency=ON, pressureDependency=OFF,
	    temperatureDependencyC=OFF, massFlowRateDependencyC=OFF, dependenciesC=0,
	    clearanceDepTable=((gap_conductance, 0.0), (0.0, conduct_gap)))

	please_check
	name1 = 'Heat convection'   ## K_hc = 0.001
	_m.FilmConditionProp(name=name1, temperatureDependency=ON, dependencies=0,
		property=((5.0*K_hc, 0.0),(8.0*K_hc, 50.0), (10.0*K_hc, 100.0), (12.5*K_hc, 150.0), (15*K_hc, 200.0),(30*K_hc, 300.0), (50*K_hc, 400.0),(100*K_hc, 600.0)))

	name1 = 'No seperation'
	create_tie_property(name=name1)
	_m.interactionProperties[name1].ThermalConductance(
	    definition=TABULAR, clearanceDependency=ON, pressureDependency=OFF,
	    temperatureDependencyC=OFF, massFlowRateDependencyC=OFF, dependenciesC=0,
	    clearanceDepTable=((gap_conductance, 0.0), (0.0, conduct_gap)))

	_m.setValues(stefanBoltzmann=5.67e-8*K_sflux)

	return

function_labels['create_contacts'] = 'PV','suntech','module','interact','find'
def create_contacts():
	## VER: ('VER: 2012-11-01, v2.0')		## modal

	if has_mount_clamp == True:
		if clamp_friction == False:
			create_clamp_contacts(prop='Frictionless')		;please_check
		else:
			create_clamp_contacts(prop='Friction')

##		if has_dam == True:
##			s2s_interact_std(mfaces=zmin_faces(dam_A1),sfaces=zmax_faces(clamp_A1), force_create=True)

	for inst in find_mdb_insts('rail'):
		find_contacts(mfaces=zmax_faces(inst),slave_parts=find_mdb_parts('frL','frS','frm'), action=rail2frL,refined_insts='both', prop='Friction')
		please_check

		if _step(1).procedureType != FREQUENCY:
			rail_dir = get_beam_dir(inst)

			if rail_dir == 'x' and _xlength(inst) > _xlength(lam)/2:
				faces_glass = faces_of_cut(lam_A1,z=_zmin(lam_A1,x=MID,y=MID))
				faces_rail = face_select(inst,faces=zmax_faces(inst),x=(MIN,_xmax(lam)))
				s2s_interact_std(mfaces=faces_glass,sfaces=faces_rail,force_create=True)		;please_check

			elif rail_dir == 'y' and _ylength(inst) > _ylength(lam)/2:
				faces_glass = faces_of_cut(lam_A1,z=_zmin(lam_A1,x=MID,y=MID))
				faces_rail = face_select(inst,faces=zmax_faces(inst),y=(MIN,_ymax(lam)))
				s2s_interact_std(mfaces=faces_glass,sfaces=faces_rail,force_create=True)		;please_check

	if has_frame == True:
		create_module_contacts()    ## 9(no cell),or 10(has cell)

##	if has_mount_bolt == True:
##		find_contacts(mfaces='fm_bolt_stud',slave_parts=find_mdb_parts('frL','frm','rail','gasket'),action='interact',fix='-bolt')
##		find_contacts(mfaces='fm_bolt_nut_high',slave_parts=find_mdb_parts('frL','frm',),action='interact',prop='Frictionless')		;please_check
##		find_contacts(mfaces='fm_bolt_nut_low',slave_parts='rail',action='interact',prop='Frictionless')	;please_check

	return

def create_coupled_temp_displacement_step(stepname='step1',step=None, prestep='',period=1.0, timePeriod=None,initial_inc=0.01,
	max_inc=None,fix_inc=False,response='steady',delta_Tmax=5,time_scale=1, mass_scale=None):
	## VER: ('VER: 2015-04-01, v3.4')
	## LS-DYNA: mass_scale = damping_scale*damping_scale
	## 隐式的温度热力耦合分析和显式的温度热力耦合分析。采用隐式时，耦合分析的效率非常低，算得很慢。
	## 如果是一个动力学过程（如拉丝），隐式算法甚至可能不收敛。

	global my_steps

##	create_general_static_step('heating', period=1)
##	create_general_static_step('bonding', period=1)  ## stress free
##	create_coupled_temp_displacement_step('cooling', period=250,response='transient')  ## time dependent

##	check_suitable_step(fn())

	if type_of(step) == 'STR':
		stepname = step

	stepname = new_key(_m.steps.keys(),stepname,force_new_key=True)		;please_check
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('No such prestep',prestep)

	if is_number(timePeriod):
		period = timePeriod

	if response in ['static','steady']:   ## steady-state analysis
		_m.CoupledTempDisplacementStep(name=stepname, description='steady temp-disp coupled analysis', previous=prestep, response=STEADY_STATE,
			timePeriod=period, initialInc=initial_inc*period, deltmx=None, cetol=None, creepIntegration=None, amplitude=RAMP, nlgeom=ON,maxNumInc=2000)

		_m.steps[stepname].setValues(stabilizationMagnitude=0.0002, stabilizationMethod=DISSIPATED_ENERGY_FRACTION,
		    continueDampingFactors=False, adaptiveDampingRatio=0.05)

	elif response in ['implicit','transient', 'dynamic','explicit']:   ## transient analysis
		if max_inc == None:
			max_inc = period

		if response in ['implicit', 'transient']:
			if fix_inc == False:
				_m.CoupledTempDisplacementStep(name=stepname, description='transient temp-disp coupled analysis', previous=prestep, nlgeom=ON,
					timePeriod=period, initialInc=initial_inc*period, minInc=0.0001*period, maxInc=max_inc, deltmx=delta_Tmax,maxNumInc=2000)
			else:
				_m.CoupledTempDisplacementStep(name=stepname, description='transient temp-disp coupled analysis',previous=prestep, timePeriod=period,
					timeIncrementationMethod=FIXED, initialInc=initial_inc*period, deltmx=None, cetol=None, creepIntegration=None, nlgeom=ON,maxNumInc=2000)

		 	_m.steps[stepname].setValues(stabilizationMagnitude=0.0002, stabilizationMethod=DISSIPATED_ENERGY_FRACTION,
			    continueDampingFactors=False, adaptiveDampingRatio=0.05)

 		elif response in ['dynamic','explicit']:
 			if fix_inc == True:
 				timeIncrementationMethod = FIXED_EBE
 			else:
 				timeIncrementationMethod = AUTOMATIC_GLOBAL

##			_m.TempDisplacementDynamicsStep(name=stepname,
##			    previous=prestep, timePeriod=period, scaleFactor=time_scale, massScaling=((
##			    SEMI_AUTOMATIC, MODEL, AT_BEGINNING, 1000.0, 0.0, None, 0, 0, 0.0, 0.0, 0, None), ))

			_m.TempDisplacementDynamicsStep(name=stepname, description = 'explicit dynamic temp-displacement analysis', timeIncrementationMethod=timeIncrementationMethod,
				previous=prestep, timePeriod=period, scaleFactor=time_scale)	 ## can also add mass scale

##			print fnln(),'mass_scale=',mass_scale
##			raise Exception

			if is_number(mass_scale):
				if mass_scale < 1:
					raise Exception('*** mass_scale should greater than 1')

				_m.steps[stepname].setValues(massScaling=((SEMI_AUTOMATIC, MODEL, AT_BEGINNING, mass_scale, 0.0, None, 0, 0, 0.0, 0.0, 0, None), ))

##			mdb.models['Model-1'].TempDisplacementDynamicsStep(name='Step-1',
##			    previous='Initial', massScaling=((SEMI_AUTOMATIC, MODEL, AT_BEGINNING,
##			    1000.0, 0.0, None, 0, 0, 0.0, 0.0, 0, None), ))

##			_m.TempDisplacementDynamicsStep(name=stepname, previous=prestep, timePeriod=timePeriod, timeIncrementationMethod=timeIncrementationMethod,
##			    massScaling=((SEMI_AUTOMATIC, MODEL, AT_BEGINNING, scale_factor, 0.0, None, 0, 0,  0.0, 0.0, 0, None), ))	## mass scale

##	create_T_output('T_output',step=stepname)

	step = _m.steps[stepname]
	my_steps[len(_m.steps) - 1] = {'procedureType': step.procedureType, 'domain': TIME, 'type': type_of(step), 'name': stepname,
		'function': 'create_coupled_temp_displacement_step'}

	print fnln_fnln(),stepname,'is created, type=',type_of(_m.steps.values()[-1])
	if response == 'transient':
		print 'period=',period,'sec, max_inc=',max_inc,'sec, fix_inc=',fix_inc,'sec'
	print ' '

	return stepname

def create_csys(poa=None,loc=(),name='origin_csys',x=0,y=0,z=0,csys_type=CARTESIAN, axial_dir='x', U1_point=None,
	U2_point=None,mirror=None, mirror1=None,mirror2=None):
	## VER: ('VER: 2016-05-24, v2.2')

	## RP可以作为显式的当前局部坐标系。而CSYS可作为显式的vertice set. RP可以位于任何地方，但作为KP set的CSYS最好位于vertice处。
	## 注意：建立CSYS不需要在非要在某个vertice上。即使当前part没有vertices，也可以建立CSYS和RP。
	## 不过，当移动part时，csys和RP并不自动跟着移动。
	## 为此，可以选择part的某个点建立其setname=O1，然后始终在此点上有csys, name=O1.
	## 让局部坐标系的位置用RP的位置来表示，则局部坐标系回到O1时，令RP也位于O1
	## 也就是说，RP代表当前的某个局部坐标系的位置。
	## Reference Point和CSYS都是part的feature

	## reference: create_cylind_csys()
	## Example: create_csys(x=640)  ## will create a local csys.
	## >>> create_csys(x=640,mirror1='x')

	mirror1 = get_real_input(mirror1, mirror)

	if is_pia(poa):
		poa = check_pias(poa)
		if type_of(poa) == 'PINSTANCE':
			poa = a

		if name in poa.features.keys():
			del poa.features[name]
	elif type_of(poa) == 'ODB':
		if 'openOdb' in repr(poa):
			poa = session.ScratchOdb(poa)
		poa = poa.rootAssembly
	else:
		dpo = get_dpo()
		if type_of(dpo) == 'ASSEMBLY':
			poa = dpo
		elif type_of(dpo) == 'ODB':
##			poa = dpo.rootAssembly
			poa = session.ScratchOdb(dpo).rootAssembly   ## csys create in session, not in odb
		elif type_of(dpo) == 'PART':
			poa = dpo
		else:
			raise Exception('*** part,instance,assembly, or odb is requred.')

	if type_of(loc) == 'vertices':
		loc = loc.pointOn[0]
	elif type_of(loc) == 'DATUMPOINT':
		loc = loc.pointOn
	elif type_of(loc) == 'referencePoints':
		loc = RPxyz

	if loc in empty:
		if is_numbers(x,y,z) == False:
			raise Exception('*** x,y,z error for the csys loc.')
		loc = (x,y,z)

	if len(loc) == 2:
		dimensionality = 2
		loc0 = (0,0)
	elif len(loc) == 3:
		dimensionality = 3
		loc0 = (0,0,0)
	else:
		dimensionality = 1
		loc0 = (0,)

	csys_type = totext(csys_type).lower()
	if csys_type.startswith('car'):
		csys_type = CARTESIAN
	elif csys_type.startswith('cylin'):
		csys_type = CYLINDRICAL
	elif csys_type.startswith('spher'):
		csys_type = SPHERICAL

	U1_dir = (1,0,0)
	U2_dir = (0,1,0)
	if U1_point in empty or U2_point in empty:
		if csys_type == CARTESIAN:
			if dimensionality == 3:
				U1_dir = (1,0,0)
				U2_dir = (0,1,0)
			elif dimensionality == 2:
				U1_dir = (1,0)
				U2_dir = (0,1)
		elif csys_type == CYLINDRICAL:
			if axial_dir == 'x':   ## yoz
				if dimensionality == 3:
					U1_dir = (0,1,0)
					U2_dir = (0,0,1)
			elif axial_dir == 'y':   ## zox
				if dimensionality == 3:
					U1_dir = (0,0,1)   ## 注意不用(0,0,-1)
					U2_dir = (1,0,0)
			elif axial_dir == 'z':   ## xoy
				if dimensionality == 3:
					U1_dir = (1,0,0)
					U2_dir = (0,1,0)
		elif csys_type == SPHERICAL:
			U1_dir = (1,0,0)
			U2_dir = (0,1,0)

		U1_point = []
		U2_point = []
		for i in range(dimensionality):
			U1_point.append(loc[i] + U1_dir[i])
			U2_point.append(loc[i] + U2_dir[i])
		U1_point = totuple(U1_point)
		U2_point = totuple(U2_point)

	print fnln(),'loc=',loc
	if is_location(loc) == False:
		raise Exception('*** Incorrect origin location = ' + str(loc))

	datum_feature = poa.DatumCsysByThreePoints(name=name, coordSysType=csys_type, origin=loc, point1=U1_point, point2=U2_point)

##		x0,y0,z0 = loc
##		x1,y1,z1 = U1_point
	## DatumCsysByThreePoints
##	if U1_point in empty or U2_point in empty:
##		datum_feature = poa.DatumCsysByThreePoints(name=name, coordSysType=csys_type, origin=loc, line1=U1_dir, line2=U2_dir)
##	else:
##		datum_feature = poa.DatumCsysByThreePoints(name=name, coordSysType=csys_type, origin=loc, point1=U1_point, point2=U2_point)

	if type_of(poa) != 'ODBASSEMBLY':
		csys = poa.datums[datum_feature.id]
	else:
		csys = name
		vpnow = get_vpnow()
		vpnow.odbDisplay.basicOptions.setValues(coordSystemDisplay=ON)

		dtm = poa.datumCsyses[name]
		vpnow.odbDisplay.basicOptions.setValues(datumCsys=dtm)	 ## apply the cylindrical system, not applicable for Mises, Principal stress.
		print '要想把其他对称的部分显示出来，需要view-->Odb display options-->Mirror/sweep选择合适的对称面，并且选择该局部坐标系。'
		## 只是把坐标系显示出来，要想把其他对称的部分显示出来，需要view-->Odb display options-->Mirror/sweep选择合适的对称面。

##		dtm = session.scratchOdbs[odb.name].rootAssembly.datumCsyses[name]
		vpnow.odbDisplay.basicOptions.setValues(transformationType=USER_SPECIFIED)   ## 如果是在直角坐标系和柱坐标系之间切换，结果数值将发生变化。such as: hoop stress, radial stress

		if type_of(mirror1) == 'STR':
			mirror1 = mirror1.lower()
			if mirror1 not in ['x','y','z']:
				raise Exception('*** mirror axis should be x, y, or z. x means yoz plane.')

			if mirror1 == 'x':
				vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName=name, mirrorAboutYzPlane=True)
			elif mirror1 == 'y':
				vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName=name, mirrorAboutXzPlane=True)
			elif mirror1 == 'z':
				vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName=name, mirrorAboutXyPlane=True)

		if type_of(mirror2) == 'STR':
			mirror2 = mirror2.lower()
			if mirror2 not in ['x','y','z']:
				raise Exception('*** mirror axis should be x, y, or z. x means yoz plane.')

			if mirror2 == 'x':
				vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName=name, mirrorAboutYzPlane=True)
			elif mirror2 == 'y':
				vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName=name, mirrorAboutXzPlane=True)
			elif mirror2 == 'z':
				vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName=name, mirrorAboutXyPlane=True)


	return csys

def create_cylind_csys(name='csys_1',poi=None,origin=(0,0,0),point1=(1,0,0),point2=(0,0,1),ndir=None):
	## VER: 2014-11-13, v1.3, 柱坐标系U1代表径向，U2代表旋转角度（半径的旋转,circular, alpha), U3代表轴向(thickness)
	## reference: create_csys()
	## 确保point1的方向就是某个z轴的正向，所以，point1可能是(1,0,0)，但不要是(-1,0,0)，此时，point1代表的是平行x轴且取x轴的正向。

	## Example:
##	CSYS_name = create_cylind_csys('cylind_CSYS_1',origin=(x0,y0,z0),ndir=axis)

	refresh()
	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) == 'ODB':
		## S11: radial stress(+:tensile, -:compress), S22: circular stress(or hoop stress) (+:tensile, -:compressive)
		## S33: stress in height direction(+:tensile in height direction, -:compressive in height direction)

##		scratchOdb = session.scratchOdbs[odb.name]
		scratchOdb = session.ScratchOdb(odb)
		oa = scratchOdb.rootAssembly
		name = 'Cylind csys'
		try:
			oa.DeleteDatumCsys(name=name)
		except:
			pass

		oa.DatumCsysByThreePoints(name=name, coordSysType=CYLINDRICAL, origin=origin, point1=point1, point2=point2)
		dtm = oa.datumCsyses[name]
		vpnow.odbDisplay.basicOptions.setValues(datumCsys=dtm)	 ## apply the cylindrical system, not applicable for Mises, Principal stress.

		dtm = session.scratchOdbs[odb.name].rootAssembly.datumCsyses[name]
		vpnow.odbDisplay.basicOptions.setValues(transformationType=USER_SPECIFIED)


	else:  ## for mdb
		if poi in empty:
			poi = a
		elif type_of(poi) == 'PINSTANCE':
			poi = a

		name = new_key(a.features,name)

		if is_STR(ndir):
			ndir = ndir.lower()

		if ndir in ['x','y','z']:  ## provided ndir
			x0,y0,z0 = origin
			if ndir == 'z' or ndir in zdir:
				point1 = (x0,y0 + 1,z0)   ##  right hand食指
				point2 = (x0 - 1, y0, z0) ## right hand中指
			elif ndir == 'x' or ndir in xdir:
				point1 = (x0, y0 + 1, z0)
				point2 = (x0, y0, z0 + 1)
			elif ndir == 'y' or ndir in ydir:   ## Z = +y
				point1 = (x0, y0, z0 + 1)  ## R = +z
				point2 = (x0 + 1, y0, z0)  ## T = +x

##				point1 = (x0 + 1, y0, z0)
##				point2 = (x0, y0, z0 - 1)

		poi.DatumCsysByThreePoints(name=name, coordSysType=CYLINDRICAL,
		    origin=origin, point1=point1, point2=point2)

	print '--->Cylindrical CSYS is created, origin=',origin, ', radial point1=', point1, ', circlar point2=',point2

	return name

def create_cylinder_series(part,ndir, dlens=(), dlocs=(),center0=(0,0,0),keep_D1=None, x0=None,y0=None,z0=None,partition=True,direction='forward'):
	## VER: 2014-12-09, v1.3

##		create_cylinder_series('cshaft','x', dlens=[(cshaft_OD1,cshaft_L1),(cshaft_OD2,cshaft_L2),(cshaft_OD3,cshaft_L3),(cshaft_OD4,cshaft_L4),(cshaft_OD5,cshaft_L5)],partition=True)
##		create_cylinder_series('cshaft','x',dlocs=[(cshaft_D1,cshaft_x1),(cshaft_D2,cshaft_x2),(cshaft_D3,cshaft_x3),(cshaft_D4,cshaft_x4),(cshaft_D5,cshaft_x5)])
##		create_cylinder_series('carbide','x',x0=carbide_x0, dlocs=[(carbide_D0,cshaft_D2,carbide_x1),(carbide_D2,cshaft_D2,carbide_x2)])
##		create_cylinder_series('carbide','x',x0=carbide_x0, keep_D1 = cshaft_D2, dlocs=[(carbide_D0,carbide_x1),(carbide_D2,carbide_x2)])

	if part not in _m.parts.keys() and type_of(part) == 'STR':
		part = blank_part(part)

	part = check_part(part)
	if type_of(ndir) == 'STR':
		ndir = ndir.lower()

	if ndir not in ['x','y','z']:
		raise Exception('*** ndir should be x, y or z')

##	center1 = center0
	center0 = tolist(center0)
	if is_number(x0):
		center0[0] = x0
	if is_number(y0):
		center0[1] = y0
	if is_number(z0):
		center0[2] = z0
	center1 = copy.deepcopy(center0)
	x0,y0,z0 = center0

	ndir = dir2num(ndir)
	start = center0[ndir]

	if direction == 'forward':
		sign = 1
	elif direction == 'reverse':
		sign = -1
	else:
		raise Exception('*** direction should be forward or reverse.')

	if len(dlens) == 0 and len(dlocs) == 0:
		raise Exception('*** Please provide dlens or dlocs')

##	print fnln(),'dlens=',dlens
##	raise Exception

	diameters = []
	if dlens not in empty:
		dlens = totable(dlens)

		for i in range(len(dlens)):
			if len(dlens[i]) == 2:
				D1 = 0
				if is_number(keep_D1):
					D1 = keep_D1

				D2,L = dlens[i]
			elif len(dlens[i]) == 3:
				D1,D2,L = dlens[i]

			D1,D2 = _sort(D1,D2)

			if L < 0:
				direction = 'reverse'
				L = abs(L)
				sign = -1
			else:
				direction = 'forward'
				sign = 1

			if D1 > 0 and D1 not in diameters:
				diameters.append(D1)

			if D2 not in diameters:
				diameters.append(D2)

##			check1()
			cylinder_grow(part,ndir=ndir, center0=totuple(center0), OD1=D1,OD2=D2, L=L,direction=direction)
			center0[ndir] = center0[ndir] + L*sign

	elif dlocs not in empty:
		dlocs  = totable(dlocs)

		for i in range(len(dlocs)):
			info = dlocs[i]
			if len(info) == 2:
				D1 = 0
				if is_number(keep_D1):
					D1 = keep_D1

				D2 = info[0]

			elif len(info) == 3:
				D1 = info[0]
				D2 = info[1]

			else:
				raise Exception('*** Error dlocs')

			D1,D2 = _sort(D1,D2)

			locs = info[-1]
			if is_number(locs):
				begin = center0[ndir]
				end = locs

			elif type_of(locs) in ['TUPLE','LIST'] and len(locs) == 2:
				begin,end = locs
				center0[ndir] = begin

			else:
				raise Exception('*** Error loc info: begin, start =?')

			L = end - begin
			if L < 0:
				direction = 'reverse'
				L = abs(L)
				sign = -1
			else:
				direction = 'forward'
				sign = 1

			if D1 > 0 and D1 not in diameters:
				diameters.append(D1)

			if D2 not in diameters:
				diameters.append(D2)

			cylinder_grow(part,ndir=ndir, center0=totuple(center0), OD1=D1,OD2=D2, L=L,direction=direction)
##			stop1()
			center0[ndir] = center0[ndir] + L*sign

	part.regenerate()
##	print fnln(),'diameters=',diameters
##	raise Exception

	diameters = _sort(diameters)
	diameters = diameters[:-1]
	if partition == True:
		i = 0
		for OD in diameters:
			faces = face_select(part,radius=OD/2)
			if faces not in empty:
				divide_by_face(part,face=faces[0])

	return


def create_dam():
	## VER: 2012-03-07, v1.1

	blank_part('dam')
	create_block(dam,(_xmin(clamp),_xmax(clamp,z=MAX)),(_ymin(clamp),_ymax(clamp)),(_zmax(clamp),_zmax(clamp) + 2))   ## dam_thick=2
	set_mat(dam,mat='Al_6061')
##	create_side_sets(dam)

##	if dam2clamp > 0:
##		move_part(dam,z1=MAX,z2=_zmax(dam) + dam2clamp)

	new_instance(dam)

	return

def create_datum_axis(poi,edir=None,point1=None,point2=None,vector=None, angle=None,about_axis=None):
	## VER: 2014-10-17, v1.3

	## Example:
##	point1 = _xmid(cutter),_ymin(cutter), _zmid(cutter)
##	axis1 = create_datum_axis(cutter,point1=point1,edir='x',angle=-47.79,about_axis='y')
	## angle: 逆时针为正

	poi = check_pias(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	if point1 in empty and point2 not in empty:
		point1, point2 = point2, point1

	if type_of(point1) == 'vertices':
		point1 = point1.pointOn[0]
	elif type_of(point1) == 'DATUMPOINT':
		point1 = point1.pointOn
	elif type_of(point1) == 'nodes':
		point1 = point1.coordinates

	if type_of(point2) == 'vertices':
		point2 = point2.pointOn[0]
	elif type_of(point2) == 'DATUMPOINT':
		point2 = point2.pointOn
	elif type_of(point2) == 'nodes':
		point2 = point2.coordinates

	if is_location(point1) == False:   ## point1 is the pass point when edir is also provided.
		point1 = (0,0,0)

	if is_vector(vector) == True:
		x0,y0,z0 = point1
		x1,y1,z1 = vector
		x2,y2,z2 = x0 + x1, y0 + y1, z0 + z1
		point2 = (x2,y2,z2)

	if is_location(point2) == False:
		if type_of(edir) == 'STR':
			edir = edir.lower()

		if edir not in ['x','y','z']:
			raise Exception('*** edir should be x, y, or z')

		if edir == 'x':
			point2 = point1[0] + 100, point1[1], point1[2]
		elif edir == 'y':
			point2 = point1[0], point1[1] + 100, point1[2]
		elif edir == 'z':
			point2 = point1[0], point1[1], point1[2] + 100

	if is_location(point2) == False:
		raise Exception('*** location of point2 is required.')

	axis = create_datum_axis_by_2points(poi, start=point1, end=point2)

	if about_axis not in empty and type_of(angle) in numerics:
		if about_axis in ['x', 'y','z']:
			if about_axis == 'x':
				pt2 = point1[0] + 100, point1[1], point1[2]
			elif about_axis == 'y':
				pt2 = point1[0], point1[1] + 100, point1[2]
			elif about_axis == 'z':
				pt2 = point1[0], point1[1], point1[2] + 100

			about_axis = create_datum_axis_by_2points(poi, start=point1, end=pt2)

		feature = poi.DatumAxisByRotation(line=axis, axis=about_axis, angle=angle)
		axis = poi.datums[feature.id]

	return axis

def create_axis_x(poi,y=0,z=0,loc=None):
	## VER: 2014-07-20, v1.1

	if is_location(loc):
		x,y,z = loc
	start = (0,y,z)
	end = (100,y,z)
	axis = create_datum_axis_by_2points(poi,start=start, end=end)

	return axis   ## type_of(axis) = 'DATUMAXIS'

def create_axis_y(poi,x=0,z=0,loc=None):
	## VER: 2014-07-20, v1.1

	if is_location(loc):
		x,y,z = loc
	start = (x,0,z)
	end = (x,100,z)
	axis = create_datum_axis_by_2points(poi,start=start, end=end)

	return axis   ## type_of(axis) = 'DATUMAXIS'

def create_axis_z(poi,x=0,y=0,loc=None):
	## VER: 2014-07-20, v1.1

	if is_location(loc):
		x,y,z = loc
	start = (x,y,0)
	end = (x,y,100)
	axis = create_datum_axis_by_2points(poi,start=start, end=end)

	return axis   ## type_of(axis) = 'DATUMAXIS'

def create_datum_axis_by_2points(p,end,start=None):
	## 2015-09-06, v1.7

	p = check_pia(p)
	if type_of(p) == 'PINSTANCE':
		p = a

	if start in empty:
		start = (0,0,0)

	if type_of(start) in ['vertices','DATUMPOINT']:
		point1 = start
	elif is_3D_loc(start) == True:
		datum1 = p.DatumPointByCoordinate(coords=start)
		point1 = p.datums[datum1.id]
	else:
		raise Exception('loc, vertice or datum point is required.')

	if type_of(end) in ['vertices','DATUMPOINT']:
		point2 = end
	elif is_3D_loc(end) == True:
		datum2 = p.DatumPointByCoordinate(coords=end)
		point2 = p.datums[datum2.id]
	else:
		raise Exception('loc, vertice or datum point is required.')

##	p.DatumPointByCoordinate(coords=end)
##	p.DatumAxisByTwoPoint(point1=p.datums[p.datums.keys()[-1]], point2=p.datums[p.datums.keys()[-2]])
##	datum_axis = p.DatumAxisByTwoPoint(point1=p.datums[p.datums.keys()[-2]], point2=p.datums[p.datums.keys()[-1]])
##	vector_edge = p.datums[p.datums.keys()[-1]]
##	vector_edge = p.datums[max(p.datums.keys())]

	datum_feature = p.DatumAxisByTwoPoint(point1=point1, point2=point2)
	datum_axis = p.datums[datum_feature.id]

	return datum_axis

def create_datum_plane_by_point_and_axis(p,point,axis):
	## VER: 2015-09-06, v1.1

	p = check_pia(p)
	if type_of(p) == 'PINSTANCE':
		p = a

	point1,point2 = two_points_of_edge(axis)
	plane1 = create_datum_plane_by_3points(p,point1,point2,point)

	return plane1

def create_datum_plane_by_2axis(poi,axis1,axis2):
	## VER: 2015-09-06, v1.2
	## to get 3 points to create the datum plane

	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	if type_of(axis1) == 'DATUMAXIS':
		point1, point2 = two_points_of_datum_axis(axis1)
	elif type_of(axis1) == 'edges':
		vertices = edges_to_vertices(axis1)
		point1 = vertices[0].pointOn[0]
		point2 = axis1.pointOn[0]

	if type_of(axis2) == 'DATUMAXIS':
		p1, p2 = two_points_of_datum_axis(axis2)
		point3 = (p1[0]+p2[0])/2, (p1[1]+p2[1])/2, (p1[2]+p2[2])/2
	elif type_of(axis2) == 'edges':
		point3 = axis2.pointOn[0]

	plane1 = create_datum_plane_by_3points(poi,point1,point2,point3)

	return plane1

def create_datum_plane_by_3points(poi,point1=(),point2=(),point3=(),face=None):
	## VER: 2015-07-06, v1.3

	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	if face not in empty:
		point1,point2,point3 = three_points_of_face(face)

	if type_of(point1) in ['TUPLE','LIST'] and len(point1) == 3 and type_of(point1[0]) in numerics:
		point1 = create_datum_point(poi,loc=point1)

	if type_of(point2) in ['TUPLE','LIST'] and len(point2) == 3 and type_of(point2[0]) in numerics:
		point2 = create_datum_point(poi,loc=point2)

	if type_of(point3) in ['TUPLE','LIST'] and len(point3) == 3 and type_of(point3[0]) in numerics:
		point3 = create_datum_point(poi,loc=point3)

	if type_of(point1) not in ['vertices','DATUMPOINT'] or type_of(point2) not in ['vertices','DATUMPOINT'] or type_of(point3) not in ['vertices','DATUMPOINT']:
		raise Exception('****vertice or datumpoint is required.')

	try:
		poi.DatumPlaneByThreePoints(point1=point1, point2=point2, point3=point3)
		datum_index = poi.datums.keys()[-1]
		datum_plane = poi.datums[datum_index]
	except:
		raise Exception('****Fail to create the datum plane')

	ndir = ndir_of_datum_plane(datum_plane)
	if ndir[0] == '-':
		poi.DatumPlaneByThreePoints(point1=point3, point2=point2, point3=point1)   ## reverse
		datum_index = poi.datums.keys()[-1]
		datum_plane = poi.datums[datum_index]

	return datum_plane  ## obj type:DATUMPLANE

def create_plane_x(poi,offset=0,x=None,loc=None):
	## VER: 2014-07-21, v1.0
	## Reference: create_axis_x()

	if is_location(loc):
		x = None
		offset = loc[0]

	datum_plane = create_datum_plane_by_offset(poi=poi, ndir='x', offset=offset, x=x)

	return datum_plane

def create_plane_y(poi,offset=0,y=None,loc=None):
	## VER: 2014-07-21, v1.0
	## Reference: create_axis_y()

	if is_location(loc):
		y = None
		offset = loc[1]

	datum_plane = create_datum_plane_by_offset(poi=poi, ndir='y', offset=offset, y=y)

	return datum_plane

def create_plane_z(poi,offset=0,z=None,loc=None):
	## VER: 2014-07-21, v1.0
	## Reference: create_axis_z()

##	>>> create_plane_z(cutter)   ## 将在z=0处生成datum plane
##	mdb.models['Model-1'].parts['cutter'].datums[5]
##	>>> show_datum()
##	>>>

	if is_location(loc):
		z = None
		offset = loc[2]

	datum_plane = create_datum_plane_by_offset(poi=poi, ndir='z', offset=offset, z=z)

	return datum_plane

def create_datum_plane_by_offset(poi=None,ndir=None,offset=0,x=None,y=None,z=None,face=None):
	## VER: 2014-08-01, v1.7

##>>> create_datum_plane_by_offset(p1,z=0)
##mdb.models['Model-1'].parts['p1'].datums[5]
##>>> show_datum()

	if face not in empty:
		if type_of(face) != 'faces':
			raise Exception('Invalid face')
		poi = get_poi(face)

	poi = check_pias(poi)

	if is_poi(poi):
		x,y,z = real_xyz(poi,x,y,z)

	if type_of(poi) == 'PINSTANCE':
		poi = a
	clear_datum_points(poi)

	if ndir in [0,1,2]:
		ndir = num2dir(ndir)

	if face in empty:
		if type_of(x) in numerics:
			offset = x
			ndir = 'x'
		elif type_of(y) in numerics:
			offset = y
			ndir = 'y'
		elif type_of(z) in numerics:
			offset = z
			ndir = 'z'

		if type_of(ndir) == 'STR':
			ndir = ndir.lower()

		if ndir not in ['x','y','z']:
			raise Exception('*** ndir is required: x,y or z')

		ndir = ndir.lower()
		if ndir == 'x':
			plane1 = YZPLANE
		elif ndir == 'y':
			plane1 = XZPLANE
		elif ndir == 'z':
			plane1 = XYPLANE

		poi.DatumPlaneByPrincipalPlane(offset=offset, principalPlane=plane1)

	else:
		curvature = get_curvature(face)
		if curvature not in empty:
			raise Exception('**Flat face is required to create a datum plane.')

		poi.DatumPlaneByOffset(plane=face, flip=SIDE1, offset=offset)

	datum_index = poi.datums.keys()[-1]
	plane = poi.datums[datum_index]

	return plane   ## type_of(plane)='DATUMPLANE'

def create_datum_point(p=None,loc=None,parameter=None,edge=None):
	## VER: 2014-08-04, v1.6. parameter: 0~1.0, 从edge的一端到另外一端。逆时针
	## edge可以来自instance，也可以来自part
	## 不能清除别的datum point，因为往往同时生成多个datum points.
	## type_of(datum_point) = 'DATUMPOINT', 不是'FEATURE', 也不是'DATUM'

	if p in empty:
		p = get_poi(edge)

	p = check_pias(p)
	if type_of(p) == 'PINSTANCE':
		p = a

	if type_of(edge) == 'edges' and type_of(parameter) in numerics:
		p.DatumPointByEdgeParam(edge=edge,parameter=parameter)
	elif loc not in empty:
		if len(loc) != 3:
			raise Exception('*** loc should be consist of x,y,z')

		p.DatumPointByCoordinate(coords=loc)
	else:
		raise Exception('******loc or edge division parameter is required.')

	datum_index = p.datums.keys()[-1]
	datum_point = p.datums[datum_index]		## location of datum_point: datum_point.pointOn, 结果形式如(1.5,0,1)

	return datum_point  ## type_of(datum_point) = 'DATUMPOINT', 不是'FEATURE'

def create_std_rail(name='rail',support_option='long_edge+short_rail',length=60,width=50,thick=3,xspace=(),yspace=(),mat='Al_6063',global_var=True,rail2corner=None):
	## VER: ('VER: 2012-12-17, v1.5')

	partname = blank_part(name)
	rail = _m.parts[partname]

	support_option = totext(support_option)
	support_option = modify_string(support_option,' ')		## 去掉空格

	if rail2corner in empty:
		rail2corner = globals()['clamp2corner']

	if support_option in ['long_edge//long_rail','short_edge+long_rail']:
		if has_frame == True:
			length = _ymax(frL) - _ymin(frL) + 20
		else:
			length = _ylength(lam) + 20

	elif support_option in ['short_edge//long_rail','long_edge+long_rail']:
		if has_frame == True:
			length = _xmax(frL) - _xmin(frL2) + 20
		else:
			length = _xlength(lam) + 20

	if 'long_edge//' in support_option or 'short_edge+' in support_option:
		create_block(rail,(0,width),(0,length),(0,thick),mat=mat)
	else:
		create_block(rail,(0,length),(0,width),(0,thick),mat=mat)

	if global_var == True:
		globals()['rail_length'] = length
		globals()['rail_width'] = width
		globals()['rail_thick'] = thick

	if support_option == 'long_edge//long_rail':
		if has_frame == True:
			move_part(rail,x1=MAX,x2=_xmax(frL) + 10,y1=MIN,y2=_ymin(frL),z1=_zmax(rail),z2=_zmin(frL))
		else:
			move_part(rail,x1=MAX,x2=_xmax(lam) + 10,y1=MIN,y2=_ymin(lam),z1=_zmax(rail),z2=_zmin(lam,x=MAX))

	elif support_option in ['long_edge//short_rail','long_edge+short_rail']:
		if has_frame == True:
			move_part(rail,x1=MAX,x2=_xmax(frL) + 10,y1=MID,y2=_ymax(frL) - rail2corner,z1=_zmax(rail),z2=_zmin(frL))
		else:
			move_part(rail,x1=MAX,x2=_xmax(lam),y1=MID,y2=_ymax(lam) - rail2corner,z1=_zmax(rail),z2=_zmin(lam,x=MAX) - lam2rail)

	elif support_option == 'short_edge//long_rail':
		if has_frame == True:
			move_part(rail,y1=MAX,y2=_ymax(frS) + 10,x1=MIN,x2=_xmin(frS),z1=_zmax(rail),z2=_zmin(frS))
		else:
			move_part(rail,y1=MAX,y2=_ymax(lam) + 10,x1=MIN,x2=_xmin(lam),z1=_zmax(rail),z2=_zmin(lam,y=MAX))

	elif support_option in ['short_edge//short_rail','short_edge+short_rail','short_edge+long_rail']:
		if has_frame == True:
			move_part(rail,y1=_ymax(rail),y2=_ymax(frS) + 10,x1=_xmid(rail),x2=_xmax(frS) - rail2corner,z1=_zmax(rail),z2=_zmin(frS))
		else:
			move_part(rail,y1=_ymax(rail),y2=_ymax(lam) + 10,x1=_xmid(rail),x2=_xmax(lam) - rail2corner,z1=_zmax(rail),z2=_zmin(lam,y=MAX))

	## 其他option则不移动rail
	if has_frame == True:
		if _xmin(lam) == _xmin(frS):
			bias_cut(partname,x=_xmin(lam),cut_sides='-x')
		if _ymin(lam) == _ymin(frL):
			bias_cut(partname,y=_ymin(lam),cut_sides='-y')

		if len(_m.parts[partname].vertices) == 0:
			raise Exception('Error rail2corner or clamp2corner. rail is blank now.')

	new_instance(partname)

	return partname

function_labels['frequency_response_direct_modal_dynamics_step'] = 'frequency scanning','mode','modal analysis','direct','damping'
def frequency_response_direct_modal_dynamics_step(stepname='step1',prestep='',freq_range=[0,30],alpha_damping=None, beta_damping=None, direct_damping=None,damp_modes=None,point_num=20,bias=None):
	## VER: 2016-11-09, v1.0
	## 例子：在外界载荷pressure下，假定该载荷以某个频率作用，那么一个频率区间内模型的响应。
	## 不需要先进行模态分析步，而是将模态分析与频率响应分析合并为一步进行（类似动态耦合）。

## =========================例2
##		frequency_response_direct_modal_dynamics_step(stepname='step2',freq_range=(0,40))
##		apply_pressure(name='pressure_top',step='step2', faces=zmax_faces(lam_A1))
##		对应的inp关键字为:
##
##		*Step, name=step2, perturbation
##		*Steady State Dynamics, direct, frequency scale=LINEAR, friction damping=NO
##		0., 40., 20, 3.
##		**
##		** LOADS
##		**
##		** Name: _01_pressure_top_25783   Type: Pressure
##		*Dsload
##		_PickedSurf95, P, 0.001
##		**
##		** OUTPUT REQUESTS
##		**
##		**
##		** FIELD OUTPUT: F-Output-2
##		**
##		*Output, field, variable=PRESELECT
##		**
##		** HISTORY OUTPUT: H-Output-1
##		**
##		*Output, history, variable=PRESELECT
##		*End Step

	## 结果的样子：
	## Index 	Description
	## 0		Increment 0: base state
	## 1		Increment 1: freuency = 0.001
	## 2		Increment 2: frequency = 0.6132
	## 3		Increment 3: frequency = 1.2225
## 	每一个模态都可以动画演示

	global my_steps

	stepname = new_key(stepname,_m.steps.keys(),force_new_key = True)
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('No such prestep',prestep)

	freq_range = tolist(freq_range)
	freq_range.sort()

	if len(freq_range) == 2:
		freq1,freq2 = freq_range
	elif len(freq_range) == 1:
		freq1 = freq2 = freq_range[0]
	else:
		raise Exception('Invalid frequence range =' + repr(freq_range))

	if freq1 == 0:
		freq1 = 0.001		## 防止曲线突变。

	if bias in empty:
		bias = 1

	if freq1 != freq2:
		point_num = 50
	else:
		point_num = 10

	range = ((freq1, freq2, point_num, bias), )
	_m.SteadyStateDirectStep(name=stepname, previous=prestep, frequencyRange=range, scale=LINEAR)

	if damp_modes in empty:
		damp_modes = (1,10)		;please_check
		for name1 in _m.steps.keys():
			if name1 != 'Initial' and type_of(_m.steps[name1]) == 'FrequencyStep':
				damp_modes = (1,_m.steps[name1].numEigen)
				break
	else:
		if type_of(damp_modes) == 'INT':
			damp_modes = (1,damp_modes)
		elif type_of(damp_modes) in ['TUPLE','LIST'] and len(damp_modes) == 2:
			damp_modes = totuple(damp_modes)
		else:
			raise Exception('Incorrect damp_modes=',repr(damp_modes))

	mode1,mode2 = damp_modes
	if mode1 == 0:
		mode1 = 1

	damp_type = ''
	if type_of(direct_damping) in ['FLOAT','INT'] and direct_damping !=0:
		damp_type = 'direct'

	elif alpha_damping not in empty or beta_damping not in empty:
		if alpha_damping in empty:
			alpha_damping = 0

		if beta_damping in empty:
			beta_damping = 0

		print 'alpha_damping=',alpha_damping, ', beta_damping=',beta_damping
		if not (alpha_damping == 0 and beta_damping == 0):
			damp_type = 'rayleigh'

	if damp_type == 'rayleigh':
		_m.steps[stepname].setValues(rayleighDamping=((mode1, mode2, alpha_damping, beta_damping), ))
	elif damp_type == 'direct':
		_m.steps[stepname].setValues(directDamping=((mode1, mode2,direct_damping), ))	## 直接给临界阻尼,通常2%-3%
##	else:
##		raise Exception('Unknown damp_type=' + repr(damp_type))

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.setValues(step=stepname)

	print '--->Created frequenc scaning step:',stepname

##	step = _m.steps[stepname]
##	my_steps[len(_m.steps) - 1] = {'procedureType': step.procedureType, 'domain': FREQUENCY, 'type': type_of(step), 'name': stepname,
##		'function':'frequency_response_direct_modal_dynamics_step'}

	return stepname

function_labels['time_response_modal_dynamics_step'] = 'transient','release','spring back','vibration','relax','damping','modal dynamics','response'
def time_response_modal_dynamics_step(stepname='step2',prestep=None,step_time=1, inc_time=0.001, alpha_damping=None, beta_damping=None, direct_damping=None,damp_modes=None, output_freq=5):
	## VER: ('VER: 2016-11-23, v2.2') 虽然是真实时间，但计算速度很快。
	## time_response_modal_dynamics_step()观察的是给一个外部载荷激励后，在给定的step_time内的衰减过程。
	## frequency_response_modal_dynamics_step()观察的是外部载荷随着激励频率不断提高，模型的响应。是响应分析。
	## 注意：在time_response_modal_dynamics_step()中创建的载荷，并不会propogate到下一个载荷步中。
	## 在阻尼=0.1(direct)及output_freq=5的情况下，运算非常快。
	## inc_time是时间增量步，每一个increment增量为inc_time，不会自动加快。与显式动力学类似。

	## 例如：step1=frequency step(提取频率，没有时间）,step2=time_response_modal_dynamics_step(),有时间，是一个有固定频率的载荷；step3也是，但是释放该载荷。
	## 获取是域响应曲线的办法（例如某个节点的U随时间的变化。)
	## Create xyData -> Odb field output -> active steps/frames中不选择step1(提取频率)，而选择step2(施加振动载荷）和step3（撤销振动载荷)
	## -> variables: unique nodal, Spatial displacement, U3 -> ELements/Nodes: pick from viewport -> Plot可画出振动响应曲线来。

	global my_steps

	## analysis1
##	create_general_static_step()

	## analysis2：衰减分析
##	frequency_and_mode_shapes_step()
##	time_response_modal_dynamics_step(stepname='step2',beta_damping=0,alpha_damping=0, direct_damping=0.02, output_freq=1, step_time=2)

	## analysis3：频谱分析
##	frequency_and_mode_shapes_step()
##	frequency_response_modal_dynamics_step(freq_range=(0,30),direct_damping=0.02)

	## Example: 先做频率分析，获得各阶频率，然后进行模态动力学分析。
##	##  Create a frequency extraction step
##	##
##	mdb.models['standard'].FrequencyStep(name='Extract frequencies',
##	    previous='Initial',
##	    description='First 30 modes', numEigen=30,
##	    maxEigen=None, shift=None, eigensolver=LANCZOS, minEigen=None,
##	    blockSize=DEFAULT, maxBlocks=DEFAULT)
##	session.viewports['Viewport: 1'].assemblyDisplay.setValues(
##	    step='Extract frequencies')
##	##
##	##  Create a modal dynamics step
##	##
##	mdb.models['standard'].ModalDynamicsStep(name='Transient modal dynamics',
##	    previous='Extract frequencies',
##	    description='Crane Response to Dropped Load',   ## crane=吊车，时间是真实时间
##	    continueAnalysis=OFF, timePeriod=0.5, incSize=0.005, directDamping=((1,
##	    30, 0.05), ), compositeDamping=None, rayleighDamping=None, amplitude=STEP)
##	session.viewports['Viewport: 1'].assemblyDisplay.setValues(
##	    step='Transient modal dynamics')

	## Example:
##	time_response_modal_dynamics_step(stepname='step3',beta_damping=beta,alpha_damping=alpha, direct_damping=direct_damping, output_freq=10, step_time=release_time)

##	frequency_and_mode_shapes_step(stepname='step1')

##	stop()

	## frequence scanning
##	frequency_response_modal_dynamics_step(stepname='step2',prestep='step1',freq_range=(0,40),beta_damping=beta,alpha_damping=alpha, direct_damping=direct_damping)
##	apply_pressure(name='pressure_top',step='last', faces=zmax_faces(lam_A1), magnitude=press_Pa)

##	stop()

	## modal dynamics
##	amp_1 = create_periodic_amplitude(name='Amp_1',freq=freq,magnitude=1)
##	tab_1 = create_tabular_amplitude(freq=freq,magnitude=1,shape='half-sin',bias='+')		;please_check
##
##	time_response_modal_dynamics_step(stepname='step2',beta_damping=beta,alpha_damping=alpha, direct_damping=direct_damping, output_freq=5, step_time=load_time)
##	_m.Gravity(name='Load_gravity', createStepName='step2', comp3=accel, amplitude=amp_1, distributionType=UNIFORM, field='')
##	apply_pressure(name='pressure_top',step='last', faces=zmax_faces(lam_A1), magnitude=press_Pa, amplitude=tab_1)

##	time_response_modal_dynamics_step(stepname='step3',beta_damping=beta,alpha_damping=alpha, direct_damping=direct_damping, output_freq=10, step_time=release_time)
##

##	check_suitable_step(fn())

	stepname = new_key(stepname,_m.steps.keys(),force_new_key = True)
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('No such prestep',prestep)

	_m.ModalDynamicsStep(name=stepname, previous=prestep, timePeriod=step_time, incSize=inc_time, continueAnalysis=ON)

	if damp_modes in empty:
		damp_modes = (1,10)		;please_check
		for name1 in _m.steps.keys():
			if name1 != 'Initial' and type_of(_m.steps[name1]) == 'FrequencyStep':
				damp_modes = (1,_m.steps[name1].numEigen)
				break

	else:
		if type_of(damp_modes) == 'INT':
			damp_modes = (1,damp_modes)
		elif type_of(damp_modes) in ['TUPLE','LIST'] and len(damp_modes) == 2:
			damp_modes = totuple(damp_modes)
		else:
			raise Exception('Incorrect damp_modes=',repr(damp_modes))

	mode1,mode2 = damp_modes
	if mode1 == 0:
		mode1 = 1

	damp_type = 'NA'
	if type_of(direct_damping) in ['FLOAT','INT'] and direct_damping !=0:
		damp_type = 'direct'

	elif alpha_damping not in empty or beta_damping not in empty:
		if alpha_damping in empty:
			alpha_damping = 0

		if beta_damping in empty:
			beta_damping = 0

		print 'alpha_damping=',alpha_damping, ', beta_damping=',beta_damping
		if not (alpha_damping == 0 and beta_damping == 0):
			damp_type = 'rayleigh'

	if damp_type == 'rayleigh':
		_m.steps[stepname].setValues(rayleighDamping=((mode1, mode2, alpha_damping, beta_damping), ))
	elif damp_type == 'direct':
		_m.steps[stepname].setValues(directDamping=((mode1, mode2,direct_damping), ))	## 直接给临界阻尼,通常2%-3%
	else:
		raise Exception('Unknown damp_type=' + repr(damp_type))

	_m.steps[stepname].setValues(amplitude=STEP)		## STEP=instantaneous, RAMP=ramp linearly over step.

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.setValues(step=stepname)

	## 每output_freq个增量步都输出结果。如果output_freq=1，则每个增量步都输出结果，odb文件就会非常大，类似dynamics explicit
	if output_freq <5:
		raise Exception('*** output_freq is too small to make a big size odb file.')
	## 每一次输出结果，就会形成一个frame(帧)
	## 没有必要每个increment就是一个frame

	_m.fieldOutputRequests.values()[-1].setValues(frequency=output_freq)
	_m.historyOutputRequests.values()[-1].setValues(frequency=output_freq)

##	step = _m.steps[stepname]
##	my_steps[len(_m.steps) - 1] = {'procedureType': step.procedureType, 'domain': TIME, 'type': type_of(step), 'name': stepname,
##		'function':'time_response_modal_dynamics_step'}

	return stepname

function_labels['frequency_response_modal_dynamics_step'] = 'steady_state_modal_dynamics_step', 'frequency scanning','modal','mode','damping','response','modal dynamics'
def frequency_response_modal_dynamics_step(stepname='step1',prestep='',freq_range=[0,30],alpha_damping=0, beta_damping=0, direct_damping=None,damp_modes=None, point_num=20,bias=None):

	## VER: ('VER: 2016-11-15, v1.9')	## steady state dynamics, modal. 扫频实验。可以是单位幅值，也可以是实际的幅值。但是都不用定义amplitude(艾国庆）。
	## time_response_modal_dynamics_step()相当于瞬态响应，而frequency_response_modal_dynamics_step()相当于稳态响应。
	## time_response_modal_dynamics_step()的例子：观察一个跌落的过程中的很短时间内（0.7秒）的反应。
	## frequency_response_modal_dynamics_step()的例子：在外界载荷pressure下，假定该载荷以某个频率作用，那么一个频率区间内模型的响应。

	## time_response_modal_dynamics_step()观察的是给一个外部载荷激励后，在给定的step_time内的衰减过程。
	## frequency_response_modal_dynamics_step()观察的是外部载荷随着激励频率不断提高，模型的响应。是响应分析。

	## analysis1
##	create_general_static_step()

	## analysis2：衰减分析
##	frequency_and_mode_shapes_step()
##	time_response_modal_dynamics_step(stepname='step2',beta_damping=0,alpha_damping=0, direct_damping=0.02, output_freq=1, step_time=2)

	## analysis3：频谱分析。注意频率响应的曲线(峰值变化）属于field output。建立xydata时，选的是field output variable
##	frequency_and_mode_shapes_step()
##	frequency_response_modal_dynamics_step(freq_range=(0,30),direct_damping=0.02)

	## 结果观察：
	## xyData from ODB field output->output variable选unique nodal,仅选择step2，选择U2,pick一个节点，plot出曲线来。
	## create xyData时，别忘了点击save，就会保存数据（table)。编辑该xyData，看到该table内容，拷贝出来放到Origin中画出来。

	global my_steps

	## Example: 光伏组件的频率响应分析
##	frequency_and_mode_shapes_step(stepname='step1')
##	frequency_response_modal_dynamics_step(stepname='step2',prestep='step1',freq_range=(0,40),beta_damping=0,alpha_damping=0, direct_damping=0.02)
##	apply_pressure(name='pressure_top',step='last', faces=top_of(lam_A1), magnitude=press_Pa)

	stepname = new_key(stepname,_m.steps.keys(),force_new_key = True)
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('No such prestep',prestep)

	if type_of(_m.steps.values()[-1]) != 'FrequencyStep':
		raise Exception('*** Please perform Frequency analysis in previous step.')

	freq_range = tolist(freq_range)
	freq_range.sort()

	if len(freq_range) == 2:
		freq1,freq2 = freq_range
	elif len(freq_range) == 1:
		freq1 = freq2 = freq_range[0]
	else:
		raise Exception('*** Invalid frequence range =' + repr(freq_range))

	if freq1 == 0:
		freq1 = 0.001		## 防止曲线突变。

	## step_type = modal
	if bias in empty:
		bias = 3
	range = ((freq1, freq2, point_num, bias), )
	_m.SteadyStateModalStep(name=stepname, previous=prestep, frequencyRange=range, scale=LINEAR)

##		_m.SteadyStateModalStep(name=stepname, previous=prestep, frequencyRange=range, directDamping=((1, 40, 0.02), ))

## ==================例1
##		frequency_response_modal_dynamics_step(stepname='step2',prestep='step1',freq_range=(0,40))
##		apply_pressure(name='pressure_top',step='step2', faces=zmax_faces(lam_A1))
##		对应的inp关键字为:
##
##		** STEP: step2
##		**
##		*Step, name=step2, perturbation
##		*Steady State Dynamics, frequency scale=LINEAR
##		0., 40., 20, 3.
##		**
##		** LOADS
##		**
##		** Name: _01_pressure_top_25694   Type: Pressure
##		*Dsload, load case=1
##		_PickedSurf278, P, 1.
##		**
##		** OUTPUT REQUESTS
##		**
##		**
##		** FIELD OUTPUT: F-Output-2
##		**
##		*Output, field, variable=PRESELECT
##		**
##		** HISTORY OUTPUT: H-Output-1
##		**
##		*Output, history, variable=PRESELECT
##		*End Step

	if damp_modes in empty:
		damp_modes = (1,10)		;please_check
		for name1 in _m.steps.keys():
			if name1 != 'Initial' and type_of(_m.steps[name1]) == 'FrequencyStep':
				damp_modes = (1,_m.steps[name1].numEigen)
				break
	else:
		if type_of(damp_modes) == 'INT':
			damp_modes = (1,damp_modes)
		elif type_of(damp_modes) in ['TUPLE','LIST'] and len(damp_modes) == 2:
			damp_modes = totuple(damp_modes)
		else:
			raise Exception('Incorrect damp_modes=',repr(damp_modes))

	mode1,mode2 = damp_modes
	if mode1 == 0:
		mode1 = 1

	if type_of(direct_damping) in ['FLOAT','INT'] and direct_damping !=0:
		damp_type = 'direct'
	elif alpha_damping + beta_damping > 0:
		damp_type = 'rayleigh'
	else:
		direct_damping = 0.02
		damp_type = 'direct'

	if damp_type == 'rayleigh':
		_m.steps[stepname].setValues(rayleighDamping=((mode1, mode2, alpha_damping, beta_damping), ))
	elif damp_type == 'direct':
		_m.steps[stepname].setValues(directDamping=((mode1, mode2,direct_damping), ))	## 直接给临界阻尼,通常2%-3%

	return stepname

function_labels['frequency_and_mode_shapes_step'] = 'create_frequency_step'
def frequency_and_mode_shapes_step(stepname='step1',prestep='',modenum=10):
	## VER: ('VER: 2015-04-01, v1.2')	## 提取各阶模态频率。模态分析运算极快。
	## 不能施加载荷，例如压力，重力。

	global my_steps

	## Results:每一个frame就是一个模态，有其模态频率。
	## frame 1: Freq=22.9
	## frame 2: Freq=24.2
	## frame 3: Freq=25.8


##	check_suitable_step(fn())

	stepname = new_key(_m.steps.keys(),stepname,force_new_key=True)		;please_check
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('No such prestep',prestep)

##	if modenum in empty:
##		modenum = 10		;please_check

	_m.FrequencyStep(name=stepname, previous=prestep, numEigen=modenum)
	_m.fieldOutputRequests['F-Output-1'].setValues(variables=('S', 'LE', 'U'))

##	step = _m.steps[stepname]
##	my_steps[len(_m.steps) - 1] = {'procedureType': step.procedureType, 'domain': MODAL, 'type': type_of(step), 'name': stepname,
##		'function':'frequency_and_mode_shapes_step'}

	print '--->Created frequency step to retrieve the modal frequancies, modenum=',modenum

##		** STEP: step1
##		**
##		*Step, name=step1, perturbation
##		*Frequency, eigensolver=Lanczos, acoustic coupling=on, normalization=displacement
##		10, , , , ,
##		**
##		** OUTPUT REQUESTS
##		**
##		*Restart, write, frequency=0
##		**
##		** FIELD OUTPUT: F-Output-1
##		**
##		*Output, field
##		*Node Output
##		U,
##		*Element Output, directions=YES
##		LE, S
##		*End Step

	return stepname

def create_ball(partname, radius=5,R=None, solid=True, angle=360,counter_clock=True,open='up'):
	## VER: 2016-05-20, v1.3
	## Example: create_ball('ball',radius=5)

##	create_ball('ball',R=5,angle=180)
##	create_ball('ball',R=5,angle=180,solid=False)

##	create_ball('ball',R=5,angle=180,solid=False,open='up')		## 开口向上的碗
##	create_ball('ball',R=5,angle=180,solid=False,open='down')   ## 开口向下的碗

	if is_number(R):
		radius = R

	if angle == 180:
		if open in ['down', '-z']:
			counter_clock = False

	sketch = create_base_sketch(name='s_'+partname,sketch_plane='xoy', return_sketch=True)

	sketch_name = sketch.name

	point1,point2,arc1 = create_arc(sketch_name,center=(0,0),point1=(0,radius),point2=(0,-radius),direction=CLOCKWISE)
	if solid == True:
		connect_points(sketch_name,point1,(0,0),point2)  ## 圆心是直径上的一个点

	partname = revolve_sketch_to_part(partname=partname,sketch=sketch_name,angle=angle,axis='V',solid=solid,counter_clock=counter_clock)

	print '--->Create ball, partname=',partname, ', radius=',radius

	return partname

def create_half_ball(partname, radius, sketch_plane='xoy'):
	## VER: 2013-08-20, v1.0

	partname = blank_part(partname)
	sketch = create_base_sketch(name='s_'+partname,sketch_plane=sketch_plane, return_sketch=True)
##	sketch_name = sketch['name']
	sketch_name = sketch.name

	point1,point2,arc1 = create_arc(sketch_name,center=(0,0),point1=(0,radius),point2=(radius,0),direction=CLOCKWISE)
	connect_points(sketch_name,point1,(0,0),point2)

##	print fnln_fnln(),'here'
	revolve_sketch_to_part(partname=partname,sketch=sketch_name,angle=360,axis='V')

	print fnln_fnln(),'--->Create half ball, partname=',partname, ', radius=',radius

	return partname

def create_heat_from_plastic_work(pois,fraction = 0.9):
	## VER: 2015-03-19, v1.0
##	*inelastic heat fraction and *specific heat are only used in an adiabatic(绝热，隔热) analysis and a coupled temperature-displacement analysis(稳态应力分析无效)
	## example:
	## create_heat_from_plastic_work(['wire','nib'])
##	fraction = 0.9

	mats = []
	pois = tolist(pois)
	for poi in pois:
		mats = mats + mats_of_poi(poi)

	mats = remove_repeated_items(mats)
	for mat in mats:
		_m.materials[mat].InelasticHeatFraction(fraction=fraction)

	return

def create_heat_transfer_step(stepname='step1',prestep='',period=1.0, initial_inc=0.01, max_inc=None,fix_inc=None,end_delta_T=None,response='transient',delta_Tmax=5):
	## VER: ('VER: 2015-04-01, v1.1')
	## end_delta_T: End step when temperature change is less than ___
	## 建立接触对时，需要定义两个界面之间的传导关系。较为复杂。另外一种方法是使用tie，不过，后续的分析步无法分开或抑制，此时可以用顺序耦合（导入导出)。

	global my_steps

##	check_suitable_step(fn())
	stepname = new_key(_m.steps.keys(),stepname,force_new_key=True)		;please_check
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('No such prestep',prestep)

	if response in ['static','steady']:
		_m.HeatTransferStep(name=stepname, previous=prestep,  timePeriod=period, response=STEADY_STATE, initialInc=initial_inc, amplitude=RAMP,end=end_delta_T)

	elif response == 'transient':
		if fix_inc in empty:
			if max_inc == None:
				max_inc = period/4.

			if max_inc <= 0:
				raise Exception('*** Error: max_inc =' + str(max_inc))
			_m.HeatTransferStep(name=stepname, previous=prestep,  timePeriod=period, initialInc=initial_inc, maxInc=max_inc, deltmx=delta_Tmax)

		else:
			if type_of(fix_inc) not in numerics:
				raise Exception('*** fix_inc is required.')

			_m.HeatTransferStep(name=stepname, previous=prestep, timePeriod=period, timeIncrementationMethod=FIXED, initialInc=fix_inc)

##	create_T_output('T_output',step=stepname)

	step = _m.steps[stepname]
	my_steps[len(_m.steps) - 1] = {'procedureType': step.procedureType, 'domain': TIME, 'type': type_of(step), 'name': stepname,
		'function': 'create_heat_transfer_step'}

	print fnln_fnln(),stepname,'is created, type=',type_of(_m.steps.values()[-1])
	if response == 'transient':
		print 'period=',period,'sec, max_inc=',max_inc,'sec, fix_inc=',fix_inc
	print ' '

	return stepname

def history_output_request(name='H-Output-2',step='step1',variables=(),region=None,region_set=None,
	rigid_body=None,frequency=None,every_inc=1,time_points=None,time_size=None,interval=None,x=None):
	## VER: 2016-08-31, v1.4
	## region is set like region, 因为不可能是surface like region
	## 对于rigid_body的参考点的结果输出，可以每一个增量步都输出结果，对odb的大小的影响不大。
	## time_points: evenly spaced time intervals: 默认200，即把整个step time分成200等份的时间点，每一个时间点都输出结果。
	## every_time: every x unit of tme: 即每过多长时间(如0.1s)就输出一次结果。
	## 稳态分析不建议用every_inc=1，因为计算顺利的话，每一个增量步的时间可能越来越快。every_inc=1适合于显式分析

##	history_output_request(rigid_body=shell_A1,variables=['RF','S','PRESS'])

##	_m.HistoryOutputRequest(name='his_die',
##	    createStepName='under filling', variables=('U3', 'RF3'), frequency=1,
##	    region=set_die, sectionPoints=DEFAULT, rebar=EXCLUDE)

##	history_output_request(name='his_die',variables=('U3','RF3'),region_set=set_die)
##	history_output_request(name='his_pin',variables=('U3','RF3'),region_set=set_pin)
##	history_output_request(name='his_ejector',variables=('U3','RF3'),region_set=set_ejector)

	if is_number(x):
		time_size = x

	if is_number(interval):
		time_points = interval

	if is_int(frequency):
		every_inc = frequency

	if is_pia(rigid_body):
		rigid_body = check_inst(rigid_body)

	if region_set not in empty:
		region = region_set

	if type_of(rigid_body) == 'PINSTANCE':
		name = 'RP_' + rigid_body.name
		region = create_set(name=name,p=rigid_body, RP = rigid_body.referencePoints.values()[0])

##	>>> inst1 = _inst('powder_A1')
##	>>> inst1.sets.keys()
##	['ALE_powder', 'set_H10pow']   ## 该set是建在part上，并继承到instance。继承到instance上的set不在a.sets.keys()中
##	>>> type_of(inst1.sets['ALE_powder'])
##	'SET'
##	>>>

	if type_of(region) == 'STR':
		set_name = region
		if set_name in a.sets.keys():
			region = a.sets[set_name]
		else:
			raise Exception('*** incorrect setname in assembly')

	if region in empty:
		raise Exception('*** set like region is required, such as set')

	variables = tolist(variables)
	variables1 = variables
	if variables1 in empty:
		variables1 = ['RF1','RF2','RF3','RM1','RM2','RM3']
	else:
		if 'RF' in variables:
			variables1 = variables1 + ['RF1','RF2','RF3','RM1','RM2','RM3']
		if 'S' in variables:
			variables1 = variables1 + ['S11', 'S22', 'S33', 'S12', 'S13', 'S23', 'SP', 'TRESC', 'PRESS', 'INV3', 'MISES', \
				'SSAVG1', 'SSAVG2', 'SSAVG3', 'SSAVG4', 'SSAVG5', 'SSAVG6']
		if 'U' in variables:
			variables1 = variables1 + ['U1', 'U2', 'U3', 'UR1', 'UR2', 'UR3', 'UT', 'UR', \
				'V1', 'V2', 'V3', 'VR1', 'VR2', 'VR3', 'VT', 'VR']

	variables = totuple(variables1)

	name = new_key(_m.historyOutputRequests.keys(),name)

	step = check_step(step)
	if step == 'Initial':
		raise Exception('*** history output cannot created at Initial step.')

	if is_number(time_points): ## evenly spaced time intervals
		_m.HistoryOutputRequest(name=name, createStepName=step, variables=variables, region=region,
			numIntervals=time_points)
	elif is_number(time_size): ## every x unit of tme
		_m.HistoryOutputRequest(name=name, createStepName=step, variables=variables, region=region,
			timeInterval=time_size)
	else:
		_m.HistoryOutputRequest(name=name, createStepName=step, variables=variables, region=region,
			frequency=every_inc)

	return name

function_labels['set_hyperElastic'] = 'PV','suntech','EVA','silicone','rubber','material property','YEOH'
def set_hyperElastic(matname,model='YEOH',table=None):
	## 2017-10-22, v2.0 缺省Marlow材料模型(输入测试数据，不能输入系数)

	global options

	options.append('HyperElastic ' + matname + '(' + model + ' model)')	##********

##	new_create = False
##	if matname not in _m.materials.keys():
##		_m.Material(name=matname)
##		new_create = True

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	try:
		del _m.materials[matname].elastic
	except:
		pass

	if type_of(model) == 'STR':
		model = model.upper()

	if table in empty:
		if matname in ['Silic','Silic2']:  ## silicone 0.14MPa = 140kPa
			table = ((0,0),(2,100/100), (4.5, 200/100), (16, 590/100))	## 借用EVA数据(成功用于橡胶)
##			table = ((0,0),(0.14, 25/100), (0.4, 50/100), (0.9, 300/100))	## 幕墙结构胶
##			table = ((0,0),(0.14, 25/100), (0.4, 50/100), (0.9, 200/100))	## 幕墙结构胶 JS-6000建筑用硅酮结构胶(适用于建筑幕墙中的玻璃结构粘结装配)
##			table = ((0,0),(0.14, 25/100), (0.3, 50/100), (0.65, 200/100))	## 幕墙结构胶(之江JS1200(单组分酸性)及JS2200(中性)建筑用透明硅酮结构密封胶)(适用于建筑幕墙中的玻璃结构粘结装配)
##			table = ((0,0),(1.3, 100/100), (1.79, 200/100), (2.33, 355))   ## 铝边框用天山1527硅胶
##			table = ((0,0),(0.8371, 0.2509,(1.3581, 0.5011),(2.3401, 0.7508))  ## 真应力与真应变，文献，uniaxial compression， obtained by Jorgen Bergstrom (jorgen@polymerfem.com)

		elif matname in ['EVA','EVA2']: ## 硅片应力主要受100%模量影响,而200%模量的影响很小。
			model = 'MARLOW'
##			table = ((0,0),(4,100/100), (4.5, 200/100), (16, 590/100))	## (边框优化项目)
##			table = ((0,0),(3,100/100), (4.5, 200/100), (16, 590/100))	## ****Good
			table = ((0,0),(EVA100,100/100), (4.5, 200/100), (16, 590/100))
##			table = ((0,0),(3.5, 50/100),(4.0, 100/100), (4.5, 200/100),(16, 590/100))  ## 文献，结果硅片应力94.26MPa，偏高
##			table = ((0,0),(2.08333,0.31429),(2.70833,0.71429),(3.54167,1.42857),(4.16667,1.85714),
##				(4.58333,2.14286),(6.25,3),(8.33333,3.64286),(10.41667,4.21429),(12.5,4.71429),
##				(14.16667,5),(16,5.9))  ##文献拟合数据，结果硅片应力87MPa，偏高

			options.append('EVA 100% modulus=' + str(EVA100) + 'MPa')  ##********

		elif matname in ['Rubber', 'Rubber2']:
			factor = rubber2_scale   ## factor=2.5或3时，对Diamon clamp mounting比较适合。
			table = ((0,0), (1.5*factor, 50/100), (2.5*factor, 100/100), (4.2*factor, 150/100))   	## 文献，清华大学王友善，轮胎，天然橡胶 (不收敛, TF clamp model)
##			table = ((0,0),(2,100/100), (4.5, 200/100), (16, 590/100))			## 借用EVA数据(成功用于橡胶，TF clamp model)

			## 艾国庆提供的曲线（橡胶很软）
##			table = ((0.0, 0.0), (0.080664, 0.10667), (0.15, 0.17333), (0.25, 0.24333), (0.3, 0.30667), (0.34, 0.36333), (0.37, 0.42667), (0.4, 0.47667), (0.42, 0.52667), (0.44, 0.56667), (0.46, 0.61333), (0.48, 0.65333), (0.51, 0.68667), (0.53, 0.72), (0.56, 0.74667), (0.58, 0.77667), (0.61, 0.79667), (0.66, 0.80667), (0.7, 0.81333))

	if model == 'OGDEN':
		model = OGDEN
	elif model in ['NH','N-H','R-POLY','NEO HOOKE', 'Neo-Hookean']:		##应变超过100%时可能橡胶的模拟应力偏小。
		model = NEO_HOOKE
	elif model == 'MARLOW': ## 最能体现双线性、多线性，只能输入测试数据，不能输入系数形式。
		model = MARLOW
	elif model == 'YEOH':	## 是N=3时的缩减多项式的特殊形式。在中等和很大的应变曲，模拟结果吻合较好。
		model = YEOH			## 该模型如果采用系数形式，需要3个系数。
	elif model in ['MOONEY_RIVLIN', 'MR','M-R']:			## 该模型如果采用系数形式，需要3个系数。
		model = MOONEY_RIVLIN

	_m.materials[matname].Hyperelastic(type=model,
	    volumetricResponse=POISSON_RATIO, poissonRatio=0.48, table=())		;please_check
	_m.materials[matname].hyperelastic.UniaxialTestData(table=table)

##	if new_create == True:
##		hex_name = matname + '_sec'
##		_m.HomogeneousSolidSection(material=matname, name=hex_name, thickness=1.0)

	return

def create_insts_dg(insts,name1='inst_dg1'):
	## VER: 2014-04-30, v1.0, note: display group will not save in cae file.

	insts = real_insts(insts)
	name1 = new_key(session.displayGroups.keys(), name1)

	leaf = dgm.LeafFromInstance(totuple(insts))
	dg = session.DisplayGroup(leaf=leaf, name=name1)

	return dg

function_labels['create_job'] = 'job','running','submit','core','parallel','inp'
def create_job(jobname=None,model_name=None,memory = 85,request_num=1, core_num=None, clear_jobs=True,restart=False,submit=False,activate_field=True):
	## VER: ('2017-06-07, v6.1') will create the inp file
	## Example:  一个空白模型，仅仅生成了一个分析步，也是可以生成inp文件的。
##	odb_title1 = create_inp(inp_file_title,request_num=6) ;please_check
##	mdb.jobs[odb_title1].submit()
##	print 'inp尚未提交。点击submit可以提交，或者用batch_run()运行inp'
##	print '注意：如果生成job后，GUI下又修改了边界条件，点击submit时，将按照最新的边界条件执行'

##	create_job()
##	submit()

	global options

	refresh()

	if is_int(core_num) and core_num > 0:
		request_num = core_num

	if jobname in empty:
		if 'inp_file_title' in globals().keys():
			jobname = inp_file_title
		else:
			cae_file = get_cae_file_title()
			if '_job' not in cae_file[-6:]:
				jobname = cae_file + '_job1'
			else:
				jobname = cae_file

	if type_of(jobname) != 'STR':
		raise Exception('**** jobname is required.')

	jobname = modify_string(jobname,'.','_')
	jobname = modify_string(jobname,'-','_')
	jobname = modify_string(jobname,' ','_')
	jobname = modify_string(jobname,'=')

	if clear_jobs == True:
		for job in mdb.jobs.keys():
			del mdb.jobs[job]
	else:
##		if jobname in mdb.jobs.keys() and restart == False:
##			del mdb.jobs[jobname]   ## delete existed job.

		jobname = new_key(mdb.jobs.keys(),jobname)

	print fnln(),'jobname=',jobname
##	print fnln(),'inp_file_title=',inp_file_title
##	print fnln(),'scrip file=    ',script_file_full[:-3]
##	print fnln(),'cae_file_title=',cae_file_title

##	raise Exception

##	print 'Saving mdb and submitting job...'
##	mdb.saveAs(script_file_full[:-3])

	if len(_m.predefinedFields) == 1:
		f1 = _m.predefinedFields.values()[0]
		if f1.suppressed == True:
			f1.resume()    ##  To avoid temporary suppressed predefined fields

	print 'Saving mdb as new job name...'
	mdb.saveAs(jobname)	;please_check

##	parameters = get_user_parameters()
##	write_user_parameters(jobname + '.vars',parameters=parameters)   ## will create the var file

##	show_time('Before submitting job ' + jobname)
##	int_num = len(_m.interactions)
##	tie_num = len(_m.constraints)
##	options.append('total interacts=' + str(int_num))
##	options.append('total ties=' + str(tie_num))

	if fnln_fnln()[0] != 'cliCommand':   ## 不是在GUI下运行create_inp()命令
		plot(a)
		vpnow = get_vpnow()
		vpnow.view.setValues(session.views['Front'])
		vpnow.enableMultipleColors()
		vpnow.setColor(initialColor='#BDBDBD')
		cmap=vpnow.colorMappings['Material']
		vpnow.setColor(colorMapping=cmap)
		vpnow.disableMultipleColors()
		save_image(postfix='_mats',opendir=False)

		vpnow.enableMultipleColors()
		vpnow.setColor(initialColor='#BDBDBD')
		cmap=vpnow.colorMappings['Part instance']
		vpnow.setColor(colorMapping=cmap)
		vpnow.disableMultipleColors()
		save_image(postfix='_insts',opendir=False)

	if restart == True:  ## next analysis will restart from this analysis.
		for part in _m.parts.keys():
			for setname in _m.parts[part].sets.keys():
##				print2('part=',part)
				if type_of_set(_m.parts[part], setname) != 'cells':
					del _m.parts[part].sets[setname]

	mats = get_all_mats()
	for mat in _m.materials.keys():
		if mat not in mats:
			del _m.materials[mat]

	a.regenerate()

	if model_name in empty:
		model_name = current_model_name
	else:
		if model_name not in mdb.models.keys():
			raise Exception('*** Error model name')

	import multiprocessing
	core0 = multiprocessing.cpu_count()

##	if core0 > 6:
##		core0 = 6  ## one license allow only 6 cores
##
##	if request_num > core0:
##		if get_computer_name()[0:3] != 'CND':
##			request_num = core0
##		elif submit == True:
##			request_num = core0

	## 不让人为指定并行数量。
	if get_computer_name()[0:3] == 'CND':
		request_num = 4
	else:
		request_num = 1
##		request_num = core0

	if len(_m.adaptiveMeshControls) > 0:  ## powder compaction, 局部ALE，多核可运行，但结果可能不对。
		request_num = 1   ## 有ALE，例如metal cutting and powder compaction

	## Explicit中使用多核可能出错。尤其是美国不允许使用多核。

	## create job
	mdb.Job(atTime=None, contactPrint=OFF, description=jobname,
	    echoPrint=OFF, explicitPrecision=SINGLE, getMemoryFromAnalysis=True,
	    historyPrint=OFF, memory=memory, memoryUnits=PERCENTAGE, model=model_name,
	    modelPrint=OFF, multiprocessingMode=DEFAULT, name=jobname,
	    nodalOutputPrecision=SINGLE, numCpus=request_num, numDomains=request_num,
	    parallelizationMethodExplicit=DOMAIN, queue=None, scratch='',
	    type=ANALYSIS, userSubroutine='', waitHours=0, waitMinutes=0)

##	if mdb.jobs[jobname].analysis == EXPLICIT_ANALYSIS:
	mdb.jobs[jobname].setValues(explicitPrecision=DOUBLE)	  ;changing

	## create the inp file
	mdb.jobs[jobname].writeInput(consistencyChecking=OFF)  ## write inp之前一定要先保存cae。
	copy_file(jobname + '.inp','inp')

	print '--->Inp file was written:', jobname + '.inp, model_name=',model_name

	if by_GUI == False:
		file_path = get_script_file()
		attrib(file_path,readonly=True)

##	file_path = '"' + file_path + '"'
##	comm = 'attrib +R ' + file_path
##	print fnln(),'command =',comm
##	os.system(comm)  ## file_path必须是绝对路径。不能仅仅是文件名。
##	stop1()

	print '  '
	print '****Model options, please check ...'
	print options
	print '  '

##	print 'Debugging: Warning..measure..contact..loading..BC..model..MP..meshing..animation..curve...'
	print 'Assembly->Step->output request and element type->Mesh->Interaction->Loads->Job'
	print ' '

	stats = a.getMeshStats(tuple(a.instances.values()))
	print ' '
##	print fnln(),'mesh stats=',stats
	if stats not in empty:  ## stats = None for an imported deformed mesh part, no geometry inside.
		print '** Model mesh status: Total hex elements number=',stats.numHexElems,
		if stats.numTetElems > 0:
			print ', Total tri elements numbers=',stats.numTetElems,
		print ', nodes numbers=',stats.numNodes
		print ' '

##	global cae_time
##	_time2 = time.time()
##	cae_time = round((_time2 - start_time)/60,2)

##	write_global_variables(var_file_full,output_vars, options,BCs,cae_time)

##	model_summary()

	num = mdb.jobs[jobname].numCpus

	print ' '
	print '*** Job',jobname+'.inp','is created, cpu num =',num
	print ' '
	print 'Further model change will change the job.'
	print 'Try batch_run() for many inp files'
##	print 'You can create a lot of inp files and then run batch_run() for efficiency'
##	print 'You need to save mdb then write inp, for correct parameters.'
##	print 'Or you can modify inp file directly.'
	print ' '

##	print 'inp尚未提交。点击submit可以提交，或者用batch_run()运行inp'
##	print '注意：如果生成job后，GUI下又修改了边界条件，点击submit时，将按照最新的边界条件执行'
##	if submit == True:
##		mdb.jobs[jobname].submit()

	return jobname

create_inp = create_job

def create_line_part(partname='line1',point1=(0,0),point2=(),sym_axis='V',ptype='analytical'):
	## VER: 2013-10-10, v1.0
	## Example: 	create_line_part(point2=(20,0))

	partname = new_key(_m.parts.keys(),partname)

	if is_location(point2) == False:
		raise Exception('*** location point2 is required.')

	## horizontal ejector
	sketch1 = create_base_sketch(name='s_line1',ndir='z', return_sketch=True)
##	s = sketch1['sketch']
	sketch1.setPrimaryObject(option=STANDALONE)
	sketch1.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
	sketch_name = sketch1.name

	create_sketch_line(sketch_name,point1=point1, point2=point2)
	sketch_to_wire(sketch_name,partname=partname,pshape='axisymmetric',ptype=ptype)

	return partname


def create_mat_hex(mat,propname):
	## VER: 2010-01-01

	_m.Material(name=mat)
	density = eval(propname + '_D')
	modulus = eval(propname + '_E')
	poisson = eval(propname + '_v')

	_m.materials[mat].Density(table=((density, ), ))
	_m.materials[mat].Elastic(table=((modulus, poisson), ))

	sec_name = mat + '_sec'
	_m.HomogeneousSolidSection(material=mat, name=sec_name, thickness=1.0)

	return

function_labels['create_material_iron'] = 'temperature','property','dependent','steel'
def create_material_iron(unit='mm',on_temp=True,on_rate=False) :
	## VER: 2015-04-28, v1.0
	## unit in SI
	# temp is for temperatutre

##	>>> create_material_iron()
##	['create_material_iron', 123] ---> Material iron is created, temperature dependency = True , rate dependency = False
##	>>> create_material_iron(on_rate=True)
##	['create_material_iron', 123] ---> Material iron is created, temperature dependency = True , rate dependency = True

	get_current_model()
	_m.setValues(absoluteZero=0.0, stefanBoltzmann=5.67e-8) # W/m2/K4	开氏温度
	myMaterial = _m.Material(name='iron')

	dataLineTuple = []
	temp = -6.0
	for i in range(0,150) :
		temp = temp + 10.0
		list1 = [elastic_mod_iron(temp,unit=unit), poissons_ratio_iron(temp), temp]
		dataLineTuple.append(list1)
	dataTuple = tuple(dataLineTuple)
	myMaterial.Elastic(temperatureDependency=ON, table=(dataTuple))

	dataLineTuple = []
	temp = 81.0
	for i in range(0,87) :
		temp = temp + 10.0
		list1 = [mean_CTE_iron(temp), temp]
		dataLineTuple.append(list1)
	dataTuple = tuple(dataLineTuple)
	myMaterial.Expansion(type=ISOTROPIC, zero=293.0, temperatureDependency=ON, table=(dataTuple))

	dataLineTuple = []
	temp = 67.0
	for i in range(0,118) :
		temp = temp + 10.0
		list1 = [conductivity_iron(temp,unit=unit), temp]
		dataLineTuple.append(list1)
	dataTuple = tuple(dataLineTuple)
	myMaterial.Conductivity(type=ISOTROPIC, temperatureDependency=ON, table=(dataTuple))

	dataLineTuple = []
	temp = -1.0
	for i in range(0,190) :
		temp = temp + 10.0
		list1 = [specific_heat_iron(temp,unit=unit), temp]
		dataLineTuple.append(list1)
	dataTuple = tuple(dataLineTuple)
	myMaterial.SpecificHeat(temperatureDependency=ON, table=(dataTuple))

	dataLineTuple = []
	temp = 81.0
	for i in range(0,87) :
		temp = temp + 10.0
		list1 = [density_iron(temp,unit=unit), temp]
		dataLineTuple.append(list1)
	dataTuple = tuple(dataLineTuple)
	myMaterial.Density(temperatureDependency=ON, table=(dataTuple))

	## temp = temperature data was taken at, rate = strain rate data was taken at
	dataLineTuple = []
	strain = -0.01
	temp = 773 # only needed if you want to enter the temperature of the data, 相当于500度
	rate = 0.01 # only need if you want to enter the strain rate of the test
	for i in range(0,55) :
		strain = strain + 0.01
		if on_temp == True and on_rate == ON:
			list1 = [Iron_stress_strain_3_4(strain,unit=unit), strain, rate, temp] # if you want to enter the strain rate use this line
		elif on_temp == True:
			list1 = [Iron_stress_strain_3_4(strain), strain, temp] # if you do not want to enter the strain rate use this line
		else:
			list1 = [Iron_stress_strain_3_4(strain), strain] # if you do not want to enter the temperature or strain rate use this line

		dataLineTuple.append(list1)

	strain = -0.01
	temp = 1073 # only needed if you want to enter the temperature of the data，相当于800度
	rate = 0.01 # only need if you want to enter the strain rate of the test
	for i in range(0,55) :
		strain = strain + 0.01
		if on_temp == True and on_rate == ON:
			list1 = [Iron_stress_strain_2_4(strain,unit=unit), strain, rate, temp] # if you want to enter the strain rate use this line
		elif on_temp == True:
			list1 = [Iron_stress_strain_2_4(strain), strain, temp] # if you do not want to enter the strain rate use this line
		else:
			list1 = [Iron_stress_strain_2_4(strain), strain] # if you do not want to enter the temperature or strain rate use this line

		dataLineTuple.append(list1)

	strain = -0.01
	temp = 773 # only needed if you want to enter the temperature of the data, 相当于500度
	rate = 0.1 # only need if you want to enter the strain rate of the test
	for i in range(0,55) :
		strain = strain + 0.01
		if on_temp == True and on_rate == ON:
			list1 = [Iron_stress_strain_3_3(strain,unit=unit), strain, rate, temp] # if you want to enter the strain rate use this line
		elif on_temp == True:
			list1 = [Iron_stress_strain_3_3(strain), strain, temp] # if you do not want to enter the strain rate use this line
		else:
			list1 = [Iron_stress_strain_3_3(strain), strain] # if you do not want to enter the temperature or strain rate use this line

		dataLineTuple.append(list1)

	strain = -0.01
	temp = 1073 # only needed if you want to enter the temperature of the data, 相当于800度
	rate = 0.1 # only need if you want to enter the strain rate of the data
	for i in range(0,55) :
		strain = strain + 0.01
		if on_temp == True and on_rate == ON:
			list1 = [Iron_stress_strain_2_3(strain,unit=unit), strain, rate, temp] # if you want to enter the strain rate use this line
		elif on_temp == True:
			list1 = [Iron_stress_strain_2_3(strain), strain, temp] # if you do not want to enter the strain rate use this line
		else:
			list1 = [Iron_stress_strain_2_3(strain), strain] # if you do not want to enter the temperature or strain rate use this line

		dataLineTuple.append(list1)

	dataTuple = tuple(dataLineTuple)

	if on_temp == True and on_rate == ON:
		myMaterial.Plastic(temperatureDependency=ON, rate=ON, table=(dataTuple))
	elif on_temp == True:
		myMaterial.Plastic(temperatureDependency=ON, table=(dataTuple))
	else:
		myMaterial.Plastic(table=(dataTuple))

	print fnln(),'---> Material iron is created, temperature dependency =',on_temp, ', rate dependency =',on_rate

	return

##################################################################################################

def poissons_ratio_iron(temp) :
        # Poissons ratio is unitless
        # temp must be in degrees Kelvin for these equations
	if temp >= 4.0 and temp <= 273.0 :
		data =  -6.293870E-13*temp*temp*temp*temp + 5.370994E-10*temp*temp*temp -6.309382E-08*temp*temp + 4.180781E-08*temp + 2.850633E-01
	elif temp > 273.0 and temp <= 1053.0 :
		data =  1.246582E-11*temp*temp*temp -3.856929E-08*temp*temp + 7.030261E-05*temp + 2.712267E-01
	elif temp > 1053.0 and temp <= 1500.0 :
		data = 1.661461E-09*temp*temp -1.242823E-06*temp + 3.165268E-01
	elif temp < 4.0 :
		data = 2.850625E-01
	elif temp > 1500.0 :
		data =  3.184009E-01

	data = smart_round(data)

	return data

##################################################################################################

def elastic_mod_iron(temp,unit='mm') :
        # Note: approximate values for plain carbon and low alloy steels;
        # values below 273K were calculated from C11, C12, C44
        # elastic modulus is in units of Pa
        # temp must be in degrees Kelvin for these equations
	if temp >= 4.0 and temp <= 273.0 :
		data =  -1.145454*temp*temp*temp*temp + 9.266601E+02*temp*temp*temp -3.051404E+05*temp*temp + 5.020008E+06*temp + 2.217366E+11
	elif temp > 273.0 and temp <= 1050.0 :
		data =  -1.063196E+05*temp*temp + 3.572844E+07*temp + 2.109875E+11
	elif temp > 1050.0 and temp <= 1500.0 :
		data =  -6.773810E+07*temp + 2.024261E+11
	elif temp < 4.0 :
		data =  2.217519E+11
	elif temp > 1500.0 :
		data =  1.008190E+11

	if unit == 'mm':
		data = data*1e-6   ## modulus unit = MPa
	data = smart_round(data)

	return data

##################################################################################################

def mean_CTE_iron(temp) :
        # the reference temperature is 293K; 8% error
        # data is in units of 1/K
        # temp must be in degrees Kelvin for these equations
	if temp >= 91.0 and temp < 410.0 :
		data =  8.156945e-014*temp*temp*temp -9.244895e-011*temp*temp +3.775811e-008*temp +6.517108e-006
	elif temp >= 410.0 and temp <= 960.0 :
		data =  4.782671e-017*temp*temp*temp*temp -1.357633e-013*temp*temp*temp +1.324312e-010*temp*temp -4.591434e-008*temp +1.664716e-005
	elif temp < 91.0 :
		data =  9.248995e-006
	elif temp > 960.0 :
		data =  1.512476e-005
	data = smart_round(data)

	return data

##################################################################################################

def conductivity_iron(temp,unit='mm') :
        # data is in units of W/(m-K)
        # temp must be in degrees Kelvin for these equations
	if temp >= 77.0 and temp <= 1255.0 :
		data = 9.690376e-011*temp*temp*temp*temp -2.494362e-007*temp*temp*temp +2.508465e-004*temp*temp -1.697584e-001*temp +1.066114e+002
	elif temp < 77.0 :
		data = 9.491680e+001
	elif temp > 1255.0 :
		data = 3.599398e+001

	if unit not in['mm','SI']:
##		data = data*coeff
		raise Exception('*** please provide the coefficient here.')
	data = smart_round(data)

	return data

##################################################################################################

def specific_heat_iron(temp, unit='mm') :
        # data is in units of J/(kg-K)
        # temp must be in degrees Kelvin for these equations, 需要用开氏温度

	if temp >= 1.0 and temp < 20.0 :
		data = 8.786827e-006*temp*temp*temp*temp +3.434114e-005*temp*temp*temp +3.543513e-003*temp*temp +7.343790e-002*temp +1.640777e-002
	elif temp >= 20.0 and temp < 130.0 :
		data =  5.251765e-008*temp*temp*temp*temp*temp -1.807849e-005*temp*temp*temp*temp +1.972324e-003*temp*temp*temp -5.588171e-002*temp*temp +9.005499e-001*temp -4.129967e+000
	elif temp >= 130.0 and temp < 500.0 :
		data =  -1.683141e-008*temp*temp*temp*temp +2.868283e-005*temp*temp*temp -1.780930e-002*temp*temp +5.191206e+000*temp -1.438118e+002
	elif temp >= 500.0 and temp < 1000.0 :
		data =  1.852870e-008*temp*temp*temp*temp -4.990048e-005*temp*temp*temp +5.023704e-002*temp*temp -2.189081e+001*temp +3.998510e+003
	elif temp >= 1000.0 and temp < 1042.0 :
		data =  6.672367e-004*temp*temp*temp -1.889510e+000*temp*temp +1.783888e+003*temp -5.606426e+005
	elif temp >= 1042.0 and temp < 1184.0 :
		data =  3.231248e-006*temp*temp*temp*temp -1.504264e-002*temp*temp*temp +2.625897e+001*temp*temp -2.037174e+004*temp +5.927268e+006
	elif temp >= 1184.0 and temp < 1665.0 :
		data =  1.496811e-001*temp +4.295303e+002
	elif temp >= 1665.0 and temp <= 1809.0 :
		data =  1.778200e-001*temp +4.402844e+002
	elif temp < 1.0 :
		data =  9.343231e-002
	elif temp > 1809.0 :
		data =  7.619609e+002

	if unit == 'mm':
		data = data*1e6
	data = smart_round(data)

	return data


##################################################################################################

def density_iron(temp,unit='mm') :
        # the reference temperature is 293K; 8% error
        # data is in units of g/cm^3
        # temp must be in degrees Kelvin for these equations

	if temp >= 91.0 and temp < 190.0 :
		data =  -6.010914e-009*temp*temp*temp +2.196832e-006*temp*temp -4.306436e-004*temp +7.924000e+000
	elif temp >= 190.0 and temp <= 960.0 :
		data =  1.470685e-010*temp*temp*temp -3.511597e-007*temp*temp -1.002710e-004*temp +7.910967e+000
	elif temp < 91.0 :
		data =  7.898474e+000
	elif temp > 960.0 :
		data =  7.621195e+000

	if unit == 'mm':
		data = data*1e-12
	data = smart_round(data)

	return data

##################################################################################################

def Iron_stress_strain_3_3(strain,unit='mm') :
	# bal Fe, 0.007 C, 0.03 Mn, 0.005 strain, 0.003 P (wt%)
	# forged at 1173K and annealed at 1023K for 2 h, alpha iron, tested
	# at 773K; measured in compression, strain rate of 0.1/strain
	# data is in units of Pa

	if strain >= 0.000000e+000 and strain < 5.000000e-002 :
		data = -1.203463e+012*strain**4 +4.772727e+011*strain**3 -6.325758e+010*strain*strain +3.847403e+009*strain +1.363636e+008
	elif strain >= 5.000000e-002 and strain <= 5.500000e-001 :
		data = -2.693338e+009*strain**4 +4.261622e+009*strain**3 -2.555474e+009*strain*strain +7.489855e+008*strain +1.911502e+008
	else :
		data = 1.000000e+100

	if unit == 'mm':
		data = data*1e-6
	data = smart_round(data)

	return data

##################################################################################################

def Iron_stress_strain_2_3(strain,unit='mm') :
	# bal Fe, 0.007 C, 0.03 Mn, 0.005 strain, 0.003 P (wt%)
	# forged at 1173K and annealed at 1023K for 2 h, alpha iron, tested
	# at 1073K; measured in compression, strain rate of 0.1/strain
	# data is in units of Pa

	if strain >= 0.000000e+000 and strain < 2.500000e-002 :
		data = -6.246135e+011*strain**4 +2.391775e+011*strain**3 -2.949134e+010*strain*strain +1.571583e+009*strain +3.084416e+007
	elif strain >= 2.500000e-002 and strain <= 5.500000e-001 :
		data = 4.499607e+009*strain**5 -7.743565e+009*strain**4 +5.084152e+009*strain**3 -1.686610e+009*strain*strain +3.486258e+008*strain +4.745064e+007
	else :
		data = 1.000000e+100

	if unit == 'mm':
		data = data*1e-6
	data = smart_round(data)

	return data

##################################################################################################

def Iron_stress_strain_3_4(strain,unit='mm') :
	# bal Fe, 0.007 C, 0.03 Mn, 0.005 strain, 0.003 P (wt%)
	# forged at 1173K and annealed at 1023K for 2 h, alpha iron, tested
	# at 773K; measured in compression, strain rate of 0.01/strain
	# data is in units of Pa

	if strain >= 0.000000e+000 and strain < 2.500000e-002 :
		data = 3.090909e+011*strain**3 -5.772727e+010*strain*strain +3.613636e+009*strain +9.090909e+007
	elif strain >= 2.500000e-002 and strain <= 5.500000e-001 :
		data = 2.608081e+009*strain**5 -7.291472e+009*strain**4 +6.866451e+009*strain**3 -3.033937e+009*strain*strain +7.530978e+008*strain +1.329767e+008
	else :
		data = 1.000000e+100

	if unit == 'mm':
		data = data*1e-6
	data = smart_round(data)

	return data


##################################################################################################

def Iron_stress_strain_2_4(strain,unit='mm') :
	# bal Fe, 0.007 C, 0.03 Mn, 0.005 strain, 0.003 P (wt%)
	# forged at 1173K and annealed at 1023K for 2 h, alpha iron, tested
	# at 1073K; measured in compression, strain rate of 0.01/strain
	# data is in units of Pa

	if strain >= 0.000000e+000 and strain < 5.000000e-002 :
		data = 5.194805e+009*strain**3 -1.688312e+009*strain*strain +2.012987e+008*strain +2.597403e+007
	elif strain >= 5.000000e-002 and strain <= 5.500000e-001 :
		data = -1.562222e+008*strain**4 +3.044643e+008*strain**3 -2.137375e+008*strain*strain +7.071508e+007*strain +2.940902e+007
	else :
		data = 1.000000e+100

	if unit == 'mm':
		data = data*1e-6
	data = smart_round(data)

	return data

function_labels['set_plastic_johnson_cook'] = 'metal cutting', 'hardening','isotropic','stainless steel','material property'
def set_plastic_johnson_cook(mat):
	## VER: 2017-10-22, v1.1

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	if mat == 'Steel_SS316L':
		## data from kevin's metal cutting job (A0199)
		del _m.materials['Steel_SS316L'].plastic
		                                                               ##    A      B      n      m     melting point    transition temperature
		_m.materials['Steel_SS316L'].Plastic(hardening=JOHNSON_COOK, table=((595.0, 580.0, 0.133, 1.03, 1520.0,           20.0),   ))
		_m.materials['Steel_SS316L'].plastic.RateDependent(type=JOHNSON_COOK, table=((0.023, 0.001), ))    ## c=0.023, epsilon dot zero=0.001
		_m.materials['Steel_SS316L'].InelasticHeatFraction(fraction=0.9)	## Independent heat fraction, default = 0.9, 功转热

	return

function_labels['set_damage_cohesive_failure'] = 'PV','suntech','tape','failure','VHB','3M','material property'
def set_damage_cohesive_failure(mat):
	## VER: 2017-10-22, v1.1

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	## Tape_damage = 'cohesive_failure'
	if mat == 'Tape':
		_m.materials['Tape'].MaxsDamageInitiation(table=((Tape_strength, Tape_strength, Tape_strength), ))		## 为了简化，就用实际测试结果（取三个方向的值都一样）
		_m.materials['Tape'].maxsDamageInitiation.DamageEvolution(type=DISPLACEMENT, table=((0.5, ), ))

##		del _m.materials['Tape'].elastic
		_m.materials['Tape'].Elastic(type=TRACTION, table=((Tape_E, Tape_E/3, Tape_E/3), ))

##		del _m.sections['Tape_sec']
		_m.CohesiveSection(name='Tape_sec', material='Tape', response=TRACTION_SEPARATION, outOfPlaneThickness=None)

	return

function_labels['material_database'] = 'suntech','PV','glass','silicone','PVB','EVA','rubber','TPT','tape','hard material','cemented carbide','property','database','library'
def material_database(unit='mm'):
	## VER: ('VER: 2016-10-23, v3.1')
	## 一开始执行material_database()时并不会创建所有的材料，而是在执行set_material()之后，才会根据需要创建相应的材料。

	global mat_lib, mat_names

	please_check
	materials = [ 'Diamond', 'WCCo', 'H3F','SixUF','H6F', 'H6N', 'DM80','H10F', 'H10pow', 'H11N','H15F', 'H15N', 'C20C', 'C9M', 'TM10', \
		'Steel','Steel1','Steel_SS316L', 'Steel_4340', 'Steel_PH174','Steel_Q235', 'Steel_Q345', 'Steel_K390', 'Steel_K460', \
		'Steel_EN24T', 'Steel_D2', 'Steel_H13', 'Steel_WMoCrV','Steel_36NiCrMo','Steel_C45', 'Steel_EN10718',	\
		'Rigid', 'DAEpow', 'Al_Au4G2017', 'Al_6063','Copper','Graphite','wood', 'Glass', 'Glass2', 'Silic','Silic2',  \
		'PVB', 'EVA','EVA2', 'Rubber','Rubber2', 'Al_6063','Al_6061', 'TPT', 'Si', 'Tape',  'Paper', 'Steel', 'Rigid', 'Wood', 'FRP']

	materials = remove_repeated_items(materials)

	mat_lib = {}
	for mat in materials:
		globals()[mat] = mat
		mat_lib[mat] = mat

	mat_names = []
	keys0 = locals().keys()

	## 符号：K is also used as ramda λ
	## Material properties: 至少需要E,D,v,CTE四项

	## Units
	## Linear phase(E)           Density(kg/m3)                Poison ratio
	## CTE (/K)                  Thermal conduction(W/m.K)     Specific heat capacity(J/kg.K)

	mat_names.append('Rigid')
	Rigid_E = 10000e9*KE		;		Rigid_D = 7.8*KD			;	Rigid_v = 0.01		;	Rigid_CTE = 5e-9
	Rigid_K = 0.1	;		Rigid_Cp = 485.7*K_Cp  ## steel

	## Steel is elastic (计算钢材用量时，按密度钢材7.85计算。)
	mat_names.append('Steel')
	Steel_E = 200e9*KE		;	Steel_D = 7.85e3*KD		;	Steel_v = 0.3
	Steel_CTE = 14.3e-6		; 	Steel_K = 60			;	Steel_Cp = 485.7*K_Cp  ## steel  (原来:11.19)
	## Dont' apply plastic behavior here

	mat_names.append('Steel1')
	Steel1_E = 200e9*KE			;	Steel1_D = 7.85e3*KD		;	Steel1_v = 0.3
	Steel1_CTE = 14.3e-6		; 	Steel1_K = 60				;	Steel1_Cp = 485.7*K_Cp  ## steel  (原来:11.19)
	Steel1_plastic = (235.0, 0.0),(390.0, 0.27)	## Q235
##	Steel1_plastic = (345, 0.0),(490, 0.21)

##	AISI Type H13 Hot Work Tool Steel
##	Categories:	Metal; Ferrous Metal; Tool Steel; Hot Work Steel
##	Material Notes:	High hardenability, excellent wear resistance and hot toughness. H13 has good thermal shock resistance and will tolerate some water cooling in service. Nitriding will improve hardness, but can diminish shock resistance if hardened layer is too thick. Electroslag Remelted (ESR) H13 has greater homogeneity and an exceptionally fine structure, resulting in improved machinability, polishability and high temperature tensile strength.
##	Applications: hot work applications: pressure die casting tools, extrusion tools, forging dies, hot shear blades, stamping dies, plastic molds. ESR H13 is great for aluminum die-casting tools and plastic mold tools requiring a very high polish.
##	Weldability: Pre and Post-heating recommended, can be welded with oxy-acetylene, inert shielded gas and shielded metal arc; Filler should be similar to the base metal.
##	Key Words:	UNS T20813, ASTM A681, FED QQ-T-570, BS 4659 BH13, BS 4659 H13, BS EN ISO 4957 :2000 X40CrMoV5-1, Werkstoff 1.2344

##	Uddeholm Orvar Supreme is a chromiummolybdenum-vanadium-alloyed steel which is 	characterized by:
##	? High level of resistance to thermal shock and thermal fatigue
##	? Good high-temperature strength
##	? Excellent toughness and ductility in all directions
##	? Good machinability and polishability
##	? Excellent through-hardening properties
##	? Good dimensional stability during hardening

	## steel, AISI H13, used for such as can tooling steel holder for carbide, job# A0270
	mat_names.append('Steel_H13')   ## 5.2wt% Cr, 1.4wt% Mo, 0.9wt% V, 1.0wt% Si, 0.4 wt% Mn, 0.39 wt% C, HRC=45-50
	Steel_H13_E = 210e9*KE		;	Steel_H13_D = 7.8e3*KD		;	Steel_H13_v = 0.3
	Steel_H13_CTE = 11.5e-6		; 	Steel_H13_K = 24.3			;	Steel_H13_Cp = 460*K_Cp     ## 经常写成: Cp=0.46J/g.K
##	Steel_H13_CTE = (11e-6,100),(11.5e-6,200),(12.4e-6,550)    ## means: 25-550degC: CTE=12.4e-6
	Steel_H13_CTE = (12.6e-6, 400), (13.2e-6, 600)  ## provided by supplier
##	Steel_H13_plastic = (1520,0),(1820,0.09)   ## elongation of 9% at break (?) for HRC=52
	Steel_H13_plastic = (1280, 0, 20), (1420, 0.09, 20), (1000, 0, 400), (600, 0, 600)   ## provided by supplier for HRC=45 ## 这里，Rm=1420 tensile strength, R02=1280 yield strength,

	## steel, Grade: z85wdcv6542, high speed steel: W6Mo5Cr4V2
	## High speed special steel bar 6542 /Din 1.3343/ Aisi M2 SKH9/ SKH51 /W6Mo5Cr4V2
	## job#: A0198, A0212, rotary cutter, 用于anvil的working table (surface)
	mat_names.append('Steel_WMoCrV')
	Steel_WMoCrV_E = 217e9*KE		;	Steel_WMoCrV_D = 8.1e3*KD		;	Steel_WMoCrV_v = 0.3
	Steel_WMoCrV_CTE = 11.5e-6		; 	Steel_WMoCrV_K = 19				;	Steel_WMoCrV_Cp = 460*K_Cp
##	Steel_WMoCrV_plastic = ((450,0), (750, 0.15))
	Steel_WMoCrV_plastic = (1200,0)

	## steel, Brand name: 35NCD16, Grade: Mat.No. 1.6773, DIN 36NiCrMo16 调质合金结构钢
	## job#:A0198, A0212, rotary cutter, 用于anvil shaft and CRC cutter steel shaft
	mat_names.append('Steel_36NiCrMo')
	Steel_36NiCrMo_E = 205e9*KE		;	Steel_36NiCrMo_D = 7.83e3*KD		;	Steel_36NiCrMo_v = 0.28
	Steel_36NiCrMo_CTE = 11.4e-6		;	Steel_36NiCrMo_K = 36				;	Steel_36NiCrMo_Cp = 480*K_Cp
##	Steel_36NiCrMo_yield = 800			;	Steel_36NiCrMo_tensile = 1000		;	Steel_36NiCrMo_elong = 0.08
	Steel_36NiCrMo_plastic = (800,0), (1000, 0.08)

	mat_names.append('Steel_PH174')
	Steel_PH174_E = 196e9*KE		;	Steel_PH174_D = 7.78e3*KD		;	Steel_PH174_v = 0.31
	Steel_PH174_CTE = 11.3e-6

	mat_names.append('Steel_plating')  ## 电镀钢
	Steel_plating_E = 200e9*KE		;	Steel_plating_D = 7.85e3*KD		;	Steel_plating_v = 0.3
	Steel_plating_CTE = 14.3e-6		; 	Steel_plating_K = 60			;	Steel_plating_Cp = 485.7*K_Cp
	Steel_plating_plastic = (205, 0), (360, 0.27)


	mat_names.append('Steel_Q235')
	Steel_Q235_E = 200e9*KE			;	Steel_Q235_D = 7.85e3*KD		;	Steel_Q235_v = 0.3
	Steel_Q235_CTE = 14.3e-6		; 	Steel_Q235_K = 60				;	Steel_Q235_Cp = 485.7*K_Cp  ## steel  (原来:11.19)
	Steel_Q235_plastic = (235.0, 0.0),(390.0, 0.27)
##	Steel_Q235_plastic = (210.0, 0.0),(370.0, 0.27)

	mat_names.append('Steel_Q345')
	Steel_Q345_E = 200e9*KE			;	Steel_Q345_D = 7.85e3*KD		;	Steel_Q345_v = 0.3
	Steel_Q345_CTE = 14.3e-6		; 	Steel_Q345_K = 60					;	Steel_Q345_Cp = 485.7*K_Cp  ## steel  (原来:11.19)
	Steel_Q345_plastic = (345, 0.0),(490, 0.21)


##  For wire drawing:
##	1. Grade of steel (important): 0.82%C
##	2. Elastic modulus (important): 210000 N/mm2
##	3. Yield stress and the plastic stress-strain behavior. (important)------>I will ask for more concrete info.
##	3. CTE (thermal expansion coefficient): 0.12 μm/K in range [40 – 300°C], or (0.0001*T2+0.08333*T-3.3907) μm at T(°C) in range [40 – 600°C]
##	4. Thermal conductivity: l = 20.6+0.008*T(°C) W/m.K
##	5. Specific heat capacity: Cp = 427.7+0.2965*T(°C) J/kg.K

	## S45C 拉丝模用
	## 45号钢, is used for wirdraw case; AISI/ASTM 1045 steel, normal DIN C45 steel (tool steel, plain steel)
	## C:=0.42-0.5wt%,Mn:=0.5-0.8wt%, Si:<0.4wt%, Cr:<0.4wt%, Ni:<0.4wt%, Mo:<0.1wt%, Cr+Mo+Ni<=0.63wt%
	mat_names.append('Steel_C45') ## 有时称为C45E
	Steel_C45_E = 210e9*KE		;	Steel_C45_D = 7.85e3*KD		;	Steel_C45_v = 0.27
	Steel_C45_CTE = 10e-6		;	Steel_C45_K = 25			;	Steel_C45_Cp = 460*K_Cp
##	Steel_C45_plastic = (490, 0), (680, 0.16)
##	Steel_C45_plastic = (430, 0), (650, 0.16) ## saarstahl
	Steel_C45_plastic = (340, 0), (620, 0.14) ## www.lucefin.com, hot rolled
##	Steel_C45_plastic = (350, 0), (640, 0.16)
	Steel_C45_fatigue = 275     ## 45号钢的疲劳极限是σ-1=241.8MPa, 25#钢(C%=0.25%)的疲劳极限是σ-1=127.1MPa

	mat_names.append('Steel_SS304')
	Steel_SS304_E = 210e9*KE		;	Steel_SS304_D = 7.8e3*KD		;	Steel_SS304_v = 0.3
	Steel_SS304_CTE = 12.22e-6		;	Steel_SS304_K = 42.5			;	Steel_SS304_Cp = 379*K_Cp
	Steel_SS304_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
##	Steel_SS304_plastic = (215,0), (515,0.4)

	## SS316L
	## data from kevin's metal cutting job (A0199). Application in wire draw (A0232)
	mat_names.append('Steel_SS316L')
	Steel_SS316L_E = 210e9*KE		;	Steel_SS316L_D = 7.8e3*KD		;	Steel_SS316L_v = 0.3
	Steel_SS316L_CTE = 12.22e-6		;	Steel_SS316L_K = 42.5			;	Steel_SS316L_Cp = 379*K_Cp
	Steel_SS316L_plastic = (490, 0), (680, 0.16)  ## hardening=ISOTROPIC						;please_check
	Steel_SS316L_plastic_hardening = ISOTROPIC
	Steel_SS316L_fatigue = 275
	## data from A0199, metal cutting
	Steel_SS316L_plastic_hardening = JOHNSON_COOK
	## see set_johnson_cook()
##	## data from kevin's metal cutting job (A0199)
##	del _m.materials['Steel_SS316L'].plastic
##	_m.materials['Steel_SS316L'].Plastic(hardening=JOHNSON_COOK, table=((595.0, 580.0, 0.133, 1.03, 1520.0, 20.0),   ))
##	_m.materials['Steel_SS316L'].plastic.RateDependent(type=JOHNSON_COOK, table=((0.023, 0.001), ))
##	_m.materials['Steel_SS316L'].InelasticHeatFraction(fraction=0.9)	## default = 0.9, 功转热


	## cold work tool steel，如上下冲的刀柄用。(注意：上下冲的工具钢的刀柄处于压应力状态，是安全的）
	## job# A0205, press tool crack，三角形下冲
	mat_names.append('Steel_K460')
	Steel_K460_E = 210e9*KE		;	Steel_K460_D = 7.85e3*KD	;	Steel_K460_v = 0.3
	Steel_K460_CTE = 12.5e-6		;	Steel_K460_K = 30				;	Steel_K460_Cp = 460*K_Cp
##	Steel_K460_yield_compr = 1900	## cold work tool steel
	Steel_K460_plastic = (1900, 0)	## compressive

	## PM tool steel K390, 奥地利Bohler（百禄）公司
	## job# A0205, press tool crack，三角形下冲
	mat_names.append('Steel_K390')
	Steel_K390_E = 220e9*KE		;	Steel_K390_D = 7.51e3*KD		;	Steel_K390_v = 0.3
	Steel_K390_CTE = 13.2e-6	;	Steel_K390_K = 20.1				;	Steel_K390_Cp = 464*K_Cp
	Steel_K390_TRS=6000
	Steel_K390_plastic = (1900, 0)	## compressive

	## 牌号：USA AISI/ASTM 4340, Japan JIS SNCM8, Australia 4340, GB BS970 EN24.
	## job#: A0210, steel case for multihole press tie.   alloy steel (强韧性指标大约是45号钢的2倍),
	mat_names.append('Steel_4340')
	Steel_4340_E = 205e9*KE		;	Steel_4340_D = 7.85e3*KD	;	Steel_4340_v = 0.29
	Steel_4340_CTE = 13.7e-6	;	Steel_4340_K = 44.5			;	Steel_4340_Cp = 475*K_Cp
##	Steel_4340_yield = 850		;  Steel_4340_tensile=980 		;  Steel_4340_elong = 0.17
	Steel_4340_plastic = (850, 0), (980, 0.17)
	Steel_4340_fatigue=470

	## 牌号GB EN24; AISI 4340
	## job#: A0192, steel case for die, requestor: Matthew Gibbs, UK Coventry (916 pressing die)
	mat_names.append('Steel_EN24T')
	Steel_EN24T_E = 206e9*KE		;	Steel_EN24T_D = 7.8e3*KD		;	Steel_EN24T_v = 0.3	;
	Steel_EN24T_CTE = 14e-6			; 	Steel_EN24T_K = 37.7				;	Steel_EN24T_Cp = 460*K_Cp
	Steel_EN24T_plastic = ((680, 0), (850, 0.13))

	## 牌号：SKD11 = AISI D2 = DIN 1.2379, 高碳（硬度高）高铬（强度高）冷作模具钢, i.e, so called: Cr12 steel
	## 916压型模具的中模（无锡，Coventry)
	## Job#: A0216
	mat_names.append('Steel_D2')
	Steel_D2_E = 200e9*KE		;	Steel_D2_D = 7.7e3*KD		;	Steel_D2_v = 0.3	;
	Steel_D2_CTE = 10.4e-6		; 	Steel_D2_K = 25				;	Steel_D2_Cp = 460*K_Cp
	Steel_D2_plastic = (450, 0), (750, 0.15)				;	Steel_D2_fatigue = 275

	## 低碳钢介绍
##	低碳钢（mild steel）为碳含量低于0.25%的碳素钢，因其强度低、硬度低而软，故又称软钢。它包括大部分普通碳素结构钢和一部分优质碳素结构钢，
##	大多不经热处理用于工程结构件，有的经渗碳和其他热处理用于要求耐磨的机械零件。[1]
##	低碳钢退火组织为铁素体和少量珠光体，其强度和硬度较低，塑性和韧性较好。因此，其冷成形性良好，可采用卷边、折弯、冲压等方法进行冷成形。
##	这种钢还具有良好的焊接性。含碳量从0.10%至0.30%低碳钢易于接受各种加工如锻造，焊接和切削， 常用於制造链条， 铆钉， 螺栓， 轴等。

	## 牌号：EN 1.0718 = AISI 12L13 = EN 11SMnPb30= DIN 9SMnPb28 (wire draw用，西班牙，贝尔卡特的钢套）。steel case
	## C:0.08wt%, Mn: 0.9-1.3wt%, Pb: 0.2-0.35wt%, S: 0.3wt%,
	mat_names.append('Steel_EN10718')
	Steel_EN10718_E = 211e9*KE			;	Steel_EN10718_D = 7.8e3*KD		;	Steel_EN10718_v = 0.3	;
	Steel_EN10718_CTE = 12.2e-6			; 	Steel_EN10718_K = 51.9			;	Steel_EN10718_Cp = 472*K_Cp
##	Steel_EN10718_yield = 529			;	Steel_EN10718_tensile = 572		;	Steel_EN10718_elong = 0.08	   ## steel
##	Steel_EN10718_plastic = (529,0), (572, 0.08)
	Steel_EN10718_plastic = (235,0), (395, 0.22)  	## www.matweb.com, hot rolled 热轧
##	Steel_EN10718_plastic = (415,0), (540, 0.10)  	## www.matweb.com, cold drawn 冷拉，冷拔
##	Steel_EN10718_plastic = (400,0), (550, 0.10)  	## saarstahl, cold drawn

	## tensile strength, ultimate: 拉断的强度，拉伸强度
	## tensile strength, yield: 拉伸屈服强度

	##=================carbide

	mat_names.append('WCCo')
	WCCo_E = 531e9*KE		;		WCCo_D = 14.4e3*KD			;	WCCo_v = 0.23			;	WCCo_CTE = 10e-6		;	WCCo_K = 20	;			WCCo_Cp = 300*K_Cp      ## has problem

	## RTP 076粉。application: such as bottom punch
	## job# A0205, press tool crack，三角形下冲
	mat_names.append('H15F')
	H15F_E = 531e9*KE		;		H15F_D = 13.91e3*KD		;	H15F_v = 0.23
	H15F_CTE = 6.73e-6		;		H15F_K = 62.8			;	H15F_Cp = 340*K_Cp		## K:400degC的结果,  CTE曾用7.42
	H15F_K = (90.5, 20), (60.9, 200.0), (62.8, 400.0), (72.6, 1000.0)
	H15F_Cp = (250.0*K_Cp, 20), (340.0*K_Cp, 500.0), (420.0*K_Cp, 1000.0)

	## origin: E=540GPa, CTE=6.23
	mat_names.append('H15N')
	H15N_E = 540e9*KE		;		H15N_D = 13.9e3*KD		;	H15N_v = 0.23
	H15N_CTE = 6.23e-6    ## origin: 6.23,  3.4*9/5 = 6.12.  Other tested data (T drive) is about 6.7 for RT-400degC

	## H11N carbide, used in PDC, Co=11%. Job#: A0215
	mat_names.append('H11N')  ## High toughness grade, corrosion > 7. 不耐腐蚀
	H11N_E = 570e9*KE		;		H11N_D = 15.80e3*KD		;	H11N_v = 0.24
	H11N_CTE = 5.9e-6		;		H11N_K = 62.8			;	H11N_Cp = 340*K_Cp		## K and Cp need confirm

	## TM10, cermet, TiMoCN + 13Ni + 2Mo
	mat_names.append('TM10')
	TM10_E = 440e9*KE		;		TM10_D = 6.09e3*KD		;	TM10_v = 0.22
	TM10_CTE = 8.46e-6

	## C9M, cermet, RTP code=436, PEG=DPS, HIP sintering, 8.02%Ni, Cr3C2=0.8%, Mo=0.28%, WC=90.9%, fine grade(2-4um), powder density=3.50g/cc, sinter loss=2.50%, K1c=11, compressive strength=4500,
	## application: pump seal ring, can tooling die(cupper杯型 press tooling), 耐腐蚀(PH>3), 不含Co. Binder=NiMoCr
	mat_names.append('C9M')	## HV30=1315-1435, HRA=89.7-90.5
	C9M_E = 600e9*KE		;		C9M_D = 14.6e3*KD		;	C9M_v = 0.22
	C9M_CTE = 5.3e-6		;		C9M_K = 65				;	C9M_tensile = 2600   ## or 2600(宣传手册）
##	C9M_CTE = (5.5e-6, 100), (5.4e-6, 300), (5.7e-6, 600)
	C9M_CTE = (5.3e-6, 100), (5.3e-6, 200),(5.5e-6, 300), (5.7e-6, 400),(5.7e-6, 500),(5.9e-6, 600),(5.8e-6, 700),(5.7e-6, 800),(5.4e-6, 900), (3.5e-6, 1000)
	## CTE来自C9M-436.pdf
	## 没有ultimate stress and strain at break (ideally have stress-strain curve for the material)
	## The intention is to have the pump operating in the temperature interval -30 – +120 degC, alternatively up to +180 degC or 230 degC.
	## Because of the elevated temperatures in use, it would be good to know how the above material data depend on temperature.

	## C10C:耐腐蚀，Binder=NiMoCr

	## C20C, 9.0%Co, 10%Ni, 0.95%Cr, grain size 3.5-5um, cermet
	mat_names.append('C20C')
	C20C_E = 400e9*KE		;		C20C_D = 13.52e3*KD		;	C20C_v = 0.24
	C20C_CTE = 6.05e-6		;		C20c_K = 65

	## warning: K and Cp need confirm
	## WC-Co (RTP060), W2B粉类似于H10F,但W2B粉烧损=2.78
	mat_names.append('H10F')
	H10F_E = 583e9*KE		;		H10F_D = 14.46e3*KD			;	H10F_v = 0.23
	H10F_CTE = 5.9e-6		;		H10F_K = 71.2					;	H10F_Cp = 340*K_Cp		## K:400degC的结果, RTP 060粉
	H10F_plastic = (1000, 0), (2750, 0.005), (4250, 0.01), (5000, 0.014), (5500, 0.02), (5700, 0.03), (5700, 0.04), (5600, 0.06)
	H10F_shrinkage = 0.19	## need confirm
##	H10F_plastic = get_true_stress_and_plastic_strain(stress_strain_table=H10F_plastic, modulus=583000, strain_limit=0.0037)
	## 结果: H10F_plastic = ((2157.1, 0), (4250, 0.0027), (5000, 0.0054), (5500, 0.0106), (5700, 0.0202), (5700, 0.0302), (5600, 0.0504))
##	_m.materials[H10F].Plastic(table=((2750, 0), (4250, 0.01), (5000, 0.014), (5500, 0.02), (5700, 0.03), (5700, 0.04), (5600, 0.06)))

	mat_names.append('H10pow')   ## 060粉
	H10pow_E = 7e9*KE		;		H10pow_D = 3.24e3*KD			;	H10pow_v = 0.22		## density=3.37 or 3.24?
	H10pow_plastic = 'DPC_cap';		H10pow_C1 = 2.505	## 不同批次会不同，例如：2.42, 2.45, 2.505, 2.52, 2.61 (sinter loss)
	## H10的回收粉的sinter loss要大些，例如W2B=2.78

	## PN90: modulus = 595GPa，晶粒很细，竞争对手仿不出来。在旋转刀具用得很多

	## RTP 040粉
	mat_names.append('H6F')
	H6F_E = 628e9*KE		;		H6F_D = 14.9e3*KD			;	H6F_v = 0.23
	H6F_CTE = 5.3e-6		;		H6F_K = 75.3				;	H6F_Cp = 340*K_Cp		## K:400degC的结果，

	## H6N, hardness HV30=1578, average grain size=1.5um
	mat_names.append('H6N')	## 不耐腐蚀，碱性环境使用
	H6N_E = 634e9*KE		;		H6N_D = 14.96e3*KD			;	H6N_v = 0.23
	H6N_CTE = 5.34e-6		;		H6N_K = 75.3				;	H6N_Cp = 340*K_Cp		## K:400degC的结果，
	## CTE: RT-100degC = 3.6ppm/K, test data: 5.34 in T drive.

	## RTP 007粉，used in wire draw Nib (参考文档: TM R&D 48919)
	mat_names.append('H3F')
	H3F_E = 667e9*KE		;		H3F_D = 15.3e3*KD			;	H3F_v = 0.23
	H3F_CTE = 4.9e-6		;		H3F_K = 73					;	H3F_Cp = 290*K_Cp		## CTE:0-300degC，
	H3F_bend = 3152*KE

##	H3F:
##	1.       Modulus of elasticity: 670GPa
##	2.       Poisson modulus: 0.22
##	3.       Density: 15.23 g/cm3
##	4.       Thermal expansion coefficient: 5.73e-6 (RT-400degC)
##	5.       Thermal conductivity: 84 W/m-degC
##	6.       Specific heat capacity: 0.21 J/(g-K) @ RT, 0.29@500degC,  0.41@1000degC

	## 6UF, (ultra Fine) 6%Co, 参考6UF的properties (From MPD data). used in wire draw Nib
	mat_names.append('SixUF')
	SixUF_E = 620e9*KE		;		SixUF_D = 14.75e3*KD		;	SixUF_v = 0.23
	SixUF_CTE = 5.31e-6		;		SixUF_K = 51.5				;	SixUF_Cp = 280*K_Cp		## K:400degC的结果，
	SixUF_bend = 2958*KE
	SixUF_plastic = (1000, 0), (3000, 0.005), (5500, 0.01), (7000, 0.016), (7600, 0.02), (8000, 0.026)

##	6UF:
##	1.       Modulus of elasticity: 621GPa
##	2.       Poisson modulus: 0.22
##	3.       Density: 14.75
##	4.       Thermal expansion coefficient: 5.45e-6 (RT-400degC)
##	5.       Thermal conductivity: 64 W/m-degC
##	6.       Specific heat capacity: 0.20 J/(g-K) @ RT, 0.28@500degC,  0.39@1000degC

	## warning: density need confirm, K and Cp need confirm
	## DM80 is 8UF, WC-Co (RTP626)
	## job#: A0197, HPHT tools, see TM5856 Tooling report, sometimes we say DM80_E = 600GPa
	mat_names.append('DM80')
	DM80_E = 595e9*KE		;		DM80_D = 14.46e3*KD		;		DM80_v = 0.23
	DM80_CTE = 5.6e-6		;		DM80_K = 62.8			;		DM80_Cp = 340*K_Cp
	DM80_plastic = (1000, 0), (3000, 0.005),(5200, 0.01), (6000, 0.0125), (7000, 0.02), (7500, 0.028)
##	table1 = ((1000, 0), (3000, 0.005), (5500, 0.01), (7000, 0.016), (7600, 0.02), (8000, 0.026))
##	DM80_plastic = get_true_stress_and_plastic_strain(stress_strain_table=table1, modulus=595000, strain_limit=0.006)
##	print 'DM80: DM80_plastic=',DM80_plastic
##	_m.materials[DM80].Plastic(table=DM80_plastic)
	## 结果: DM80_plastic = ((3570.0, 0), (7000, 0.0042), (7600, 0.0072), (8000, 0.0126))
##	_m.materials[H10F].Plastic(table=((1000, 0), (2750, 0.005), (4250, 0.01), (5000, 0.014), (5500, 0.02), (5700, 0.03), (5700, 0.04), (5600, 0.06)))
##	_m.materials[DM80].Plastic(table=((4600, 0), (5500, 0.01), (7000, 0.016), (7600, 0.02), (8000, 0.026)))

	## PCD, used in PDC, job#: A0215 (modulus and density based on recent work on D27 PCD layers at Northwestern University)
	mat_names.append('Diamond')
	Diamond_E = 1045e9*KE		;		Diamond_D = 3850e3*KD		;		Diamond_v = 0.14
	Diamond_CTE = 4.0e-6		;		Diamond_K = 62.8			;		Diamond_Cp = 340*K_Cp		## K and Cp need to confirm

	## ==============Others
	mat_names.append('Copper')
	Copper_E = 117e9*KE		;	Copper_D = 8.9e3*KD		;	Copper_v = 0.34		;	Copper_CTE = 22e-6		; 	Copper_K = 391	;	Copper_Cp = 385*K_Cp  ;
	Copper_plastic = ((160,0), (370, 0.49))
	Copper_fatigue = 999

	mat_names.append('Graphite')
	Graphite_E = 8.5e9*KE		;	Graphite_D = 1.75e3*KD		;	Graphite_v = 0.22		;	Graphite_CTE = 3e-6		; 	Graphite_K = 190	;	Graphite_Cp = 999*K_Cp  ; 	Graphite_Re = 999	;		Graphite_tensile = 999;   Graphite_elong = 999   ;  Graphite_fatigue = 999

	mat_names.append('Al_Au4G2017')
	Al_Au4G2017_E = 72.4e9*KE	;	Al_Au4G2017_D = 2.79e3*KD		;	Al_Au4G2017_v = 0.33	;	Al_Au4G2017_CTE = 22.9e-6	; 	Al_Au4G2017_K = 134	;	Al_Au4G2017_Cp = 920*K_Cp  ; Al_Au4G2017_Re = 280

	mat_names.append('Al_6063')  ## 边框用铝
	Al_6063_E = 69e9*KE	;		Al_6063_D = 2.7e3*KD		;	Al_6063_v = 0.33		;	Al_6063_CTE = 23.4e-6
	Al_6063_K = 209			;  	Al_6063_Cp = 900*K_Cp		## 边框用铝   209
	A6063_T5a = (140.0, 0.0),(180.0, 0.08)   ## 偏低
	A6063_T5b = (180.0, 0.0),(220.0, 0.08)
	A6063_T5c = (195.0, 0.0),(240.0, 0.08)
	A6063_A = (160.0, 0.0),(200.0, 0.05)
	frame_alum_strength = 180	;changing
	if frame_alum_strength > 185:
		Al_6063_plastic = A6063_T5c  ;please_check
	else:
		Al_6063_plastic = A6063_T5b

	mat_names.append('Al_6061')
	Al_6061_E = 69e9*KE	;		Al_6061_D = 2.7e3*KD		;	Al_6061_v = 0.33		;	Al_6061_CTE = 23.4e-6
	Al_6061_K = 209	;  			Al_6061_Cp = 900*K_Cp		## 非边框用铝
	A6061_T6 = (240.0, 0.0),(290.0, 0.1)   ## Reliathon
	Al_6061_plastic = A6061_T6

	mat_names.append('PVB')
	PVB_E = 100e6*KE		;		PVB_D = 1.1e3*KD			;	PVB_v = 0.47			;	PVB_CTE = 240e-6

	mat_names.append('EVA')
	EVAE = 15	;changing   ## 5, 15
	EVA100 = 2.5		;		please_check('100%模量')
	EVA_E = EVAE*1e6*KE		;	EVA_D = 0.95e3*KD		;	EVA_v = 0.47			;	EVA_CTE = 180e-6
	EVA_K = 0.23		;		EVA_Cp = 2300*K_Cp
	EVA_hyperElastic = ''   ;please_check ## empty means simple elastic

	mat_names.append('EVA2')
	EVA2_E = 5e6*KE			;	EVA2_D = 0.95e3*KD			;	EVA2_v = 0.47			;	EVA2_CTE = 180e-6
	EVA2_K = 0.23			;	EVA2_Cp = 2300*K_Cp
	EVA2_hyperElastic = 'YEOH'	;please_check

	mat_names.append('Rubber')
	Rubber_E = 5e6*KE		;	Rubber_D = 1.1e3*KD			;	Rubber_v = 0.45			;	Rubber_CTE = 200e-6
	Rubber_K = 0.2	;			Rubber_Cp = 1600*K_Cp

	mat_names.append('Rubber2')
	rubber2_scale = 2.5
	Rubber2_E = 5e6*KE		;	Rubber2_D = 1.1e3*KD			;	Rubber2_v = 0.45			;	Rubber2_CTE = 200e-6
	Rubber2_K = 0.2	;			Rubber2_Cp = 1600*K_Cp
	Rubber2_hyperElastic = 'YEOH'	;please_check

	mat_names.append('Silic')
	silE = 2   ;changing  ## default = 0.5MPa
	Silic_E = silE*1e6*KE	;	Silic_D = 1.1e3*KD			;	Silic_v = 0.48			;	Silic_CTE = 230e-6
	Silic_K = 0.3			;	Silic_Cp = 1600*K_Cp
	Silic_strength = 0.2e6*KE

	mat_names.append('Silic2')
	silE = 2   ;changing  ## default = 0.5MPa
	Silic2_E = silE*1e6*KE	;	Silic2_D = 1.1e3*KD			;	Silic2_v = 0.48			;	Silic2_CTE = 230e-6
	Silic2_K = 0.3			;	Silic2_Cp = 1600*K_Cp
	Silic2_strength = 0.2e6*KE
	Silic2_hyperElastic = 'YEOH'

	mat_names.append('Tape')
	Tape_E = 0.9e6*KE		;	Tape_D = 0.7e3*KD			;	Tape_v = 0.47			;	Tape_CTE = 180e-6
	Tape_K = 0.08	;			Tape_Cp = 280*K_Cp		## ******** B23F: K=0.08
	Tape_strength = 0.3e3*KE    ## 85MPa (Tape_strength is used in cohesive failure)
##	Tape_E = 0.5e6*KE		;		Tape_D = 0.7e3*KD			;	Tape_v = 0.35			;	Tape_CTE = 180e-6		; 	Tape_K = 0.08	;	Tape_Cp = 280*K_Cp		## ******** B23F: K=0.08
	Tape_type = 'cohesive'		;please_check('elastic, cohesive')
	if Tape_type == 'cohesive':
		Tape_damage = 'cohesive_failure'
	else:
		Tape_damage = ''

	mat_names.append('TPT')
	TPT_E = 2e9*KE			;	TPT_D = 1.4e3*KD			;	TPT_v = 0.35			;	TPT_CTE = 180e-6
	TPT_K = 0.36		;  		TPT_Cp = 1050*K_Cp

	mat_names.append('FRP')
	FRP_E = 40e9*KE			;	FRP_D = 2.1e3*KD			;	FRP_v = 0.3				;	FRP_CTE = 10e-6
	FRP_K = 0.5		;			FRP_Cp = 1500*K_Cp

	mat_names.append('Makrolon')
	Makrolon_E = 2.4e9*KE	;		Makrolon_D = 1.2e3*KD		;	Makrolon_v = 0.38		;	Makrolon_CTE = 65e-6

	mat_names.append('Paper')
	Paper_E = 38e6*KE		;		Paper_D = 0.6e3*KD			;	Paper_v = 0.2			;	Paper_CTE = 10e-6

	mat_names.append('Si')
	Si_E = 131e9*KE			;		Si_D = 2.33e3*KD			;	Si_v = 0.28				;	Si_CTE = 2.6e-6

	mat_names.append('Glass')
	glassE = 70		;changing	## 70, 67
	Glass_E = glassE*1e9*KE	;	Glass_D = 2.5e3*KD			;	Glass_v	= 0.23			;	Glass_CTE = 9.28e-6
	Glass_K = 0.95	;			Glass_Cp = 880*K_Cp			## 0.98, 超白浮法玻璃, 9.28(jinjing)

	mat_names.append('Glass2')
	Glass2_E = 72e9*KE		;	Glass2_D = 2.5e3*KD			;	Glass2_v	= 0.23		;	Glass2_CTE = 8.6e-6
	Glass2_K = 0.95	;			Glass2_Cp = 880*K_Cp			## 0.98，普通浮法玻璃

	mat_names.append('wood')
	wood_E = 6e9*KE	;		wood_D = 0.6e3*KD			;	wood_v = 0.2			;	wood_CTE = 100e-6		;	wood_K = 30	;			wood_Cp = 100*K_Cp	## 只有E是准确的。


	## DAE is one powder from internet (DAE Pulver)
	mat_names.append('DAEpow')
	DAEpow_E = 7e9*KE		;		DAEpow_D = 3.37e3*KD			;	DAEpow_v = 0.18			;	DAEpow_CTE = 5.9e-6		;	DAEpow_K = 62.8;			DAEpow_Cp = 340*K_Cp
	DAC_plastic = 'DPC_cap'


	locals2globals(keys0,locals())	;please_check

function_labels['create_material'] = 'property','section'
def create_material(mat):
	## VER: 2016-10-24, v1.1

	if type_of(mat) != 'STR':
		raise Exception('*** material name is required.')

	if mat in _m.materials.keys():
		print fnln_fnln(), '*** material already existed.'
		return

	try:
		density = eval(mat + '_D')
		modulus = eval(mat + '_E')
		poisson = eval(mat + '_v')
	except:
		raise Exception('*** No such material properties')

	_m.Material(name=mat)   ## create new material
	if mat + '_description' in globals().keys():
		description = eval(mat + '_description')
		_m.materials[mat].setValues(description=description)

	table1 = eval(mat + '_D')
	set_density(mat,table1)   ## may be temperature dependent

	_m.materials[mat].Elastic(table=((modulus, poisson), ))  ## temperature independent

	if mat + '_hyperElastic' in globals().keys():
		model = eval(mat + '_hyperElastic')
		if model not in empty:
			set_hyperElastic(mat,model=model)	;please_check

	if mat + '_plastic' in globals().keys():
		table1 = eval(mat + '_plastic')
		if table1 == 'DPC_cap':
			set_DPC_plastic_cap(mat)
		else:
			set_plastic(mat,table1)	## stress strain behavior

	if mat + '_plastic_hardening' in globals().keys():
		hardening = eval(mat + '_plastic_hardening')  ## default = ISOTROPIC
		if hardening == JOHNSON_COOK:
			set_plastic_johnson_cook(mat)

	if mat + '_damage' in globals().keys():
		damage = eval(mat + '_damage')
		if damage == 'cohesive_failure':
			set_damage_cohesive_failure(mat)

	if mat + '_CTE' in globals().keys():
		table1 = eval(mat + '_CTE')
		set_CTE(mat,table1,zero_expand_temp=20)

	if mat + '_K' in globals().keys():
		table1 = eval(mat + '_K')
		set_conductivity(mat,table1)

	if mat + '_Cp' in globals().keys():
		table1 = eval(mat + '_Cp')
		set_Cp(mat,table1)

 	## 并不是说if len(p.cells)>0, 用'_sec'; else用'_shell'
 	##Create solid material section
	sec_name = mat + '_sec'   ## applicable for 2D_axisymmetric_shell, 2D_planar_shell, 例如压型的压坯button
	_m.HomogeneousSolidSection(material=mat, name=sec_name, thickness=1.0)  ## Applicable for both solid and shell parts
	## type: Solid, homogeneous, thickness means the plane strain/stress thickness. 对于一个3D模型，勾选thickness无影响。

##	shell_name = mat + '_shell'   ## for '3D_shell' only，对于solid part用不到，即使是2D_axisymmetric模型。
##	_m.HomogeneousShellSection(name=shell_name,  preIntegrate=OFF, material=mat, thicknessType=UNIFORM, thickness=1.0,
##	    thicknessField='', idealization=NO_IDEALIZATION, poissonDefinition=DEFAULT,
##	    thicknessModulus=None, temperature=GRADIENT, useDensity=OFF, integrationRule=SIMPSON, numIntPts=5)

	return

function_labels['set_DPC_plastic_cap'] = 'Drucker-Prager/Cap model','powder compaction','material property'
def set_DPC_plastic_cap(mat):
	## VER: 2017-10-22, v1.1

	## Cap plasticity for carbide powder compaction (2D model)
	## dependencies=1表示多出一列自定义列来(Field 1，最后一列)。
	## temperatureDependency=ON表示比默认多出一列的名称为Temp

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	if mat == 'H10pow':
		_m.materials['H10pow'].CapPlasticity(dependencies=1, temperatureDependency=OFF, table=(
		## cohesion, angle of friction, cap eccentricity, initial yield surface(0.0), transition surface radius(0.01), flow stress ratio(0), field 1
			(0.01, 56.3, 1.0, 0.0, 0.01, 0.0, 1.0),
			(0.03, 56.3, 1.0, 0.0, 0.01, 0.0, 1.33),
			(0.17, 56.3, 1.0, 0.0, 0.01, 0.0, 1.61),
			(0.34, 56.3, 1.0, 0.0, 0.01, 0.0, 1.715),
			(0.87, 56.3, 1.0, 0.0, 0.01, 0.0, 1.834),
			(1.15, 56.3, 1.0, 0.0, 0.01, 0.0, 1.868),
			(1.51, 56.3, 1.0, 0.0, 0.01, 0.0, 1.9),
			(1.97, 56.3, 0.95, 0.0, 0.01, 0.0, 1.928),
			(2.53, 56.3, 0.9, 0.0, 0.01, 0.0, 1.955),
			(3.23, 56.3, 0.8, 0.0, 0.01, 0.0, 1.98),
			(3.84, 56.3, 0.77, 0.0, 0.01, 0.0, 2.0),
			(70, 56.3, 0.7, 0.0, 0.01, 0.0, 2.01)		  ## add an additional row for tension space
			))

		## Error: YIELD STRESS IS TOO LOW, THE CAP WOULD BE IN TENSION SPACE WHEN PB=0.75000, COHESION= 3.8400, BETA=56.300, R=0.77000
		## Error: YIELD STRESS IS TOO LOW, THE CAP WOULD BE IN TENSION SPACE WHEN PB=0.75000, COHESION= 38.400, BETA=56.300, R=0.70000

		_m.materials['H10pow'].elastic.setValues(dependencies=1, table=(
			(300.0, 0.18, 1.0),
			(1440.0, 0.18, 1.61),
			(2220.0, 0.18, 1.715),
			(3300.0, 0.18, 1.798),
			(4770.0, 0.18, 1.868),
			(6790.0, 0.18, 1.928),
			(9540.0, 0.18, 1.98),
			(11000.0, 0.18, 2.0)
			))

		_m.materials['H10pow'].capPlasticity.CapHardening(table=(
			(0.75, 0.0),
			(1.0, 0.295),
			(1.12, 0.308),
			(2.06, 0.378),
			(3.59, 0.442),
			(5.94, 0.5),
			(9.49, 0.553),
			(14.71, 0.604),
			(22.24, 0.651),
			(32.93, 0.696),
			(47.96, 0.74),
			(68.9, 0.781),
			(97.83, 0.821),
			(137.7, 0.861),
			(192.47, 0.899),
			(273.0, 0.939),
			(371.1, 0.975),
			(513.8, 1.012),
			(800.0, 1.063),
			(1500.0, 1.135)
		    ))	;changing  ## 1500 ???

	elif mat == 'DAEpow':
		## DAE powder
		_m.materials['DAEpow'].CapPlasticity(dependencies=1, temperatureDependency=ON, table=(
			(0.00001, 70.0, 0.55, 0.00001, 0.0, 0.0, 3.1),
			(0.00209, 70.0, 0.55076, 0.647, 0.0, 0.0, 3.2),
			(0.00488, 70.0, 0.55163, 1.39868, 0.0, 0.0, 3.3),
			(0.00858, 70.0, 0.55264, 2.26802, 0.0, 0.0, 3.4),
			(0.01345, 70.0, 0.5538, 3.26914, 0.0, 0.0, 3.5),
			(0.01979, 70.0, 0.55511, 4.4174, 0.0, 0.0, 3.6),
			(0.02801, 70.0, 0.5566, 5.7294, 0.0, 0.0, 3.7),
			(0.03857, 70.0, 0.5583, 7.2231, 0.0, 0.0, 3.8),
			(0.05206, 70.0, 0.56021, 8.91789, 0.0, 0.0, 3.9),
			(0.06917, 70.0, 0.56235, 10.8346, 0.0, 0.0, 4.0),
			(0.09077, 70.0, 0.56477, 12.9957, 0.0, 0.0, 4.1),
			(0.11786, 70.0, 0.56746, 15.4251, 0.0, 0.0, 4.2),
			(0.15167, 70.0, 0.57047, 18.1486, 0.0, 0.0, 4.3),
			(0.19364, 70.0, 0.57382, 21.1937, 0.0, 0.0, 4.4),
			(0.24547, 70.0, 0.57754, 24.5898, 0.0, 0.0, 4.5),
			(0.30921, 70.0, 0.58165, 28.368, 0.0, 0.0, 4.6),
			(0.38722, 70.0, 0.5862, 32.5618, 0.0, 0.0, 4.7),
			(0.4823, 70.0, 0.59122, 37.2065, 0.0, 0.0, 4.8),
			(0.5977, 70.0, 0.59675, 42.3396, 0.0, 0.0, 4.9),
			(0.73721, 70.0, 0.60281, 48.001, 0.0, 0.0, 5.0),
			(0.90523, 70.0, 0.60946, 54.2327, 0.0, 0.0, 5.1),
			(1.10685, 70.0, 0.61674, 61.0794, 0.0, 0.0, 5.2),
			(1.34795, 70.0, 0.62469, 68.5881, 0.0, 0.0, 5.3),
			(1.63528, 70.0, 0.63337, 76.8085, 0.0, 0.0, 5.4),
			(1.9766, 70.0, 0.64281, 85.793, 0.0, 0.0, 5.5),
			(2.38079, 70.0, 0.65308, 95.5968, 0.0, 0.0, 5.6),
			(2.85798, 70.0, 0.66422, 106.278, 0.0, 0.0, 5.7),
			(3.41973, 70.0, 0.67631, 117.897, 0.0, 0.0, 5.8),
			(4.07915, 70.0, 0.68939, 130.519, 0.0, 0.0, 5.9),
			(4.85113, 70.0, 0.70353, 144.211, 0.0, 0.0, 6.0),
			(5.75252, 70.0, 0.7188, 159.043, 0.0, 0.0, 6.1),
			(6.80234, 70.0, 0.73526, 175.089, 0.0, 0.0, 6.2),
			(8.02202, 70.0, 0.75299, 192.426, 0.0, 0.0, 6.3),
			(9.43569, 70.0, 0.77207, 211.136, 0.0, 0.0, 6.4),
			(11.0704, 70.0, 0.79256, 231.304, 0.0, 0.0, 6.5),
			(12.9566, 70.0, 0.81456, 253.016, 0.0, 0.0, 6.6),
			(15.1281, 70.0, 0.83815, 276.367, 0.0, 0.0, 6.7),
			(17.6229, 70.0, 0.86341, 301.452, 0.0, 0.0, 6.8),
			(20.4833, 70.0, 0.89045, 328.371, 0.0, 0.0, 6.9),
			(23.7563, 70.0, 0.91934, 357.23, 0.0, 0.0, 7.0),
			(27.4944, 70.0, 0.9502, 388.137, 0.0, 0.0, 7.1),
			(31.7555, 70.0, 0.98312, 421.205, 0.0, 0.0, 7.2),
			(36.6041, 70.0, 1.01821, 456.553, 0.0, 0.0, 7.3),
			(42.1114, 70.0, 1.05559, 494.303, 0.0, 0.0, 7.4),
			(48.3561, 70.0, 1.09537, 534.584, 0.0, 0.0, 7.5)
			))

		_m.materials['DAEpow'].elastic.setValues(dependencies=1, table=(
			(3402.41, 0.00157, 3.1),
			(4431.87, 0.01422, 3.2),
			(5466.95, 0.02193, 3.3),
			(6508.91, 0.0272, 3.4),
			(7559.25, 0.03109, 3.5),
			(8619.71, 0.03415, 3.6),
			(9692.29, 0.03667, 3.7),
			(10779.3, 0.03884, 3.8),
			(11883.5, 0.04078, 3.9),
			(13007.9, 0.04258, 4.0),
			(14156.0, 0.04429, 4.1),
			(15332.0, 0.04595, 4.2),
			(16540.5, 0.04761, 4.3),
			(17786.7, 0.0493, 4.4),
			(19076.8, 0.05104, 4.5),
			(20417.8, 0.05286, 4.6),
			(21817.6, 0.05477, 4.7),
			(23285.5, 0.05679, 4.8),
			(24832.1, 0.05895, 4.9),
			(26469.4, 0.06126, 5.0),
			(28211.6, 0.06374, 5.1),
			(30074.9, 0.06641, 5.2),
			(32078.3, 0.06928, 5.3),
			(34243.7, 0.07238, 5.4),
			(36596.9, 0.07571, 5.5),
			(39168.1, 0.0793, 5.6),
			(41992.9, 0.08315, 5.7),
			(45113.4, 0.0873, 5.8),
			(48579.7, 0.09174, 5.9),
			(52451.6, 0.09651, 6.0),
			(56800.9, 0.10161, 6.1),
			(61714.3, 0.10705, 6.2),
			(67297.0, 0.11284, 6.3),
			(73677.3, 0.11901, 6.4),
			(81012.9, 0.12555, 6.5),
			(89498.5, 0.13248, 6.6),
			(99376.2, 0.1398, 6.7),
			(110949.0, 0.14751, 6.8),
			(124600.0, 0.15562, 6.9),
			(140814.0, 0.16412, 7.0),
			(160212.0, 0.17301, 7.1),
			(183595.0, 0.18228, 7.2),
			(212007.0, 0.19192, 7.3),
			(246814.0, 0.20191, 7.4),
			(289828.0, 0.21224, 7.5)
			))

		_m.materials['DAEpow'].Density(dependencies=1, table=(
			(0.0031, 3.1),
			(0.0032, 3.2),
			(0.0033, 3.3),
			(0.0034, 3.4),
			(0.0035, 3.5),
			(0.0036, 3.6),
			(0.0037, 3.7),
			(0.0038, 3.8),
			(0.0039, 3.9),
			(0.004, 4.0),
			(0.0041, 4.1),
			(0.0042, 4.2),
			(0.0043, 4.3),
			(0.0044, 4.4),
			(0.0045, 4.5),
			(0.0046, 4.6),
			(0.0047, 4.7),
			(0.0048, 4.8),
			(0.0049, 4.9),
			(0.005, 5.0),
			(0.0051, 5.1),
			(0.0052, 5.2),
			(0.0053, 5.3),
			(0.0054, 5.4),
			(0.0055, 5.5),
			(0.0056, 5.6),
			(0.0057, 5.7),
			(0.0058, 5.8),
			(0.0059, 5.9),
			(0.006, 6.0),
			(0.0061, 6.1),
			(0.0062, 6.2),
			(0.0063, 6.3),
			(0.0064, 6.4),
			(0.0065, 6.5),
			(0.0066, 6.6),
			(0.0067, 6.7),
			(0.0068, 6.8),
			(0.0069, 6.9),
			(0.007, 7.0),
			(0.0071, 7.1),
			(0.0072, 7.2),
			(0.0073, 7.3),
			(0.0074, 7.4),
			(0.0075, 7.5)
			))

		_m.materials['DAEpow'].capPlasticity.CapHardening(table=(
			(0.0001, 0.0),
			(0.647, 0.03175),
			(1.39868, 0.06252),
			(2.26802, 0.09237),
			(3.26914, 0.12136),
			(4.4174, 0.14953),
			(5.7294, 0.17693),
			(7.2231, 0.2036),
			(8.91789, 0.22957),
			(10.8346, 0.25489),
			(12.9957, 0.27958),
			(15.4251, 0.30368),
			(18.1486, 0.32721),
			(21.1937, 0.3502),
			(24.5898, 0.37268),
			(28.368, 0.39465),
			(32.5618, 0.41616),
			(37.2065, 0.43721),
			(42.3396, 0.45783),
			(48.001, 0.47804),
			(54.2327, 0.49784),
			(61.0794, 0.51726),
			(68.5881, 0.5363),
			(76.8085, 0.555),
			(85.793, 0.57335),
			(95.5968, 0.59136),
			(106.278, 0.60906),
			(117.897, 0.62646),
			(130.519, 0.64355),
			(144.211, 0.66036),
			(159.043, 0.67689),
			(175.089, 0.69315),
			(192.426, 0.70915),
			(211.136, 0.7249),
			(231.304, 0.7404),
			(253.016, 0.75567),
			(276.367, 0.77071),
			(301.452, 0.78552),
			(328.371, 0.80012),
			(357.23, 0.81451),
			(388.137, 0.82869),
			(421.205, 0.84268),
			(456.553, 0.85647),
			(494.303, 0.87008),
			(534.584, 0.8835)
			))

	return

##function_labels['create_materials_PV'] = 'suntech','property','glass','silicone','PVB','EVA','rubber','aluminum','TPT','silicon','tape'
##def create_materials_PV():
##	## VER: ('VER: 2012-08-21, v1.7')
##
##	global mat_lib
##
##	please_check
##	materials = ['Glass', 'Glass2', 'Silic','Silic2', 'PVB', 'EVA','EVA2', 'Rubber','Rubber2', 'Al_6063','Al_6061', 'TPT', 'Si', 'Tape',
##				'Paper', 'Steel', 'Rigid', 'Wood', 'FRP']

##	mat_lib = {}
##	for mat in materials:
##		globals()[mat] = mat
##		mat_lib[mat] = mat

##	keys0 = locals().keys()

	#### material property
##	EVA100 = 2.5   				#;please_check('100%模量')
##	EVAE = 15						;please_check(5, 15)
##	silE = 2   						;please_check('default=0.5MPa')
##	glassE = 70						;please_check('70,67')
##	rubber2_scale = 2.5			#;please_check
##	FRPE = 40						;please_check
##	pack_mat = 'Silic'				;please_check
##	tape_type = 'elastic'		;please_check('elastic,cohesive')
##	Tape_strength = 0.3			;please_check('0.3MPa')


	  ## Material properties: 至少需要E,D,v,CTE四项
##	Steel_E = 200e9*KE		;		Steel_D = 7.85e3*KD			;	Steel_v = 0.3			;	Steel_CTE = 18e-6		; 	Steel_K = 11.19	;	Steel_Cp = 485.7*K_Cp

##	Al_6063_E = 69e9*KE	;		Al_6063_D = 2.7e3*KD		;	Al_6063_v = 0.33		;	Al_6063_CTE = 23.4e-6   	; Al_6063_K = 209	;  Al_6063_Cp = 900*K_Cp		## 边框用铝
##	Al_6061_E = 69e9*KE	;		Al_6061_D = 2.7e3*KD		;	Al_6061_v = 0.33		;	Al_6061_CTE = 23.4e-6  	; Al_6061_K = 209	;  Al_6061_Cp = 900*K_Cp		## 非边框用铝

##	EVA_E = EVAE*1e6*KE		;		EVA_D = 	0.95e3*KD		;	EVA_v = 0.47			;	EVA_CTE = 180e-6			; EVA_K = 0.23		;	EVA_Cp = 2300*K_Cp
##	EVA2_E = 5e6*KE			;		EVA2_D = 0.95e3*KD			;	EVA2_v = 0.47			;	EVA2_CTE = 180e-6			; EVA2_K = 0.23		;	EVA2_Cp = 2300*K_Cp

##	please_check('glassE')
##	Glass_E = glassE*1e9*KE	;		Glass_D = 2.5e3*KD			;	Glass_v	= 0.23			;	Glass_CTE = 9.28e-6		; Glass_K = 0.95	;	Glass_Cp = 880*K_Cp			## 0.98, 超白浮法玻璃, 9.28(jinjing)
##	Glass2_E = 72e9*KE		;		Glass2_D = 2.5e3*KD			;	Glass2_v	= 0.23		;	Glass2_CTE = 8.6e-6		; Glass2_K = 0.95	;	Glass2_Cp = 880*K_Cp			## 0.98，普通浮法玻璃

##	Makrolon_E = 2.4e9*KE	;		Makrolon_D = 1.2e3*KD		;	Makrolon_v = 0.38		;	Makrolon_CTE = 65e-6
##	Paper_E = 38e6*KE		;		Paper_D = 0.6e3*KD			;	Paper_v = 0.2			;	Paper_CTE = 10e-6
##	PVB_E = 100e6*KE		;		PVB_D = 1.1e3*KD			;	PVB_v = 0.47			;	PVB_CTE = 240e-6
##	Rigid_E = 1e15*KE		;		Rigid_D = 7.8e3*KD			;	Rigid_v = 0.01			;	Rigid_CTE = 18e-6

##	Rubber_E = 5e6*KE		;		Rubber_D = 1.1e3*KD			;	Rubber_v = 0.45			;	Rubber_CTE = 200e-6		; 	Rubber_K = 0.2	;	Rubber_Cp = 1600*K_Cp
##	Rubber2_E = 5e6*KE		;		Rubber2_D = 1.1e3*KD		;	Rubber2_v = 0.45		;	Rubber2_CTE = 200e-6	; 	Rubber2_K = 0.2	;	Rubber_Cp2 = 1600*K_Cp

##	Silic_E = silE*1e6*KE	;		Silic_D = 1.1e3*KD			;	Silic_v = 0.48			;	Silic_CTE = 230e-6		; 	Silic_K = 0.3	;	Silic_Cp = 1600*K_Cp
##	Silic2_E = silE*1e6*KE	;		Silic2_D = 1.1e3*KD			;	Silic2_v = 0.48			;	Silic2_CTE = 230e-6		; 	Silic2_K = 0.3	;	Silic2_Cp = 1600*K_Cp

##	Si_E = 131e9*KE			;		Si_D = 2.33e3*KD			;	Si_v = 0.28				;	Si_CTE = 2.6e-6

##	Tape_E = 0.9e6*KE		;		Tape_D = 0.7e3*KD			;	Tape_v = 0.47			;	Tape_CTE = 180e-6		; 	Tape_K = 0.08	;	Tape_Cp = 280*K_Cp		## ******** B23F: K=0.08
##	Tape_E = 0.5e6*KE		;		Tape_D = 0.7e3*KD			;	Tape_v = 0.35			;	Tape_CTE = 180e-6		; 	Tape_K = 0.08	;	Tape_Cp = 280*K_Cp		## ******** B23F: K=0.08

##	TPT_E = 2e9*KE			;		TPT_D = 1.4e3*KD			;	TPT_v = 0.35			;	TPT_CTE = 180e-6		; 	TPT_K = 0.36		;  TPT_Cp = 1050*K_Cp
##	Wood_E = 6e9*KE			;		Wood_D = 0.6e3*KD			;	Wood_v = 0.2			;	Wood_CTE = 15e-6
##	FRP_E = FRPE*1e9*KE			;		FRP_D = 2.1e3*KD			;	FRP_v = 0.3				;	FRP_CTE = 10e-6			;	FRP_K = 0.5		;	FRP_Cp = 1500*K_Cp

##	Silic_strength = 0.2e6*KE		; Tape_strength = 85e3*KE

##	locals2globals(keys0,locals())

	##???****
##	options.append('EVA_E=' + str(EVA_E) + 'MPa')   ## 考虑cell的增强作用，考虑45 degC ******** 3,5
##	options.append('Tape_E=' + str(Tape_E) + 'MPa, Tape_v=' + str(Tape_v))
##	options.append('Silic_E=' + str(Silic_E) + 'MPa')

	 ##Define material
	 ##Create solid material section
##	for mat,prop in mat_lib.items():
##		_m.Material(name=mat)
##		density = eval(prop + '_D')
##		modulus = eval(prop + '_E')
##		poisson = eval(prop + '_v')
##
##		_m.materials[mat].Density(table=((density, ), ))
##		_m.materials[mat].Elastic(table=((modulus, poisson), ))
##
##		set_thermal_prop(mat)
##
##		hex_name = prop + '_sec'
##		_m.HomogeneousSolidSection(material=mat, name=hex_name, thickness=1.0)

##	please_check
##	if tape_type == 'cohesive':
##		_m.materials['Tape'].MaxsDamageInitiation(table=((Tape_strength, Tape_strength, Tape_strength), ))		## 为了简化，就用实际测试结果（取三个方向的值都一样）
##		_m.materials['Tape'].maxsDamageInitiation.DamageEvolution(type=DISPLACEMENT, table=((0.5, ), ))
##
##		del _m.materials['Tape'].elastic
##		_m.materials['Tape'].Elastic(type=TRACTION, table=((Tape_E, Tape_E/3, Tape_E/3), ))
##
##		del _m.sections['Tape_sec']
##		_m.CohesiveSection(name='Tape_sec', material='Tape', response=TRACTION_SEPARATION, outOfPlaneThickness=None)

	###???****
##	keys0 = locals().keys()

##	## Alum
##	A6063_T5a = (140.0, 0.0),(180.0, 0.08)
##	A6063_T5b = (180.0, 0.0),(220.0, 0.08)
##	A6063_T5c = (195.0, 0.0),(240.0, 0.08)
##
##	A6063_A = (160.0, 0.0),(200.0, 0.05)
##	A6061_T6 = (240.0, 0.0),(290.0, 0.1)   ## Reliathon

	## Steel
##	Steel_304 = (215, 0), (515, 0.4)
##	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel

##	Steel_plating = (205, 0), (360, 0.27)
##	Steel_Q235 = (210.0, 0.0),(370.0, 0.27)
##	Steel_Q345 = (345, 0.0),(490, 0.21)
##	Steel_cjf = (400,0),(420,0.02),(500,0.2),(600,0.5)		## Prof. cao jinfeng

##	locals2globals(keys0,locals())

	## Al_6063 边框用铝
##	if frame_alum_strength > 185:
##		table = A6063_T5c  ;please_check
##	else:
##		table = A6063_T5b
##	_m.materials[Al_6063].Plastic(table=table)   ## 6063T5 铝边框(标准组件用)
##	options.append('Mat Al_6063: ' + str(table))	##********

	## Al_6061 非边框用铝
##	table = A6061_T6  ;please_check
##	_m.materials[Al_6061].Plastic(table=table)   ## 6061 T6
##	options.append('Mat Al_6061: ' + str(table))	##********
##
##	_m.materials[Steel].Plastic(table=Steel_plating)		;please_check

###	_m.materials[Steel].Plastic(table=((210.0, 0.0),(370.0, 0.27) ))   ## Q235
###	_m.materials[Steel].Plastic(table=((345, 0.0),(490, 0.21) ))   	## Q345	(如果有应力集中，看不出承载能力)
##	options.append('Mat Steel: Q345')

##	set_hyperElastic(EVA2)
##	set_hyperElastic(Rubber2,model='YEOH')	;please_check
##	set_hyperElastic(Silic2)						;please_check

##	return

def create_mesh_part(part,newname=None):
	## VER: 2015-06-03, v1.1
	## 相当于网格与几何分离。
	## materials, sets will be remained.
	## create a new part with only mesh

	part = check_part(part)
	if _len(part.elements) == 0:
		raise Exception('*** part is not mesh yet.')

	if newname in empty:
		newname = part.name

	newname1 = new_key(_m.parts.keys(),'mesh_part')
	part.PartFromMesh(name=newname1,copySets=True)   ## geometry set, element set, and node set will be copied.

	if newname == part.name:
		del_parts(part.name)

	rename(newname1,newname)

	print '---> Created mesh part',newname,', no geometry inside.'

	return newname

def create_mix_region(poi=None,faces=[],xEdges=[],faces_seq=None,xEdges_seq=None,xEdges_name=''):
	## 2011-02-10, v1.3

	if faces_seq in empty:
		if type_of(faces) in ['PART','PINSTANCE']:
			poi,faces = faces, poi

		if poi == None and type_of(faces) == 'LIST':
			poi = get_poi(faces)

		if type_of(faces) == 'faces':
			faces = [faces]
		elif type_of(faces) == 'STR':
			faces = set2objs(faces,poi)

		faces_seq = list2sequence(faces)

	if type_of(xEdges) == 'SEQUENCE':
		xEdges_seq = xEdges

	if xEdges not in empty and xEdges_seq in empty:
		if type_of(xEdges) == 'STR':
			xEdges = set2objs(xEdges,poi)
		elif type_of(xEdges) == 'edges':
			xEdges = [xEdges]

		xEdges_seq = list2sequence(xEdges)

	if xEdges_seq not in empty and xEdges_name == '':
##		xEdges_name = '_xEdges_' + poi.name
		xEdges_name = '_xEdges'

	if xEdges_seq not in empty:
		region = Region(faces = faces_seq, xEdges = xEdges_seq)
	else:
		region = Region(faces = face_seq)

##	if len(xEdges) > 0:
##		create_set(poi,objs=xEdges,name=xEdges_name,check_name=True)
##		edge_seq = list2sequence(xEdges,poi)
##	else:
##		region = Region(faces = face_seq)

	return region


def create_module_contacts(prop='Frictionless',cell_loc='bot'):

	## VER: ('VER: 2012-08-16, v2.2')	## 共有10个接触对(1/4模型，如果没有cell，则为9个=3*3)，其中两个interaction: frame_corner, frame_adhesive_corner

	global options

	num = find_contacts(master_set='fm_frame_corner',action='interact',prop=prop)
	if num == 0:
		raise Exception('fail to find the contact for frame corner')

	num = find_contacts(action='tie',master_set='fm_kahuang')
	if num == 0:
		raise Exception('fail to find the contact for kahuang')

	num = find_contacts(action='interact',master_set='fm_adhesive_corner')		;options.append('fm_adhesive_corner is interact')
	if num == 0:
		raise Exception('fail to find the contact for adhesive corner')

##	find_contacts(action='tie',master_set='fm_adhesive_corner')		;options.append('fm_adhesive_corner is tie')


	please_check
	find_contacts(action='tie',slave_set='fs_frame_mouth_top',mate_parts=find_mdb_parts('lam'),xEdges='e_xEdges_frame_lam')
	find_contacts(action='tie',slave_set='fs_frame_mouth_bot',mate_parts=find_mdb_parts('lam'),xEdges='e_xEdges_frame_lam')
	find_contacts(action='tie',slave_set='fs_frame_mouth_side',mate_parts=find_mdb_parts('lam'),xEdges='e_xEdges_frame_lam')

	if len(_m.interactions) + len(_m.constraints) < 9:
		raise Exception('Some contacts was not built. Please check.')

	if 'cell' in _m.parts.keys():
		find_contacts(action='tie',slave_set='f_cell_top',mate_parts=find_mdb_parts('lam'))
##		find_contacts(action='tie',slave_set='f_cell_right',mate_parts=find_mdb_parts('lam'))	;please_check
##		find_contacts(action='tie',slave_set='f_cell_back',mate_parts=find_mdb_parts('lam'))		;please_check

	return

def create_dynamic_explicit_step(stepname='step1',timePeriod=1e-3, period=None,output_num=None, step=None, output_time_interval=None, prestep='', scale_factor=1,restart_interval=None):
	## VER: 2017-11-01, v1.7     output_time_interval means every x units of time in GUI.
	## The greater output_num, the slower run

	## example:
##	create_dynamic_explicit_step(stepname='step1',timePeriod=1e-4, output_num=50)

##	create_dynamic_explicit_step(step='move', timePeriod=1.0)
##	field_output_request(timepoints=timepoints1)

##	check_suitable_step(fn())

	if step not in empty:
		stepname = step

	if is_number(period):
		timePeriod = period

	stepname = new_key(_m.steps.keys(),stepname,force_new_key=True)		;please_check
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('**** No such prestep',prestep)

	if type_of(timePeriod) not in numerics:
		raise Exception('*** timePeriod is required.')

	mats = get_all_mats(a)
	if 'H10pow' in mats and scale_factor == 1:
		scale_factor = 2000	;please_check

	if scale_factor > 1:
		if type_of(scale_factor) != 'INT':
			raise Exception('**** integer is required for scale factor.')

		_m.ExplicitDynamicsStep(name=stepname, previous=prestep, timePeriod=timePeriod,
		    massScaling=((SEMI_AUTOMATIC, MODEL, AT_BEGINNING, scale_factor, 0.0, None, 0, 0,  0.0, 0.0, 0, None), ))
	else:
		_m.ExplicitDynamicsStep(name=stepname, previous=prestep, timePeriod=timePeriod)

	if type_of(restart_interval) == 'INT':
		_m.steps['step1'].Restart(numberIntervals=restart_interval, overlay=OFF, timeMarks=OFF)

##	if output_num in empty and output_time_interval in empty:
##		raise Exception('*** output_num or output_time_interval is required.')

	if get_real_input(output_num, output_time_interval) not in empty:
		if type_of(output_num) == 'INT':
			output_time_interval = round(timePeriod/output_num,6)
			if output_time_interval == 0:
				raise Exception('*** Too small output_time_interval')

		if type_of(output_time_interval) not in numerics:
			raise Exception('*** output_time_interval is required')

		if check_step('step1') == stepname:
			_m.fieldOutputRequests['F-Output-1'].setValues(variables=ALL, timeInterval=output_time_interval)	; please_check  ## create
		else:
			_m.fieldOutputRequests['F-Output-1'].setValuesInStep(stepName=stepname, timeInterval=output_time_interval)   ## modify

	return stepname


def create_expression(expression,name='express_1',localCsys=None,description=''):
	## VER: 2014-11-11, v1.0

	## Example:
##	y1 = ylocs(anvil,pointOn=False)[-2]
##	y2 = total_H
####	p = (y-y1)/(y2-y1)*pressure
##	expression = '(y - ' + str(y1) + ')' + '/' + str(y2-y1) + '*' + str(pressure)
##	express = create_expression(expression)
##
##	faces = face_select(anvil_A1,y=(MAX,MAX1),include_ends=True)
##	apply_pressure('load_top',faces=faces,expression=express,create_step='step1')	;please_check

	name = new_key(_m.analyticalFields.keys(),name)
	expression = modify_string(expression,'x','X')
	expression = modify_string(expression,'y','Y')
	expression = modify_string(expression,'z','Z')
	expression = modify_string(expression,' ')

	_m.ExpressionField(name=name, localCsys=None, description='', expression=expression)

	return name


def create_fillet(partname='fillet',sketchname='temp_sketch1',ndir='y',quarter=1,radius=5, length=20,mat='Al_6063'):
	## VER: 2012-11-22, v1.3。  在选择观察视图的时候，如果ndir != 'y'，则视图上y朝上，另外一根轴朝右。如果ndir='y'，则视图上把z朝上，'x'朝右
	## quarter表示在第几象限。
	## 参数quarter: 表示填充的是哪个象限的直角边。

	sketchname = new_key(_m.sketches.keys(),sketchname)
	partname = new_key(_m.parts.keys(),partname)

	if quarter == 1:
		quarter = 3
	elif quarter == 3:
		quarter = 1
	elif quarter == 2:
		quarter = 4
	elif quarter == 4:
		quarter = 2

	## 此时的quarter不在表示填充坐标轴直角边，而是圆弧之外的填充。

	center = (0,0)
	x1 = (-radius,0)
	x2 = (radius,0)
	y1 = (0,-radius)
	y2 = (0,radius)

	x2y2 = (radius,radius)
	x1y2 = (-radius,radius)
	x1y1 = (-radius,-radius)
	x2y1 = (radius,-radius)

	blank_part(partname)
	p = _m.parts[partname]

	sketch1 = create_base_sketch(name='temp_sketch1',ndir='z', return_sketch=True)
##	s = _m.sketches[sketch1]
	s = sketch1
	s.setPrimaryObject(option=STANDALONE)
	s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	if quarter == 1:
		s.ArcByCenterEnds(center=center, point1=x2, point2=y2, direction=COUNTERCLOCKWISE)
		s.Line(point1=x2,point2	= x2y2)
		s.Line(point1=y2,point2 = x2y2)
	elif quarter == 2:
		s.ArcByCenterEnds(center=center, point1=y2, point2=x1, direction=COUNTERCLOCKWISE)
		s.Line(point1=x1,point2	= x1y2)
		s.Line(point1=y2,point2 = x1y2)
	elif quarter == 3:
		s.ArcByCenterEnds(center=center, point1=x1, point2=y1, direction=COUNTERCLOCKWISE)
		s.Line(point1=x1,point2	= x1y1)
		s.Line(point1=y1,point2 = x1y1)
	elif quarter == 4:
		s.ArcByCenterEnds(center=center, point1=y1, point2=x2, direction=COUNTERCLOCKWISE)
		s.Line(point1=x2,point2	= x2y1)
		s.Line(point1=y1,point2 = x2y1)

	p = _m.Part(name=partname, dimensionality=THREE_D, type=DEFORMABLE_BODY)
	p = _m.parts[partname]
	p.BaseSolidExtrude(sketch=s, depth=abs(length))		## depth必须是正的。不用datum plane
	s.unsetPrimaryObject()

	set_mat(p,mat=mat)

	edges = edge_select(p,radius=radius)
	create_set(p,edges=edges,name='e_fillet_circle')

	create_set(p,cells=p.cells,name='c_fillet')

	rotate_part_from_xysketch(p,ndir=ndir)

	return partname

def create_frame_rail(length=None,width=None,thick=3,mat='Steel'):
	## 2012-01-05, v1.9

	global frS_A1,frL_A1,frS,frL

	if 'frm_A1' in a.instances.keys():
		frS_A1 = frm_A1
		frL_A1 = frm_A1
		frS = frm
		frL = frm

	if length == None:
		if support_option == 'short_edge//long_rail':
			length = (_xmax(frS_A1) - _xmin(frS_A1)) + 10
			full_support = True
		elif support_option == 'long_edge//long_rail':
			length = (_ymax(frL_A1) - _ymin(frL_A1)) + 10
			full_support = True
		else:
			length = 70			;please_check

	if width == None:
		width = 50				;please_check

	partname = blank_part('rail')
	create_block(rail,(0,length),(0,width),(0,thick))
	set_mat(rail,mat=mat)

	if 'short_edge+' in support_option or support_option == 'long_edge//long_rail':
		rotate_part(rail,angle_z = 90)

	create_side_sets(rail)

	if has_mount_clamp == True or ('clamp2corner' in globals().keys() and clamp2corner >= 0):  ## 可能有rail，但是没有clamp，类似材料实验室。
		if '+' in support_option:
			if 'long_edge' in support_option:
				move_part(rail,x1=_xmax(rail),x2=_xmax(frL) + 10,y1=_ymid(rail),y2=_ymax(frL) - clamp2corner,z1=_zmax(rail),z2=_zmin(frL))
			elif 'short_edge' in support_option:
				move_part(rail,y1=_ymax(rail),y2=_ymax(frS) + 10,x1=_xmid(rail),x2=_xmax(frS) - clamp2corner,z1=_zmax(rail),z2=_zmin(frS))

		elif '//long_rail' in support_option:
			if 'short_edge' in support_option:
				move_part(rail,y1=_ymax(rail),y2=_ymax(frS) + 10,x1=MIN,x2=0,z1=_zmax(rail),z2=_zmin(frS))
			elif 'long_edge' in support_option:
				move_part(rail,x1=_xmax(rail),x2=_xmax(frL) + 10,y1=MIN,y2=0,z1=_zmax(rail),z2=_zmin(frS))

	if '+' in support_option:
		if 'long_edge' in support_option:
			divide(frL,y=_ymin(rail))
			if _ymax(frL) - _ymax(rail) > 40:
				divide(frL,y=_ymax(rail))

		elif 'short_edge' in support_option:
			divide(frS,x=_xmin(rail))
			if _xmax(frS) - _xmax(rail) > 40:
				divide(frS,x=_xmax(rail))

	new_instance(rail)

	global rail_length, rail_width, rail_thick, has_rail
	rail_length = length
	rail_width = width
	rail_thick = thick
	has_rail = True

	return

def create_frame_rail_contacts(frame=['frL','frS']):
	## VER: 2011-02-28, v1.0. rail属于简单的六面体形状。

	master_insts = find_mdb_insts('rail')
	mate_insts = find_mdb_insts(frame)

	find_contacts(action='interact',master_insts=master_insts,mate_insts=mate_insts)

	return

def create_new_parts_with_deformed_mesh(odb_file,insts=()):
	## VER: 2013-06-02, v1.2
##	print2('model_name=',_m.name)

	odb_file = open_odb(odb_file,readonly=False)

	last_step_num = len(odb.steps) - 1  ## start from 0
	last_increment_num = len(odb.steps.values()[-1].frames) - 1

	if insts in empty:
		insts = odb.rootAssembly.instances.keys()
	else:
		insts1 = []
		for inst in insts:
			inst1 = real_key(odb.rootAssembly.instances.keys(), inst)
			if inst1 not in empty:
				insts1.append(inst1)
		insts = insts1

##	if replace_mesh == True or new_part_mesh == True:
##		inst_part = {}
##		for inst in _m.rootAssembly.instances.keys():
##			name = inst.upper()
##			partname = _m.rootAssembly.instances[inst].partName
##			inst_part[name] = partname

##	plot(_m.rootAssembly)

	if odb_file[-4:] == '.odb':
		odb_file = odb_file[:-4]

##	if replace_mesh == True:
##		for inst,partname in inst_part.items():
##			_m.parts[partname].replaceMesh(instance=inst, odb=odb, shape=DEFORMED, step=last_step_num, frame=last_increment_num)

##	elif new_part_mesh == True:
##	Mdb()
##	mdb.saveAs(pathName=odb_file)
##	refresh()

		## One inst in odb will be created as a new part in mdb. Two insts cannot share one part.
##	print2('model_name=',_m.name)

	for inst in insts:
		partname = inst + '_p'
		_m.PartFromOdb(name=partname, instance=inst, odb=odb, shape=DEFORMED, step=last_step_num, frame=last_increment_num)

		p = _m.parts[partname]
		a.Instance(name=inst, part=p, dependent=ON)   ## name is in capitallized.

	mdb.save()
	refresh()

	return

function_labels['assembly_and_fill'] = 'PV, OB, AB, PFH, PH', 'powder_compaction','mining button'
def assembly_and_fill(top_sketch,bot_sketch,die_R=None, PFH=None,L1=None,PH=None, fill_volume=None, weight_density=False, mat='H10pow',create_instance=True):
	## VER: 2015-11-12, v1.5
	## top_punch and bot_punch will be moved, which are global object.

	## Example:
##	assembly_and_fill(top_sketch='s_bpunch2', bot_sketch='s_punch2',fill_volume=fill_volume0)

	powder = 'powder'
	bpunch = 'bpunch'
	tpunch = 'tpunch'

	powder_part = new_key(_m.parts.keys(),'powder')  ## create new part

	read_vars_from_model_description() 	;please_check
	if PH in empty:
		PH = _vars['PH']

	top_sketch = check_sketch(top_sketch)
	bot_sketch = check_sketch(bot_sketch)

	top_sketch_name = top_sketch.name
	bot_sketch_name = bot_sketch.name

	if die_R in empty:
		die_R = _vars['die_R']

	## move bot_sketch (bot part总是bpunch)
	move_geometry(bot_sketch,x1=MIN,x2=0, y1=MAX,y2=0)  ## 归位
##	check1()
	bpunch_part = sketch_to_wire(bot_sketch,partname='bpunch',symmetric=True, ptype='analytical')   ## 直接生成刚体。建立接触对时，只需建立surface
	bpunch_depth = _ylength(bpunch_part)
	save_user_data(bpunch_depth)

##	print 'bot_sketch=',bot_sketch
##	raise Exception

##	pt = vertice_select(bpunch_part,x=MIN)[0]
	loc = locs_of_poi(bpunch_part, x=MIN)[0]
	create_RP(bpunch_part,loc=loc,name='bpunch', clear_RP=True)

##	check1()
	if bpunch_depth > 0:
		bpunch_volume = get_punch_volume(bot_sketch,'bpunch_vol',open='top')
	else:
		bpunch_volume = 0

##	print fnln(),'PFH=',PFH
##	raise Exception

	if PFH in empty:
		if type_of(fill_volume) in numerics and type_of(die_R) in numerics:
			L1 = round((fill_volume - bpunch_volume)/(pi*die_R*die_R), 3)   ## bpunch在下面时，bpunch之上的粉的高度。
			save_user_data(L1)

		if type_of(L1) in numerics:
			PFH = _ymax(bot_sketch) - _ymin(bot_sketch) + L1
		else:
			raise Exception('*** Please provide PFH, or provide fill_volume and die_R to get PFH.')

	save_user_data(PFH)

##	raise Exception

	## create powder_sketch
	powder_sketch = create_base_sketch(name='sk_' + powder_part, return_sketch=True)

	add_sketches(powder_sketch, bot_sketch)   ## only add bot_sketch !!!
	bias_cut_sketch(powder_sketch,x=die_R,side='+')

	lines = geometry_select(powder_sketch,x=0)
	if lines not in empty:
		del_geometry(powder_sketch,lines)

	loc1 = find_loc(powder_sketch,x=MIN)	;x1,y1 = loc1
	loc2 = find_loc(powder_sketch,x=MAX)

	connect_points(powder_sketch,loc1,('dy',PFH),('dx',die_R),loc2)
	powder_sketch = merge_and_clear_sketch_objs(powder_sketch)

##	raise Exception

	## fill part
	fill_part = revolve_sketch_to_part(partname='fill_part',sketch=powder_sketch,angle=360)
	if 'PW' in globals().keys() and weight_density==True:
		density = smart_round(PW/get_volume(fill_part)*1e-6)
		set_density(mat,table=density)   ## 3.234

	set_mat(fill_part,mat=mat)   ## 此时get_volume(fill_part) == fill_volume0

	fill_volume1 = get_volume(fill_part)
	if type_of(fill_volume) in numerics:
		if abs(fill_volume1 - fill_volume) > 2:
			raise Exception('*** Inconsistent fill volume. please check')
	fill_volume = fill_volume1
	save_user_data(fill_volume)

	## powder part
	sketch_to_shellpart(powder_sketch,partname=powder_part,pshape='axisymmetric',ptype='deformable')

##	raise Exception

##	vertices = vertice_select(powder_part, y=0)
##	print fnln(),'ignore vertice at loc=',vertices[0].pointOn[0]
##	ignore_vertices(powder_part,vertices=vertices[0])

##	raise Exception

##	edges = edge_select(powder_part, y=(_ymax(bot_sketch),MIN1),x=(MIN1,MAX1))
##	if len(edges) > 1:
##		merge_edges(powder_part, edges=edges)  ;please_check  ## after combine, edge_shape() = 'arc'

	set_mat(powder_part,mat=mat)

##	raise Exception

	## move top_sketch, top总是tpunch
	move_geometry(top_sketch, x1=MIN,x2=0, y1=MIN,y2=_ymax(powder_sketch))
	tpunch_part = sketch_to_wire(top_sketch,partname='tpunch',pshape='axisymmetric',ptype='analytical')	;please_check

	pt = vertice_select(tpunch_part,x=MIN)[0]
	create_RP(tpunch_part,loc=pt.pointOn[0],name='tpunch', clear_RP=True)

##	tpunch_depth = _ymax(tpunch) - _ymin(tpunch)
	tpunch_depth = _ylength(tpunch)
	if tpunch_depth > 0:
		tpunch_volume = get_punch_volume(top_sketch_name,'tpunch_vol',open='bot')
	else:
		tpunch_volume = 0
	save_user_data(tpunch_volume)

##	raise Exception

	## create die_sketch and die_part
	sketch1 = create_base_sketch(name='sk_die',return_sketch=True)
	die_sketch = sketch1.name

##	create_sketch_line(die_sketch,point2=(die_R,_ymax(powder_part) + 0.5), point1=(die_R,_ymin(bot_sketch)))
	connect_points(die_sketch, (die_R,_ymin(bot_sketch)), (die_R,_ymax(powder_part) + 0.5))
	die_part = sketch_to_wire(die_sketch,partname='die',pshape='axisymmetric',ptype='analytical')	;please_check

	pt = vertice_select(die_part,y=MAX)[0]
	create_RP(die_part,loc=pt.pointOn[0],name='Die',clear_RP=True)

##	raise Exception

	## green sketch and green part
	green_sketch = create_base_sketch(name='s_pressed', return_sketch=True)
	gren_sketch = green_sketch.name

	add_sketches(green_sketch,bot_sketch)
	add_sketches(green_sketch,top_sketch,y1=_ymax(top_sketch), y2=_ymin(bot_sketch) + PH) ## please_check

	bias_cut_sketch(green_sketch,x=die_R,side='+',connect=True)

	lines = geometry_select(green_sketch,x=0)
	del_geometry(green_sketch,lines)

##	raise Exception

##	locs = points_at_geometry_y(green_sketch,x=MIN)
	locs = locs_of_sketch(green_sketch,x=MIN,pointOn=True)
	connect_points(green_sketch,locs)

	part1 = revolve_sketch_to_part(partname='green',sketch=green_sketch,angle=360)

	green_volume = get_volume(part1)
	compress = fill_volume/green_volume
	compress = round(compress, 4)   ## 压缩比 = before/after
	V2H = round(green_volume/PH, 3) ## 相同的压高，实际的体积。

	save_user_data(compress,green_volume, V2H)

	if create_instance == True:
		for part in [powder_part,bpunch_part,tpunch_part,die_part]:
			new_instance(part)

##	fill_top_H = cross_section_length(powder,x=MAX)
##	dist = tpunch_depth + fill_top_H/5
##	if dist > fill_top_H/2:
##		dist = fill_top_H/4
##	divide(powder,y=_ymax(powder) - dist)
##
##	dist = bpunch_depth + fill_top_H/5
##	if dist > fill_top_H/2:
##		dist = fill_top_H/4
##	divide(powder,y=dist)
##
##	divide(powder,x=_xmax(powder) - 1)

	return

def create_point_mass_damping(RP,mass=None,name='Inertia_1',alpha=0,composite=0):
	## VER: 2014-06-30, v1.0

	region = None
	if type_of(RP) == 'SET':
		region = RP
	else:
		RP = feature_to_obj(RP)
		region = create_set(name='RP_mass',objs=RP)

	if alpha == 0 and composite == 0:
		if type_of(mass) not in numerics:
			raise Exception('*** numerical mass value is required.')

	name = formatted_name(a.engineeringFeatures.inertias,name)
	if mass not in empty:
		a.engineeringFeatures.PointMassInertia(name=name, region=region, mass=mass, alpha=alpha, composite=composite)
	else:
		a.engineeringFeatures.PointMassInertia(name=name, region=region, alpha=alpha, composite=composite)

	print fnln(),'--->created engineering feature: pointMassInertia, name=',name

	return name


def create_rail(length=50,width=50,thick= 3,mat='Al_6063',name='rail',dir1='x',global_var=False):

	## VER: ('VER: 2012-03-19, v1.1')

##	if global_var == True:
##		name = 'rail'

	partname = blank_part(name)
	rail = _m.parts[partname]

	if dir1 == 'x':
		create_block(rail,(0,length),(0,width),(0,thick),mat=mat)
	elif dir1 == 'y':
		create_block(rail,(0,width),(0,length),(0,thick),mat=mat)

	if global_var == True:
##		new_instance(rail)
		globals()['rail_length'] = length
		globals()['rail_width'] = width
		globals()['rail_thick'] = thick

	return

def create_rectangle_shell(partname,corner1=(0,0),corner2=(),axis_symmetric=False,sym_axis='V'):
	## VER: 2014-08-21, v1.1

	## Example: create_rectangle_shell('powder2',corner1=(0,0),corner2=(25,60))

	## plate with hole
##	length = 40	;	width = 20
##	part1 = create_rectangle_shell('part1',corner1=(-length/2,-width/2),corner2=(length/2,width/2))
##	radial_cut(part1,ndir='z',radius=5)

	if is_part(partname):
		existed = True
		p = check_part(partname)
		partname = p.name
	else:
		existed = False
		partname = new_key(_m.parts.keys(),partname)

	sketchname = 'sk_temp'
	sketchname = new_key(sketchname,_m.sketches)

	s = _m.ConstrainedSketch(name=sketchname, sheetSize=200.0)
	g, v, d, c = s.geometry, s.vertices, s.dimensions, s.constraints
	s.setPrimaryObject(option=STANDALONE)
	s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	if axis_symmetric == True:
		pshape = AXISYMMETRIC
		s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
		sym_axis = sym_axis.upper()
		if sym_axis == 'V':
			s.ConstructionLine(point1=(0.0, -100.0), point2=(0.0, 100.0))
		else:
			s.ConstructionLine(point1=(-100.0, 0), point2=(100.0, 0))
	else:
		pshape = TWO_D_PLANAR

	if is_location(corner1) == False:
		raise Exception('*** Error location for corner1')

	if is_location(corner2) == False:
		raise Exception('*** Error location for corner2')

	if existed == False:
		s.rectangle(point1=corner1, point2=corner2)
		p = _m.Part(name=partname, dimensionality=pshape, type=DEFORMABLE_BODY)
		p = _m.parts[partname]
		p.BaseShell(sketch=s)

	else:
		p.projectReferencesOntoSketch(sketch=s, filter=COPLANAR_EDGES)
		s.ConstructionLine(point1=(0.0, -100.0), point2=(0.0, 100.0))
		s.rectangle(point1=corner1, point2=corner2)
##		p = mdb.models['Model-1'].parts['case']
		p = _m.parts[partname]
		p.Shell(sketch=s)

	s.unsetPrimaryObject()
	p = _m.parts[partname]
	vpnow = get_vpnow()
##	vpnow.setValues(displayedObject=p)

	update_part(partname)

	return partname

def create_restart_model(model_name='restart',odb_title1=''):
	## VER: 2014-08-20, v1.0
	## 在新的模型中，仍然可以向前一个模型（预处理步骤）一样，按照前一个模型的尺寸来选择几何。
	## 例如：edges = edge_select(case_A1,x=case_OD/2.0)

##	create_restart_model(model_name='restart',odb_title1=odb_title1)
##	new_instance(wire)
##	create_dynamic_explicit_step(stepname='step2',timePeriod=draw_time)

	if odb_title1 in mdb.jobs.keys():
		job1 = mdb.jobs[odb_title1]
		if job1.status in [RUNNING,SUBMITTED]:
			mdb.jobs[odb_title1].waitForCompletion()

	model_name = copy_model(to_name='restart')
	clear_model_settings()
	if odb_title1 in mdb.jobs.keys():
		import_initial_state(odb_title1)	## even though no step is created in the new model.

	get_current_model()

	return model_name

def create_right_edge(p,maxx=None,maxy=None):
	## VER: 2014-09-08, v1.3
	## reference: right_edge_of_datum_plane()
	## reference: create_axis_x(), create_axis_y(), create_axis_z()

	p = check_part(p)

	if maxx in empty or maxy in empty:
		lenx,leny,lenz = spans_of_poi(p)

	if maxx in empty:
		lenx = max(int(lenx),100)	## 100可能也是有问题的，后面的草图线条可能会超出该'right edge'
	else:
		lenx = maxx

	if maxy in empty:
		leny = max(int(leny),100)
	else:
		leny = maxy

	lenz = max(int(lenz),100)

	p.DatumPointByCoordinate(coords=(2*lenx, 0, 0))
	p.DatumPointByCoordinate(coords=(2*lenx, 2*leny, 0))
	p.DatumAxisByTwoPoint(point1=p.datums[p.datums.keys()[-1]], point2=p.datums[p.datums.keys()[-2]])
	right_edge1 = p.datums[p.datums.keys()[-1]]

	return right_edge1

def part_to_inp(part,jobname=None):
	## VER: 2017-06-15, v1.1

##	clear()
##	import part from odb, deformed shape
##	save_imported()
##	part_to_inp(p1,'sinter_B102')

	refresh()

	if is_pia(jobname):
		part,jobname = jobname,part

	part = check_part(part)
	if jobname in empty:
		jobname = part.name

	insts = a.instances.keys()
	for inst in insts:
		a.features[inst].suppress()

	inst1 = new_instance(part)

	jobname = 'part_' + jobname

	if jobname in mdb.jobs.keys():
		del mdb.jobs[jobname]

##	jobname = part.name
##	while True:
##		if jobname[0] == '_' or jobname[0].isdigit():
##			jobname = jobname[1:]
##		else:
##			break
##
##	print 'jobname=',jobname

	try:
		mdb.Job(name=jobname, model=_m.name, description='', type=ANALYSIS,
		    atTime=None, waitMinutes=0, waitHours=0, queue=None, memory=90,
		    memoryUnits=PERCENTAGE, getMemoryFromAnalysis=True,
		    explicitPrecision=SINGLE, nodalOutputPrecision=SINGLE, echoPrint=OFF,
		    modelPrint=OFF, contactPrint=OFF, historyPrint=OFF, userSubroutine='',
		    scratch='', resultsFormat=ODB, multiprocessingMode=DEFAULT, numCpus=1, numGPUs=0)
	except:
		raise Exception('*** Invalid jobname')

	mdb.jobs[jobname].writeInput(consistencyChecking=OFF)

	del_insts(inst1)

	for inst in insts:
		a.features[inst].resume()

	return jobname + '.inp'


def part_to_rigid_body(inst,side_num=None,name='rigid_body',region_type='body',side='',RP=None):
	## VER: 2015-04-24, v1.3, 在接触模块。会建立该inst的参考点。
	## any part can be set as regid body
	## 如果一个part一开始就是rigid body(离散或解析)，则只需建立其surface
	## region_type: body适用于离散刚体（所以需要网格划分），surface适用于解析刚体。

	## Example:
##	part_to_rigid_body(shell1_A1,region_type='body')

	inst = check_inst(inst)
	type1 = part_type(inst)

	if len(inst.cells) > 0:
		region_type = 'body'		## body to rigid body
	elif len(inst.faces) > 0:
		if '2D' in part_shape(inst)[-1]:
			region_type = 'body'

	shape1 = part_shape(inst)[1]

	region1 = None
	if 'RIGID' in totext(type1):
		print 'Instance',inst.name,'has been rigid part already.'
		print 'region_type =',region_type

		if region_type == 'surface':
			region1 = create_surface(inst,side_num=side_num,side=side)

	else:
		if region_type == 'body':	## DISCRETE_RIGID_SURFACE (离散刚体) 离散刚体进行刚体约束时，不需要指定side_num
			objs = body_obj(inst)
			region1 = create_set(inst,objs=objs)

		elif region_type == 'surface':
			region1 = create_surface(inst,side_num=side_num,side=side)

		else:
			raise Exception('*** Error region type')

		region2 = RP2region(inst,RP=RP)
		name = new_key(_m.constraints.keys(),name)

		if region_type == 'body':
			_m.RigidBody(name=name, refPointRegion=region2, bodyRegion=region1, refPointAtCOM=ON)
		elif region_type == 'surface':
			_m.RigidBody(name=name, refPointRegion=region2, surfaceRegion=region1, refPointAtCOM=ON)

		print '--->created rigid body:',name,'for',inst.name

	return region2	## return referencePoint object

def create_rigid_pipe(partname,x=None,y=None,radius=None,sketch=None,length=20,ptype='discrete'):
	## VER: 2014-09-20, v1.2

##		create_rigid_plane('hang',x=20,y=80)
##		rotate_part(hang,angle_x=90)
##		move_part(hang,x1=MID,x2=_xmid(bar),y1=MIN,y2=_ymin(bar),z1=MID,z2=_zmid(bar))
##		divide(hang,z=MID)   ## for contact with bar
##		new_instance(hang)

		## U型吊钩，吊耳,建立surface时，凹面为正。
##		create_rigid_pipe('hang',radius=(door_hole + 5)/2.0,length=50)
##		bias_cut('hang',y=MID,cut_sides='+y')
##		rotate_part('hang',angle_y=90)
##		move_part('hang',x1=MID,x2=_xmid(bar),y1=MIN,y2=_ymin(bar), z1=MID,z2=_zmid(bar))
##		divide(hang,z=MID)
##		new_instance(hang)

	partname = new_key(_m.parts.keys(),partname)

	s = _m.ConstrainedSketch(name='__profile__',  sheetSize=200.0)
	s.setPrimaryObject(option=STANDALONE)

	if type_of(radius) in numerics:
		s.CircleByCenterPerimeter(center=(0.0, 0.0), point1=(radius, 0.0))
	elif is_numbers(x,y):
		s.rectangle(point1=(0.0, 0.0), point2=(x, y))
	elif is_sketch(sketch):
		sketch = check_sketch(sketch)
		s.retrieveSketch(sketch)
	else:
		raise Exception('*** dimensions or a sketch is required.')

	ptype = totext(ptype).lower()
	if 'disc' in ptype:
		ptype = DISCRETE_RIGID_SURFACE
	elif 'anal' in ptype:
		ptype = ANALYTIC_RIGID_SURFACE
	else:
		raise Exception('*** Error ptype')

	_m.Part(name=partname, dimensionality=THREE_D, type=ptype)
	p = _m.parts[partname]
	p.BaseShellExtrude(sketch=s, depth=length)
	s.unsetPrimaryObject()

	p = _m.parts[partname]
	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=p)
	del mdb.models[_m.name].sketches['__profile__']

	return

def create_rigid_plane(partname,ndir='z',offset=0, length=None,width=None,radius=None,x=None,y=None,z=None,
	xmin=None,xmid=None,xmax=None,ymin=None,ymid=None,ymax=None,zmin=None,zmid=None,zmax=None):
	## VER: 2015-05-13, v1.4

	## Example:
##	create_rigid_plane('plate',length=15,width=15,ndir='y',offset=_ymin(compound),xmin=0,zmax=0)
##	new_instance('plate')

	partname = new_key(_m.parts.keys(),partname)
	if ndir not in ['x','y','z']:
		raise Exception('*** ndir should be x, y, or z')

	s = _m.ConstrainedSketch(name='s_plate',  sheetSize=200.0)
	s.setPrimaryObject(option=STANDALONE)

	if is_number(x):
		length = x

	if is_number(y):
		width = y

	if type_of(radius) in numerics:
		s.CircleByCenterPerimeter(center=(0.0, 0.0), point1=(radius, 0.0))
		_m.Part(name=partname, dimensionality=THREE_D, type=DISCRETE_RIGID_SURFACE)
	elif is_numbers(length,width):
		s.rectangle(point1=(0.0, 0.0), point2=(length, width))
		_m.Part(name=partname, dimensionality=THREE_D, type=DISCRETE_RIGID_SURFACE)
		## ANALYTIC_RIGID_SURFACE，如果建为解析刚体，则经过平移翻转之后，可能会出现建surface的错误
		## Analytical rigid surface of an unknown type in part instance plate_A1, 结果生成inp文件时会强行退出。
	else:
		raise Exception('*** dimension is required.')

	p = _m.parts[partname]
	p.BaseShell(sketch=s)
	s.unsetPrimaryObject()

	if ndir == 'x':
		rotate_part(partname,angle_y=90)
		if offset != 0:
			move_part(partname,x1=MID,x2=offset)

		if is_number(ymin):
			move_part(partname,y1=MIN,y2=ymin)
		elif is_number(ymax):
			move_part(partname,y1=MAX,y2=ymax)
		elif is_number(ymid):
			move_part(partname,y1=MID,y2=ymid)

		if is_number(zmin):
			move_part(partname, z1=MIN,z2=zmin)
		elif is_number(zmax):
			move_part(partname, z1=MAX,z2=zmax)
		elif is_number(zmid):
			move_part(partname,z1=MID,z2=zmid)

	elif ndir == 'y':
		rotate_part(partname,angle_x=90)
		if offset != 0:
			move_part(partname,y1=MID,y2=offset)

		if is_number(xmin):
			move_part(partname,x1=MIN,x2=xmin)
		elif is_number(xmax):
			move_part(partname,x1=MAX,x2=xmax)
		elif is_number(xmid):
			move_part(partname,x1=MID,x2=xmid)

		if is_number(zmin):
			move_part(partname, z1=MIN,z2=zmin)
		elif is_number(zmax):
			move_part(partname, z1=MAX,z2=zmax)
		elif is_number(zmid):
			move_part(partname,z1=MID,z2=zmid)

	else:
		if offset != 0:
			move_part(partname,z1=MID,z2=offset)

		if is_number(xmin):
			move_part(partname,x1=MIN,x2=xmin)
		elif is_number(xmax):
			move_part(partname,x1=MAX,x2=xmax)
		elif is_number(xmid):
			move_part(partname,x1=MID,x2=xmid)

		if is_number(ymin):
			move_part(partname,y1=MIN,y2=ymin)
		elif is_number(ymax):
			move_part(partname,y1=MAX,y2=ymax)
		elif is_number(ymid):
			move_part(partname,y1=MID,y2=ymid)

	return partname

def create_round_block(partname,_xlength,_ylength,_zlength,radius=1,mat=None):
	## VER: 2013-03-28, v1.0

	if type_of(partname) != 'STR':
		raise Exception('partname is required.')

	partname = new_key(_m.parts.keys(),partname)
	blank_part(partname)
	part1 = _m.parts[partname]

	create_block(part1,x=(0,_xlength),y=(0,_ylength),z=(0,_zlength))

	if type_of(radius) in numerics and radius > 0:
		round_edges(part1,x=MIN,y=MAX,radius=radius)
		round_edges(part1,x=MIN,y=MIN,radius=radius)
		round_edges(part1,x=MAX,y=MIN,radius=radius)
		round_edges(part1,x=MAX,y=MAX,radius=radius)

	if type_of(mat) == 'STR':
		set_mat(part1,mat=mat)

	print '--->Created new part, name=',partname

	return partname

def create_RP(poa,loc=(),name='RP', clear_RP= False, create_CSYS=False, csys_type=CARTESIAN, axial_dir='x', U1_point=None, U2_point=None):
	## VER: ('VER: 2014-09-17, v1.8')	## RP可以作为显式的当前局部坐标系。而CSYS可作为显式的vertice set.
	## loc可以位于任何地方，即使没有vertice
	## csys_type: CARTESIAN or CYLINDRICAL
	## X–Y plane or the r–theta plane
	## 柱坐标系：U1=R, U2=theta, U3=Z
	## 参考: create_cylind_csys()
	## 如果poa是部件，得到的是部件的reference Point，而使用的是实例的reference point
	## 参考点也是质量点，可以建在part上，也可以建立set

##	vertices = vertice_select(tpunch,z=MAX)
##	vertices = vertices_sort_byx(vertices)
##	create_RP(tpunch,loc=vertices[0][1][0],name='RP_punch')  ## 参考点建在part上
##	set_punch = create_set('tpunch_A1',name='RP_punch',RP=_inst('tpunch_A1').referencePoints.values()[0])  ## 利用instance的参考点建立set，便于施加约束

##		RP, csys = create_RP(shaft_A1,loc=((x12+x2)/2, 0, 0), name='local_csys',csys_type=CYLINDRICAL,axial_dir='z')
##		faces = face_select(shaft_A1,radius=shaft_D2/2,x=((x12+x2)/2 - 3, (x12+x2)/2 + 3),ny=-1)
####		coupling_faces_to_point('shaft_coupling',faces=faces,control_point=RP,U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=DISTRIBUTING)
##		coupling_faces_to_point('shaft_coupling',faces=faces,control_point=RP,U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=KINEMATIC)
##		apply_disp_fix('fix_bearing1',referencePoints=RP,U2=0)

##	RP = create_RP(ashaft_A1,loc=(bearing_ashaft, _ymid(ashaft_A1), 0), name='ashaft_bearing')
##	RP_set2 = create_set(objs=RP,setname='ashaft_RP_set')

	poa = check_pias(poa)	## part or assembly, no instance

##	if clear_RP == True:
##		names = get_RP_names(poa)
##		del_features(poa,names=names)

	if type_of(loc) == 'vertices':
		loc = loc.pointOn[0]

	if len(poa.vertices) > 0:
		pt1 = poa.vertices[0].pointOn[0]

		if len(pt1) == 2:
			dimensionality = 2
			loc0 = (0,0)
		elif len(pt1) == 3:
			dimensionality = 3
			loc0 = (0,0,0)
		else:
			dimensinality = 1
			loc0 = (0,)
	else:
		dimensionality = 3
		loc0 = (0,0,0)
		pt1 = (0,0,0)

	space = poi_space(poa)

	## please_check
	if loc in empty:
		if type_of(poa) == 'PART' and 'RIGID' in totext(poa.type):
			loc = pt1
		else:
			if within_space(space,loc0):
				loc = loc0
			else:
				if len(poa.vertices) > 0:
					loc = pt1
				else:
					loc = loc0

	if is_location(loc) == False:
		raise Exception('**** location of RP is required.')

	if type_of(poa) == 'PINSTANCE':
		poa = a

	please_check
##	if loc == (0,0,0):
##		name = 'O'

	RPnames = get_RP_names(poa)
	if name in RPnames:
		del poa.features[name]

	RPnames = get_RP_names(poa)
	if type_of(poa) == 'PART' and len(RPnames) == 1:
		del poa.features[RPnames[0]]

##	if name in ['RP','O']:
##		if 'RP' in poa.features.keys():
##			del poa.features['RP']
##		if 'O' in poa.features.keys():
##			del poa.features['O']
##	else:
##		name = new_key(poa.features.keys(),name)
##
##	## 无法获得一个rp的feature name，也无法知道rp对应哪个feature
##	if type_of(poa) == 'PART' and len(poa.referencePoints) == 1:
##		for name1 in poa.features.keys():
##			if 'RP' in name1:
##				del poa.features[name1]

	results = []
	RP = poa.ReferencePoint(point=loc)
	if RP.name != name:
		poa.features.changeKey(fromName=RP.name, toName = name)

	RP_id = RP.id
	RP = poa.referencePoints[RP_id]   ## type_of(RP) == 'referencePoints', not 'FEATURE'
##	results.append(RP)  ## obj

	return RP	## return referencePoint object

def create_set(p=None, name='set1', setname=None, objs=None, cells=None, faces=None, edges=None, vertices=None, RP=None,
	elements=None, nodes=None, node_labels=None, obj_type=None,objs_seq=None,check_name=True,info='',return_setname=False):
	## VER: ('VER: 2017-09-25, v3.9')	##datum cannot create a set
	## create set like region: Region(obj_type = objs)
	## defalt to check name
	## datum point不能建set
	## ctrl+左键:去除选择; shift+左键: 增加选择

## nodes的再次选择的方法: 在CAE界面上,首先建立这些nodes的set，然后tools-set-Edit该set，这些节点将被点亮。此时按住Ctrl键+鼠标左键框选去除部分高亮的节点。或按Shift键+鼠标左键增加新的节点。

	## PDC_A1.sets['H11N'] is also a set like region

##	>>> create_set(objs=nodes,name='set1',check_name=False)
##	['cliCommand', 1, 'create_set', 18328] ******setname set1 already existed in part powder . It will be overwrite.
##	mdb.models['Model-1'].parts['powder'].sets['set1']
##	>>> create_set(objs=nodes,name='set1',check_name=False)
##	['cliCommand', 1, 'create_set', 18328] ******setname set1 already existed in part powder . It will be overwrite.
##	mdb.models['Model-1'].parts['powder'].sets['set1']

##	RP = create_RP(ashaft_A1,loc=(bearing_ashaft, _ymid(ashaft_A1), 0), name='ashaft_bearing')
##	RP_set2 = create_set(objs=RP,setname='ashaft_RP_set')


##	seq1 = list2sequence(_inst(nib_A1).faces)
##	seq2 = list2sequence(_inst(case_A1).faces)
##	region = a.Set(faces=seq1 + seq2, name='cell_region')

##	cells = cell_select(anvil,z=(MID,MIN))
##	create_set(anvil,name='anvil_back',cells=cells)

##	nodes1 = _inst('plate_A1').nodes[:]
##	nodes2 = _inst('green_A1').nodes[:]
##	region = a.Set(nodes=nodes1+nodes2, name='all_nodes')   ## sequence1 + sequence2 = sequence3

	print fnln(),'check_name=',check_name

	if check_name == 0:
		check_name = False
	elif check_name == 1:
		check_name = True

	if type_of(setname) == 'STR':
		name = setname

	if is_pia(p):
		p = check_pias(p)
	elif type_of(p) == 'STR':
		name = p
		p = None
	elif p not in empty and objs in empty:
		objs = p
		p = None

	if type_of(RP) == 'RPREPOSITORY':
		store = RP
		if len(store.values()) == 1:
			RP = store.values()[0]
		else:
			raise Exception('*** No reference point or more than one reference point.')

	if node_labels not in empty:
		nodes = node_labels

	if is_numbers(nodes):
		if is_poi(p) == False:
			raise Exception('*** poi is required when provide node labels.')
		p = check_poi(p)
		nodes = labels_to_nodes(p,nodes)

##>>> a.referencePoints.keys()   ## not RP name
##[231]
##>>>
##>>> get_RP_names(a)
##['RP-1']
##>>> get_RP_objs(a)
##[mdb.models['Model-1'].rootAssembly.features['RP-1']]
##>>>
	if info == '':
		info = '1'

##	print fnln(),'elements=',_len(elements)
	objs = get_real_input(objs, objs_seq, cells, faces, edges, vertices, RP, elements, nodes)
##	print fnln(),'objs=',objs

	## you can also provide Reference Point object
	if objs == RP and type_of(RP) == 'STR':
		objs = get_RP_objs(p)
		if objs in empty:
			raise Exception('*** faile to get the RP objects.')
		else:
			objs_seq = totuple(objs)

	if is_poi(objs):
		p = check_poi(objs)
		if len(p.cells) > 0:
			objs = p.cells[:]
		elif len(p.faces) > 0:
			objs = p.faces[:]
		elif len(p.edges) > 0:
			objs = p.edges[:]
		elif len(p.elements) > 0:
			objs = p.elements[:]

	if type_of(objs) == 'SEQUENCE':
		objs_seq = objs

	objs = tolist(objs)
	if objs in empty:
		raise Exception('objs are required to create a set.')

	pois = get_pois(objs)
	poi_type = type_of(pois[0])
##	if name == 'set1':
##		if poi_type == 'PINSTANCE' and len(pois) == len(a.instances):
##			name = 'set_model_1'
##		else:
##			if len(pois) == 1:
##				poi = pois[0]
##				name1 = ''
##				if type_of(poi) == 'PART':
##					name1 = poi.name
##				elif type_of(poi) == 'PINSTANCE':
##					name1 = poi.partName
##				name = 'set_' + name1 + '_' + info
##			else:
##				name0 = 'set_'
##				for poi in pois:
##					name0 = name0 + poi.name[:4]
##					name0 = modify_string(name0,' ','_')
##					name0 = modify_string(name0,'-','_')
##					if name0[-1] != '_':
##						name0 = name0 + '_'
##				name = name0 + info

	obj_type = type_of(objs[0])
##	if RP not in empty:
##		obj_type = 'referencePoints'

	if p in empty:
##		print fnln(),objs
		p = get_pois(objs)[0]

	p0 = None
	if type_of(p) in ['PART','PINSTANCE']:
		p0 = p

	if type_of(p) == 'PINSTANCE':
		p = a

	if type_of(p) not in ['PART','ASSEMBLY']:
		raise Exception('Part or instance is required. ')  ##**********

	if name == p.name:
		name = 's_' + p.name
		print fnln_fnln(),'******setname == part name. Changed s_' + p.name

	if name in p.sets.keys() and check_name == False:
		print fnln_fnln(),'******setname',name,'already existed in part',p.name,'. It will be overwrite.'

	##???**** 更改setname
	if check_name == True:
		name = new_key(p.sets.keys(),name)

##	print fnln(),'p=',type_of(p)
##	print fnln(),'before: num=',len(objs)
	if objs_seq in empty:
		objs_seq = list2sequence(objs,p0)   ## if objs are come from several insts, p0 will be useless.

##	print fnln(),'type_of objs_seq=',type_of(objs_seq)
##	print fnln(),'after: num=',len(objs_seq)
##	prettyPrint(objs_seq,4)

##	print fnln(),'name=',name
##	print fnln(),'obj_type=',obj_type

	## faces and elements also have surface like region.
##	print fnln_fnln(),'obj_type=',obj_type

##	raise Exception

	if objs_seq not in empty:
		if obj_type == 'cells':
			p.Set(cells = objs_seq,name = name)

		elif obj_type == 'faces':      ## set like region is: region = regionToolset.Region(faces = objs_seq)
			p.Set(faces = objs_seq,name = name)

		elif obj_type == 'edges':
			p.Set(edges = objs_seq,name = name)

		elif obj_type == 'vertices':
			p.Set(vertices = objs_seq, name = name)

		elif obj_type == 'elements':  ## set中包含element and nodes
			p.Set(elements = objs_seq, name = name)   ## set like region is: region = regionToolset.Region(elements = objs_seq)

		elif obj_type == 'nodes':
			p.Set(nodes = objs_seq, name = name)

		elif obj_type == 'referencePoints':
			print fnln(),'objs_seq=',objs_seq
			p.Set(referencePoints = objs_seq, name=name)

		print '--->Created new',obj_type,'set for',p.name, ', setname=',name

	else:
		print fnln_fnln(),'****Set',name,'was not created. objs=',repr(objs)

	try:
		a.regenerate()
	except:
		pass

	return p.sets[name]   ## return set like region except for interact.

function_labels['create_std_module'] = 'PV','suntech','model','standard','frame'
def create_std_module(cut_TPT=False,cut_EVA=False,cell_nums=None,frame_adhesive=None,frL_adhesive='Silic',frS_adhesive=None,cell_loc='bot'):
	## VER: ('VER: 2016-10-21, v5.0') ## 边框组件

	global module_mass,frame_mass,reduceM,lam_mass,silic_mass, lam2rail

	if cut_EVA == True:
		cut_TPT = True
		lam_has_EVA = False
	else:
		lam_has_EVA = True

	if frame_adhesive not in empty:
		frL_adhesive = frS_adhesive = frame_adhesive

	if frS_adhesive == None:
		frS_adhesive = frL_adhesive

	glass_lenx = glass_width
	glass_leny = glass_length

	local2global(locals(),'lam_has_EVA','glass_lenx','glass_leny')

##	raise Exception

	## lam,laminate
	create_single_lam(glass_length, glass_width, glass_thick,has_EVA_TPT = True)

##	stop()

	## long frame
	frL = blank_part('frL')	## 建立RP
	frL = _part(frL)

##	s1 = create_base_sketch('sk_frL')
##	set_point0((0,0))
##	add_points(('x',-top_lip_width),('dy',-top_lip_thick - top_adhesive_thick),('x',-outer_wall_thick - silic_side),('dy',-lam_thick),
##		('x',-bot_lip_width),('dy',-bot_lip_thick - bot_adhesive_thick),('x',0),('y',0))
##	poly_line(s1)
##	extrude_sketch_to_part(frL,s1,length=module_top_length)

	xleft,xright,ybot,ytop,zbot,ztop = 0,1,2,3,4,5  ## index
	## 铝边框的基本框架
	xline1 = create_block(frL,x=(0,-top_lip_width),z=(0,-top_lip_thick - top_adhesive_thick),y=(-module_top_length/2,module_top_length/2))
	xline2 = create_block(frL,x=(0,-bot_lip_width),PRz=(xline1[zbot], -lam_thick, -bot_adhesive_thick - bot_lip_thick))
	xline3 = create_block(frL,x=(-legs_span,0),PRz=(-frame_height,base_thick))

	zline1 = create_block(frL,x=(0,-outer_wall_thick),z=(0,-frame_height))
	zline2 = create_block(frL,PRx=(zline1[xleft],-silic_side),z=(0,xline2[zbot]))
	zline3 = create_block(frL,PRx=(-legs_span,inner_wall_thick),z=(-frame_height,xline2[ztop]))

	z01 = divide(frL,z=-top_lip_thick)
	z02 = divide(frL,PRz=(xline2[ztop],-bot_adhesive_thick))

	## 目前为止，没有flange.

	## grow flange
	if flange_dir == 'inside':
		xline4 = create_block(frL,x=(-legs_span,-frame_bot_width),PRz=(-frame_height,flange_thick))
	elif flange_dir == 'outside': ## Reliathon
		xline4 = create_block(frL,x=(0,frame_bot_width_big - legs_span),PRz=(-frame_height,flange_thick))
		zline4 = create_block(frL,PRx=(xline4[xright],-turn_thick),PRz=(-frame_height,turn_H))

	cells1 = cell_select(frL,x=(-outer_wall_thick,MIN),z=(-top_lip_thick,xline2[ztop]-bot_adhesive_thick))
	set_mat(frL,cells=cells1,mat=frL_adhesive)

	cells = unselect(frL,cells1)
	set_mat(frL,cells=cells,mat=Al_6063,subset='Frame')

	raise Exception

	## copy part
	copy_part(frL,'frS',change_setname=True)

	bias_cut(frL,cut_sides='+y',y=frame_length_L/2)
	bias_cut(frL,cut_sides='-y',y=-frame_length_L/2)

##	raise Exception

	move_RP(frL,x=-outer_wall_thick,y=MAX,z=-frame_height + base_thick)
	create_block(frL,(0,-leg_gap),(0,-kahuang_L),(0,leg_gap_H),mat=Al_6063,addRP=True,bigset='Kahuang')   ## 所以Al_6063的cells比Frame的Cells多

	move_RP(frL,dy=-frame_length_L)
	create_block(frL,(0,-leg_gap),(0,kahuang_L),(0,leg_gap_H),mat=Al_6063,addRP=True,bigset='kahuang')		## kahuang

##	if _module_type == 'R1b' and wide_leg_gap == True:
##		hex_cut(frL,x=(MIN,_xmin(frL) + step_width),z=(MIN,_zmin(frL) + step_H))

	bias_cut(frL,cut_sides=('-x','y'),x=KPx(frL),y=MAX,angle_with_X=45)
	bias_cut(frL,cut_sides=('-x','-y'),x=KPx(frL),y=MIN,angle_with_X=45)
	divide(frL,x=KPx(frL) - outer_wall_thick - silic_side)

	move_RP(frL,gohome=True)

##	raise Exception

	faces_slope = find_slope_faces(frL,ndir='slope',mat='Al_6063')
	ext_faces = exterior_faces_of_faces(faces_slope)
	create_set(frL,faces=ext_faces,name='fm_frame_corner')

	kahuang_faces = unselect(faces_slope,ext_faces)
	create_set(frL,faces=kahuang_faces,name='fm_kahuang')

	silic_faces = find_slope_faces(frL,mat=frame_adhesive,ndir='slope')
	create_set(frL,faces=silic_faces,name='fm_adhesive_corner')

	faces1 = faces_of_cut(frL,z=KPz(frL,O2) + bot_adhesive_thick)
	create_set(frL,faces=faces1, name='fs_frame_mouth_bot')
	del faces1

	faces2 = faces_of_cut(frL,z=-top_lip_thick - top_adhesive_thick)
	create_set(frL,faces=faces2, name='fs_frame_mouth_top')
	del faces2

	faces3 = faces_of_cut(frL,x=-outer_wall_thick - silic_side)
	create_set(frL,faces=faces3, name='fs_frame_mouth_side')
	del faces3

	faces = faces_of_cut(frL,x=KPx(frL))
	create_set(frL, faces=faces, name='fs_frame_wall')
	del faces

	edges = exterior_edges('fm_adhesive_corner',poi=frL)
	create_set(frL, faces=edges, name='e_xEdges_frame_lam')
	del edges

	new_instance(frL,'frL_A1')

##	stop()

	## drill hole
	if flange_dir == 'inside' and has_mid_hole == True:
		hole_x = _xmax(frL) - legs_span - bot_flange_hange/2
		drill_hole(frL,x=hole_x,y=0,D=ehole_D,divide_dir='y')

	if cut_long_flange == True:
		hex_cut(frL,x=(MIN,_xmax(frL) - frL_bot_width),z=(MIN,_zmin(frS) + flange_thick))

##	stop()

	## short frame
	bias_cut(frS,cut_sides='+y',y=frame_length_S/2)
	bias_cut(frS,cut_sides='-y',y=-frame_length_S/2)

	if _module_type[0] == 'R':
		bias_cut(frS,cut_sides='+x',x=_xmax(frS,z=MAX))

	move_RP(frS,x=-outer_wall_thick,y=MAX,z=-frame_height + base_thick)
	create_block(frS,(0,-leg_gap),(0,-kahuang_L),(0,leg_gap_H),mat=Al_6063,addRP=True,bigset='Kahuang')   ## kahuang

	move_RP(frS,dy=-frame_length_S)
	create_block(frS,(0,-leg_gap),(0,kahuang_L),(0,leg_gap_H),mat=Al_6063,addRP=True,bigset='Kahuang')

##	if _module_type == 'R1b' and wide_leg_gap == True:
##		hex_cut(frS,x=(MIN,_xmin(frS) + step_width),z=(MIN,_zmin(frL) + step_H))

	move_RP(frS,gohome=True)
	if cut_short_flange == True:   ## 如果不是用胶带，即leg_gap=4，则切掉20,即保持底部为15宽。
		hex_cut(frS,x=(MIN,_xmin(frS,z=MID)),z=(MIN,_zmin(frS) + flange_thick))

	bias_cut(frS,cut_sides=('-x','y'),x=KPx(frS),y=MAX,angle_with_X=45)
	bias_cut(frS,cut_sides=('-x','-y'),x=KPx(frS),y=MIN,angle_with_X=45)
	divide(frS,x=KPx(frS) - outer_wall_thick - silic_side)

	move_RP(frS,gohome=True)

	faces_slope = find_slope_faces(frS,ndir='slope',mat='Al_6063')
	ext_faces = exterior_faces_of_faces(faces_slope)
	create_set(frS,faces=ext_faces,name='fs_frame_corner')

	kahuang_faces = unselect(faces_slope,ext_faces)
	create_set(frS,faces=kahuang_faces,name='fs_kahuang')

	silic_faces = find_slope_faces(frS,mat=frame_adhesive,ndir='slope')
	create_set(frS,faces=silic_faces,name='fs_adhesive_corner')

	faces1 = faces_of_cut(frS,z=KPz(frS,O2) + bot_adhesive_thick)
	create_set(frS,objs=faces1,name='fs_frame_mouth_bot')
	del faces1

	faces2 = faces_of_cut(frS,z=-top_lip_thick - top_adhesive_thick)
	create_set(frS,objs=faces2,name='fs_frame_mouth_top')
	del faces2

	faces3 = faces_of_cut(frS,x=-outer_wall_thick - silic_side)
	create_set(frS,objs=faces3,name='fs_frame_mouth_side')
	del faces3

	edges = exterior_edges('fs_adhesive_corner',poi=frS)
	create_set(frS,objs=edges, name='e_xEdges_frame_lam')

##	stop()

	## Assembly:
	move_part(lam,x1=MID,x2=0,y1=MID,y2=0)		##确定零点位置。其他parts装配到lam。后面将保留右上角的1/4模型，此时左下角为绝对坐标零点。
	## 本行命令不能手工执行，否则，看不到lam.

	new_instance(lam)

	move_part(frL,x1=_xmax(frL,z=MAX) - outer_wall_thick - silic_side, x2 = _xmax(lam),y1=MID,y2=_ymid(lam),
		z1=_zmax(frL) - top_lip_thick - top_adhesive_thick, z2=_zmax(lam))
	new_instance(frL)

	if kahuang_L > _ymax(frL) - _ymax(frL,x=MIN):
		divide(frL,y=_ymax(frL) - kahuang_L)
		divide(frL,y=_ymin(frL) + kahuang_L)

	if kahuang_L > _ymax(frS) - _ymax(frS,x=MIN):
		divide(frS,y=_ymax(frS) - kahuang_L)
		divide(frS,y=_ymin(frS) + kahuang_L)

##	stop()

	## frL2
	copy_part(frL,'frL2',change_setname=True)
	if _module_type[0] == 'R':
		bias_cut(frL2,x=_xmax(frL2,z=MAX),cut_sides='+x')
		create_block(frL2,x=(MAX, _xmax(frL2) + U_gap_small + turn_thick),z=(MIN,_zmin(frL) + base_thick),mat='Al_6063',bigset='Frame')
		create_block(frL2,x=(MAX,_xmax(frL2) - turn_thick), z=(MIN,_zmin(frL2) + turn_H),mat='Al_6063',bigset='Frame')

##	stop()

	rotate_part(frL2,angle_z=180)

	move_part(frL2,x1 = KPx(frL2) + outer_wall_thick + silic_side, x2 = _xmin(lam), z1=MAX, z2=_zmax(frL))
	new_instance(frL2)

	rotate_part(frS,angle_z=90)
	move_part(frS,y1=KPy(frS) - outer_wall_thick - silic_side,y2 = _ymax(lam),x1=MID,x2=_xmid(lam),
		z1=MAX,z2=_zmax(frL))
	new_instance(frS)

	## frS2
	copy_part(frS,'frS2',change_setname=True)
	rotate_part(frS2,angle_z=180)

	move_part(frS2,y1=KPy(frS2) + outer_wall_thick + silic_side, y2 = _ymin(lam), z1=MAX, z2=_zmax(frL))
	new_instance(frS2)

##	stop()

	## aditional divide
	batch_divide(z='p_lam_dirz')

##	raise Exception

	if has_mid_hole == True:
		batch_divide(lam,y=[-ehole_D*1.2, ehole_D*1.2])

	if leg_gap + outer_wall_thick >= top_lip_width + 1:
		divide(frL,x=_xmax(frL,z=MAX) - top_lip_width)
		divide(frS,y=_ymax(frS,z=MAX) - top_lip_width)

	divide(lam,x=_xmax(frL,z=MAX) - bot_lip_width)
	divide(lam,y=_ymax(frS,z=MAX) - bot_lip_width)
	divide(lam,x=_xmin(frL2,z=MAX) + bot_lip_width)
	divide(lam,y=_ymin(frS2,z=MAX) + bot_lip_width)

	divide(lam,x=_xmax(frL,z=MAX) - top_lip_width)
	divide(lam,y=_ymax(frS,z=MAX) - top_lip_width)
	divide(lam,x=_xmin(frL2,z=MAX) + top_lip_width)
	divide(lam,y=_ymin(frS2,z=MAX) + top_lip_width)

	if flange_thick > base_thick:
		batch_divide([frL,frS],z=_zmin(frL) + flange_thick)

	try:
		cell_mass = glass_length*glass_width*cell_thick*Si_D*1e6
		cell_mass = int(round(cell_mass))
	except:
		cell_mass = 0
		print fnln_fnln(),'******cell_mass = 0'

##	stop()

	frame_mass = (get_mass(frL,setname='Frame') + get_mass(frS,setname='Frame'))*2   ## 不是1/4模型，是全模型。不含卡黄。
	frame_mass = round(frame_mass*1e3,2)

	reduceM = round(frame_mass - frame_mass_ref,2)  	## reduceM < 0表示减重，reduceM > 0表示增重。
	silic_mass = get_mass(setname=frL_adhesive)

	lam_mass = glass_length*glass_width*(cell_thick*Si_D + EVA_thick*EVA_D + TPT_thick*TPT_D + glass_thick*Glass_D)
	lam_mass = int(round(lam_mass*1e6))

	frame_mass1 = get_mass(parts=[frL,frS,frL2,frS2])   ## 连硅胶

	module_mass = lam_mass + frame_mass1

	lam2rail = _zmin(lam) - _zmin(frL)

	write_global_variables(var_file_full,module_mass,frame_mass,lam_mass,silic_mass, reduceM, lam2rail)

	keys0 = locals().keys()
	bot_lip_top = _zmin(frL) + base_thick + leg_gap_H + bot_lip_thick

	top_lip_tipx = _xmax(frL) - top_lip_width
	bot_lip_tipx = _xmax(frL) - bot_lip_width
	flange_tipx = _xmin(frL,z=MIN)

	top_lip_tipy = _ymax(frS) - top_lip_width
	bot_lip_tipy = _ymax(frS) - bot_lip_width
	flange_tipy = _ymin(frS,z=MIN)

	frame_top = _zmax(frL)
	frame_bot = _zmin(frL)

	locals2globals(keys0,locals())

	batch_divide(lam,x=[top_lip_tipx, bot_lip_tipx])
	batch_divide(lam,y=[top_lip_tipy, bot_lip_tipy])

	if frS_adhesive != frL_adhesive:
		cross_set_mat(frS,mat_old=frL_adhesive,mat=frS_adhesive)
		cross_set_mat(frS2,mat_old=frL_adhesive,mat=frS_adhesive)

	if cut_EVA == True:
##		hex_cut(lam,(-glass_width/2 + glass_cover,glass_width/2 - glass_cover),(-glass_length/2 + glass_cover,glass_length/2 - glass_cover),(_zmin(lam), _zmin(lam) + EVA_thick + TPT_thick))
		hex_cut(lam,(_xmin(frL2,z=MAX) + bot_lip_width,_xmax(frL,z=MAX) - bot_lip_width),(_ymin(frS2,z=MAX) + bot_lip_width,_ymax(frS,z=MAX) - bot_lip_width),(_zmin(lam), _zmin(lam) + EVA_thick + TPT_thick))
	elif cut_TPT == True:
##		hex_cut(lam,(-glass_width/2 + glass_cover,glass_width/2 - glass_cover),(-glass_length/2 + glass_cover,glass_length/2 - glass_cover),(_zmin(lam), _zmin(lam) + TPT_thick))
		hex_cut(lam,(_xmin(frL2,z=MAX) + bot_lip_width,_xmax(frL,z=MAX) - bot_lip_width),(_ymin(frS2,z=MAX) + bot_lip_width,_ymax(frS,z=MAX) - bot_lip_width),(_zmin(lam), _zmin(lam) + TPT_thick))

	## cell
	if has_cell == True:
		create_cell_block(cell_nums=cell_nums,cell_top = ['EVA2',EVA_thick/2])
		if cell_loc == 'bot':
			if _module_type == 'U':
				move_part(cell,x1=_xmin(cell),x2=_xmid(lam), y1=(cell_length + cell_gap)/2,y2=_ymid(lam),z1=_zmax(cell),z2=_zmin(lam,x=0,y=0))
			else:
				move_part(cell,x1=_xmin(cell),x2=_xmid(lam), y1=_ymin(cell),y2=_ymid(lam), z1=_zmax(cell),z2=_zmin(lam,x=0,y=0))

		elif cell_loc == 'top':
			if _module_type == 'U':
				move_part(cell,x1=_xmin(cell),x2=_xmid(lam), y1=(cell_length + cell_gap)/2,y2=_ymid(lam),z1=_zmin(cell),z2=_zmax(lam,x=0,y=0))
			else:
				move_part(cell,x1=_xmin(cell),x2=_xmid(lam), y1=_ymin(cell),y2=_ymid(lam), z1=_zmin(cell),z2=_zmax(lam,x=0,y=0))

		new_instance(cell)
		divide(lam,y=_ymax(cell))
		divide(lam,x=_xmax(cell))

	get_current_model()
##	create_poi_vars()

	return module_mass

def create_sketch_line(sketch,point1,point2):
	## VER: 2013-05-22, v1.1

	sketch = check_sketch(sketch)
	if type_of(point1) == 'vertices':
		point1 = point1.coords

	if type_of(point2) == 'vertices':
		point2 = point2.coords

	if is_location(point1) == False or is_location(point2) == False:
		raise Exception('**** location is required for point')

	sketch.Line(point1 = point1, point2 = point2)

	return point1, point2


def create_spline_wire(part, points,start=None,close=True):
	## VER: 2014-07-14, v1.1
	## 如果是封闭的一个wire，则只有一个vertice
	## GUI: 生成一个空白part部件(blank_part函数)=>Shape=>Wire=>Point to Point
	## 每个点都必须有x,y,z坐标

##	p = mdb.models['Model-1'].parts['p1']
##	p.WireSpline(points=((-5.12491, 8.031159, 0.0), (-4.910048, 8.011183, 0.0), (
##	    -4.698784, 7.979461, 0.0), (-4.480965, 7.949606, 0.0), (-4.260648,
##	    7.920234, 0.0), (-4.03591, 7.892222, 0.0), (-3.803806, 7.865666, 0.0), (
##	    -3.565172, 7.839438, 0.0), (-3.325105, 7.816152, 0.0), (-3.080291,
##	    7.793274, 0.0), (-2.828508, 7.772622, 0.0), (-2.571855, 7.752835, 0.0), (
##	    -2.309278, 7.735267, 0.0), (-2.042361, 7.719172, 0.0), (-1.767906,
##	    7.705268, 0.0), (-1.486387, 7.692723, 0.0), (-1.196303, 7.682316, 0.0), (
##	    -0.906721, 7.674192, 0.0), (-0.614566, 7.668103, 0.0), (-0.326105,
##	    7.664643, 0.0), (-0.047497, 7.662807, 0.0), (0.219629, 7.663934, 0.0), (
##	    0.484409, 7.665788, 0.0), (0.744576, 7.670611, 0.0), (1.003744, 7.676091,
##	    0.0), (1.263955, 7.684447, 0.0), (1.529891, 7.694048, 0.0), (1.79115,
##	    7.705798, 0.0), (2.05167, 7.719329, 0.0), (2.318535, 7.735549, 0.0), (
##	    2.591067, 7.7541, 0.0), (3.174045, 7.801463, 0.0), (3.440514, 7.82641,
##	    0.0), (3.687812, 7.85235, 0.0), (3.924715, 7.878433, 0.0), (4.14984,
##	    7.90583, 0.0), (4.366456, 7.933183, 0.0), (4.576476, 7.96173, 0.0), (
##	    4.783767, 7.990166, 0.0), (4.98489, 8.020669, 0.0)), mergeType=MERGE,
##	    meshable=ON, smoothClosedSpline=ON)
##	p = mdb.models['Model-1'].parts['p1']
##	e = p.edges
##	edges = e.findAt(((-2.604305, 7.755212, 0.0), ))
##	p.Set(edges=edges, name='Wire-1-Set-1')
##	>>> p1 = _part('p1')
##	>>> len(p1.edges)
##	1


##	p = mdb.models['Model-1'].parts['p2']
##	p.WireSpline(points=((-5.125515, 8.03124, 0.0), (-4.910769, 8.011356, 0.0), (
##	    -4.699445, 7.979757, 0.0)), mergeWire=ON, meshable=ON,
##	    smoothClosedSpline=ON)
##	p = mdb.models['Model-1'].parts['p2']
##	v = p.vertices
##	verts = v.findAt(((-5.125515, 8.03124, 0.0), ), ((-4.699445, 7.979757, 0.0), ))
##	p.Set(vertices=verts, name='Wire-2-Vertex-1')

##	37.2.55 WireSpline(...)
##	This method creates an additional Feature object by creating a spline wire that passes through a sequence of given points. Each point can be a datum point, a vertex, an interesting point, or a tuple.
##
##	Path
##	mdb.models[name].parts[name].WireSpline
##	Required argument
##
##	points
##	A sequence of Vertex, Datum point, or InterestingPoint objects specifying the points through which the spline wire will pass. points can also be a sequence of tuples of Floats. You must specify at least two values in the sequence.
##
##	Optional arguments
##	mergeType
##	A SymbolicConstant specifying the merge behavior of the wire with existing geometry. If mergeType is MERGE, Abaqus merges the wire into solid regions of the part if the wire passes through them. If mergeType is IMPRINT, Abaqus imprints the spline wire on existing geometry as edges. If mergeType is SEPARATE, Abaqus neither merges nor imprints the spline wire with existing geometry. It creates the wire separately. The default value is IMPRINT.
##
##	smoothClosedSpline
##	A Boolean specifying the behavior of Abaqus when the points defining a spline wire form a closed loop (the start and end points are the same). If smoothClosedSpline=ON, Abaqus creates a smooth spline wire where the tangencies at the end point meet smoothly. If smoothClosedSpline=OFF, Abaqus does not automatically create a smooth end condition. The default value in OFF.
##
##	Return value
##	A Feature object.

	if type_of(part) == 'STR' and part not in _m.parts.keys():
		part = blank_part(part)

	part = check_part(part)

	if type_of(points) not in ['TUPLE','LIST']:
		raise Exception('*** a list of points are required.')

	if type_of(start) == 'STR':
		start = start.lower()

	locs = []
	for point in points:
		loc = point
		if type_of(loc) == 'vertices':
			loc = loc.pointOn[0]
		elif type_of(loc) == 'referencePoints':
			loc = RPxyz(loc)

		if is_location(loc) and loc not in locs:
			locs.append(loc)
##		else:
##			raise Exception('*** a loc, vertice, or RF list is required.')

	if len(locs) == 1:
		raise Exception('*** at least two points are required.')

	print 'before: len=',len(locs)
	if start not in empty:
##		locs = points
		if start == 'ymax':
			ymax=locs[0][1]
			label = 0
			for i in range(len(locs)):
				y1 = locs[i][1]
				if PK(y1,ymax) == '>':
					ymax = y1
					label = i
		elif start == 'ymin':
			ymin=locs[0][1]
			label = 0
			for i in range(len(locs)):
				y1 = locs[i][1]
				if PK(y1,ymin) == '<':
					ymin = y1
					label = i
		elif start == 'xmax':
			xmax = locs[0][0]
			label = 0
			for i in range(len(locs)):
				x1 = locs[i][0]
				if PK(x1,xmax) == '>':
					xmax = x1
					label = i
		elif start == 'xmin':
			xmin = locs[0][0]
			label = 0
			for i in range(len(locs)):
				x1 = locs[i][0]
				if PK(x1,xmin) == '<':
					xmin = x1
					label = i

		locs = locs[label:] + locs[:label]

##		print fnln(),'locs[-1]=',locs[-1]
##		print fnln(),'locs[0]=',locs[0]

	## checking
	locs1 = [locs[0]]
	for i in range(len(locs))[1:]:
		loc1 = locs[i]
		dist = get_distance(loc1,locs1[-1])
		if PK(dist,1e-5) == '>':
			locs1.append(loc1)
	locs = locs1

	if close == True:
		locs.append(locs[0])

	edges0 = part.edges[:]

	part.WireSpline(points=locs, mergeWire=ON, meshable=ON, smoothClosedSpline=ON)
	edges1 = unselect(part.edges[:], edges0)

	setname = create_set(part, edges=edges1, setname='spline_1',return_setname=True)

	if len(edges1) == 1:
		edges1 = edges1[0]

	return edges1

def upper_text(obj):
	## VER: 2014-08-20, v1.0

	return get_text(obj).upper()

def create_dynamic_implicit_step(stepname='step1',prestep='',period=1.0, timePeriod=None, initial_inc=1e-7, min_inc=1e-10,
	max_inc=None, max_inc_num=1000, fix_inc=False, application='QUASI_STATIC',
	matrix_storage='UNSYMMETRIC', solution_technique='FULL_NEWTON'):
	## VER: 2015-04-01, v1.5
	## such as wire drawing process, or applying a velocity
	## max_inc_num表示该载荷步最多有多少个增量步,如果已经达到该数量，将不再计算，即不收敛。
	## 不能做热力耦合分析? ★★

##	create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='transient',matrix_storage='UNSYMMETRIC')

##	check_suitable_step(fn())

	stepname = new_key(_m.steps.keys(),stepname,force_new_key=True)		;please_check
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('**** No such prestep',prestep)

	if is_number(timePeriod):
		period = timePeriod

	if max_inc == None:
		max_inc = period/4

	_m.ImplicitDynamicsStep(name=stepname, description='implicit dynamics step', previous=prestep, timePeriod=period, initialInc=initial_inc, minInc=min_inc, maxNumInc=max_inc_num)

	matrix_storage = upper_text(matrix_storage)
	solution_technique = upper_text(solution_technique)
	application = upper_text(application)

	## application的类型：quasi_static准静态, Transient fidelity(保真), moderate dissipation(损耗，消散)
##	if application == 'QUASI_STATIC':   ## 准静态
	if 'STATIC' in application:  ## prefered for wire drawing.
		_m.steps[stepname].setValues(application=QUASI_STATIC, nohaf=OFF, amplitude=RAMP, alpha=DEFAULT, initialConditions=OFF)   ## initial condition is byPass(忽视)
	elif 'TRANSIENT' in application:   ## 运算速度非常慢，需要更多的增量步。
	## default load variation with time has been changed to instantaneous, initial acceleration calculation at beginning of step has been changed to allow.
		_m.steps[stepname].setValues(application=TRANSIENT_FIDELITY, nohaf=OFF, amplitude=STEP, alpha=DEFAULT, initialConditions=ON)
	elif 'DISSIPATION' in application:
		_m.steps[stepname].setValues(application=MODERATE_DISSIPATION, nohaf=OFF, alpha=DEFAULT, initialConditions=OFF)

	if matrix_storage == 'UNSYMMETRIC' and solution_technique != 'FULL_NEWTON':
		raise Exception('*** UNSYMMETRIC require FULL_NEWTON, or QUASI_NEWTON require SYMMETRIC.')

	if matrix_storage == 'SOLVER_DEFAULT':
		_m.steps[stepname].setValues(matrixStorage = SOLVER_DEFAULT)
	elif matrix_storage == 'SYMMETRIC':
		_m.steps[stepname].setValues(matrixStorage = SYMMETRIC)
	elif matrix_storage == 'UNSYMMETRIC':
		_m.steps[stepname].setValues(matrixStorage = UNSYMMETRIC)  ## 有时能加快求解(对于严重非线性的情形)

	if solution_technique == 'FULL_NEWTON':
		_m.steps[stepname].setValues(solutionTechnique=FULL_NEWTON)
	elif solution_technique == 'QUASI_NEWTON':
		_m.steps[stepname].setValues(solutionTechnique=QUASI_NEWTON)

	return stepname

def create_general_static_step(stepname='step1',prestep='',stable=True,period=1.0,timePeriod=None, initial_inc=1e-5, max_inc=None, min_inc=None, fix_inc=False,
	solver_method='DIRECT', matrix_storage='SOLVER_DEFAULT', solution_technique='FULL_NEWTON',restart=True,max_inc_num=1000):
	## VER: ('VER: 2016-04-05, v4.0')
	## restart is True by default. 并不会增加odb的大小。将生成.res文件。便于后面的import_initial_state()
	## matrix_storage = 'UNSYMMETRIC':  有时能加快求解(对于严重非线性的情形)
	## 最多允许有1000个增量步 max_inc_num

	global my_steps

##	create_general_static_step(stepname='expan')  ## step1
##	create_general_static_step(stepname='force')  ## step2,apply transverse load at high temperature


	## Example:
	## create_general_static_step(stepname='step1',solver='direct_unsymmetric',solution_technique='contact_iterations')	##但求解速度非常慢

##	check_suitable_step(fn())

	stepname = new_key(_m.steps.keys(),stepname,force_new_key=True)		;please_check
	if prestep in empty:
		prestep = _m.steps.keys()[-1]
	elif prestep not in _m.steps.keys():
		raise Exception('**** No such prestep',prestep)

##	add_model_description(' ')
	add_model_description('## stepname = ' + stepname)

	py_version = get_python_version()

	if is_number(timePeriod):
		period = timePeriod

	if max_inc == None:
		max_inc = period/4

	if min_inc == None:
		min_inc = period/1e5
		if min_inc > 1:
			min_inc = 0.001

	_m.StaticStep(description='static general step', name=stepname, nlgeom=ON, timePeriod=period, initialInc=period/1e3,
		minInc=min_inc, maxInc=max_inc, previous=prestep, maxNumInc = max_inc_num)

##_m.StaticStep(name=stepname, previous=prestep,
##    timePeriod=250.0, stabilizationMagnitude=0.0002,
##    stabilizationMethod=DISSIPATED_ENERGY_FRACTION,
##    continueDampingFactors=False, adaptiveDampingRatio=0.05, initialInc=0.01,
##    minInc=0.0025, maxInc=250.0, nlgeom=ON)

	if stable == True:  ## may also stable by damping
		_m.steps[stepname].setValues(stabilizationMagnitude=0.0002, stabilizationMethod=DISSIPATED_ENERGY_FRACTION,
		    continueDampingFactors=False, adaptiveDampingRatio=0.05)

	solver_method = get_text(solver_method).upper()
	matrix_storage = get_text(matrix_storage).upper()
	solution_technique = get_text(solution_technique).upper()

	if solution_technique == 'QUASI_NEWTON' and solver_method != 'DIRECT':
		raise Exception('DIRECT solver_method is required when solution_technique = QUASI_NEWTON')

	if solver_method == 'DIRECT ':
		_m.steps[stepname].setValues(matrixSolver = DIRECT)
	elif solver_method == 'ITERATIVE':
		_m.steps[stepname].setValues(matrixSolver = ITERATIVE)

	if matrix_storage == 'SOLVER_DEFAULT':
		_m.steps[stepname].setValues(matrixStorage = SOLVER_DEFAULT)
	elif matrix_storage == 'SYMMETRIC':
		_m.steps[stepname].setValues(matrixStorage = SYMMETRIC)
	elif matrix_storage == 'UNSYMMETRIC':  ## 有时能加快求解(对于严重非线性的情形)
		_m.steps[stepname].setValues(matrixStorage = UNSYMMETRIC)

	if solution_technique == 'FULL_NEWTON':
		_m.steps[stepname].setValues(solutionTechnique=FULL_NEWTON)
	elif solution_technique == 'QUASI_NEWTON':
		_m.steps[stepname].setValues(solutionTechnique=QUASI_NEWTON)


##	if solver == 'direct_solver_default' or solver == 'direct_user_solver_default':
##		_m.steps[stepname].setValues(matrixSolver=SOLVER_DEFAULT)
##	elif solver == 'direct_unsymmetric':	## 有时能加快求解
##		_m.steps[stepname].setValues(matrixSolver=DIRECT_UNSYMMETRIC)
##		print 'here'
##	elif solver == 'direct_symmetric':
##		_m.steps[stepname].setValues(matrixSolver=DIRECT_SYMMETRIC)
##	elif solver == 'iterative_symmetric':	## Error in connection to analysis
##		if solution_technique not in ['full_newton', 'quasi_newton']:
##			raise Exception('Solution_technique can only be full_newton or quasi_newton')
##
##		_m.steps[stepname].setValues(stabilizationMethod=NONE, continueDampingFactors=False, adaptiveDampingRatio=None,
##		    matrixSolver=DDM_ITERATIVE, applyContactIterations=False)

##	if stable == 'no':
##		_m.StaticStep(description=stepname, name=stepname, nlgeom=ON, initialInc=0.1, previous=prestep)
##	elif stable == 'yes':  ## default
##		_m.StaticStep(description=stepname, name=stepname, nlgeom=ON, timePeriod=period, initialInc=0.01, maxInc=max_inc, previous=prestep,
##			stabilizationMagnitude=0.0002,stabilizationMethod=DISSIPATED_ENERGY_FRACTION,
##			continueDampingFactors=False, adaptiveDampingRatio=0.05)		## good
##			continueDampingFactors=False, adaptiveDampingRatio=0.05, applyContactIterations=True, solutionTechnique=CONTACT_ITERATIONS)
##			continueDampingFactors=False, adaptiveDampingRatio=0.05, matrixSolver=DIRECT_UNSYMMETRIC)	##??****并未见加快求解

##	_m.steps[stepname].setValues(stabilizationMethod=NONE, continueDampingFactors=False, adaptiveDampingRatio=None,
##	    matrixSolver=DDM_ITERATIVE, applyContactIterations=False, solutionTechnique=FULL_NEWTON)

	step = _m.steps[stepname]
	my_steps[len(_m.steps) - 1] = {'procedureType': step.procedureType, 'domain': TIME, 'type': type_of(step), 'name': stepname,
		'function':'create_general_static_step'}

	if restart == True:
		_m.steps[stepname].Restart(frequency=1, numberIntervals=0, overlay=OFF, timeMarks=OFF)

	print fnln_fnln(),stepname,'is created, type=',type_of(_m.steps.values()[-1])
	print ' '

	if _m.fieldOutputRequests.keys() == ['F-Output-1']: ## Automaticaly created when created the first step
		del mdb.models[_m.name].fieldOutputRequests['F-Output-1']

##	print fnln(),len(_m.fieldOutputRequests.keys())
##	print fnln(),_m.fieldOutputRequests.keys()
##	raise Exception

	if _m.fieldOutputRequests.keys() in empty:
		field_output_request()  ## Do not use the system automatic created field output.

	return stepname

def create_step(stepname='step1',antype='stress',response='steady',timePeriod=1, scale=2000,interval=10, output_time_interval=0.02):
	## VER: 2016-10-29, v1.1   对于time_interval=0.02, time=1时，输出50个结果。
	## antype = stress(default), thermal_stress, temp, modal, explicit

	antype = antype.lower()
	if antype == 'stress':
		stepname = create_general_static_step(stepname=stepname,period=timePeriod)
	elif antype == 'temp':
		stepname = create_heat_transfer_step(stepname=stepname, response=response)
	elif antype == 'thermal_stress':
		stepname = create_coupled_temp_displacement_step(stepname=stepname)

##	elif antype == 'explicit':
##		stepname = create_dynamic_explicit_step(stepname=stepname, restart_interval=interval, scale_factor=scale)
##		name = new_key(_m.fieldOutputRequests,'field_output')
##		_m.fieldOutputRequests[name].setValues(variables=ALL, timeInterval=output_time_interval)	; please_check

		## timeInterval = EVERY_TIME_INCREMENT

##	add_model_description(' ')
##	save_user_data(antype)
##	add_model_description('## stepname = ' + stepname)
##	add_model_description(' ')

	return stepname

def is_surface(surf):
	## VER: 2014-08-17, v1.0

	result = False
	if surf in a.surfaces.keys() or surf in a.surfaces.values():
		result = True

	return result

function_labels['create_surface_of_nodes'] = 'element surface','nodal'
def create_surface_of_nodes(nodes,name='surf'):
	## VER: 2016-11-11, v1.0

##	>>> surf = create_surface_of_nodes(nodes)
##	--->Created nodal surface, name= surf , element faces= ['face3', 'face5']
##	>>> unlight()
##	>>> light(surf)

	if type_of(nodes) == 'STR':
		nodes,name = name,nodes

	nodes = tolist(nodes)
	poi = get_poi(nodes)

	if type_of(poi) == 'PINSTANCE':
		poi = a
	name = new_key(poi.surfaces.keys(),name)

	dict1 = facenum_elements_of_nodes(nodes)
	list1 = sort(dict1.keys())

##	if len(list1) == 1:
##		sequence = list2sequence(dict1[list1[0]])
##		exec('poi.Surface(' + list1[0] + 'Elements=sequence, name=name)')
	sides = []
	if len(list1) > 0:
		seqs = ''
		for i in range(len(list1)):
			face = list1[i]
			sides.append(face)
			seq = list2sequence(dict1[face])
			exec('seq' + str(i) + ' = seq')
			seqs = seqs + face + 'Elements= seq' + str(i) + ','

		exec('poi.Surface(' + seqs + 'name=name)')

	if sides not in empty:
		print '--->Created nodal surface, name=',name,', element faces=',sides
		surface = poi.surfaces[name]
	else:
		raise Exception('*** Fail to create the surface')

	return surface


def create_surface(name='surf',objs=None,faces=None,edges=None,elements=None, nodes=None, poi=None,side_num=1, side=None,info='',
	select_sym=False,face='',fine_angle=30,axis='',rough_angle=70,by_fine=True):
	## VER: 2016-11-11, v2.9  part也可以创建几何surface。对解析刚体，为side_num, 对其他为face_num
	## 检查surface的side正确与否的方法：在GUI左边的目录树中点击surfaces->具体的surface名，surface将被高亮(红色)。
	## use for interaction
	## surface is a region, not set like region, but surface like retion.
	## sequence + side = surface
	## 一个圆柱面shell，凹面的side_num=2, 凸面的side_num=1。三角形的insert模具的内侧也是side_num=2
	## please use get_surface_side() to confirm the surface side.

##	m_die = create_surface(die_A1,side_num=2)  ## side_num = 2，凹的一面
##	m_bpunch = create_surface(bpunch_A1,side='+z')  ## side_num = 2, 凹的一面
##	m_corepin = create_surface(corepin_A1,side_num=1)  ## 外侧

##	>>> surf = create_surface(nodes=nodes)
##	--->Created nodal surface, name= surf_pocket , element faces= ['face3']
##	>>> light(surf)

##	elems = element_select('p1',z=MAX,nz=1)
##	create_surface('surf-zmax',elements=elems,axis='z')  ## 成功，半径=30的上表面

##	elems = element_select('p1',x=MAX,nx=1)  ## USM insert
##	create_surface('surf-max',elements=elems,axis='x')

##	p.Surface(face3Elements=face3Elements, face4Elements=face4Elements,
##	    face5Elements=face5Elements, face6Elements=face6Elements, name='Surf-1')

##	>>> elems=set2objs('set1')
##	>>> create_surface(elements=elems)
##	p.Surface(face2Elements=face2,face3Elements=face3,name=name)
##	mdb.models['Model-1'].rootAssembly.surfaces['surf_powder']
##	>>>

	## Example:
	## 解析刚体
##	m_punch = create_surface(tpunch_A1,side='-y')
##	m_ejector = create_surface(bpunch_A1,side='+y')
##	m_die = create_surface(die_A1,side='-x')

##	edges = edge_select(case_A1,y=MID,nx=-1)
##	create_surface('case_ID',edges=edges)
##
##	edges = edge_select(nib_A1,nx=1)
##	create_surface('nib_OD',edges=edges)

	## 解析刚体
##	tpunch_surface = create_surface(tpunch_A1.edges,side='-y')
##	bpunch_surface = create_surface(bpunch_A1.edges,side='-y')
##	die_surface = create_surface(die_A1.edges,side='-y')

	## Example:
##	sfaces = face_select(punch_A1,nx=1,x=MAX1)
##	mfaces = create_surface(shell2_A1.faces, side='-x')
##	s2s_interact_std('right_face',mfaces=mfaces,sfaces=sfaces)

	## Example:
	## create_surface(punch_w_A1.edges, side_num=2)
	## create_surface('surf_tpunch',edges=_inst(tpunch_A1).edges, side_num=1)

##>>> create_surface(faces=f2, side='+x')
##--->surface Surf-2 is created, side_num = 2
##mdb.models['Model-1'].rootAssembly.surfaces['Surf-2']
##>>>

##	>>> create_surface(poi='tpunch_A1')
##	--->surface surf_tpunch_1 is created, side_num = 1
##	mdb.models['Model-1'].rootAssembly.surfaces['surf_tpunch_1']
##	>>>

##	>>> create_surface(poi='tpunch_A1')
##	--->surface surf_tpunch_1 is created, side_num = 1
##	mdb.models['Model-1'].rootAssembly.surfaces['surf_tpunch_1']
##	>>> create_surface(poi='tpunch_A1',side='-y')
##	['create_surface', 14431] vector= (-0.0, -1.0, 0.0) , side= -y
##	--->surface surf_tpunch_2 is created, side_num = 1
##	mdb.models['Model-1'].rootAssembly.surfaces['surf_tpunch_2']
##	>>>
##	>>> get_surface_side('surf_tpunch_1')
##	[SIDE1]
##	>>> get_surface_side('surf_tpunch_2')
##	[SIDE1]
##	>>>

	if is_inst(name):
		poi = check_inst(name)
		name = 'surf'

	objs = get_real_input(objs,faces,edges,elements,nodes)
	if objs in empty and type_of(name) != 'STR':
		objs = name
		name = 'surf'

	if is_surface(objs):
		objs = check_obj(objs,a.surfaces)
		return objs

	elif is_inst(objs):
		poi = check_inst(objs)
		objs = None

	elif type_of(objs) == 'STR':
		objs = set2objs(objs,poi)

	if objs in empty and is_inst(poi):
		poi = check_inst(poi)
		if len(poi.faces) > 0:
			if '2D' not in part_shape(poi)[-1]:   ## 对于2D, 一个shell part的faces不能建立surface
				objs = poi.faces
			else:
				raise Exception('*** Fail to create the surface.')

		elif len(poi.edges) > 0:
			objs = poi.edges
		else:
			raise Exception('**** faces or edges are required.')

	pois = get_pois(objs)
	poi_type = type_of(pois[0])
	if name == 'surf':
		if poi_type == 'PINSTANCE' and len(pois) == len(a.instances):
			name = 'surf_model'
		else:
			if len(pois) == 1:
				poi = pois[0]
				name1 = ''
				if type_of(poi) == 'PART':
					name1 = poi.name
				elif type_of(poi) == 'PINSTANCE':
					name1 = poi.partName
				name = 'surf_' + name1 + info
			else:
				name0 = 'surf_'
				pois1 = pois[:3]
				for poi in pois1:
					name0 = name0 + poi.name[:3]
					name0 = modify_string(name0,' ','_')
					name0 = modify_string(name0,'-','_')
					if name0[-1] != '_':
						name0 = name0 + '_'
				name = name0 + info

	if name[-1] == '_':
		name = name[:-1]

	if info != '':
		if info[0] == '_':
			name = name + info
		else:
			name = name + '_' + info

	type1 = type_of(objs)
	if type1 == 'SEQUENCE':
		sequence = objs
	else:
		objs = tolist(objs)
		sequence = list2sequence(objs,poi)

	obj_type = type_of(objs[0])
	if obj_type not in ['faces','edges','elements','nodes']:
		raise Exception('**** faces or edges or nodes are required.')

##	print fnln(),'side=',side,', obj_type=',obj_type

	if poi in empty:
		poi = get_poi(objs[0])

	if type_of(poi) == 'ASSEMBLY':
		poi = a
	else:
		poi = check_poi(poi)

		if type_of(poi) == 'PINSTANCE':
			poi = a

	name = new_key(poi.surfaces.keys(),name)

	if obj_type == 'elements':
		surface = elements_to_surface(elements=elements,name=name,select_sym=select_sym,face=face,fine_angle=fine_angle,axis=axis,rough_angle=rough_angle,by_fine=by_fine)
		return surface

	elif obj_type == 'nodes':
		surface = create_surface_of_nodes(nodes=objs,name=name)
		return surface

	if type_of(side) == 'STR' and side[-1] in ['x','y','z']:
		if side[0] not in ['+','-']:
			raise Exception('*** side should be such as +x, -x')

		if obj_type == 'faces':   ## 即使圆柱面也可能适用，如果是1/4面的话
			vector = None
			if side[-1] == 'x':
				for face in objs:
					vector1 = face.getNormal()
					if abs(vector1[0]) > 0.01:
						vector = vector1
						break
			elif side[-1] == 'y':
				for face in objs:
					vector1 = face.getNormal()
					if abs(vector1[1]) > 0.01:
						vector = vector1
						break
			elif side[-1] == 'z':
				for face in objs:
					vector1 = face.getNormal()
					if abs(vector1[2]) > 0.01:
						vector = vector1
						break
			if vector == None:
				raise Exception('*** The vector in ' + side + ' dose not match the vector direction comparasion.')

		elif obj_type == 'edges':
			vector = edge_to_vector(objs[0])
			vector = rotated_vector(vector)

		print fnln(),'vector=',vector, ', side=', side
		if same_axis_direction(vector, side):   ## 例如：vector= (-0.0, -1.0, 0.0)与side=-y是match的。
			side_num = 1	## Magenta [ma:ginta]
		else:
			side_num = 2	## Yellow
##	raise Exception

##	if poi in empty:
##		poi = get_poi(objs[0])

	p0 = get_poi(objs[0])
	if 'solid' in part_shape(p0)[1]:
		side_num = 1

##	if is_2D_or_3D() == '3D':
##		side_num = 1

	if type_of(side_num) == 'STR':
		side_num = side_num.lower()
		if side_num == 'magenta':
			side_num = 1
		elif side_num == 'yellow':
			side_num = 2

	if side_num not in [1,2]:
		raise Exception('**** Error side_num =' + str(side_num))


	if side_num == 2:
		name = name + '_side2'
	name = new_key(poi.surfaces.keys(),name)

	if obj_type == 'faces':
		if side_num == 1:
			surface = poi.Surface(side1Faces=sequence, name=name)
		elif side_num == 2:
			surface = poi.Surface(side2Faces=sequence, name=name)

	elif obj_type == 'edges':
		if side_num == 1:
			surface = poi.Surface(side1Edges=sequence, name=name)
		elif side_num == 2:
			surface = poi.Surface(side2Edges=sequence, name=name)

	print ' '
	print '--->surface',name,'is created, side_num =',side_num,'  1紫2红'

	return surface	## return surface object	## type_of(surface) = 'SURFACE'     ## surface region will be a.surfaces[name]

def create_symset(p,x='NA',y='NA',z='NA'):
	## 2011-01-07, v1.2

	if x != 'NA':
		faces = faces_of_cut(p,x=x)
		create_set(p, objs=faces, name='f_XSym',check_name=True)

	if y != 'NA':
		faces = faces_of_cut(p,y=y)
		create_set(p, objs=faces, name='f_YSym',check_name=True)

	if z != 'NA':
		faces = faces_of_cut(p,z=z)
		create_set(p, objs=faces, name='f_ZSym',check_name=True)

	print '--->Created symmmetry faces set for',p.name,'at x=',x,', y=',y,', z=',z

	return

def create_T_output(name,step='step1'):
	## VER: 2010-09-05, v1.0

	step = check_step(step)

	_m.FieldOutputRequest(name=name, createStepName=step, variables=('NT', 'TEMP', 'HFL', 'HFLA', 'HTL',
	    'HTLA', 'RFLE', 'RFL', 'HBF'))

	return

def cross_of_cell_and_space(poi,cell,space,mark_select=False):

	## VER: ('VER: 2012-08-17, v1.2')

	if type_of(cell) != 'cells':
		raise Exception('cell object is required.')

	faces = cell.getFaces()
	newlist = []
	for index in faces:
		face = poi.faces[index]
		x0,y0,z0 = face.getCentroid()[0]
		if not within_range(x0,space[0:2]):
			continue

		if not within_range(y0,space[2:4]):
			continue

		if not within_range(z0,space[4:6]):
			continue

		newlist.append(face)
	faces = newlist

	cross = False
	if faces not in empty:
		cross = True

		xlocs=[]
		ylocs=[]
		zlocs=[]
		indexs0 = []
		for face in faces:
			indexs = face.getVertices()
			for index in indexs:
				if index not in indexs0:
					indexs0.append(index)

		for index in indexs0:
			x0,y0,z0 = poi.vertices[index].pointOn[0]
			xlocs.append(x0)
			ylocs.append(y0)
			zlocs.append(z0)
		xlocs.sort()
		ylocs.sort()
		zlocs.sort()

		x1,x2 = xlocs[0],xlocs[-1]
		y1,y2 = ylocs[0],ylocs[-1]
		z1,z2 = zlocs[0],zlocs[-1]

		if equal(x1,x2) and (equal(x1,space[0]) or equal(x1,space[1])):
			cross = False
		elif equal(y1,y2) and (equal(y1,space[2]) or equal(y1,space[3])):
			cross = False
		elif equal(z1,z2) and (equal(z1,space[4]) or equal(z1,space[5])):
			cross = False

	return cross

def cross_of_faces_and_faces(faces1,faces2,p1=None,p2=None,fix='_',refined_insts='_',force_create=False,gap=None,method='simple'):
	## VER: ('VER: 2012-12-20, v1.7')
	## 本函数主要用于建立接触对，如果只是看是否有交集，也可参考cross_of_spaces()
	## caller = get_msface_and_msregion(), find_contacts()

	global msfaces_determined

	add_to_process()

	type1 = type_of(faces1)
	type2 = type_of(faces2)

	if type1 == 'STR' and p1 not in empty:
		faces1 = set2objs(p1,faces1)
	elif type1 == 'faces':
		faces1 = [faces1]

	if type2 == 'STR' and p2 not in empty:
		faces2 = set2objs(p2,faces2)
	elif type2 == 'faces':
		faces2 = [faces2]

	type1 = type_of(faces1[0])
	type2 = type_of(faces2[0])

	if type1 != 'faces' or type2 != 'faces':
		raise Exception('******faces required for faces1 or faces2.')

	if p1 in empty:
		p1 = get_poi(faces1)

	if p2 in empty:
		p2 = get_poi(faces2)

##	fix,refined_insts = check_fix_extend(p1=p1,p2=p2,fix=fix,refined_insts=refined_insts)

	## force_create和gap是一起的，主要用于法向
	if force_create == False:
		if gap not in empty:
			force_create = True

	plane_prop1 = plane_normal_and_offset(faces1[0])
	plane_prop2 = plane_normal_and_offset(faces2[0])

	offset1 = plane_prop1['offset']
	offset2 = plane_prop2['offset']

	normal1 = plane_prop1['normal']
	normal2 = plane_prop2['normal']

	cross = {}
	cross['no_cross'] = False
	cross[p1.name] = faces1
	cross[p2.name] = faces2

	if normal1 in ['x','y','z'] and normal2 in ['x','y','z']:
		## 法向
		if offset1 != offset2 or normal1 != normal2:	## 法线方向有gap
			cross['no_cross'] = True

			## 如果不返回，则所以的面都保留下来，即在法向上不进行refine
			if force_create == False or normal1 != normal2:
				return cross

		## inplane
		method = 'complex'
		faces1,faces2 = refine_faces_pair_inplane(faces1,faces2, refined_insts=refined_insts, fix=fix)
		if faces1 in empty or faces2 in empty:
			cross['no_cross'] = True
			return cross

	else:
		if is_cylind_faces(faces1):
			space1 = circular_space_of_faces(faces1)	;please_check
		else:
			space1 = objs_space(faces1)

		if is_cylind_faces(faces2):
			space2 = circular_space_of_faces(faces2)	;please_check
		else:
			space2 = objs_space(faces2)

		cross1 = cross_of_spaces(space1,space2)
		cross = collect_new_key(cross1,cross)   ## 此时cross中增加了faces1和faces2的信息。

		if cross['no_cross'] == True and force_create == False:   ##接触对将不被建立，也就不必要进行下面的refine了。
			return cross

	trace0 = get_traceback()[-2:];		trace0[0] = '  ' + trace0[0]
	msfaces_trace.append(trace0 + [p1.name + '_faces1',objs_num(faces1),p2.name + '_faces2',objs_num(faces2), 'ext=' + refined_insts,'fix=' + fix,'force=' + repr(force_create), 'method=' + method])

	if method == 'simple':
		faces1 = face_select(p1,faces=faces1,x=cross['cross_x'],y=cross['cross_y'],z=cross['cross_z'])   ## 如果某个方向上没有交集，则在该方向上不做另选。
		if len(faces1) == 0:
			cross['no_cross'] = True

		faces2 = face_select(p2,faces=faces2,x=cross['cross_x'],y=cross['cross_y'],z=cross['cross_z'])
		if len(faces2) == 0:
			cross['no_cross'] = True

	## 收集cross faces到各自的inst下
	cross[p1.name] = faces1
	cross[p2.name] = faces2

	please_check
	if len(faces1) > 0 and len(faces2) > 0:
		msfaces_determined = True

	return cross

def create_tabular_amplitude(name='Table_1',time_span='step',freq=None,circular_freq=None,
	magnitude=1, time_table=None,shape='sin', bias=None,cycle_num=2):
	## VER: ('VER: 2017-05-27, v1.3')
	## Edit该amplitude, 拷贝数据，直接粘贴到Origin中，可以plot出曲线来。
	## amplitude是该曲线的幅值，magnitude是该曲线要放大多少倍，一般为1倍。

##	>>> create_tabular_amplitude('lower press',time_table=[(0,0),(0.3,1)])  ## lower press step的time period为0.3
##	--->Created tabular amplitude, name= lower press
##	'lower press'
##	>>>

	## Example
##	tab_1 = create_tabular_amplitude(freq=freq,magnitude=1,shape='half-sin',bias='+')		;please_check

	name = new_key(_m.amplitudes.keys(),name,force_new_key=True)
##	if freq in empty and circular_freq in empty:
##		raise Exception('freq or circular_freq is required.')

	if time_span == 'step' or time_span == 'STEP':
		time_span = STEP  ## amplitude仅适用于所在的step time period
	elif time_span == 'total' or time_span == 'TOTAL':
		time_span = TOTAL

	if time_span not in [STEP,TOTAL]:
		raise Exception('time_span should be STEP or TOTAL')

	if is_number(freq):
		circular_freq = 2*pi*freq   ## circular_freq即ω，即圆频率。ω=2*pi*f  在create periodic type amplitude时，freq=1对应ω=6.28319
	elif is_number(circular_freq):
		freq = circular_freq/(2*pi)

	if is_number(freq):
		if shape in ['half-sin', 'half-cos']:
			freq = freq/2.0		## 此时的freq变成了full-sin相对应的frequence

		T = 1/freq   ## T是一个完整的周期。假如每秒一个半周期，且只有半周期，其实完整周期为2秒。
		print 'T=',T

	if 'sin' in shape:
		function = 'sin(2*pi*freq*time)'
	elif 'cos' in shape:
		function = 'cos(2*pi*freq*time)'
	else:
		if time_table in empty:
			raise Exception('function expression is required.')

##	>>> sin(pi/2)
##	1.0
##	>>> sin(2*pi*1/4) = 1   ## 1/4周期时有最大值。

	if time_table in empty or type_of(time_table) not in ['TUPLE','LIST']:
		time_table = []
		time = 0
		while time <= cycle_num*T:
			amp = eval(function)
			if bias == '+' and amp < 0:
				if shape == 'sin':
					amp = 0
				elif shape == 'half-sin':
					amp = -amp
			elif bias == '-' and amp > 0:
				if shape == 'cos':
					amp = 0
				elif shape == 'half-cos':
					amp = -amp

			point = (time,amp)
			time_table.append(point)
			time = time + 0.001

	else:
		time_table = totable(time_table)
		if type_of(time_table[0]) != 'TUPLE':
			raise Exception('Error table element format, should be one tuple.')
		if len(time_table) == 1:
			raise Exception('Not enough time_table data, only has one point')

	if magnitude != 1:
		new_table = []
		for point in time_table:
			A,B = point
			elem = (A,B*magnitude)	;please_check
			new_table.append(elem)
		time_table = new_table

	_m.TabularAmplitude(name=name, timeSpan=time_span, smooth=SOLVER_DEFAULT, data=totuple(time_table, open_element=False))

	print '--->Created tabular amplitude, name=',name,
	if is_number(freq):
		', shape=',shape
	else:
		print ' '

	return name

def cross_divide(p,cells=None,ndir='z', x=(),y=(),z=(),pass_x1y1z1=True,pass_opposite_x1y1z1=True, setname=None):
	## VER: 2011-11-24, v1.0, 适合对hole的周边进行divide. opposite_x1y1z1为x1y1z1的面内对角顶点

	p = check_part(p)
	if ndir not in ['x','y','z']:
		raise Exception('ndir should be x,y,or z')

	type1 = type_of(cells)
	if type1 == 'cells':
		cells = [cells]
	elif type1 == 'STR':
		cells = set2objs(p,cells)

	if cells in empty:
		cells = p.cells

	if setname == None:
		setname = 'Xcell'
	create_set(p,cells=cells,name=setname)

	x1,x2,y1,y2,z1,z2 = objs_space(cells,p)

	if x in empty:
		x = [x1,x2]

	if y in empty:
		y = [y1,y2]

	if z in empty:
		z = [z1,z2]

	x1,x2 = x
	y1,y2 = y
	z1,z2 = z

	## 请画六面体便可知道各个点
	if ndir == 'z':
		line1_p1 = (x1,y1,z1)   ## p1,p2: x,y的注脚相同
		line1_p2 = (x2,y2,z1)
		line1_p3 = (x2,y2,z2)	## p2和p3:仅差z

		line2_p1 = (x1,y2,z1)   ## p1,p2: x,y的注脚相反
		line2_p2 = (x2,y1,z1)
		line2_p3 = (x2,y1,z2)	## p2和p3:仅差z

	elif ndir == 'y':
		line1_p1 = (x1,y1,z1)	## p1,p2: x,z的注脚相同
		line1_p2 = (x2,y1,z2)
		line1_p3 = (x2,y2,z2)	## p2和p3:仅差y

		line2_p1 = (x1,y1,z2)	## p1,p2: x,z的注脚相反
		line2_p2 = (x2,y1,z1)
		line2_p3 = (x2,y2,z1)	## p2和p3:仅差y

	elif ndir == 'x':
		line1_p1 = (x1,y1,z1)	## p1,p2: y,z的注脚相同
		line1_p2 = (x1,y2,z2)
		line1_p3 = (x2,y2,z2)	## p2和p3:仅差x

		line2_p1 = (x1,y1,z2)	## p1,p2: y,z的注脚相反
		line2_p2 = (x1,y2,z1)
		line2_p3 = (x2,y2,z1)	## p2和p3:仅差x

	if pass_x1y1z1 == True:
		divide_by3points(p,line1_p1,line1_p2,line1_p3,cells=cells)

	if pass_opposite_x1y1z1 == True:
		cells = set2objs(setname,p)
		divide_by3points(p,line2_p1,line2_p2,line2_p3,cells=cells)

	return

function_labels['refine_faces_pair_inplane'] = 'contact','interact','tie','mate'
def refine_faces_pair_inplane(faces1,faces2,refined_insts='_',fix='_'):
	## VER: ('VER: 2016-10-25, v1.2')	## caller = refine_faces_pair_inplane()
	## faces1通常是base faces, faces2很可能是mate faces.
	## refined_insts相当于获得cross_space后，重新选择。

	global msfaces_trace

	add_to_process()

	please_check
	if faces1 in empty or faces2 in empty:
		return faces1,faces2

	inst1 = get_poi(faces1).name
	inst2 = get_poi(faces2).name

##	fix,refined_insts = check_fix_extend(p1=inst1,p2=inst2,fix=fix,refined_insts=refined_insts)

	if refined_insts == '_':
		print 'No need to refine faces.'
		return faces1,faces2

	faces1_prop = plane_normal_and_offset(faces1[0])
	normal1,offset1 = faces1_prop['normal'], faces1_prop['offset']
	if normal1 not in ['x','y','z']:
		print 'Only refine faces with normal in x,y,z.'
		return faces1,faces2

	faces2_prop = plane_normal_and_offset(faces2[0])
	normal2,offset2 = faces2_prop['normal'], faces2_prop['offset']
	if normal2 not in ['x','y','z']:
		print 'Only refine faces with normal in x,y,z.'
		return faces1,faces2

	if normal1 != normal2:
		print '**normal1 != normal2. Cannot refine the faces.'
		return faces1, faces2

	ndir = normal1

	x01,x02,y01,y02,z01,z02 = objs_space(faces1)
	x1,x2,y1,y2,z1,z2 = objs_space(faces2)
	cross_x0 = cross_of_ranges((x01,x02),(x1,x2))['range']
	cross_y0 = cross_of_ranges((y01,y02),(y1,y2))['range']
	cross_z0 = cross_of_ranges((z01,z02),(z1,z2))['range']

##	cross_x0 = cross_x['range']
##	cross_y0 = cross_y['range']
##	cross_z0 = cross_z['range']

##	cross_x1 = [cross_x0[0] - 2, cross_x0[1] + 2]
##	cross_y1 = [cross_y0[0] - 2, cross_y0[1] + 2]
##	cross_z1 = [cross_z0[0] - 2, cross_z0[1] + 2]

	if inst1 in refined_insts:
		if ndir == 'z':
			faces1 = face_select(inst1,faces=faces1, x=cross_x0,y=cross_y0)  ## 在原有基础上选择
		elif ndir == 'x':
			faces1 = face_select(inst1,faces=faces1, y=cross_y0, z=cross_z0)
		elif ndir == 'y':
			faces1 = face_select(inst1,faces=faces1, x=cross_x0, z=cross_z0)

	if inst2 in refined_insts:
		if ndir == 'z':
			faces2 = face_select(inst2,faces=faces2, x=cross_x0,y=cross_y0)
		elif ndir == 'x':
			faces2 = face_select(inst2,faces=faces2, y=cross_y0,z=cross_z0)
		elif ndir == 'y':
			faces2 = face_select(inst2,faces=faces2, x=cross_x0,z=cross_z0)


##	if ndir == 'z':
##		if inst1 not in fix:  ## 不固定，意味着可以调整
##			if inst1 in refined_insts:   ##要调整，说明要重新选择
##				faces1 = faces_of_cut(inst1,x=cross_x1,y=cross_y1,z=offset1)   	## 重新选择，且范围边框了，上下+/- 2
##
##			else:
##				faces1 = face_select(inst1,faces=faces1, x=cross_x0,y=cross_y0)  ## 在原有基础上选择
##
##		if inst2 not in fix:
##			if inst2 in refined_insts:
##				faces2 = faces_of_cut(inst2,x=cross_x1,y=cross_y1,z=offset2)
##
##			else:
##				faces2 = face_select(inst2,faces=faces2, x=cross_x0,y=cross_y0)
##
##	elif ndir == 'x':
##		if inst1 not in fix:
##			if inst1 in refined_insts:
##				faces1 = faces_of_cut(inst1,y=cross_y1,z=cross_z1,x=offset1)
##
##			else:
##				faces1 = face_select(inst1,faces=faces1, y=cross_y0, z=cross_z0)
##
##		if inst2 not in fix:
##			if inst2 in refined_insts:
##				faces2 = faces_of_cut(inst2,y=cross_y1,z=cross_z1,x=offset2)
##
##			else:
##				faces2 = face_select(inst2,faces=faces2, y=cross_y0,z=cross_z0)
##
##	elif ndir == 'y':
##		if inst1 not in fix:
##			if inst1 in refined_insts:
##				faces1 = faces_of_cut(inst1,x=cross_x1,z=cross_z1,y=offset1)
##
##			else:
##				faces1 = face_select(inst1,faces=faces1, x=cross_x0, z=cross_z0)
##
##		if inst2 not in fix:
##			if inst2 in refined_insts:
##				faces2 = faces_of_cut(inst2,x=cross_x1,z=cross_z1,y=offset2)
##
##			else:
##				faces2 = face_select(inst2,faces=faces2, x=cross_x0,z=cross_z0)

##	trace0 = get_traceback()[-2:];		trace0[0] = '      ' + trace0[0]
##	msfaces_trace.append(trace0 + [inst1 + '_faces1',objs_num(faces1),inst2 + '_faces2',objs_num(faces2), 'dir1=x', 'cross_x', cross_x0, 'ext=' + refined_insts])

	return faces1, faces2

def cross_of_faces_and_inst(faces,inst):

	## VER: ('2012-08-08, v2.1')
	## caller = side1_faces_to_pair, (find method)

	if type_of(faces) == 'PINSTANCE':
		faces,inst = inst,faces

	faces = tolist(faces)
	if faces in empty:
		raise Exception('faces are required.')
	if type_of(faces[0]) != 'faces':
		raise Exception('faces are required.')

	inst_faces = get_poi(faces[0])
	inst = check_inst(inst)

	space_faces = objs_space(faces)
	space_inst = poi_space(inst)

	print ' '
	print '---'
	print 'checking cross between faces from', inst_faces.name,'and inst=',inst.name
	cross = cross_of_spaces(space_faces,space_inst)
	if cross['no_cross'] == True:
		print fnln_fnln(),'******No cross. cross=',cross
		return cross

	space = cross['cross_space']

	cells2 = cell_select_by_container(inst,space=space)
	if cells2 in empty:
		cross['no_cross'] = True

	return cross

def cross_of_pois(poi1,poi2):
	## VER: 2014-06-27, v1.0

	poi1 = check_poi(poi1)
	poi2 = check_poi(poi2)

	space1 = poi_space(poi1)
	space2 = poi_space(poi2)

	cross = cross_of_spaces(space1,space2)

	myprint(cross)

	return cross

def cross_of_ranges(range1=(),range2=(),err=1e-4):
	## VER: 2014-08-11, v1.9, 如果有交集，则range中的上下限分别来自range1,range2
	## if length <= err, then length=0

	if type_of(range1) in ['FLOAT','INT']:
		range1 = [range1,range1]

	if type_of(range2) in ['FLOAT','INT']:
		range2 = [range2,range2]

	range1 = tolist(range1)
	range2 = tolist(range2)

	range1.sort()
	range2.sort()

	v11,v12 = range1
	v21,v22 = range2

	list1 = [range1[0],range1[1],range2[0],range2[1]]
	list1.sort()

	range0 = [list1[1],list1[2]]
	length = round(list1[2] - list1[1], 6)

	please_check
	if length <= err:  ## 0.1um, origin: 1e-6    ## for example, (39.999,40) and (40,40): length=0
		length = 0

	if within_range(list1[1],range1) == False:   ## list1[1]属于range2. range2偏小
		length = -length
		range0 = [list1[2],list1[1]]
	elif within_range(list1[1],range2) == False:
		length = -length
	elif within_range(list1[2],range1) == False:
		length = -length
	elif within_range(list1[2],range2) == False:
		length = -length
		range0 = [list1[2],list1[1]]

	touch = False
	if length == 0:
		if PK(v11,v22) == 0 or PK(v12,v21) == 0:
			touch = True

	dict1 = {'length':length, 'range':range0, 'touch':touch}

	return dict1

def cross_of_spaces(space1,space2,mark_select=False):
	## VER: ('VER: 2012-12-18, v2.6')

	## if cross['gap_dir'] 非空，则没有交集
	## if cross['touch_dir']非空，为touch

	if len(space1) != 6 or len(space2) != 6:
		raise Exception('Tuple or list with 6 location elements is required, such as (x1,x2,y1,y2,z1,z2). line=3666, cross_of_spaces().')   ## **********

##	print '  in cross_of_spaces(), caller=',caller_fnln()

	gap_dir = []
	touch_dir = []

	x11,x12,y11,y12,z11,z12 = space1
	x21,x22,y21,y22,z21,z22 = space2

	cross_x = cross_of_ranges(space1[0:2],space2[0:2])
##	print '     cross_x=',cross_x
	if cross_x['length'] < -1e-6:
		gap_dir.append(0)
	elif cross_x['touch'] == True:
		touch_dir.append(0)

	cross_y = cross_of_ranges(space1[2:4],space2[2:4])
##	print '     cross_y=',cross_y
	if cross_y['length'] < -1e-6:
		gap_dir.append(1)
	elif cross_y['touch'] == True:
		touch_dir.append(1)

	cross_z = cross_of_ranges(space1[4:6],space2[4:6])
##	print '     cross_z=',cross_z
	if cross_z['length'] < -1e-6:
		gap_dir.append(2)
	elif cross_z['touch'] == True:
		touch_dir.append(2)

	if mark_select == False and len(touch_dir) >= 2:			##???****
		gap_dir = gap_dir + touch_dir
		touch_dir = []

	cross_dir = unselect([0,1,2],gap_dir)

	cross = {0:cross_x,
				1:cross_y,
				2:cross_z,
				'touch_dir': touch_dir,
				'gap_dir':gap_dir,
				'cross_dir':cross_dir,
				'no_cross':False}

	if cross['gap_dir'] not in empty:
		cross['no_cross'] = True

	cross['cross_space'] = ()
	if len(cross_dir) == 3:
		cross['cross_space'] = cross_x['range'] + cross_y['range'] + cross_z['range']  ## 增加新的key

	if 0 in cross_dir:
		cross['cross_x'] = cross_x['range']
	else:
		cross['cross_x'] = ()

	if 1 in cross_dir:
		cross['cross_y'] = cross_y['range']
	else:
		cross['cross_y'] = ()

	if 2 in cross_dir:
		cross['cross_z'] = cross_z['range']
	else:
		cross['cross_z'] = ()

	return cross

def select_by_expand_faces(faces0,axis=None,include_itself=True,angle=None):
	## VER: 2016-04-16, v1.2

##	faces = face_select('botbush_A1',D=bush_ID)
##	faces1 = select_by_expand_faces(faces,angle=80)   ## will connect adjacent conical faces

	faces0 = tolist(faces0)
	if faces0 in empty or type_of(faces0[0]) != 'faces':
		raise Exception('*** a face is required.')

	faces01 = []
	for face in faces0:
		faces = face.getAdjacentFaces()  ## face is not included in faces
		faces = tolist(faces)

		if axis in ['x','y','z']:
			faces1 = []
			for face0 in faces:
				if parallel_to_axis(face0,axis=axis) == True:
					faces1.append(face0)
			faces = faces1

		if include_itself == True:
			faces.append(face)

		if is_number(angle):
			faces2 = connect_all_faces(face,angle=angle)
			faces = get_common(faces,faces2)

		faces01 = faces01 + faces

	faces = remove_repeated_items(faces01)

	return faces

def connect_all_faces(face,angle=20):
	## VER: 2013-11-11, v1.0, select faces by angle
	## 可以利用该方法通过简单的面寻找到其他的面。
	## can be used in face_select()
	## faces = face_select('diamond_A1',y=(MAX,MAX1),connect_faces=True,include_ends=True)
	## reference: select_by_expand_faces() only connect adjacent faces

	if type_of(face) != 'faces':
		raise Exception('*** a face is required.')

	faces = face.getFacesByFaceAngle(angle)
	faces = tolist(faces)   ## face is included in faces

	return faces

def create_line_then_circle(sketch,loc0,tangent_angle,radius,center_x=None,center_y=None,fix_x=None,fix_y=None, center_line=None,toX=None,toY=None,toCurve=None,side=None):
	## VER: 2015-04-20, v1.1 注意，切点是待定的，即使在图纸上标明切点位置也是粗略的。

	global last_point

	## Example: 两条语句即可建立Nib的草图
##	s1 = create_base_sketch('sk_nib')
##	loc0 = (bearing_D/2.0, exit_dy)
##	loc1 = create_line_then_circle(s1,loc0,tangent_angle=90 - reduction_angle/2, radius=approach_R,center_x='+',center_y=nib_H - approach_center_to_top, toY=nib_H,fix_y=True)
##	connect_points(s1,loc0,ytilt(-exit_dy,exit_angle/2),('x',nib_diameter/2),('y',nib_H),loc1)


##	line1 = slope_construction(s1,loc=loc0,angle=90 - reduction_angle/2)
##	dict1 = create_tangent_circle(s1,radius=approach_R,center_x='+', center_y=nib_H - approach_center_to_top,tangent_line=line1, toY=nib_H,fix_y=True)
##	connect_points(s1,loc0,dict1['tangent_loc'])

	s1 = check_sketch(sketch)
	line1 = slope_construction(s1,loc=loc0,angle=tangent_angle)
	dict1 = create_tangent_circle(s1,radius=radius,tangent_line=line1, center_x=center_x,center_y=center_y,fix_x=fix_x, fix_y=fix_y, center_line=center_line, toX=toX, toY=toY, toCurve=toCurve,side=side)
	connect_points(s1,loc0,dict1['tangent_loc'])

	last_point = dict1['end']

	return	dict1['end']

def connect_points(sketch,*points,**options):
	## VER: 2016-07-11, v2.8, will create global variable: last_point
	## use hide_grid() to see the points and construction line
	## ## return the connected locs in sequence.
	## 注意，只适用于xoy平面的草图，否则可能有误。

	## 下面这两行等效
##	connect_points(s1,loc0,('x',nib_R2),('y',nib_y2),('x',nib_R1),loc0)
##	connect_points(s1,loc0,[nib_R2],nib_y2,[nib_R1],loc0)  ## [x],y的形式

	## 下面两句话是等效的。
##	connect_points(s1,loc0,y1,x1,y2,x2,y3,x3,y4,loc1,xytilt3(start=loc1,y=y5,Ay=mid_y_angle),x5,y6,loc0)  ## loc1是一个重复的参数
##	connect_points(s1,loc0,y1,x1,y2,x2,y3,x3,y4,xytilt3(start=loc1,y=y5,Ay=mid_y_angle),x5,y6,loc0)

##	test code for ndir == 'x':
##	s1 = create_part_sketch('pin1',name='sk_pin1',ndir='x',offset=10)
##	partname = s1['partname']
##	loc0 = (10,0,0)
##	loc1 = (10,5,0)
##	loc2 = (10,5,1)
##	loc3 = (10,0,1)
##	locs = connect_points(s1,loc0,loc1,loc2,loc3,loc0,ndir='x')
##	print locs	## [(0, 0), (5, 0), (5, 1), (0, 1), (0, 0)]  ## element = (y0,z0)而不是(z0,y0)
##	pin = revolve_sketch_to_part(partname,sketch=s1,angle=360,axis='x')

	## test code for ndir == 'y':
##	s1 = create_part_sketch('pin2',name='sk_pin1',ndir='y',offset=0)
##	partname = s1['partname']
##	loc0 = (0,0,0)
##	loc1 = (10,0,0)
##	loc2 = (10,0,1)
##	loc3 = (0,0,1)
##	locs = connect_points(s1,loc0,loc1,loc2,loc3,loc0)
##	print locs  ## [(0, 0), (10, 0), (10, 1), (0, 1), (0, 0)]  ## element = (x0,z0)而不是(z0,x0)
##	pin = revolve_sketch_to_part(partname,sketch=s1,angle=360,axis='V')

##	lines2 = connect_points(s1,(0,0),ytilt(-relief_dy,relief_angle/2),ytilt(-exit_dy,exit_angle/2),{'H':nib_thick},lines1[-1])

	## create rectangle sketch
##	connect_points(s1,(case_OD_x/2, case_OD_y/2),('x',-case_OD_x/2),('y',-case_OD_y/2),('x',case_OD_x/2),('y',case_OD_y/2))

	## Example
	## connect_points('s_ejector1',loc,{'2H':MIN},{'2V':MIN})  ## 使用匿名数值
##	connect_points(s,point2,(punch_D/2,0), 'V=-punch_D','H=-punch_D/2',point1,punch_D=punch_D)

##	point1,point2,arc1 = create_arc(s,center=(0,0),radius=rod_cave_radius,quarter=4)  ## do not automatically trimed rectangle.
##	connect_points(s,point2,(punch_D/2,0), 'dH=2', punch_D=punch_D)

##	points = connect_points('s_punch',(2,0),(0,0),{'DH':-punch_land},{'DT':(-dx1,tip_height)}, {'DT':(-dx2,tilt_H)},(-punch_D/2,punch_depth))

	## extend sketch:
##	connect_points('sk_tpunch','ymin',(dy,-1))
##	connect_points('sk_ejector','xmax',(dx,0.5))
##	connect_points('sk_bpunch','xmax',(dx,0.5))

##	locs = loc0,('x',case_ID/2),('dy',nib_H + rivet_offset),('dx',-rivet_L),('dy',rivet_H),('dx',rivet_L)
##	connect_points(s1,points=locs[:3])  ## 好处是输入不同的片段来观察连线过程。

##	locs = locs_of_sketch(green_sketch,x=MIN,pointOn=True)
##	connect_points(green_sketch,locs)


	global last_point, last_line

	if type_of(sketch) == 'DICT':
		sketch0 = sketch
		sketch = sketch0['sketch']
		ndir = sketch0['ndir']
	else:
		sketch = check_sketch(sketch)

##	print type_of(sketch)
##	sketch = check_sketch(sketch)
##	print type_of(sketch)
##	raise Exception

	if 'points' in options.keys():
		points = options['points']

	if 'ndir' not in locals().keys():
		if 'ndir' in options.keys():
			ndir = options['ndir']
		else:
			ndir = 'z'

	ndir = ndir.lower()
	if ndir not in ['x','y','z']:
		raise Exception('*** ndir of the sketch should be x,y, or z')

	## 把一个list装入到括号中
	if len(points) == 1 and type_of(points[0]) == 'LIST': ## 如果是tuple，可能是位置
		points = points[0]

	caller_code = get_caller_code()
	loc = caller_code.find(',')
	caller_code = caller_code[loc+1:].strip()

	add_last = False
	if len(points) == 1:
		if caller_code.startswith('xytilt'): ## 例如: connect_points(s1,xytilt3(start=loc0,y=y1,Ay=10))
			if type_of(points[0]) == 'LIST' and len(points[0]) == 2:
				points = points[0]
		else:
			if type_of(points[0]) in ['TUPLE','LIST'] and is_number(points[0][0]) == False:  ## 例如：connect_points(s1,locs)
				points = points[0]

	newlist = []
	for point in points:
		if type_of(point) in ['TUPLE','LIST'] and len(point) == 2 and is_location(point[0]) and type_of(point[1]) == 'DICT':
			newlist.append(point[0])
			newlist.append(point[1])
		else:
			newlist.append(point)
	points = newlist

	if is_location(points[0]) == False or len(points) == 1:  ## 例如: connect_points(s1,{'Y':5})
		if 'last_point' in globals().keys() and is_location(last_point):
			pts = [last_point]
			for item in points:
				pts.append(item)
			points = pts
		else:
			raise Exception('*** global last_point not provided.')

	print fnln(),'points=',points

	points1 = []
	k = 0
	for i in range(len(points)):
		k += 1
		point = points[i]
		num0 = len(points1)

		if len(points1) > 2 and points1[-1] == points1[-2]:
			points1.pop()	## remove repeated item (dx,dy) = (0,0)

##		if k == 3:
##			print fnln(),point
##			print fnln(),'ndir=',ndir
##			raise Exception

		if is_number(point):
			point = ('Y',point)
		elif type_of(point) == 'LIST' and len(point) == 1 and is_number(point[0]):  ## 例如:[5]表示x=5 中括号
			point = ('X',point[0])

		type1 = type_of(point)
		if is_location(point) == True:
			if len(point) == 3:   ## 草图中的坐标只有两个
				x0,y0,z0 = point
				if ndir == 'x':
					point = (y0,z0)
				elif ndir == 'y':
					point = (x0,z0)
				elif ndir == 'z':
					point = (x0,y0)

			points1.append(point)   		## provide the coords, assume to be absolute.

		elif type1 == 'vertices':
			points1.append(point.coords)  ## 草图中的点
		elif type1 == 'STR':
			point1 = point.lower()
			loc = ()
			if point1 == 'xmax':
				loc = find_loc(sketch,x=MAX)
			elif point1 == 'xmin':
				loc = find_loc(sketch,x=MIN)
			elif point1 == 'ymax':
				loc = find_loc(sketch,y=MAX)
			elif point1 == 'ymin':
				loc = find_loc(sketch,y=MIN)

			if is_location(loc):
				points1.append(loc)
			else:
				raise Exception('*** fail to get the location for ' + point1)

		else:
			if type1 == 'TUPLE' and len(point) == 2:
				if type_of(point[0]) == 'STR':
					point = {point[0]:point[1]}
					type1 = 'DICT'

			if type1 != 'DICT':
				raise Exception('*** a dict is required, indicating target (x,y) or (dx,dy)')

			x0,y0 = points1[-1]		## last_point
			if len(point) == 1:
				var = point.keys()[0]
				data = point[var]
				var = var.upper()

				## finally format to: 2H, 2V, DH, DV, DT
				please_check
				if var in ['H','X']:  ## 相当于提供了标准尺寸
					var = '2H'
				elif var in ['V','Y']:
					var = '2V'
				elif var == 'DX':
					var = 'DH'
				elif var == 'DY':
					var = 'DV'
				elif var == 'T':
					var = 'DT'

				if var[-1] == '=':
					var = var[:-1]

				if var == 'DH':
					x1 = x0 + data
					y1 = y0
					points1.append((x1,y1))

				elif var == '2H':
					data = real_xy_sketch(sketch,x=data,Xonly=True)
					x1 = data
					y1 = y0
##					print fnln(),(x1,y1)
					points1.append((x1,y1))

				elif var == 'DV':
					x1 = x0
					y1 = y0 + data

##					if ndir != 'y':
##						y1 = y0 + data
##					else:
####						y1 = y0 - data
##						y1 = y0 + data	;please_check  ## 错误

					points1.append((x1,y1))

				elif var == '2V':
					data = real_xy_sketch(sketch,y=data,Yonly=True)
					x1 = x0
					y1 = data
					points1.append((x1,y1))

				elif var == 'DT':
					x1 = x0 + data[0]
					y1 = y0 + data[1]

##					if ndir != 'y':
##						y1 = y0 + data[1]
##					else:
####						y1 = y0 - data[1]  ## 坐标值上该变大就变大。
##						y1 = y0 + data[1]  ## 错误

					points1.append((x1,y1))

				elif var == '2T':
					data = real_xy_sketch(sketch,loc=data)
					x1 = data[0]
					y1 = data[1]
					points1.append((x1,y1))

			elif len(point) == 2:
				x1 = None	;	y1 = None
				if 'x' in point.keys():
					x1 = real_xy_sketch(sketch,x=point['x'],Xonly=True)
				elif 'dx' in point.keys():
					x1 = x0 + point['dx']

				if 'y' in point.keys():
					y1 = real_xy_sketch(sketch,y=point['y'],Yonly=True)
				elif 'dy' in point.keys():
					y1 = y0 + point['dy']

				if 'angle' in point.keys():
					angle = point['angle']   ## angle的正负就决定了增量的正负。
					if x1 not in empty and y1 in empty:
						y1 = y0 + abs((x1 - x0))*tanD(angle)
					elif y1 not in empty and x1 in empty:
						x1 = x0 + abs((y1 - y0))*tanD(angle)

				if x1 in empty or y1 in empty:
					raise Exception('*** x1 and y1 are all required for slope line.')

				points1.append((x1,y1))

		num1 = len(points1)
		if num1 > num0:
			last_point = points1[-1]   ;please_check
			print fnln_fnln(),'last_point=',last_point

	locs = points1
	num = len(locs)

##	print locs
##	raise Exception

	if num > 1:
		for i in range(num - 1):
			sketch.Line(point1 = locs[i], point2 = locs[i+1])
		last_line = sketch.geometry.keys()[-1]

##	print fnln(),'locs=',locs
	last_point = points1[-1]

	return points1  ## 返回的是草图坐标(可直接用于后面的round_sketch_corner()等。return the connected locs in sequence.

##p_ = connect_points

def connect_angle_of_edges(edge1,edge2,vertice=None):
	## 2016-06-20, v1.0

	# >>> connect_angle_of_edges(e1,e3)
	# 0
	# >>> connect_angle_of_edges(e1,e2)
	# 3.5561
	# >>>

	vertices1 = edges_to_vertices(edge1)
	vertices2 = edges_to_vertices(edge2)
	vertices = get_common(vertices1,vertices2)

	if type_of(vertice) == 'vertices':
		if vertice not in vertices:
			raise Exception('*** vertice is not the connected vertice of edge1 and edge2.')
	else:
		if len(vertices) == 0:  ## 没有交点
			angle = 9999
			return angle
		elif len(vertices) == 2:  ##两头链接成环
			angle = 0  ## a loop
			return angle

		vertice = vertices[0]

	vector1 = tangent_vector_of_edge(edge1,vertice)
	vector2 = tangent_vector_of_edge(edge2,vertice)
	angle = vector_angle(vector1=vector1,vector2=vector2)

	return angle

def connect_edges(edges, startpoint, edge1):
	## VER: 2014-07-11, v1.0
	## 也可以用edge.getAdjacentEdges()

	edges = tolist(edges)
	if type_of(edge1) == 'vertices' and type_of(startpoint) == 'edges':
		startpoint,edge1 = edge1, startpoint

	if type_of(edge1) != 'edges':
		raise Exception('*** an edge is required as start edge.')

	if type_of(startpoint) != 'vertices':
		raise Exception('*** a vertice is required as start point.')

	if edge1 not in edges:
		raise Exception('*** edge1 not inside edges.')

	edges = unselect(edges, edge1)
	vertices = edges_to_vertices(edge1)
	vertices = unselect(vertices, startpoint)

	if len(vertices) != 1:
		raise Exception('*** cannot find the end point')

	endpoint = vertices[0]

	newlist = [edge1]
	while len(edges) > 0:
		for edge in edges:
			vertices = edges_to_vertices(edge)
			if endpoint in vertices:
				vertices = unselect(vertices, endpoint)

				if len(vertices) != 1:
					raise Exception('*** cannot find the end point')

				endpoint = vertices[0]
				newlist.append(edge)
				edges.remove(edge)
				break

	indexs = objs2index(newlist)

	return indexs


def consum():
	## VER: 2011-03-08, v1.0

	global conts

	list_contacts()
	for i in conts.keys():
		cshow(i)

	return

def cross_section_plot(ndir):
	## VER: 2012-10-24, v1.0	根据不同的截面法向，选择合适的视图来观察该截面（即sketch)

	vpnow = get_vpnow()
	if ndir == 'z':
		vpnow.view.setValues(session.views['Front'])
		print 'See from Front view.'
	elif ndir == 'x':
		vpnow.view.setValues(session.views['Left'])
		print 'See from Left view.'
	elif ndir == 'y':
		vpnow.view.setValues(session.views['Bottom'])
		print 'See from Bottom view.'

	return

def cross_set_mat(p,cells=None,mat=None,mat_old=None,subset=None,bigset=None):
	## VER: 2016-10-23, v1.7, reference: objs_of_material()

	global mat_lib

	p = check_part(p)

	if type_of(mat) == 'LIST' and type_of(cells) == 'STR':
		cells,mat = mat,cells

	cells = tolist(cells)
	if cells in empty:
		if mat_old not in empty:
			cells = set2objs(p,mat_old)
		else:
			cells = tolist(p.cells)

##	if mat not in mat_lib:
	if mat not in _m.materials.keys():
##		raise Exception('******No such material: mat=' + mat)
		create_material(mat)

	if subset in empty:
		subset = mat

	if subset not in empty and subset != mat:
		if not mat_lib.has_key(subset):
			if mat_lib.has_key(mat):
				mat_lib[subset] = mat_lib[mat]
			else:
				raise Exception('******No such material in mat_lib: mat=' + mat + ', line=8770, set_mat()')

##	>>> prettyPrint(_part(compound).sectionAssignments)
##	['SectionAssignment object',
##	 'SectionAssignment object',
##	 'SectionAssignment object',
##	 'SectionAssignment object']
##	>>>
##	>>> prettyPrint(_m.sections.values()[0])
##	({'material': 'Al_6063',
##	  'name': 'Al_6063_sec',
##	  'thickness': 1.0})
##	>>>

	if len(cells) > 0:
		for section in p.sectionAssignments:   ## a list
			sectionName = section.sectionName
			mat_old = _m.sections[sectionName].material
##			print 'new mat=',mat,', sectionName=',sectionName
			setname = section.region[0]
			cells0 = set2objs(p,setname)	## 原有材料
			if have_common(cells,cells0):
				i = get_sequence_index(p.sectionAssignments, section)
				cells0 = unselect(cells0,cells)		## 原有材料被新材料抢走一部分甚至全部cells
				globals()['cells0'] = cells0
				if len(cells0) > 0:
##					region0 = list2region(cells0)
					region0 = create_set(p,objs=cells0,setname=mat_old)
					p.sectionAssignments[i].setValues(region=region0)  ##对原有材料重新定义
				else:
					del p.sectionAssignments[i]
					print fnln_fnln(),'Original material section',sectionName,'deleted.'

		for setname in p.sets.keys():
			if type_of_set(p,setname) == 'cells':
				cells0 = set2objs(p,setname)
				cells1 = unselect(cells0, cells)   ## 从原有set中排除新材料所占的cells。
				if len(cells1) > 0 and cells1 != cells0:
					create_set(p,objs=cells1,name=setname,check_name=False)		##对所有的被交叉的cell set都重新定义一遍
				elif cells1 in empty:
					del p.sets[setname]

		## 新材料
##		sec_name = mat_lib[mat] + '_sec'
##		sec_name = mat2section(mat)
		sec_name = mat + '_sec'
		p.SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE, region=cells, sectionName=sec_name, thicknessAssignment=FROM_SECTION)
		a.regenerate()
		p.regenerate()

		print fnln_fnln(),'--->Cells are applied as new material',mat

		if mat != p.name:
			if mat in p.sets.keys():
				cells1 = cells + set2objs(mat,p)
			else:
				cells1 = cells
			create_set(p, objs=cells1, name=mat,check_name=False)

		if subset != mat and subset != p.name:
			create_set(p, objs=cells, name=subset,check_name=False)

		if type_of(bigset) == 'STR' and bigset != mat and bigset != p.name:
			add2set(p,cells=cells,setname=bigset)

	else:
		print fnln_fnln(),'****** Empty cells, not applied material',mat
		error_record('set_mat()')

	return

def cshow(seq=None,inst='ms',full=False):
	## VER: ('VER: 2014-09-14, v3.5')

	global mdg,sdg, conts, plot_history    ## conts obtained in list_contacts()

	unlight()

	if seq == None or 'conts' not in globals().keys():
		list_contacts()

		cont_sum = []
		for inst in a.instances.values():
			cont_sum = cont_sum + contacts_of_pois(inst,printResult=False)
		print 'Contacts summary: Format=[inst_name,cont_num/inst_num]'
		print cont_sum

	if len(conts) == 0:
		raise Exception('******There is 0 contacts.')
	else:
		print ' '
		print "**usage: cshow(seq=None,inst='ms'). Totally",len(conts),'contacts, stored in list variable contact_pairs.'
		print "eg，cshow(3,inst='m'): plot master_inst + sdg"
		print "eg，cshow(3,inst='s'): plot slave_inst + mdg"
		print "eg，cshow(3,inst='ms'): plot slave_inst + master_inst"
		print ' '

	if seq !=None and type_of(seq) != 'INT':
		print fnln_fnln(),'****** An integer seq is required.'
		return

	if seq in [0,None]:
		seq = 1
		print fnln_fnln(), 'Setting contact seq = 1'

	if seq < 0 and abs(seq) <= len(conts):
		print fnln_fnln(),'Contact seq =',seq,', that is: seq=',seq + len(conts) + 1
		seq = seq + len(conts) + 1

	if len(conts) > 0 and abs(seq) > len(conts):
		list_contacts()
		print fnln_fnln(),'******contact number range: [1,' + str(len(conts)) + ']'
		return

	pair = conts[seq]
	name = pair['name']
	master = pair['master']
	slave = pair['slave']
	mfaces = pair['mfaces']
	surf_name1 = pair['msurface']
	sfaces = pair['sfaces']
	surf_name2 = pair['ssurface']

	ndir = face_ndir(mfaces[0])

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=a)
	plot_history.append(get_traceback())

	seq_m = list2sequence(mfaces)
	seq_s = list2sequence(sfaces)

	leaf = dgm.LeafFromGeometry(faceSeq=seq_m)
	mdg = session.DisplayGroup(leaf=leaf, name='master')

	leaf = dgm.LeafFromGeometry(faceSeq=seq_s)
	sdg = session.DisplayGroup(leaf=leaf, name='slave')

	leaf = dgm.LeafFromGeometry(faceSeq=seq_m + seq_s)
	vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)

	if inst not in empty:
		if inst == 'm':   	 ## master inst: plot master inst + sdg
			insts1 = master  ## list
		elif inst == 's':		## slave inst: plot slave inst + mdg
			insts1 = slave   ## list
		else: 						## master + slave
			insts1 = master + slave

		insts1 = real_insts(insts1)
		insts1 = tuple(insts1)

		leaf = dgm.LeafFromInstance(instances=insts1)
		vpnow.assemblyDisplay.displayGroup.add(leaf=leaf)

	loc = name.rfind(')')
	if name[loc-1] == 's':
		light(sdg,pause=False)
		dg = 'sdg'
	else:
		light(mdg,pause=False)
		dg = 'mdg'

	area1 = get_area(seq_m);	area1 = round(area1,3)
	area2 = get_area(seq_s);	area2 = round(area2,3)
	ratio1 = round(area1/area2,4)
	if ratio1 >= 1.5:
		ratio1 = str(ratio1) + '**'
	else:
		ratio1 = str(ratio1)

	ratio2 = round(area2/area1,4)
	if ratio2 >= 1.5:
		ratio2 = str(ratio2) + '**'
	else:
		ratio2 = str(ratio2)

##	print 'inst contact:',name,',点击工具栏按钮Replace All可以观察该接触对在整个模型中的位置'
	print fnln_fnln(),'inst contact:',name, ', ndir=',ndir
	print 'Master: surface name=',surf_name1,', inst=',  master,',',len(seq_m),'faces, area1=',area1,'mm^2'
	print 'Slave: surface name=',surf_name2, ', inst=',  slave,',',len(seq_s),'faces, area2=',area2,'mm^2'

	if abs(area1 - area2) < 1e-6:
		print '--->**mdg = sdg, base =',dg,'(lighted)'
	elif area1 > area2:
		if dg == 'mdg':
			print '--->**mdg:sdg =',ratio1,'(lighted) : 1'
		elif dg == 'sdg':
			print '--->**mdg:sdg =',ratio1,': 1 (lighted)'
	elif area1 < area2:
		if dg == 'mdg':
			print '--->**mdg:sdg = 1 (lighted) :',ratio2
		elif dg == 'sdg':
			print '--->**mdg:sdg = 1 :',ratio2,'(lighted)'
	print '**Tips: plot(sdg), plot(mdg), light(sdg), light(mdg)'
	print ' '

	if full == True:
		leaf = dgm.Leaf(leafType=DEFAULT_MODEL)
		vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)

	return

show_contact = cshow

def density_distribution(low=0.01,high=0.99,inst=None,Rho_th=14.44,ask=False,density_vol=None,global_return=False,th=None):
	## VER: 2016-09-05, v2.1
	## 如果不主动提供理论密度，则平均密度的绝对值可能是错误的。

	global _density_vol

	## in GUI clip command window:
	## refresh():   no prompt for density confirmation
	## refresh(ask=True): prompt for density confirmation

	## Example:
	## density_distribution(low=0.5,high=99.5,th=th)   ## 0.5%-99.5%
##	density_distribution(low=0.01,high=0.99,th=14.28)

	##>>> density_distribution(low=0.01,high=0.98,th=th)
	##Fraction: (low,high) = (0.01, 0.98)

##	>>> density_distribution(low=1,high=98,th=th)
##	Fraction: (low,high) = (0.01, 0.98)

	if is_number(th):
		Rho_th = th

	if fnln_fnln()[0] == 'cliCommand':
		ask = True

	if ask == True:
		fields = (('low percentage:',str(low)),('high percentage:',str(high)),('theoretical density:',str(Rho_th)))
		low, high, Rho_th = getInputs(fields=fields, label=str(fnln_fnln()) + ': provide density range')
		low = float(low)
		high = float(high)
		Rho_th = float(Rho_th)

	if low>0.1:
		low = low/100

	if not (0.001 <= low < 0.99):
		raise Exception('*** low is between 0.001 and 0.99')

	if high>1:
		high = high/100

	if not (0.001 <= high < 0.999):
		raise Exception('*** high is between 0.001 and 0.99')

	if high <= low:
		low,high = high,low
	print 'Mass fraction: (low,high) =',(low,high)   ;changing

	insts = []
	deforms = []
	for inst in oa.instances.values():
		if inst.type == DEFORMABLE_BODY:
			deforms.append(inst)
			if 'powder' in inst.name.lower():
				insts.append(inst)
			elif 'H10POW' in inst.elements[0].sectionCategory.name:
				insts.append(inst)

	if insts in empty and len(deforms) == 1:
		insts = deforms

	step_name,frame,time1 = current_step_frame_time()
	density0 = odb.steps[step_name].frames[frame].fieldOutputs['DENSITY'].values

	vol_available = False
	if 'EVOL' in odb.steps[step_name].frames[frame].fieldOutputs.keys():
		IVOLs = odb.steps[step_name].frames[frame].fieldOutputs['EVOL'].values
		vol_available = True

	values = []
	vols = []

	num = len(density0)
	mass = 0

	if density_vol in empty:
		density_vol = []
		for value in density0:
			if value.instance in insts:  	## value.instance is object,not instance name
				density_e = value.data
				if density_e >= 14e-9:
					density_e = 14e-9	;please_check
				elif density_e <= 3e-9:
					density_e = 3e-9

				values.append(density_e)

				if vol_available:
					label = value.elementLabel
					vol_e = IVOLs[label-1].data
					mass = mass + vol_e*density_e
				else:
					vol_e = 'NA'

				vols.append(vol_e)
				density_vol.append((density_e,vol_e))

	elif type_of(density_vol) != 'LIST':
		raise Exception('*** a list of (element density, vol) for every element is required.')

	density_vol_new = []

	density_vol = sorted(density_vol, key=lambda item: item[0])   ## lambda:声明临时变量
	if vol_available == False:   ## 此时low, high仅代表数据量，不代表体积. mid_density != average
##		print ' '
		print fnln(),'*** Element volume EVOL not available, simple average.'
		low_index = int(num*low + 0.5)
		mid_index = int(num*0.5 + 0.5)	## 简单地取中间数位置的密度为中位数。此时，中位数不等于平均数。
		high_index = int(num*high + 0.5)

		low_density = density_vol[low_index][0]
		mid_density = density_vol[mid_index][0]
		high_density = density_vol[high_index][0]

		values = _sort(values)		## 数值排序
##		values = values[10:-10]		## 删除10个单元最大的值。
		average = round(sum(values)/len(values)*1e9,3)

		bulk_density = 'NA'
		mass = 'NA'
		volume = 'NA'

	else:	## 此时的low, high代表体积分数，此时mid_density = average
##		print ' '
		print fnln(), '*** Element volume EVOL available, averaged by volume fraction'
		fraction = 0
		vol_all = sum(vols)
		low_density = 0
		mid_density = 0
		high_density = 0
		average = 0

		for i in range(num):  ## low, high, mid就代表了体积分数
			density11, vol = density_vol[i]
##			fraction = fraction + vol/vol_all		;changing    ## 体积分数
			fraction = fraction + density11*vol/mass	         ## 质量分数
			average = average + density11*vol/vol_all

			if fraction > low and low_density == 0:     ##按质量累积
				low_density = density11
			if fraction > 0.5 and mid_density == 0:
				mid_density = density11
			if fraction > high and high_density == 0:
				high_density = density11

		bulk_density = round(mass/vol_all*1e9,2)	## 简单地质量/体积
		mass = round(mass*1e6,4)	## 单位：g
		average = round(average*1e9,2)	## 单位: g/cc, 与理论密度无关，而仅是有各个单元的密度平均而得。
		volume = round(vol_all,1)

	## 处理之后的平均值
	average_new = 0
	for i in range(num):
		density_new,vol = density_vol[i]
		if density_new < low_density:
			density_new = low_density
		if density_new > high_density:
			density_new = high_density

		average_new = average_new + density_new*vol/vol_all

	average_new = round(average_new*1e9,2)

	## 计算标准差 standard deviation
##	print fnln(),'average=',average
	dev = 0
##	dev8 = 0
	for i in range(num):
		dev = dev + (density_vol[i][0]*1e9 - average)**2
##		dev8 = dev8 + (density_vol[i][0]*1e9*8/average - 8.0)**2

	dev = round(sqrt(dev/num),2)
##	dev8 = round(sqrt(dev8/num),2)	## 将平均密度归到8.0，压的实的话，标准差可能会大些。

	dev1 = int(round(dev/Rho_th, 2)*100)
##	dev81 = int(round(dev8/Rho_th,2)*100)

	dict1 = {}

	dict1['average'] = average	## 体积加权平均
	dict1['average_new'] = average_new
##	dict1['reference'] = 8.0	## 0.55, reference to 14.46 full density

	relative_avg = round(average/Rho_th,3)
	dict1['relative_avg'] = relative_avg    	## 需要正确的理论密度

	low_density = round(low_density*1e9,3)
	mid_density = round(mid_density*1e9,3)
	high_density = round(high_density*1e9,3)


	dict1['low_density'] = low_density
	dict1['mid_density'] = mid_density
	dict1['high_density'] = high_density
	dict1['weight'] = mass
	dict1['volume'] = volume
	dict1['weight/volume'] = bulk_density
	dict1['dev'] = dev

	relative = int(round(average/Rho_th,2)*100)

	gap = high_density - low_density

	low_percent = repr(low*100)
	high_percent = repr(high*100)

	average = str(average)
	relative = str(relative) + '%'
	dev = str(dev)		;	dev1 = str(dev1) + '%'
##	dev8 = str(dev8)	;	dev81 = str(dev81) + '%'

	low_density = round(low_density,2)
	mid_density = round(mid_density,2)
	high_density = round(high_density,2)

	if vol_available:
		text1 = 'mass%:'
	else:
		text1 = 'seq:'
	text1 = text1 + low_percent + '-50-' + high_percent + '= '
	text1 = text1 + repr((low_density,mid_density,high_density))
	text1 = text1 + ', avg =' + average + '(' + relative + ')'
	text1 = text1 + ', dev=' + dev + '(' + dev1 + ')'
##	text1 = text1 + ', new_avg=' + str(average_new)

	text1 = modify_string(text1,' ')
	dict1['summary'] = text1

	vpnow = get_vpnow()
	setting = current_variable_setting()
	if setting['main'] != 'DENSITY':
		plot_variable('density')

	vpnow.odbDisplay.contourOptions.setValues(maxAutoCompute=OFF, maxValue=high_density*1e-9, minAutoCompute=OFF, minValue=low_density*1e-9)
	vpnow.odbDisplay.contourOptions.setValues(numIntervals=10)   ## 绿色为中值，平均值得分布区。

	fontsize = get_fontsize()
	font_height = int(fontsize*0.40)  ## greater font height lead to greater line space.
	clearance_bot = 2		;please_check   ## anchor from bottom

	yloc_data = clearance_bot + font_height
	try:
		del session.odbs[odb.name].userData.annotations['Result']
		del session.odbs[odb.name].userData.annotations['Result' + vpnow.name]

	except:
		pass
	create_odb_annotation(odb=odb, viewport=vpnow.name,annotation_name='Result',text=text1, yloc=yloc_data)

	print ' '
	print '**Usage:  density_distribution(low=0.02,high=0.98,inst=None)'
	print ' '

	return dict1

def density_processing(density_vol=None,low=0.02,high=0.97,Rho_th=14.48,ranges=(0.1, 0.15, 0.75, 0.9),retreat=False,bymass=True,method='linear'):
	## VER: 2016-05-16, v1.1

	global _density_vol

##	density_processing(Rho_th=14.94,low=0.02,high=0.97)  ## avg = 8.43
##	dens1 = _density_vol
##	density_processing(Rho_th=14.94,ranges=(0.05,0.1,0.85,0.95),retreat=True,density_vol=dens1,method='linear')  ## avg=8.44, Density n1,n2,n3,n4= (7.597, 7.867, 8.797, 8.927)
##	density_processing(Rho_th=14.94,ranges=(0.1,0.15,0.8,0.9),retreat=True,density_vol=dens1,method='linear')  ## avg = 8.46, Density n1,n2,n3,n4= (7.867, 8.038, 8.755, 8.844)
##	dens2 = _density_vol

	method = method.lower()

	if not (0.001 <= low < 0.99):
		raise Exception('*** low is between 0.001 and 0.99')

	if not (0.001 <= high < 0.999):
		raise Exception('*** high is between 0.001 and 0.99')

	if high <= low:
		low,high = high,low

	if retreat == True and density_vol in empty:
		if '_density_vol' in globals().keys():
			density_vol = _density_vol
			print fnln(),'Use previous global _density_vol as input of density_vol for processing.'
		else:
			raise Exception('*** Global _density_vol is required.')

	mass = 0
	vol_all = 0

	n1,n2,n3,n4 = ranges
	if n1 > 1 or n2 > 1 or n3 > 1 or n4 > 1:
		raise Exception('*** n1,n2,n3,n4 should be fraction, and less than 1')
	print fnln(),'Fraction n1,n2,n3,n4=',(n1,n2,n3,n4)

	if density_vol in empty:
		insts = []
		deforms = []
		for inst in oa.instances.values():
			if inst.type == DEFORMABLE_BODY:
				deforms.append(inst)
				if 'powder' in inst.name.lower():
					insts.append(inst)
				elif 'H10POW' in inst.elements[0].sectionCategory.name:
					insts.append(inst)

		if insts in empty and len(deforms) == 1:
			insts = deforms

		step_name,frame,time1 = current_step_frame_time()
		density0 = odb.steps[step_name].frames[frame].fieldOutputs['DENSITY'].values
		IVOLs = odb.steps[step_name].frames[frame].fieldOutputs['EVOL'].values

		density_vol = []
		for value in density0:
			if value.instance in insts:  	## value.instance is object,not instance name
				density_e = value.data
				if density_e >= 11e-9:
					density_e = 11e-9	;changing
				elif density_e < 3e-9:   ## below filling density, a fake density due to such as negative volume
					density_e = 7.5e-9
				elif density_e <= 5.5e-9:
					density_e = 5.5e-9	;changing

				label = value.elementLabel
				vol_e = IVOLs[label-1].data
				density_vol.append((density_e,vol_e,label))

				mass = mass + vol_e*density_e
				vol_all = vol_all + vol_e

##		density_vol = sorted(density_vol, key=lambda item: item[0])   ## lambda:声明临时变量

	else:
		if type_of(density_vol) not in ['LIST','TUPLE']:
			raise Exception('*** a list of (element density, vol) for every element is required.')

		for density_e, vol_e, label in density_vol:
			mass = mass + vol_e*density_e
			vol_all = vol_all + vol_e

	density_vol = sorted(density_vol, key=lambda item: item[0])   ## lambda:声明临时变量
##	min0 = density_vol[0][0]
##	max0 = density_vol[-1][0]

	fraction = 0
	low_density = 0
	mid_density = 0
	high_density = 0
	average = 0

	n1_density = 0
	n2_density = 0
	n3_density = 0
	n4_density = 0

	## Determine low density and high density, n
	num = len(density_vol)
	for i in range(num):  ## low, high, mid就代表了体积分数
		density11, vol, label = density_vol[i]
		if bymass == True:
			fraction = fraction + density11*vol/mass	         ## 质量分数
		else:
			fraction = fraction + vol/vol_all		;changing    ## 体积分数

		average = average + density11*vol/vol_all

		if fraction >= low and low_density == 0:     ##按质量累积
			low_density = density11
		if fraction >= 0.5 and mid_density == 0:
			mid_density = density11
		if fraction >= high and high_density == 0:
			high_density = density11

		if fraction >= n1 and n1_density == 0:
			n1_density = density11
		if fraction >= n2 and n2_density == 0:
			n2_density = density11
		if fraction >= n3 and n3_density == 0:
			n3_density = density11
		if fraction >= n4 and n4_density == 0:
			n4_density = density11

	print fnln(),'Density n1,n2,n3,n4=',(round(n1_density*1e9,3),round(n2_density*1e9,3),round(n3_density*1e9,3),round(n4_density*1e9,3))

	Ra = density_vol[0][0]
	Rb = n1_density
	Rc = n2_density
	Ra1 = density_vol[-1][0]
	Rb1 = n4_density
	Rc1 = n3_density

	print fnln(),'Ra,Rb,Rc=',(round(Ra*1e9,3),round(Rb*1e9,3),round(Rc*1e9,3))
	print fnln(),'Rc1,Rb1,Ra1=',(round(Rc1*1e9,3),round(Rb1*1e9,3),round(Ra1*1e9,3))
##	raise Exception

##	bulk_density = round(mass/vol_all*1e9,2)	## 简单地质量/体积
	mass = round(mass*1e6,4)	## 单位：g
	average = round(average*1e9,2)	## 单位: g/cc, 与理论密度无关，而仅是有各个单元的密度平均而得。
	volume = round(vol_all,1)

	## 处理之后的平均值
	average_new = 0
	print ' '
	print 'Mass fraction: (low,high) =',(low,high)   ;changing
	print fnln(),'low_density=',round(low_density*1e9,3)
	print fnln(),'high_density=',round(high_density*1e9,3)

	_density_vol=[]
	mass_new = 0
	if method == 'simple' or retreat==False:
		print fnln(),'method = simple'

	for i in range(num):
		density_new,vol,label = density_vol[i]
		if method == 'simple' or retreat==False:
			if density_new < low_density:
				density_new = low_density
			elif density_new > high_density:
				density_new = high_density
		else:
			if density_new < Rc:
				K = (Rc - Rb)/(Rc - Ra)
				density_new = Rc - K*(Rc - density_new)
			elif density_new > Rc1:
				K = (Rc1 - Rb1)/(Rc1 - Ra1)
				density_new = Rc1 - K*(Rc1 - density_new)

		_density_vol.append((density_new,vol,label))
		average_new = average_new + density_new*vol/vol_all
		mass_new = mass_new + density_new*vol

	average_new = round(average_new*1e9,2)
	mass_new = round(mass_new*1e6,4)	## 单位：g

	_density_vol = totuple(_density_vol)

	dict1 = {}
	elements = []
	num = len(_density_vol)
	for i in range(num):  ## low, high, mid就代表了体积分数
		density_e, vol_e, label = density_vol[i]
		density_e = round(density_e*1e9,3)

		if density_e not in dict1.keys():
			dict1[density_e] = []

		if label not in elements:
			dict1[density_e].append(label)
			elements.append(label)

	min0 = min(dict1.keys())
	max0 = max(dict1.keys())

	dict1 = {}
	dict1['average'] = average	## 体积加权平均
	dict1['average_new'] = average_new
##	dict1['reference'] = 8.0	## 0.55, reference to 14.46 full density

##	relative_avg = round(average/Rho_th,3)
##	dict1['relative_avg'] = relative_avg    	## 需要正确的理论密度

	low_density = round(low_density*1e9,3)
	mid_density = round(mid_density*1e9,3)
	high_density = round(high_density*1e9,3)

	dict1['low_density'] = low_density
	dict1['mid_density'] = mid_density
	dict1['high_density'] = high_density
	dict1['mass'] = mass
	dict1['volume'] = volume
	dict1['mass_new'] = mass_new
	dict1['new_min'] = _density_vol[0][0]
	dict1['new_max'] = _density_vol[-1][0]
	dict1['min0'] = min0
	dict1['max0'] = max0

	print ' '

	return dict1

def density_with_PEG_to_CTE(Rh1, deltaT=1, C1=0.024, Rho_th=14.48):
	## VER: 2016-01-21, v1.6
	## Rh1(With PEG) -> Rh0(DE-PEG) -> Rh(sintering) -> 1(Theoretical)

	## Sintering weight loss: C1
	## 当deltaT=1时，shrinkage就是CTE。
	## 注意，Rho_th的单位是g/cc，不是标准单位或其他mm单位

	## 060粉(H10F)的sinter loss大概是2.4%, 2.5%这样。

##	>>> density_with_PEG_to_CTE(8.6671)
##	0.1625
##	>>>

##	>>> density_with_PEG_to_CTE(8.6671,Rho_th=14.44*1e3*KD)
##	0.1633
##	>>> density_with_PEG_to_CTE(8.6671,Rho_th=14.44*1e3)
##	0.1633
##	>>> density_with_PEG_to_CTE(8.6671,Rho_th=14.44)
##	0.1633
##	>>>
##	>>> density_with_PEG_to_CTE(8.6671e3,Rho_th=14.44)
##	0.1633

##	>>> density_with_PEG_to_CTE(0.7, 1400)
##	8.007e-05
##	>>>
##	>>> density_with_PEG_to_CTE(0.7,1)
##	0.1121
##	>>>

	deltaT = float(deltaT)

	shrinkage = density_with_PEG_to_shrinkage(Rh1=Rh1, C1=C1, Rho_th=Rho_th)
	CTE = shrinkage/deltaT
	CTE = round(CTE,5)	;changing

	if CTE < 0:
		raise Exception('*** Error to get the CTE, a minus value.')

	return CTE

def CTE_to_density(CTE,deltaT = 1, C1=0.024,Rho_th=14.46):
	## VER: 2015-06-18, v1.0

	## 060粉(H10F)的sinter loss大概是2.4%, 2.5%这样。

##	>>> CTE_to_density(0.19)  ## shrinkage = 19%
##	7.8736

	Rh0 = (1 - deltaT*CTE)**3/(1-C1)
	print fnln(),'relative density=',Rh0
	Rh0 = Rh0*Rho_th

	Rh0 = smart_round(Rh0)

	return Rh0

def shrinkage_to_density_with_PEG(shrinkage=None,C1=0.024,Rho_th=14.46,th=None):
	## VER: 2016-04-12, v1.3.  From final shrinkage to get the green part density with PEG, not the density after DE-PEG
	## shrinkage here is actually the CTE
	## Note: the simplified formula between density and shrinkage (CTE) means the density after DE-PEG.
	## The certification of powder gives the target density, then can get the target density.
	## Green part density always with PEG (press weight not changed before and after compaction)
	## Rh1(With PEG) -> Rh0(DE-PEG) -> Rh(sintering) -> 1(Theoretical)

##	>>> shrinkage_to_density_with_PEG(shrinkage=0.2077, C1=2.757, th=14.15)
##	['shrinkage_to_density_with_PEG', 18643] relative density= 0.511458757409
##	7.2371
##	>>> shrinkage_to_density_with_PEG(shrinkage=0.195, C1=2.757, th=14.15)
##	['shrinkage_to_density_with_PEG', 18643] relative density= 0.53645005296
##	7.5908
##	>>> shrinkage_to_density_with_PEG(shrinkage=0.20, C1=2.757, th=14.15)
##	['shrinkage_to_density_with_PEG', 18643] relative density= 0.526516047428
##	7.4502
##	>>> shrinkage_to_density_with_PEG(shrinkage=0.204, C1=2.757, th=14.15)
##	['shrinkage_to_density_with_PEG', 18643] relative density= 0.518657729605
##	7.339
##	>>>

	## Reference: density_with_PEG_to_shrinkage()

##	>>> density_with_PEG_to_shrinkage(Rh1=8.4205, C1=0.02174, Rho_th=14.94)
##	0.18
##	>>> shrinkage_to_density_with_PEG(shrinkage=0.18, C1=0.02174, Rho_th=14.94)
##	['shrinkage_to_density_with_PEG', 18088] relative density= 0.563621123219
##	8.4205
##	>>>

	## 060粉(H10F)的sinter loss大概是2.4%, 2.5%这样。

##	>>> CTE_to_density(0.19)  ## shrinkage = 19%
##	7.8736

##	>>> shrinkage_to_density_with_PEG(0.18,C1=0.0218,Rho_th=14.94)
##	['shrinkage_to_density_with_PEG', 18070] relative density= 0.563655694132
##	8.421
##	>>> shrinkage_to_density_with_PEG(0.18,C1=2.18,Rho_th=14.94)
##	['shrinkage_to_density_with_PEG', 18070] relative density= 0.563655694132
##	8.421
##	>>> shrinkage_to_density_with_PEG(18,C1=2.18,Rho_th=14.94)
##	['shrinkage_to_density_with_PEG', 18070] relative density= 0.563655694132
##	8.421
##	>>>

	if is_number(th):
		Rho_th = th

	if shrinkage >60:
		shrinkage = (100-shrinkage)/shrinkage
	elif shrinkage > 1:
		shrinkage = shrinkage/100

	if C1>0.5:
		C1 = C1/100     ## if C1 = 2.4, then C1 = 0.024

	## True formular is: Rh1 = (1 - CTE*deltaT)**3/(1-C1)
	Rh1 = (1 - shrinkage)**3/(1-C1)
	print fnln(),'relative density=',Rh1
	Rh1 = Rh1*Rho_th

	Rh1 = smart_round(Rh1)

	return Rh1

def shrinkage_to_relative_density(shrinkage,C1=0.024):
	## VER: 2015-07-22, v1.0

	## 060粉(H10F)的sinter loss大概是2.4%, 2.5%这样。

##	>>> shrinkage_to_relative_density(0.19)
##	0.5445
##	>>> shrinkage_to_relative_density(19)
##	0.5445
##	>>>

	if shrinkage >60:
		shrinkage = (100-shrinkage)/shrinkage
	elif shrinkage > 1:
		shrinkage = shrinkage/100

	Rh0 = (1 - shrinkage)**3/(1-C1)
	Rh0 = smart_round(Rh0)

	return Rh0


def read_density_and_element_labels(file1):
	## VER: 2015-07-08, v1.1
	## reference: read_lines(),pick(),get_line_code()

##	>>> dict1 = read_density_and_element_labels('uread.py')
##	>>> myprint(dict1)
##	5.62 : [1, 2, 3, 4, 5, 6, 7, 8]
##	5.64 : [12, 14, 16, 18, 19]
##	5.66 : [22, 26, 27, 29]
##
	if type_of(file1) == 'FILE':
		name = file1.name
		file1.close()
		file1 = name

##	if not os.path.isfile(file1):
##		raise Exception('*** No such file',repr(file1))

	file1 = search_file(file1)
	file_codes = open(file1).readlines()

	codes = []
	for i in range(len(file_codes)):
		line1 = file_codes[i]
		line1 = line1[:-1].strip()
		line1 = modify_string(line1,'\t','    ')	##
		line1 = modify_string(line1,' ')		;please_check  ## 如果待读取的字符串中间有空格,则空格将被去除.
		if line1 not in empty and line1[0] != '#':	## 注释
			codes.append(line1)

	line_num =  len(codes)

	dict1 = {}
	i = -1
	j = -1
	while i < line_num - 1:
		i = i + 1
		line1 = codes[i]

		density = None
		if 'density' in line1:
			loc = line1.find('=')
			expression = line1[loc+1:]
			density = eval(expression)

			j = i
			labels = ''
			while j < line_num - 1:
				j = j + 1
				line2 = codes[j]
				if 'density' in line2:
					break

				if '=' in line2:
					loc = line2.find('=')
					line2 = line2[loc+1:]
				labels = labels + line2

			if labels not in empty:
				labels = eval(labels)

			if is_number(density) and is_numbers(labels):
				dict1[density] = labels

		if j > i:
			i = j - 1
			j = -1

	print ' '
	print fnln(),'--->',len(dict1),'density levels are imported.'

	return dict1

def density_with_PEG_to_shrinkage(Rh1=None,C1=0.024,Rho_th=14.46,th=None,density=None):
	## VER: 2016-04-12, v1.4
	## shrinkage here is actually the CTE, with deltaT=1. Because shrinkage = CTE*deltaT
	## For 060 powder, C1 = 0.026
	## Rh1(With PEG) -> Rh0(DE-PEG) -> Rh(sintering) -> 1(Theoretical)

	## reference: shrinkage_to_density_with_PEG()

##	>>> density_with_PEG_to_shrinkage(Rh1=8.4205, C1=0.02174, Rho_th=14.94)
##	0.18
##	>>> shrinkage_to_density_with_PEG(shrinkage=0.18, C1=0.02174, Rho_th=14.94)
##	['shrinkage_to_density_with_PEG', 18088] relative density= 0.563621123219
##	8.4205
##	>>>

##	>>> density_with_PEG_to_shrinkage(0.5456)
##	0.19
##	>>> density_with_PEG_to_shrinkage(0.56608)
##	0.18
##	>>> density_with_PEG_to_shrinkage(0.52567)
##	0.2
##	>>> density_with_PEG_to_shrinkage(52.567)
##	0.2
##	>>>

	if is_number(th):
		Rho_th = th

	if is_number(density):
		Rh1 = density

	if Rho_th > 1000:
		Rho_th = Rho_th/1000
	elif Rho_th < 1e-7:
		Rho_th = Rho_th/(1e3*KD)

	Rh1 = float(Rh1)
	if Rh1 > 1000:   ## kg/m3
		Rh1 = Rh1/1000
	elif Rh1 > 30 and Rh1<100:  ## percentage
		Rh1 = Rh1/100
	elif 3 < Rh1 < 15:
		Rh1 = Rh1/Rho_th

	if Rh1 > 1 or Rh1 <= 0:
		raise Exception('*** relative density Rh1 is between 0 and 1')

	if is_number(C1):
		if C1 > 0.5:
			C1 = C1/100
		if 0.01 < C1 < 0.1:
			Rh0 = Rh1*(1-C1)
		else:
			print ' '
			print fnln(),'C1=',C1
			raise Exception('*** Error C1 value')

	else:
		Rh0 = Rh1

	shrinkage = 1 - pow(Rh0, 1/3.)
	shrinkage = smart_round(shrinkage)

	return shrinkage

function_labels['dg_now'] = 'object','display group','instance','leaf','set','viewport'
def dg_now():
	## VER: 2016-10-26, v1.5

	dpo = get_dpo()

	display = get_display_now()
	if display not in empty:
		dg = display.displayGroup
	else:
		raise Exception('***part, assembly, or odb display is required.')

	leaf = dg.root.leaf  ## which part,instance, etc.
	next = []
	next1 = dg.root.next
	while next1 not in empty:
		leaf1 = next1.leaf
		action = next1.action
		next.append({'leaf':leaf1,'action':action})
		next1 = next1.next

	objs = objs_of_dg()
	objs = _sort(objs)
	locs = current_view_location()

	names = []
	text = totext(leaf)
	if 'Sets' in text:
		for set1 in objs:
			if 'SET_' in set1:
				loc = set1.rfind('SET_')
				name1 = set1[loc+4:]
				if name1 not in names:
					names.append(name1)
			else:
				loc = set1.rfind('.')
				name1 = set1[loc+1:]
				if name1 not in names:
					names.append(name1)
	else:
		names = objs

	results = {'dg':dg, 'leaf':leaf, 'next':next, 'objs':objs,'locs':locs,'names':names}

	return results

def current_variable_setting():
	## VER: 2015-05-08, v2.0

## 	such as:
##	label0 = CNORMF   ASSEMBLY_SURF_ANVIL_INT2/ASSEMBLY_SURF_CUTTER_INT2, FORCE1
##	此时：main_var = 'CNORMF', main0 = 'CNORMF   ASSEMBLY_SURF_ANVIL_INT2/ASSEMBLY_SURF_CUTTER_INT2', sub_var = 'FORCE1'

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) != 'ODB':
		raise Exception('*** an odb viewport is required.')

	main_var = sub_var = None		;please_check
	label = vpnow.odbDisplay.primaryVariableLabel

	if '(' in label:
		loc = label.find('(')
		label = label[:loc]
		label = label.strip()
	label0 = label
##	print fnln(),'label0=',label0
##	raise Exception

	## 先确定sub_var和main0
	if ',' in label:
		loc = label.rfind(',')
		sub_var = label[loc+1:]
		sub_var = sub_var.strip()
		main0 = label[:loc]
	else:
		main0 = label

	main_var = main0	## 必须原原本本的！！
	## 例如：
##	variable = (('HFL', INTEGRATION_POINT, ((INVARIANT, 'Magnitude'),)),)  			## main0 = HFL, 积分点结果
##	variable = (('HFL      General_Contact_Faces/General_Contact_Faces', NODAL),)	## main0 = 'HFL      General_Contact_Faces/General_Contact_Faces'，节点结果。
##	不能认为上述为同一个main_var，因为结果的位置不一样。界面上的结果有可能为nodal result，也有可能为积分点结果。

##	if '   ' in main0:   ## 三个空格
##		loc = main0.find('   ')
##		main_var = main0[:loc]
##	else:
##		main_var = main0

	variable_info = odb_variables(main_var)		;please_check

	position = variable_info['position']
	refinement = variable_info['refinement']
	position0 = variable_info['position0']
	description = variable_info['description'].lower()
	subs = variable_info['subs']

	if refinement in empty:
		variable = ((main_var, position), )
	else:
		variable = ((main_var, position, (refinement, )), )

##	## 应力张量tensor的定义：(一点的应力状态可由如下应力张量来表示。所以可以简单理解为把应力各分量写成一个矩阵形式就定义了张量)
####              s11   s12   s13
####	S = Sij = s21   s22   s23
####              s31   s32   s33
##
##	##对于一点的应力状态: 引入s1, s2, s3(三个主应力，或称三个正应力）。
##	## 则应力张量不变量I1为：I1 = (s11 + s22 + s33) = (s1 + s2 + s3)  ## 为三个正应力之和。

##	Permissible data type: {NONE: 2, TIME: 3, LENGTH: 6, PRESSURE_GRADIENT: 68, DISPLACEMENT: 9, PATH: 11, BIMOMENT: 70, TIME_INCREMENT: 80,
##     POSITION: 7, PATH_X: 12, PATH_Z: 14, VELOCITY_SQUARED: 24, VOLUME_FLUX: 37, ROTATIONAL_ACCELERATION: 28, DENSITY_ROTATIONAL_ACCELERATION: 72,
##     VOLUME_FRACTION: 78, NUMBER: 22, TIME_VOLUME_FLUX: 39, HEAT_FLUX: 61, TIME_HEAT_FLUX: 65, LUMIN: 53, TWIST: 75, ACOUSTIC_INTENSITY: 69,
##     DAMAGE_CRITERION: 74, TEMPERATURE: 5, FREQUENCY: 20, PRESSURE: 33, THICKNESS: 10, PHASE: 18, RATE: 19, VELOCITY: 23, MASS_FLOW_AREA: 55,
##     DENSITY: 41, ROTATIONAL_VELOCITY: 26, LINEAR_PRESSURE: 34, HEAT_FLUX_RATE: 60, FORCE: 29, VOLUME: 36, PATH_Y: 13, VOLUME_FLUX_AREA: 38,
##     ROTARY_INERTIA: 45, FORCE_VOLUME: 30, TIME_VOLUME: 40, HEAT_FLUX_AREA: 62, TIME_HEAT_FLUX_AREA: 64, HEAT_FLUX_VOLUME: 63, DAMAGE: 73,
##     ARC_LENGTH: 8, AREA_VELOCITY_SQUARED: 25, ELECTRIC_CURRENT: 46, EPOTENTIAL_GRADIENT: 51, ELECTRIC_POTENTIAL: 50, STRAIN: 57,
##     MODE_NUMBER: 21, MOMENT: 31, ACCELERATION: 27, CORIOLIS_LOAD: 71, STRESS: 32, AREA: 35, ANGLE: 17, STRAIN_RATE: 59, MASS: 4,
##     ENERGY_DENSITY: 43, ENERGY_RELEASE_RATE: 66, ENERGY: 42, ANGULAR_MOMENTUM: 44, ELECTRIC_CHARGE: 47, STATUS: 58, STRESS_INTENS_FACTOR: 67,
##     ELECTRIC_CURRENT_AREA: 48, STEP_TIME: 79, CURVATURE: 16, MASS_FLOW_RATE: 54, MASS_FLOW_AREA_RATE: 56, ECURRENT_AREA_TIME: 49, SUBSTANCE: 52, }

	data_type = ''  ## 如果data_type = ''或者不是上述data_type之一, 则contour_values_vs_time()和nodal_values_vs_time()将会出错，即画不出曲线来。
	if main_var in ['S','COPEN','CSHEAR1', 'CSHEAR2', 'CSLIP1', 'CSLIP2','PS']:
		data_type = 'Stress'
	elif 'PRESS' in main_var or main_var == 'P':
		data_type = 'Pressure'
	elif main_var in ['IVOL']:
		data_type = 'Volume'
	elif main_var in ['CF', 'RF','GRAV']:
		data_type = 'Force'
	elif main_var == 'U':
		data_type = 'Displacement'
	elif main_var in ['NT11','TEMP']:	##'HFL','RFL11','RFLE11'
		data_type = 'Temperature'
	elif 'ENER' in main_var:
		data_type = 'Energy'
	elif main_var in ['PEEQ','LE','PE']:
		data_type = 'Strain'
	elif main_var == 'DENSITY':
		data_type = 'Density'
	elif main_var in ['HFL','HFL11','RFL11','RFLE11']:
		data_type = 'HEAT_FLUX'  ## 39
	elif main_var == 'HFLA':
		data_type = 'HEAT_FLUX_AREA'
	elif main_var == 'COORD':
		data_type = 'Position'
	elif main_var == 'CM':
		data_type = 'Moment'
	else:
		if 'displacement' in description:
			data_type = 'Displacement'
		elif 'velocity' in description:
			data_type = 'Velocity'
		elif 'acceleration' in description:
			data_type = 'Acceleration'
		elif 'volume' in description:
			data_type = 'Volume'
		elif 'stress' in description:
			data_type = 'Stress'
		elif 'energy' in description:
			data_type = 'Energy'
		elif 'pressure' in description:
			data_type = 'Pressure'
		elif 'force' in description:
			data_type = 'Force'
		elif 'temperature' in description:
			data_type = 'Temperature'
		elif 'strain' in description:
			data_type = 'Strain'
		elif 'moment' in description:
			data_type = 'Moment'	## 转矩
		elif 'flux' in description:
			data_type = 'HEAT_FLUX'
		elif 'weight' in description:
			data_type = 'NUMBER'
		else:
			if show_in_items(subs, 'LE'):
				data_type = 'Strain'

	if data_type in empty:
		error_info([('main_var=',main_var),('description=',description)],'***Fail to get the data_type')

	plot_state = get_plot_state()

	dg = dg_now()
##	objs = dg['objs']
	objs = dg['names']	;please_check

##	print fnln(),'description=',description

##	print fnln(),'label=',label0

	stepname, frame, time = current_step_frame_time()
	domain = odb.steps[stepname].domain

	results = {'main':main_var, 'variable':variable, 'main0':main0, 'sub':sub_var,'description':description, 'data_type':data_type,
		'label':label0,  'position':position, 'position0':position0,'refinement':refinement,'plot_state':plot_state, 'objs':objs,
		'step_name':stepname,'frame_ID':frame, 'frame_time':time,'domain':domain}

	return results

def current_view_location():
	## VER: 2014-04-11, v1.0

	vpnow = get_vpnow()
	view = vpnow.view

##	locs = {}
##	locs['nearPlane'] = view.nearPlane
##	locs['farPlane'] = view.farPlane
##	locs['viewOffsetX'] = view.viewOffsetX
##	locs['viewOffsetY'] = view.viewOffsetY

	locs = {}
	for key in view.__members__:
		if key not in ['viewVector','displayedObjectScreenWidth','displayedObjectScreenHeight']:
			value = get_attrib(view,key)
			locs[key] = value

	return locs

def cut_instances(insts=None, sides=None,side=None,x=None,y=None,z=None,cut_sides=()):
	## VER: 2016-10-14, v2.2
	## applicable for only one instance for one part
	## 注意：如果一直意外退出软件，需要将journal文件删除，因为其中含有破碎信息。

	## Example:
	## cut_insts(x=0,side='-')
	## cut_instances(z=0,cut_sides='+')
	## cut_instances(x=_xmid(powder),cut_sides='-')
	## cut_instances(y=_ymid(powder),cut_sides='-')    ## inserts全模型变1/4模型，连模具都将被切割
	## 注意，下面方式可能有问题: cut_instances(z=MID,cut_sides='+')

	global _m, a

	setting_display()
	get_current_model()

	if side not in empty:
		sides = side

	if sides not in empty and cut_sides in empty:
		cut_sides = sides

	if insts in empty:
		insts = a.instances.values()

	insts = real_insts(insts)

	if x != None and is_number(x) == False:
		raise Exception('*** x should be numeric')

	if y != None and is_number(y) == False:
		raise Exception('*** y should be numeric')

	if z != None and is_number(z) == False:
		raise Exception('*** z should be numeric')

##	print fnln(),'x,y,z=',(x,y,z)
##	raise Exception

	instnames = poi_names(insts)
	new_names = []
	for inst in instnames:
		if inst not in a.instances.keys():
			continue

		new_name = cut_instance(inst,x=x,y=y,z=z,cut_sides=cut_sides)
		if new_name not in empty:
			new_names.append(new_name)

	if new_names not in empty:
##		print fnln(),'new_names=',new_names
##		raise Exception
		parts = parts_of_insts(new_names)
		partnames = poi_names(parts)
		print fnln(),'*** New parts',partnames,'are created by partially divide instances',new_names

	return new_names

cut_insts = cut_instances

def geometry_to_ids(curves):
	## VER: 2014-10-29, v1.0

	curves = tolist(curves)
	newlist = []
	for curve in curves:
		try:
			newlist.append(curve.index)
		except:
			try:
				newlist.append(curve.id)
			except:
				pass

	return newlist

def cut_instance(inst,x=None,y=None,z=None,cut_sides='+',side=None):
	## VER: 2016-12-21, v2.3
	## you can use bias_cut() for part instead.
	## may called by cut_instances()

	global _m, a

	get_current_model()

	if side not in empty:
		cut_sides=side

	if caller_name() != 'cut_instances':
		supps = []
		for inst1 in a.instances.keys():
			if is_suppressed(inst1):
				supps.append(inst1)

		a.deleteFeatures(totuple(supps))

##		refresh()
		get_current_model()
		convert_constraint()
##		refresh()
		get_current_model()

	inst = check_inst(inst)
	instname = inst.name
	partname = inst.partName

	if is_suppressed(inst):
		return

	space = poi_space(inst)

	if x in empty and y in empty and z in empty:
		raise Exception('******Please specify the cutting location: x,y or z.')

	x,y,z = real_xyz(inst,x,y,z)

	if cut_sides == 1:
		cut_sides = '+'
	elif cut_sides == -1:
		cut_sides = '-'

	if type_of(cut_sides) != 'STR':
		raise Exception('*** error cut_sides, should be string.')

	if '+' not in cut_sides and '-' not in cut_sides:
		print fnln(),cut_sides
		raise Exception('*** please indicate the + or - cut_sides.')

	cut_sides = cut_sides.lower()
	if x not in empty:
		offset = x
		ndir = 0
		if len(cut_sides) == 1:
			cut_sides = cut_sides + 'x'
		if cut_sides not in ['+x','-x']:
			raise Exception('*** Error cut_sides')

	elif y not in empty:
		offset = y
		ndir = 1
		if len(cut_sides) == 1:
			cut_sides = cut_sides + 'y'
		if cut_sides not in ['+y','-y']:
			raise Exception('*** Error cut_sides')

	elif z not in empty:
		offset = z
		ndir = 2
		if len(cut_sides) == 1:
			cut_sides = cut_sides + 'z'
		if cut_sides not in ['+z','-z']:
			raise Exception('*** Error cut_sides')

##	print fnln_fnln(),'space=',space
##	print fnln_fnln(),'ndir=',ndir
	poi_range = space[2*ndir:2*ndir + 2]
	if cut_sides[0] == '+':
		cut_range = [offset,_max]
	else:
		cut_range = [_min,offset]

##	print fnln_fnln(),'cut_range=',cut_range
##	print fnln_fnln(),'poi_range=',poi_range
	cross = cross_of_ranges(poi_range,cut_range)	## 判断在切削方向上是有有交叉。
	cross_length = cross['length']
##	print fnln_fnln(),'cross_length=',cross_length

##	raise Exception

	new_name = ''
	if cross_length <= 0:	## 没有交叉
		return   ## not changed
	else:
		poi_length = poi_range[1] - poi_range[0]
		if PK(poi_length,cross_length) == 0:
			del_insts(inst)   ## cover the instance
		else:   ## partial cover
			position = get_poi_position(inst)
			action = position['eqv_action']
			dx = position['translation'][ndir]
##			print fnln(),'action=',action
			if action in ['translation','stay'] and dx == 0:  ## 在切割方向上与part没有位移
##				print fnln(),'partname=',partname
				bias_cut(partname,x=x,y=y,z=z,cut_sides=cut_sides)  ## 该方法会把在切割方向范围内该part的所有类似没有平移的inst都给切削了。(part变，则所欲的insts也跟着变。)
				print fnln(),'bias_cut: partname=',partname
			else:
				insts = insts_of_part(partname)
				del_old_part = False

				if len(insts) == 1:	 ## 只有一个instance，但instance与其part之间有cut_sides方向的迁移或旋转，此时，需要把inst变成新的part来切。
					del_old_part = True
				else:
					equal = 0
					for inst1 in insts:
						position1 = get_poi_position(inst1)
						if position1['eqv_action'] == action and PK(position1['translation'][ndir], dx) == 0:
							equal = equal + 1

					if equal == len(insts):
						del_old_part = True

				newpart = temp_part_from_inst(inst)
				if del_old_part == True:
					del_parts(partname)
					change_name(newpart,partname)
					newpart = partname

				else:
					del_insts(instname)

				bias_cut(newpart,cut_sides=cut_sides,x=x,y=y,z=z)
				new_instance(newpart,inst_name=instname, plota=False)	## use the instname?

				update_part(newpart)

	get_current_model()

	if new_name not in empty:
		print fnln(),'** Created new part',new_name,'for',instname
		result = instname
	else:
		result = None

	return result


def cylindrical_fix(name,faces,CSYS_name=None,U1=0,U2=None,U3=None,step='Initial'):
	## VER: 2012-12-19, v1.1, U1: 径向

	global options

	name = new_key(_m.boundaryConditions,name)
	step = check_step(step)

	type1 = type_of(faces)
	if type1 == 'faces':
		faces = [faces]
	elif type1 == 'STR':
		faces = set2objs(faces)

	if U2 == None:
		U2 = UNSET   ## 周向

	if U3 == None:
		U3 = UNSET    ## 轴向

	if len(faces) > 0:
		if (type_of(faces[0]) == 'PART' or type_of(get_poi(faces[-1])) == 'PART'):
			raise Exception('****** Require faces from instance, not part.'	)

		axis = ''
		if CSYS_name in empty:
			center,vector0,axis = center_axis_of_cylind_face(faces[0])
			CSYS_name = create_cylind_csys('cylind_CSYS_1',origin=(x0,y0,z0),ndir=axis)

		datum = a.datums[a.features[CSYS_name].id]

		_m.DisplacementBC(name=name, createStepName=step,
		    region=faces, u1=U1, u2=U2, u3=U3, ur1=UNSET, ur2=UNSET, ur3=UNSET,
		    amplitude=UNSET, fixed=OFF, distributionType=UNIFORM, fieldName='',
		    localCsys=datum)

	print '--->Applied cylindrical BC, name=',name,', U1=',U1,', U2=',U2,', U3=',U3,
	if axis != '':
		print ', axis=',axis
	else:
		print
	print ' '

	options.append('apply_disp_fix: ' + name)

	a.regenerate()

	return

def cutted_punch_tip_length(radius,ejector_land):
	## VER: 2013-05-15, v1.0. For punch calculation.

	## Example:
	## 	tip_length = cutted_punch_tip_length(radius=9.76,ejector_land=0.22)

	cos_alpha = 1 - ejector_land/radius
	if cos_alpha > 1 or cos_alpha < 0:
		raise Exception('**** alpha should be a small angle. Error value of cos_alpha.')

	alpha = acos(cos_alpha)
	tip_length = radius*sin(alpha)
	tip_length = round(tip_length,2)

	print 'tip_length=',tip_length

	return tip_length

def cylind_dims():
	## VER: 2015-09-30, v1.0
	## For compaction of simple cylinder

	refresh()

	up_OD = zdist_of_nodes(35531,11391)
	up_ID = zdist_of_nodes(12110, 35540)

	mid_OD = zdist_of_nodes(35851, 12421)
	mid_ID = zdist_of_nodes(12430, 35800)

	bot_OD = zdist_of_nodes(36171, 12031)
	bot_ID = zdist_of_nodes(12750, 36180)

	dir1 = make_dir('results')
	file1 = '_' + odb_file_title[0:2] + '_dimensions.txt'
	file1 = open(dir1 + '/' + file1,'w')

	print >>file1, ' '
	print >>file1, 'odb file =',odb_file_title + '.odb'
	print >>file1, ' '

	print >>file1, 'up_OD =', up_OD
	print >>file1, 'up_ID =', up_ID
	print >>file1, ' '
	print >>file1, 'mid_OD =',mid_OD
	print >>file1, 'mid_ID =',mid_ID
	print >>file1, ' '
	print >>file1, 'bot_OD =',bot_OD
	print >>file1, 'bot_ID =',bot_ID
	print >>file1, ' '

	file1.close()

	print '--->Dimensions have been written to',dir1 + '/' + file1.name


	return

def cylinder_grow(p,ndir,center0=(),x=None, y=None,z=None, ref_face=None, L=None, ID=None, OD=None,OD1=None, OD2=None, L12=None, D=None,
	divide=False,direction='forward', expansion=None,half_angle=None,twist_angle=None,shell=False):
	## VER: 2016-10-31, v3.2, can also use for conical grow
	## Expansion = △OD/2.0
	## half_angle > 0: 膨胀
	## half_angle < 0: 收缩
	## 通常OD1,OD2对应L12的两头直径，在提供L12的情况下。

##	>>> edges[0]
##	mdb.models['Model-1'].parts['tpunch'].edges.findAt((0.0, -4.488723, 19.12376),)
##	>>> edges[1]
##	mdb.models['Model-1'].parts['tpunch'].edges.findAt((0.0, 4.488723, 19.123763),)
##	>>> edge_length(edges[0])
##	28.203481
##	>>> edge_length(edges[1])
##	28.203481
##	>>>

##	D = get_diameter(edges)
##	cylinder_grow(tpunch,ndir='z',center0=loc,OD=D,L=-10,shell=True)


##	cylinder_grow('carbide2',ndir='y',y=15,OD1=8.5, OD2=10, L = 15)   ## grow in +y direction, center = (0,15,0)
##	cylinder_grow('carbide2',ndir='y',OD1=10, OD2=9, L12=10, L = -15) ## grow in -y direction, center=(0,0,0)
##	cylinder_grow('carbide2',ndir='y',y=-15,OD1=8.5, OD2=10, L = -15) ## grow in -y direction, center=(0,-15,0)
##	cylinder_grow('carbide3',ndir='z',OD1=17.7546, OD2=17.0434, L12=17.7546, L = 19)

	## Example: loft grow
	## cylinder_grow('cone',ndir='y', OD=diameter, L=carbide_H - overlap_H, expansion=2, direction='reverse')
	## will grow in -y direction and will expansion

	## cylinder_grow('p4',ndir='-y',OD1=16, OD2 = 18, L = 5)  ## cylinder grow

##	cylinder_grow('p2',ndir='y',x=0,z=0, y=_ymax(compound),OD=diamond_D0, L=5,half_angle=(original_D,diamond_D0,diamond_H0))
##	cylinder_grow('p3',ndir='-y',y=_ymin(compound),OD=carbide_D0, L=5,half_angle=(original_D,carbide_D0,carbide_H0))

	try:
		p = check_part(p)
	except:
		if type_of(p) == 'STR':
			partname = p
			partname = blank_part(partname)
			p = _m.parts[partname]
		else:
			raise Exception('*** Error part for cylinder_grow. Please provide the partname')

	if ndir == 0:
		ndir = 'x'
	elif ndir == 1:
		ndir = 'y'
	elif ndir == 2:
		ndir = 'z'

	if type_of(ndir) != 'STR':
		raise Exception('*** axial dir is required.')

	if is_number(D):
		OD = D
		ID = 0

	changing
	if is_numbers(OD1,OD2,L) and L12 in empty:
		if OD1 < OD2:   ## 默认为圆柱管
			ID = OD1
			OD = OD2
			OD1 = OD2 = None
		else:
			L12 = abs(L)  ## half_angle取决于OD1,OD2,不取决于L的符号
	elif is_numbers(OD1,OD2,L12) and L in empty:
		L = L12

	if is_number(L) == False:
		L = 30  ## default

	if is_number(OD):
		OD1 = OD
		OD2 = None

	print fnln(),'OD1=',OD1

	if is_number(OD1):
		OD1 = abs(OD1)
	else:
		raise Exception('*** OD1 is required for the cylinder sketch.')

	if is_number(OD2):
		OD2 = abs(OD2)

	if direction == '+':
		direction = 'forward'
	elif direction == '-':
		direction == 'reverse'

	ndir = ndir.lower()
	if ndir[0] == '-' or L < 0:
		direction = 'reverse'
	if ndir[0] in ['+','-']:
		ndir = ndir[1]

	L = abs(L)  ## L用来判断生长方向和生长距离

	x,y,z = real_xyz(p,x,y,z)

	print fnln(),'direction=',direction

	if center0 in empty:
		if ref_face in empty:
			faces = face_select(p,ndir='cylindrical')
			if faces not in empty:
				ref_face = faces[0]
##			else:
##				raise Exception('*** no cylindrical face, please specify the radial cut center, i.e., a point that axis pass through.')

	if ref_face not in empty:
		ndir0 = face_ndir(ref_face)
		if ndir0 != 'cylindrical':
			raise Exception('*** a cylindrical face is required.')
		else:
			center0,vector0,axis = center_axis_of_cylind_face(ref_face)

	if center0 in empty:
		center0 = (0,0,0)

	center0 = list(center0)

	if is_number(x):
		center0[0] = x

	if is_number(y):
		center0[1] = y

	if is_number(z):
		center0[2] = z

	if half_angle in empty:
		if is_number(OD2):  ## 也可能提供了half_angle，但是没有提供OD2
			if is_number(L12) == False:
				raise Exception('*** L12 is required for between OD1 and OD2')

			L12 = abs(L12)
			half_angle = atanD((OD2-OD1)/(2.0*L12))    	## 与ndir的角度

	elif is_number(expansion) and half_angle in empty:
		half_angle = atanD(expansion/abs(L))    ## expansion > 0表示末端放大，expansion < 0表示末端缩小。

	if type_of(half_angle) in ['TUPLE','LIST'] and len(half_angle) == 3:
		OD1,OD2,H = half_angle   ## negative grow: H < 0

		half_angle = atanD((OD2 - OD1)/2/H)

	sign = '+'
	if direction == 'reverse':
		sign = '-'
		flip = ON   ## i.e, reverse = True
	else:
		flip = OFF

	if ndir == 'x':
		offset = center0[0]
	elif ndir == 'y':
		offset = center0[1]
	elif ndir == 'z':
		offset = center0[2]
	else:
		raise Exception('*** error ndir.')

	center1 = center0

	## conver 3D points to sketch points
	center0 = threeD_to_sketch_points(center0,ndir)
	x0 = center0[0];	y0 = center0[1]

	## create blank sketch
	sketch1 = create_part_sketch(p,ndir,offset=offset,name='temp_sketch1')
	s = sketch1['sketch']
	datum_plane1 = sketch1['datum_plane']
	right_edge1 = sketch1['right_edge']
	side = sketch1['side']

	## draw lines
	s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + OD1/2.0, y0))   ## Need only OD1 for solid grow
	if is_number(ID):
		ID = abs(ID)
		s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + ID/2.0, y0))

	print fnln(),'half_angle=',half_angle
	print fnln(),'twist_angle=',twist_angle

	if half_angle == 0:
		half_angle = None
	if twist_angle == 0:
		twist_angle = None

	if half_angle in empty and twist_angle in empty:
		if shell == False:
			p.SolidExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1,
			    sketchPlaneSide=side, sketchOrientation=RIGHT, sketch=s, depth=abs(L),
			    flipExtrudeDirection=flip, keepInternalBoundaries=ON)
		else:
			p.ShellExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1,
			    sketchPlaneSide=side, sketchOrientation=RIGHT, sketch=s, depth=abs(L),
			    flipExtrudeDirection=flip, keepInternalBoundaries=ON)

	elif is_number(half_angle):
		p.SolidExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1,
		    sketchPlaneSide=side, sketchOrientation=RIGHT, sketch=s, depth=abs(L),
		    flipExtrudeDirection=flip, keepInternalBoundaries=ON,draftAngle=half_angle)  ## draftAngle>0, radius increase; draftAngle<0,radius decrease

	elif is_number(twist_angle):
		p.SolidExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1,
		    sketchPlaneSide=side, sketchOrientation=RIGHT, sketch=s, depth=abs(L),
		    flipExtrudeDirection=flip, keepInternalBoundaries=ON,twistAngle=twist_angle)

	print '--->Performed cylinder growth in',sign+ndir,', (OD1,OD2,ID,L12,L)=',(OD1,OD2,ID,L12,L),'mm'

	if divide == True:
		circular_divide(p,ndir=ndir,D=OD2,center=totuple(center1))

		if OD1 > 0:
			circular_divide(p,ndir=ndir,D=OD1,center=totuple(center1))

	return p.name

def del_contacts_of_inst(inst):
	## VER: 2012-12-21, v1.0

	inst = check_inst(inst)
	ints,ties = contacts_of_inst(inst)

	for name in ints:
		del _m.interactions[name]

	for name in ties:
		del _m.constraints[name]

	a.regenerate()
	print len(ints) + len(ties),'contacts are deleted.'

	return

def del_edges_seed(edges,p=None):
	## VER: 2011-03-10, v1.1

	if type_of(edges) == 'PART':
		p,edges = edges,p

	if p in empty:
		p = get_poi(edges)
	else:
		p = check_part(p)

	if edges in empty:
		print fnln_fnln(),'******edges are empty. All edges in',p.name,'will be deleted for seeding.'
		edges = p.edges

	edges = tolist(edges)
	seq = list2sequence(edges,p)

	p.deleteSeeds(regions=seq)
	print '--->','Seeding for',len(edges),'edges in',p.name,'have been deleted.'

	return

def del_cells(cells):
	## 2013-09-10, v1.1

##	Example:
##	rotate_part(tray,angle_y = 90)
##	divide(tray,x=0)
##	divide(tray,z=0)
##
##	cells = cell_select(tray,x=(0,MIN))
##	del_cells(cells)
##
##	cells = cell_select(tray,z=(0,MIN))
##	del_cells(cells)

	## reference:
	## 	hex_cut(tray,x=(0,MIN))

	cells = tolist(cells)
	faces = faces_of_cells(cells)

	part = get_poi(cells)
	if type_of(part) != 'PART':
		raise Exception('******Only faces from part is allowed.')

##	newlist = []
##	for face in faces:
##		if len(face.getCells()) == 1:
##			newlist.append(face)
##	faces = newlist
	face_seq = list2sequence(faces)

	num0 = len(part.cells)
	result1 = part.RemoveFaces(face_seq, deleteCells=False)
	num1 = len(part.cells)

	print '--->',num0 - num1,'cells removed.'

	return

def del_features(poa,objs=None,names=None, key_list=[],backup=None,num=None, del_single=False):
	## VER: 2016-10-20, v1.4， key_list是feature的name list，不是feature的id list
	## partition之前生成的datum point是不能删除的，否则，会连partition也删除。

	## Example:
##	if 'O' in _part(partname).features.keys():
##		loc = loc_of_feature_point(p=partname, feature='O')
##		space = poi_space(partname)
##		if within_space(space,loc) == False:
##			_part(partname).deleteFeatures(('O',))
####		del _part(partname).features['O']   ## Error, abaqus will exit


	poa = check_pia(poa)
	if type_of(poa) == 'ASSEMBLY':
		poa = a

	if objs not in empty:
		objs = tolist(objs)
		if type_of(objs[0]) == 'STR':
			names = objs
		elif type_of(objs[0]) == 'FEATURE':
			names1 = []
			for obj in objs:
				names1.append(obj.name)
			names = names1

	if names not in empty:
		names = tolist(names)
		for name in names:
			if name in poa.features.keys():
				del poa.features[name]

	else:
		key_list = tolist(key_list)

		if len(key_list) == 1 and type_of(key_list[0]) == 'INT':
			key_id = key_list[0]
			if not del_single:
				key_list = poa.features.keys()[key_id:]
			else:
				key_list = [poa.features.keys()[key_id]]

		elif num != None:
			num = abs(num)
			key_list = poa.features.keys()[-num:]

		elif backup not in empty:
			if type_of(backup) == 'DICT':
				backup = backup.keys()
			key_list = unselect(poa.features.keys(),backup)

		key_list = totuple(key_list)
		res = False
	##	print 'key_list=',key_list

	##	print 'before delete:',len(poa.features)

		if key_list not in empty:
			res = poa.deleteFeatures(key_list)

	##	print 'after delete:',len(poa.features)
	##	print ' '
		if res in [True,1]:
			print fnln_fnln(),'--->**',len(key_list),'features of poa',poa.name,'are deleted'

	poa.regenerate()

	return

def del_geometry(sketch,curves=(),loc=(),x=None,y=None,groupX=None,groupY=None):
	## VER: 2014-12-24, v1.3
	## Reference: trim_geometry()

## 圆与直线相切，然后delete的例子。
##	connect_points(s1,(ejector_OD/2.0 + 0.5, 0), (ejector_OD/2.0, 0), (ejector_OD/2.0 - ejector_land,0), xtilt(-ejector_OD/2.0,  ejector_tangent_angle - 90))
##	fix_constraint(s1.geometry[last_line])
##
##	create_arc(s1,center=(0,2*ejector_R),radius=ejector_R,quarter=4)
##	arc_constraint(s1.geometry[last_arc],fix_x=True)
##
##	tangent_constraint(s1,last_line,last_arc)
##
##	del_geometry(s1,y=MAX1)
##	del_geometry(s1,y=MIN1)


	sketch = check_sketch(sketch)

	curves0 = curves
	curves = tolist(curves)
	if curves not in empty:
		for i in range(len(curves)):
			if curves[i] in sketch.geometry.keys():
				id = curves[i]
				curves[i] = sketch.geometry[id]

	elif curves0 == ():	  ## 本来就没提供该参数。
		if loc not in empty:
			loc = real_xy_sketch(sketch,loc=loc)

		if is_numbers(loc) == False and (groupX not in empty or groupY not in empty):
			loc = find_loc(sketch,x=x,y=y,groupX=groupX,groupY=groupY)

##		stop1()
		if is_numbers(loc):
			curves = geometry_at(sketch,loc=loc)  ## return geometry IDs
			if curves in empty:
				curve1 = sketch.geometry.findAt(coordinates=loc,printWarning=False)
				if curve1 not in empty:
					curve1 = sketch.geometry[curve1.id]
					curves = [curve1]
		else:
			curves = geometry_select(sketch,x=x,y=y)

	if is_numbers(curves):
		curves = geometry_ids_to_objs(sketch,curves)

	if curves not in empty:
		sketch.delete(objectList=totuple(curves))

	return

def del_dimensions(sketch):
	## VER: 2014-09-12, v1.0

	sketch = check_sketch(sketch)
	sketch.delete(objectList=totuple(sketch.dimensions.values()))

	return

def del_constraints(sketch):
	## VER: 2014-09-12, v1.0

	sketch = check_sketch(sketch)
	sketch.delete(objectList=totuple(sketch.constraints.values()))

	return

def curves_only(sketch):
	## VER: 2014-09-12, v1.0

	del_constraints(sketch)
	del_dimensions(sketch)
	hide_grid()

##	sketch = check_sketch(sketch)
##
##	sketch.delete(objectList=totuple(sketch.dimensions.values()))
##	sketch.delete(objectList=totuple(sketch.constraints.values()))
##	hide_grid()

	return

def del_hiden_insts():
	## VER: 2014-04-29, v1.0

	global _m, a

	hide_insts = get_hiden_insts()
	suppr_insts = get_suppressed_insts()

	if len(hide_insts + suppr_insts) > 0:
		del_insts(hide_insts + suppr_insts)
		get_current_model()

	return

def del_insts(inst_list=None,remove_contacts=False):
	## VER: 2014-09-08, v2.9

	global _m, a

	get_current_model()    ## 必须刷新当前model，否则可能出错！
	if inst_list in empty:
		a.deleteFeatures(totuple(a.instances.keys()))
		a.regenerate()
		print fnln(),'*** All instances are deleted.'
		return

	else:

		inst_list = check_pias(inst_list,force_list=True)

		if len(inst_list) == 1 and type_of(inst_list[0]) == 'PART':
			inst_list = insts_of_parts(inst_list)

		all = False
		list_length = len(inst_list)
		if list_length == len(a.instances.values()):
			all = True

		insts = []
		for inst in inst_list:
			if remove_contacts == True:
				del_contacts_of_inst(inst)

			name = inst.name
			insts.append(name)

			del a.features[name]

		a.regenerate()   ## assembly changed.

		print '  '
		if all == True:
			print '---> All instances in the model are deleted.'
		elif list_length > 0:
			print '--->',list_length,'instances are deleted:',insts

	return

def del_parts(*part_list):
	## VER: 2014-11-12, v2.2

	global default_plot, plot_history

	get_current_model()    ## 必须刷新当前model，否则可能出错！

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	if dpo != None:
		dpo = dpo.name

##	print fnln(),'partlist=',part_list
##	raise Exception

	part_list = tolist(part_list)
	if part_list in empty:
		part_list = _m.parts.values()

	part_names = []
	for part in part_list:
##		p = part
##		if type_of(part) == 'STR':    ##using keys
##			p = _m.parts[part]
		p = check_part(part)

		partname = p.name
		p_insts = insts_of_parts(p)
##		print fnln(),'p_insts=',p_insts
##		raise Exception

		if len(p_insts) > 0:
			print fnln_fnln(),partname,'have instances. This part and its instances will be deleted.'
			del_insts(p_insts)

		if partname in p.sets.keys():
			del p.sets[partname]

		part_names.append(partname)
		del _m.parts[partname]

	if len(_m.parts) > 0:
		default_plot = _m.parts.values()[0]

	if dpo != None and dpo in part_names:    ## 视图中的part被删掉了
##		print 'dpo=',dpo
##		print 'part_names=',part_names

		vpnow.setValues(displayedObject=None)
		plot_history.append(get_traceback())

##	print '  '
##	print '--->',len(part_list),'parts are deleted by del_parts() function: ',part_names

	return

def del_parts_without_instance():
	## VER: 2013-04-23, v1.0

	parts = []
	for part in _m.parts.values():
		insts = insts_of_part(part)
		if insts in empty:
			parts.append(part)
	del_parts(parts)

	return

function_labels['del_pick_sets'] = 'import','picked'
def del_pick_sets(p1=None):
	## VER: 2017-02-20, v1.3
	## used for imported part from odb, to clear the inhereted picked sets. 不必先保存cae再删除sets

	## 即使有几千个set，也可以很快删除。这些set会使操作很缓慢。
##	>>> del_pick_sets('expan')
##	>>> del_pick_sets('green')
##	>>>

	if p1 in empty:
		parts = _m.parts.values()
##		p1 = get_dpo()
	else:
		p1 = check_part(p1)
		parts = [p1]

	for part in parts:
		p1 = part
		names = []
		for name in p1.sets.keys():
			if '_PICKEDSET' in name:
				names.append(name)

		p1.deleteSets(setNames=totuple(names))

	return

def del_sketch_objs(sketch,objs,loc=(),obj_type=None):
	## VER: 2013-11-01, v1.4  to delete vertice and curve in the sketch
	## isolate point in the center of acr cannot be deleted. It will be deleted if the arc is deleted.

##	curve = geometry_select('_powder',H=_xmax1_sketch('_powder'))
##	del_sketch_objs('_powder',objs=curve)

	## Example
##	curves = geometry_at(s,loc=(0,0))
##	del_sketch_objs(s,objs=curves,loc=(0,0))

	sketch = check_sketch(sketch)
	objs = totuple(objs)
	num = len(objs)

	type1 = type_of(objs)
	if type1 == 'vertices':
		num_v0 = len(sketch.vertices)
	else:
		num_v0 = len(sketch.geometry)

	vertices = []
	curves = []
	for obj in objs:
		if type_of(obj) == 'vertices':
			vertices.append(obj)
		elif type_of(obj) == 'INT':
			id = obj
			if obj_type not in ['vertices','geometry','lines','curves']:
				raise Exception('**** obj_type is required if provided only id of object for delete.')
			if obj_type == 'vertices':
				vertices.append(sketch.vertices[id])
			else:
				curves.append(sketch.geometry[id])
		else:
			curves.append(obj)
##	curves = tuple(curves)

	if curves not in empty:
		if loc not in empty:
			for curve in curves:
				sketch.autoTrimCurve(curve1=curve, point1=loc)
		else:
##			print 'curves=',curves
##			sketch.delete(objectList=curves)
			for curve in curves:
##				sketch.delete(objectList=(sketch.geometry.findAt(curve.pointOn), ))  ## 会找到所不期望的curve
				sketch.delete(objectList=(curve,))  ## correct, 有的curve，如可能是construction删不掉。

	if vertices not in empty:
		sketch.delete(objectList=vertices)

	if type1 == 'vertices':
		num_v1 = len(sketch.vertices)
	else:
		num_v1 = len(sketch.geometry)

	print num_v0 - num_v1,'objs in sketch are deleted.'

	return

def delete_all_annotations():
	## VER: 2013-06-10, v1.0

	for name in mdb.annotations.keys():
		del mdb.annotations[name]

	for vp in session.viewports.values():
		if type_of(vp.displayedObject) == 'ODB':
			odb = vp.displayedObject
##			print odb.name

			for annotation_name in odb.userData.annotations.keys():
				del odb.userData.annotations[annotation_name]

##			for annotation_name in session.odbs[odb.name].userData.annotations.keys():
##				del session.odbs[odb.name].userData.annotations[annotation_name]

	return


def unmesh_part(*parts):
	## VER: ('VER: 2012-07-25, v1.1')

	parts = real_parts(parts)
	if parts in empty:
		parts = _m.parts.values()

	names = poi_names(parts)

	a = _m.rootAssembly
	for part in parts:
		part.deleteMesh()

	a.regenerate()
	print '  '
	print '--->Deleted mesh for parts=',names

	return

def delete_viewport_annotations(viewport):
	## VER: 2013-06-10, v1.0

	viewport_type, viewport = check_viewport(viewport)
	annotations = tolist(viewport.annotationsToPlot)  ## must change to a list, otherwise, its contents is changing.

	for annotation in annotations:
		string = totext(annotation)
		loc = string.find('.userData.annotations')

		if loc > 0:
			odb = eval(string[:loc])
			del session.odbs[odb.name].userData.annotations[annotation.name]
		else:
			del mdb.annotations[annotation.name]

	return

def diameter_of_insert_hole(p1):
	## VER: 2016-09-07, v1.0
	## reference: get_hole_diameter()更好

	p1 = check_part(p1)
	nodes_top = fix_nodes_of_insert(p1,axis_side=MAX,return_label=False)
	nodes_bot = fix_nodes_of_insert(p1,axis_side=MIN,return_label=False)

	D_top = []
	D_bot = []

	for node in nodes_top:
		x,y,z = node.coordinates
		D = sqrt(x*x + y*y)*2
		D = round(D,3)
		D_top.append(D)

	for node in nodes_bot:
		x,y,z = node.coordinates
		D = sqrt(x*x + y*y)*2
		D = round(D,3)
		D_bot.append(D)

	light(nodes_top + nodes_bot)

	avg_top = round(sum(D_top)/len(D_top),3)
	avg_bot = round(sum(D_bot)/len(D_bot),3)
	print ' '
	if avg_top > avg_bot:
		print 'D_big =',D_top, ', avg =',avg_top
		print 'D_small =',D_bot, ', avg =',avg_bot
	else:
		print 'D_small =',D_top, ', avg =',avg_top
		print 'D_big =',D_bot, ', avg =',avg_bot

	return

def dig_points(part,seeds):
	## 2010-11-09, v1.0

	if type_of(seeds) == 'TUPLE':
		seeds = [seeds]

	for seed in seeds:
		x,y,z = seed
		hex_cut(part,(x-_nearby,x+_nearby),(y-_nearby,y+_nearby),(z-_nearby,z+_nearby))

	print '--->Digged',len(seeds),'points at',part.name

	return

def dir_of_sketch_line(curve):
	## VER: 2013-06-18, v1.0

	type1 = type_of(curve)
	dir1 = 'NA'
	if 'line' in type1:
		vertices = curve.getVertices()
		pointOn = curve.pointOn
		x0,y0 = pointOn

##		print len(vertices)
##		print (x0,y0)
##		print type_and_shape_of_sketch_geometry(curve)
##		print curve.getSize(point=pointOn,length=0.5)
##		globals()['curve1'] = curve

		if vertices in empty:  ## construction line
			if PK(x0,0) == 0:
				dir1 = 'V'
			elif PK(y0,0) == 0:
				dir1 = 'H'
		else:
			x1,y1 = vertices[0].coords
			PKx = PK(x1,x0)
			PKy = PK(y1,y0)
			if PKx == 0 and PKy != 0:
				dir1 = 'V'
			elif PKx !=0 and PKy == 0:
				dir1 = 'H'
			else:
				dir1 = 'slope'

	return dir1


def dir_points(p,dirs=[],x=(),y=(),z=(),setname=''):
	## VER: 2010-11-03, v2.1

	## Example:
##	dir_points(cell,dirs=['x','y'])
##	batch_divide(cell,x='p_cell_dirx')
##	batch_divide(cell,y='p_cell_diry')
	p = check_part(p)

	dirs = tolist(dirs)
	if len(dirs) > 1:
		setname = ''

	for dir1 in dirs:
		dir = dir1.lower()

		if setname == '':
			setname = 'p_' + p.name + '_dir' + dir

		if dir == 'x':
			index1 = 0
		elif dir == 'y':
			index1 = 1
		elif dir == 'z':
			index1 = 2

		points = vertice_select(p,x,y,z)

		new_list=[]
		locs = []
		for point in points:
			loc = point.pointOn[0][index1]
			if loc not in locs:
				new_list.append(point)
				locs.append(loc)

		print 'Finally',len(new_list),'vertices were selected'
		create_set(p,objs=new_list, name=setname)

		setname = ''

	return

function_labels['dimension_compare'] = 'insert','sintering','span','ratio'
def dimension_compare(small_insert,big_insert,sym='full'):
	## VER: 2016-09-30, v1.0
	## such as: compare the green part and expanded part

##	>>> dimension_compare('green','expan',sym='xy')
##
##	Dimensions of green : (23.123456, 23.123456, 6.185937) (green part)
##	Dimensions of expan : (28.737202, 28.733098, 8.049027) (expaned part)
##
##	Ratios:
##	in length: 23.123456/28.737202 =  0.8047
##	in width: 23.123456/28.733098 =  0.8048
##	in height: 6.185937/8.049027 =  0.7685

	small_insert = check_part(small_insert)
	big_insert = check_part(big_insert)

	x1,y1,z1 = poi_span(small_insert,sym=sym)
	x2,y2,z2 = poi_span(big_insert,sym=sym)

	print ' '
	print 'Dimensions of',small_insert.name,':',(x1,y1,z1),'(green part)'
	print 'Dimensions of',big_insert.name,':',(x2,y2,z2),'(expaned part)'
	print ' '
	print 'Ratios:'
	print 'in length:',str(x1) + '/' + str(x2) + ' = ',round(x1/x2,4)
	print 'in width:',str(y1) + '/' + str(y2) + ' = ', round(y1/y2,4)
	print 'in height:',str(z1) + '/' + str(z2) + ' = ',round(z1/z2,4)

	return

def dir2num(dir='x'):
	## VER: 2010-05-07

	if dir == 'x' or dir == 'X':
		dir1 = 0
	elif dir == 'y' or dir == 'Y':
		dir1 = 1
	elif dir == 'z' or dir == 'Z':
		dir1 = 2

	return dir1

from textRepr import *
def disclose(obj,level=2):
	## VER: 2011-02-12, v1.7

	print '  '
	print '**print obj.__doc__ for obj instruction and usage'
	try:
		print obj.__doc__
	except:
		print 'This object has no usage introduction.'

	print '  '
	print "**id(obj) to get an object's memory address, e.g., if id(obj1) == id(obj2), they are the same object."
	print 'id=',id(obj)

	print '  '
	print "**print dir(obj) to show obj's member properties and methods together."
	print dir(obj)

	print '  '
	print "**print obj to show obj's values, together with their corresponding keys(if possible)."
	print obj

	print '  '
	print "**str(obj) to show obj's values, together with their corresponding keys(if possible), and store in a string"
	print str(obj)

	print '  '
	print "**print obj.__members__ to show obj's member properties only, without value."
	try:
		print obj.__members__
	except:
		print 'This object has no member property.'

	print '  '
	print '**prettyPrint(obj,level), similiar to print, but show more values and with structures.'
	print prettyPrint(obj,level)

	print '  '
	print "**print obj.__methods__ to show obj's methods only, without member property."
	try:
		meth = obj.__methods__
		print '---'
		for i in range(len(meth)):
			if meth[i][0] <= 'Z':
				if i <= len(meth) - 2 and meth[i+1][0] <='Z':
					print meth[i] + '(), ',
				else:
					print meth[i] + '()'
			else:
				break

		print '---'
		for i in range(len(meth)):
			if meth[i][0] >= 'a':
				if i <= len(meth) - 2:
					print meth[i] + '(), ',
				else:
					print meth[i] + '()'
	except:
		print 'This object has no method.'

	print '  '
	print "**type(obj) to get an object's data type"
	print 'type(obj)=',type(obj)

	print '  '
	print "**repr(obj) to get an object's root path. So, eval(repr(obj)) is the deep copy of obj."
	print 'repr(obj)=',repr(obj)

	print ' '
	print 'disclose level=',level
	print ' '

	return

def disp_group(objs, name1='group1'):
	##VER: 2014-04-30, v1.0, note: display group will not save in the cae file.

	## For display group in odb:
	## current display group object: vpnow.odbDisplay.displayGroup
	## All display group objects: session.displayGroups.keys()

##	>>> session.displayGroups.keys()
##	['All', 'arc_ymax']
##	>>>

	if type_of(objs) == 'SEQUENCE':
		Sequence = objs
	else:
		Sequence = list2sequence(objs)

	objectType = type_of(sequence[0])
	name1 = new_key(session.displayGroups.keys(), name1)

	if objectType == 'cells':
		leaf = dgm.LeafFromGeometry(cellSeq=Sequence)
	elif objectType == 'faces':
		leaf = dgm.LeafFromGeometry(faceSeq=Sequence)
	elif objectType == 'edges':
		leaf = dgm.LeafFromGeometry(edgeSeq=Sequence)

	print '--->Created display group, named',name1,', type =',objectType

	dg = session.DisplayGroup(leaf=leaf, name=name1)
	dg = session.displayGroups[name1]

	return	dg

def add_dimension(entity1,entity2=None,distance=1.0,fix_x=False,fix_y=False):
	## VER: 2015-10-13, v1.1

	if 'arc' in type_of(entity1) or 'circle' in type_of(entity1):
		arc = entity1
		vertices = arc.getVertices()
		entity1 = vertices[-1]

	if type_of(entity1) != 'vertices':
		raise Exception('*** a vertice is required.')

	point = entity1
	sketch = get_parent(point)
	loc = point.coords

	if fix_x == True:
		text_loc = loc[0] + 1,loc[1]
		line1 = vertical_construction(sketch,loc=loc)
		sketch.DistanceDimension(entity1=point,entity2=line1,textPoint=text_loc,value=0)
	elif fix_y == True:
		text_loc = loc[0],loc[1] + 1
		line1 = horizontal_construction(sketch,loc=loc)
		sketch.DistanceDimension(entity1=point,entity2=line1,textPoint=text_loc,value=0)
	else:
		if entity2 not in sketch.geometry.values() and entity2 not in sketch.vertices.values():
			raise Exception('*** Invalid entity2 for constraint.')

		if is_number(distance) == False:
			raise Exception('*** distance is required.')

		text_loc = loc[0] + 1,loc[1]
		sketch.DistanceDimension(entity1=point,entity2=entity2,textPoint=text_loc,value=distance)

	return

def radial_constraint(arc,radius=None):
	## VER: 2014-09-10, v1.0

	type1 = type_of(arc)
	if 'arc' not in type1 and 'circle' not in type1:  ## regular_arc, regular_circle
		raise Exception('*** an arc or circle is required.')

	id = arc.id
	sketch = get_parent(arc)

	if radius in empty:
		radius = radius_of_geometry(arc)

	loc = arc.pointOn
	loc = loc[0] + 1, loc[1]

	sketch.RadialDimension(curve=sketch.geometry[id],textPoint=loc, radius=radius)

	return

def arc_constraint(arc,fix_R=True,fix_x=None,fix_y=None,distance=None,entity2=None,radius=None):
	## VER: 2014-09-10, v1.0

## 圆与直线相切，然后autotrim的例子。
##	connect_points(s1,(ejector_OD/2 + 0.5, 0), (ejector_OD/2.0, 0), (ejector_OD/2.0 - ejector_land), xtilt(-ejector_OD/2.0,  ejector_tangent_angle - 90))
##	id1 = s1.geometry.values()[-1].id
##	s1.FixedConstraint(entity=s1.geometry[id1])
##
##	create_arc(s1,center=(0,2*ejector_R),radius=ejector_R,quarter=4)
##	id2 = s1.geometry.values()[-1].id
##	arc_constraint(s1.geometry[id2],fix_x=True)
##
##	tangent_constraint(s1,id1,id2)
##
##	trim_geometry(s1,y=MAX1)
##	trim_geometry(s1,y=MIN1)

	type1 = type_of(arc)
	if 'arc' not in type1 and 'circle' not in type1:  ## regular_arc, regular_circle
		raise Exception('*** an arc or circle is required.')

	if fix_R == True:
		radial_constraint(arc,radius=radius)

	if fix_x == True or fix_y == True:
		add_dimension(arc,entity2=entity2, fix_x=fix_x, fix_y=fix_y, distance=distance)

	return

def fix_constraint(obj):
	## VER: 2014-09-10, v1.0

##	print fnln(),repr(obj)
	sketch = get_parent(obj)
##	print fnln(),type_of(sketch)
##	raise Exception
	sketch.FixedConstraint(entity=obj)

	return sketch.constraints.keys()[-1]


def tangent_constraint(sketch, entity1,entity2):
	## VER: 2015-10-13, v1.1

## 圆与直线相切，然后autotrim的例子。
##	connect_points(s1,(ejector_OD/2 + 0.5, 0), (ejector_OD/2.0, 0), (ejector_OD/2.0 - ejector_land), xtilt(-ejector_OD/2.0,  ejector_tangent_angle - 90))
##	id1 = s1.geometry.values()[-1].id
##	s1.FixedConstraint(entity=s1.geometry[id1])
##
##	create_arc(s1,center=(0,2*ejector_R),radius=ejector_R,quarter=4)
##	id2 = s1.geometry.values()[-1].id
##	arc_constraint(s1.geometry[id2],fix_x=True)
##
##	tangent_constraint(s1,id1,id2)
##
##	trim_geometry(s1,y=MAX1)
##	trim_geometry(s1,y=MIN1)

	sketch = check_sketch(sketch)

	if is_number(entity1) and entity1 in sketch.geometry.keys():
		entity1 = sketch.geometry[entity1]

	if is_number(entity2) and entity2 in sketch.geometry.keys():
		entity2 = sketch.geometry[entity2]

	sketch.TangentConstraint(entity1=entity1, entity2=entity2)	## entity1是要被约束的实体, entity2是一个辅助线等。

	point1 = entity1.pointOn
	point2 = entity2.pointOn

	locs0 = locs_of_sketch_vertices('sk_ejector')

	sketch.breakCurve(curve1=entity1, point1=point1, curve2=entity2, point2=point2)
	new_locs = new_points_of_sketch(sketch,locs0)
	tangent_loc = new_locs[0]

##	print last_point

##
##	curve3 = sketch.geometry.findAt(coordinates=point1, printWarning=False)
##	entity3 = curve1
##
##	sketch.breakCurve(curve1=entity2, point1=point2, curve2=entity1, point2=point1)

	return 	tangent_loc


def divide(p,axis='x',offset=0,cells=(),faces=(),edges=(),poiRefX=(),poiRefY=(),poiRefZ=(),ref_locx=(),ref_locy=(),ref_locz=(),
	x=None,y=None,z=None,rangeX=(),rangeY=(),rangeZ=(),PRx=None,PRy=None,PRz=None):
	## VER: ('VER: 2016-10-21, v3.2')
	## divide by datum plane, can divide 1D, 2D, and 3D parts.

	## case is a 2D model
##	faces = face_select(case,y=(_ymax(nib_A1), MAX))
##	divide(case,faces=faces,x=case_ID/2.0)


	global _divide_num, default_plot

	p = check_part(p)
	axis = axis.lower()

	if PRx not in empty:
		poiRefX = PRx
	if PRy not in empty:
		poiRefY = PRy
	if PRz not in empty:
		poiRefZ = PRz

	callers = caller_names()
	if not show_in_items(callers,'divide'):
		clear_datum_points(p)

	x,y,z = real_xyz(p,x,y,z)
##	print fnln(), 'x,y,z=',(x,y,z)

	if is_empties(poiRefX,poiRefY,poiRefZ) == False:
		x1,x2,y1,y2,z1,z2 = real_space(p,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ,empty2space=True)
		print fnln(),'***z1,z2=',(z1,z2)
		if poiRefX not in empty:
			if poiRefX[1] > 0:
				x = x2
			else:
				x = x1
		elif poiRefY not in empty:
			if poiRefY[1] > 0:
				y = y2
			else:
				y = y1
		elif poiRefZ not in empty:
			if poiRefZ[1] > 0:  ## 上偏移
				z = z2
			else:
				z = z1  ##下偏移

	if x not in empty:
		x = tolist(x)
		if len(x) == 1:
			axis = 'x'
			offset = x[0]
		elif len(x) == 2:
			rangeX = x

	if y not in empty:
		y = tolist(y)
		if len(y) == 1:
			axis = 'y'
			offset = y[0]
		elif len(y) == 2:
			rangeY = y

	if z not in empty:
		z = tolist(z)
		if len(z) == 1:
			axis = 'z'
			offset = z[0]
		elif len(z) == 2:
			rangeZ = z

	if type_of(offset) == 'LIST':
		batch_divide(p,axis=axis,offsets=offset)
		return

	if axis == 'x':
		plane1 = YZPLANE
	elif axis == 'y':
		plane1 = XZPLANE
	elif axis == 'z':
		plane1 = XYPLANE

	if type_of(cells) == 'STR' and cells not in empty:
		cells = set2objs(cells,p)

	if rangeX not in empty or rangeY not in empty or rangeZ not in empty:
		cells = cell_select(p,cells=cells,x=rangeX,y=rangeY,z=rangeZ)

	p.DatumPlaneByPrincipalPlane(offset=offset, principalPlane=plane1)
	Datum_index = p.datums.keys()[-1]

	objs = []
	if cells not in empty:
		objs = tolist(cells)
	elif faces not in empty:
		objs = tolist(faces)
	elif edges not in empty:
		objs = tolist(objs)

	if objs in empty:
		if len(p.cells) > 0:
			objs = list(p.cells)
		elif len(p.faces) > 0:
			objs = list(p.faces)
		elif len(p.edges) > 0:
			objs = list(p.edges)

	divided = False
	if objs not in empty:
		if len(p.cells) > 0:
			try:
				p.PartitionCellByDatumPlane(cells=objs, datumPlane=p.datums[Datum_index])
				divided = True
			except:
				print fnln(),'partition failed.'
				pass
		elif len(p.faces) > 0:
			try:
				p.PartitionFaceByDatumPlane(faces=objs, datumPlane=p.datums[Datum_index])
				divided = True
			except:
				pass
		elif len(p.edges) > 0:
			try:
				p.PartitionEdgeByDatumPlane(edges=objs, datumPlane=p.datums[Datum_index])
				divided = True
			except:
				pass

	if divided:
		_divide_num = _divide_num + 1
		print '--->Performed partition for',p.name,', divide#=',_divide_num, ',', axis,'=',offset

	if 'temp' not in p.name:
		default_plot = p.name
	else:
		default_plot = _m.parts.values()[0]

##	return divided
	return offset

def divide_bycorner(p,ndir,bolt_inst,D1=30,depth=-5,bolt_KP='OB',setname='hole_nearby'):
	## 2011-01-07, v1.3

	center0 = KPxyz(bolt_KP,bolt_inst)
	R = D1/2
	x0 = center0[0];	y0 = center0[1];	z0 = center0[2]

	if ndir == 'x':
		x = (x0,x0 + depth)
		y = (y0 - R - _nearby, y0 + R + _nearby)
		z = (z0 - R - _nearby, z0 + R + _nearby)
	elif ndir == 'y':
		x = (x0 - R - _nearby, x0 + R + _nearby)
		y = (y0, y0 + depth)
		z = (z0 - R - _nearby, z0 + R + _nearby)
	elif ndir == 'z':
		x = (x0 - R - _nearby, x0 + R + _nearby)
		y = (y0 - R - _nearby, y0 + R + _nearby)
		z = (z0, z0 + depth)

	cells = cell_select_by_container(p,x,y,z)
	create_set(p,objs=cells,name=setname,check_name=True)
	corner_divide(p,ndir=ndir,setname=setname)
	del p.sets[setname]

	return


def divide_by3points(p,loc1='',loc2='',loc3='',cells=''):
	## VER: 2010-02-04
##	if cells == '':
	if cells in empty:
		cells = tolist(p.cells)

	p.PartitionCellByPlaneThreePoints(point1=point_at(p,loc1), point2=point_at(p,loc2), point3=point_at(p,loc3), cells=cells)
	print '--->Divided',p.name,'by the plane defined through 3 points'

	return

def divide_by_datum_plane(part,plane,cells=None):
	## VER: 2015-07-06, v1.0

	## Example: 用一个part的face去切割另外一个part的cells
##	faces = face_select('Cap',x=MAX1,ny=-1,shape='plane')
##	divide_by_datum_plane('cylind',plane=faces[0])

	part = check_part(part)
	if cells  in empty:
		cells = part.cells[:]
	seq = list2sequence(cells)

	if type_of(plane) == 'faces':
		plane = create_datum_plane_by_3points(part,face=plane)

	if type_of(plane) != 'DATUMPLANE':
		raise Exception('*** A datum plane is required.')

	num0 = len(part.cells)
	part.PartitionCellByDatumPlane(datumPlane=plane, cells=seq)
	part.regenerate()

	num1 = len(part.cells)
	if num1 > num0:
		print fnln(),'--->',part.name,'is divided by datum plane'

	return

function_labels['divide_by_face'] = 'divide','partition','circular','radial'
def divide_by_face(p,face,cells=None):
	## VER: 2015-07-05, v1., self divide. face 可以是是obj_at()得到的字典类型的对象。face可能是一个平面，也可能是一个圆柱面。
	## 只能by 一个 face，而且是p上的face，不能是别的part上的。

	## 例如：mid目前有两个盲孔，分别需要剖分透
##	faces = face_select(mid,D=holeD)
##	loc = faces[1].pointOn[0]
##	divide_by_face(mid,faces[0])
##	divide_by_face(mid,face_at(mid,loc=loc))   ## 不能用divide_by_face(mid,faces[1]) 因为编号变了

	## Example
##	faces = face_select(shaft,radius=OD/2)
##	divide_by_face(shaft,face=faces[0])

	p = check_part(p)

	if len(p.cells) == 0:
		raise Exception('*** No cell in the part for divide')

	if type_of(cells) == 'faces':
		cells, face = face, cells

	face = tolist(face)
	if type_of(face[0]) != 'faces':
		raise Exception('*** a face is required. It may be a shell.')

	face = face[0]
	if cells in empty:
		cells = p.cells

	cells = tolist(cells)
	if type_of(cells[0]) != 'cells':
		raise Exception('*** cells are required.')

	sequence = list2sequence(cells)
	part = get_poi(cells[0])

	try:
		part.PartitionCellByExtendFace(extendFace=face, cells=sequence)
		print '--->',part.name,'was divided cells by extend face'
		divided = True
	except:
		divided = False

	return divided

def divide_byinst_ends(p, dir1='x', part='',insts=''):
	## VER: 2010-08-13, v1.0

	if type_of(part) == 'PART':
		insts = insts_of_parts(part)
	elif insts in empty:
		raise Exception('Parameter insts is required. line=4274, divide_byinst_ends(). ')   ## ********

	print ' '
	if part != '':
		print 'Dividing',p.name,'by ends of instances of part',part.name,'...'
	else:
		print 'Dividing',p.name,'by ends of instances...'

	for inst in insts:
		x1,x2,y1,y2,z1,z2 = poi_space(inst)
		if dir1 == 'x':
			batch_divide(p,x=[x1,x2])
		elif dir1 == 'y':
			batch_divide(p,y=[y1,y2])
		elif dir1 == 'z':
			batch_divide(p,z=[z1,z2])

	return


def divide_bypart(p,dir='x',parts=[]):
	## VER: 2010-06-27

##	parts = copy.deepcopy(parts)

	if dir == 'x':
		dir1 = 0
	elif dir == 'y':
		dir1 = 1
	elif dir == 'z':
		dir1 = 2

	locs = []
	for vertice in p.vertices:
		ploc = vertice.pointOn[0][dir1]
		if ploc not in locs:
			locs.append(ploc)

	locs.sort()

##	if parts == [] or parts == '':
	if parts in empty:
		parts = _m.parts.values()
	elif type_of(parts) == 'PART':
		parts = [parts]

	print '  '
	print 'Performing cross-divide in',dir,'by part=',p.name,'...'
	batch_divide(parts,axis=dir,offsets=locs)

	return

def divide_bypointNormal(p,loc=(),normal='',cells = 'all'):
	## VER: 2010-03-12

	if cells == 'all':
		cells = tolist(p.cells)

	if type_of(normal) == 'STR':
		edge_set = normal
		p1 = part_byset(edge_set)
		edge1 = set2objs(edge_set,p1)[0]

	p.PartitionCellByPlanePointNormal(normal=edge1, cells=cells, point=point_at(p,loc))

	print '--->',p.name,'was divided by point and normal method'

	return

def divide_edge(edges,parameter=0.5,x=None,y=None,z=None,xpar=None,ypar=None,zpar=None, datum_plane=None):
	## VER: 2014-12-26, v1.3, default to be divide at mid point.
	## 不能用一个loc去partition，只能用其中的x, y, or z
	## 即使对于axisymmetric模型也适用。

	## Example:
	## edges = edge_select(powder,x=MIN)
	## divide_edge(edges[0],ypar=0.3)

	## Example:
##	edges = edge_select(powder,ny=-1)
##	vertices =vertice_select(powder,edges=edges,xpoint=MIN1)
##	loc = vertices[0].pointOn[0]
##	ignore_vertices(powder,vertices=vertices)
##
##	edges = edge_select(powder,x=MIN1,ny=-1)
##	divide_edge(edges[0],x=loc[0])
##	edges = edge_select(powder,x=MIN1,ny=-1)
##	radius = get_radius(edges[0])
##	print radius


	edges = tolist(edges)

	if type_of(edges[0]) != 'edges':
		raise Exception('*** edges are required.')

	seq = list2sequence(edges)

	part = get_poi(edges[0])
	if type_of(part) != 'PART':
		raise Exception('*** edges should be from part.')

	x,y,z = real_xyz(part,x,y,z)
	if is_number(x):
		datum_plane = create_plane_x(part,x=x)
	elif is_number(y):
		datum_plane = create_plane_y(part,y=y)
	elif is_number(z):
		datum_plane = create_plane_z(part,z=z)

	if type_of(datum_plane) == 'DATUMPLANE':
		part.PartitionEdgeByDatumPlane(datumPlane=datum_plane, edges=seq)

	else:  ## parameter method
		for edge in edges:
			indexs = edge.getVertices()
			x1,y1,z1 = part.vertices[indexs[0]].pointOn[0]
			x2,y2,z2 = part.vertices[indexs[1]].pointOn[0]

			if is_number(xpar):
				if 0 < xpar < 1:
					if x2 > x1:
						parameter = xpar
					else:
						parameter = 1 - xpar
				else:
					raise Exception('*** xpar should be between 0 and 1')

			elif is_number(ypar):
				if 0 < ypar < 1:
					if y2 > y1:
						parameter = ypar
					else:
						parameter = 1 - ypar
				else:
					raise Exception('*** ypar should be between 0 and 1')

			elif is_number(zpar):
				if 0 < zpar < 1:
					if z2 > z1:
						parameter = zpar
					else:
						parameter = 1 - zpar
				else:
					raise Exception('*** zpar should be between 0 and 1')

			seq = part.edges[edge.index:edge.index + 1]
			part.PartitionEdgeByParam(edges=seq, parameter=parameter)

	return

def divide_faces(faces,p=None,x=None,y=None,z=None,cross_loc=None):
	## VER: 2015-07-07, v1.3. cross_loc != None时，返回faces。否则返回成功与否(True or False).
	## 通常需要提供cross_loc，然后在三个方向上分别partition

	global default_plot

	if is_part(faces):
		p,faces = faces,p

	if p in empty:
		p = get_poi(faces)

	p = check_part(p)
	if type_of(faces) == 'STR':
		faces = set2objs(faces,p)

	if cross_loc not in empty:      ## 这是partition之前
		if type_of(faces) == 'STR':  ## 已经是一个set
			faceset = faces			  ## 保留set的名称
			faces = set2objs(faceset,p)
		else:
			faces = tolist(faces)
			faceset = '_faceset'      ##将partition之前的faces命名为一个set
			create_set(objs=faces,p=p,name=faceset)

		if cross_loc == 'pointOn':
			cross_loc = set2objs(faceset,p)[0].pointOn[0]

		divide_faces(faces=faceset,p=p,x=cross_loc[0])
		divide_faces(faces=faceset,p=p,y=cross_loc[1])
		divide_faces(faces=faceset,p=p,z=cross_loc[2])

		faces = set2objs(p,faceset)

		return faces

	else:
		offset = None
		if type_of(faces) == 'STR':
			faces = set2objs(faces,p)

		ndir = None
		if x not in empty:
			ndir = 'x'
			offset = x
		elif y not in empty:
			ndir = 'y'
			offset = y
		elif z not in empty:
			ndir = 'z'
			offset = z

		if ndir == 'x':
			plane1 = YZPLANE
		elif ndir == 'y':
			plane1 = XZPLANE
		elif ndir == 'z':
			plane1 = XYPLANE

		p.DatumPlaneByPrincipalPlane(offset=offset, principalPlane=plane1)
		Datum_index = p.datums.keys()[-1]

		divided = False
		if faces not in empty:
			try:
				p.PartitionFaceByDatumPlane(faces=faces, datumPlane=p.datums[Datum_index])
				divided = True
			except:
				pass

##		if divided == True:
##			print '--->faces are divided in',p.name,', ndir=',ndir

##		default_plot = p.name
		default_plot = _m.parts.values()[0]

	return divided

def divide_faces_by_two_points(p,point1,point2,faces=None):
	## VER: 2015-04-16, v1.3
	## use shortest path between two points

##	loc1 = loc_at('powder',y=MID,x=MIN)
##	loc2 = loc_at('powder',y=MID,x=MAX)
##	loc1 = loc1[0],loc1[1]-_ylength(bpunch),loc1[2]
##	divide_faces_by_two_points('powder',point1=loc1,point2=loc2)


	## Example:
##	point1 = ejector_w.vertices[1]
##	point2 = (_xmax(powder_s) - 1.5, _ymax(powder_s),0)
##	divide_faces_by_two_points(powder_s, faces=powder_s.faces, point1=point1, point2=point2)

	p = check_poi(p)
	p0 = p

	if faces in empty:
		faces = p.faces[:]

	seq = list2sequence(faces)

	faces_num = len(p.faces)

	if is_location(point1):
		point1 = point_at(p,loc=point1)

	if is_location(point2):
		point2 = point_at(p,loc=point2)

	if type_of(point1) not in ['vertices','DATUMPOINT'] or type_of(point2) not in ['vertices','DATUMPOINT']:
		raise Exception('*** vertice or datum point is required for face partition')

	if type_of(p) == 'ASSEMBLY':
		p = a

##	print fnln(),'point1=',point1, type_of(point1)
##	print fnln(),'point1=',point1, type_of(point1)

	p.PartitionFaceByShortestPath(faces=seq, point1=point1, point2=point2)
	faces_num1 = len(p0.faces)

	if faces_num1 > faces_num:
		print '--->faces of',p0.name,'is partitioned by divide_faces_by_two_points()'

	return


def divide_frame_by_clamp(clamp_inst,clamp_edge='long'):

	## VER: ('VER: 2012-07-18, v1.0')	## 面向clamp_inst对象，而不是面向clamp part对象

	clamp_inst=check_inst(clamp_inst)
	clamp = clamp_inst.part

	if has_frame == False or has_mount_clamp == False:
		return

	if mount_method != 'hole':
		if clamp_edge == 'long':
			batch_divide(frL,y=[_ymin(clamp_inst) - clamp_esize, _ymin(clamp_inst)])				;please_check
			if _ymax(frL) - _ymax(clamp_inst) - 35 > clamp_esize:
				batch_divide(frL,y=[_ymax(clamp_inst), _ymax(clamp_inst) + clamp_esize])

		elif clamp_edge == 'short':
			batch_divide(frS,x=[_xmin(clamp_inst) - clamp_esize, _xmin(clamp_inst)])				;please_check
			if _xmax(frS) - _xmax(clamp_inst) - 35 > clamp_esize:
				batch_divide(frS,y=[_xmax(clamp_inst), _xmax(clamp_inst) + clamp_esize])

	return

def divide_instances(insts=None,x=None,y=None,z=None):
	## VER: 2016-09-02, v1.0

	get_current_model()
	insts = real_insts(insts)
	parts = parts_of_insts(insts)

	if is_number(x):
		for part in parts:
			divide(part,x=x)
	elif is_number(y):
		for part in parts:
			divide(part,y=y)
	elif is_number(z):
		for part in parts:
			divide(part,z=z)
	else:
		raise Exception('*** x,y,or z should be numerical data.')

	a.regenerate()

	return

def divide_insts(insts=[],x=None,y=None,z=None):
	## VER: 2011-01-17, v1.1

	insts = real_insts(insts)

	offset = None
	if x not in empty:
		axis = 'x'
		offset = x
	elif y not in empty:
		axis = 'y'
		offset = y
	elif z not in empty:
		axis = 'z'
		offset = z

	offset = tolist(offset)
	offset0 = offset

	if offset != None:
		for inst in insts:
			offset = offset0
			part = inst.part
			space1 = poi_space(inst)
			space2 = poi_space(part)
			dx = space2[0] - space1[0]
			dy = space2[2] - space1[2]
			dz = space2[4] - space1[4]

			if axis == 'x':
				list_op(offset,'+',dx)
			elif axis == 'y':
				list_op(offset,'+',dy)
			elif axis == 'z':
				list_op(offset,'+',dz)

			divide(part,axis=axis,offset=offset)
			a.regenerate()

	return

def divide_part_in_clamp(clamp,clamp_edge='long+'):
	## VER: 2012-10-30, v1.1, 注意，clamp也可能是clamp的某一个instance.

	clamp = check_part(clamp)

	if '+' not in clamp_edge and '-' not in clamp_edge:
		clamp_edge = clamp_edge + '+'

	if has_frame == True:  ## clamping frame
		if clamp_edge == 'long+':
			batch_divide(frL,y=[_ymin(clamp) - clamp_esize, _ymin(clamp)])				;please_check
			if _ymax(frL) - _ymax(clamp) - 35 > clamp_esize:
				batch_divide(frL,y=[_ymax(clamp), _ymax(clamp) + clamp_esize])

		elif clamp_edge == 'short+':
			batch_divide(frS,x=[_xmin(clamp) - clamp_esize, _xmin(clamp)])				;please_check
			if _xmax(frS) - _xmax(clamp) - 35 > clamp_esize:
				batch_divide(frS,y=[_xmax(clamp), _xmax(clamp) + clamp_esize])

	elif has_frame == False:   ## clamping lam
		if clamp_edge == 'long+':
			batch_divide(lam,y=[_ymin(clamp) - clamp_esize, _ymin(clamp), _ymax(clamp), _ymax(clamp) + clamp_esize])				;please_check
			divide(lam,x=_xmin(clamp))

		elif clamp_edge == 'short+':
			batch_divide(lam,x=[_xmin(clamp) - clamp_esize, _xmin(clamp), _xmax(clamp), _xmax(clamp) + clamp_esize])				;please_check
			divide(lam,y=_ymin(clamp))

	return

def divide_edge_by_loc(part=None,edge=None,loc=None,point=None,x=None,y=None,z=None):
	## VER: 2013-06-23, v1.0

	if type_of(edge) == 'PART':
		part,edge = edge, part

	if part in empty:
		part = get_poi(edge)

	x,y,z = real_xyz(part,x,y,z)
	if is_empties(x,y,z) == False:
		if x in empty:
			x = 0
		if y in empty:
			y = 0
		if z in empty:
			z = 0
		loc = (x,y,z)

	if is_location(point):
		loc = point

	if is_location(loc) == True:
		point = create_datum_point(p=part,loc=loc)

	if edge in empty:
		if type_of(point) == 'vertices':
			loc = point.pointOn[0]
		elif type_of(point) == 'DATUMPOINT':
			loc=point.pointOn

		if is_location(loc):
			edges = edges_at(part,loc=loc)
			if edges in empty:
				raise Exception('**** No edge was found at loc= ' + repr(loc))
			edge = edges[0]

	if type_of(point) in ['vertices','DATUMPOINT'] and type_of(edge) == 'edges':
		part.PartitionEdgeByPoint(edge=edge, point=point)

	return

def divide_edge_by_par(p,edges=[],par=0.5):
	## VER: 2010-04-26

	if type_of(edges) == 'STR':
		edges = set2objs('e_hole_circum',p)
	p.PartitionEdgeByParam(edges=edges, parameter=0.5)

	print '--->',len(edges),'divided by parameter=',par

	return

function_labels['displacement_BC_of_inst'] = 'powder compaction','displacement','BC','instance','PV, OB, AB, PH, PFH'
def displacement_BC_of_inst(inst,dir1=None,finish_step=None):
	## VER: 2016-12-23, v1.3

##	>>> displacement_BC_of_inst('punch_A1')
##	---in step 1, step name= under filling , action= CREATED , BC name= punch
##	** settings = {'amplitude': 'amp_underfilling', 'u1': 0.0, 'u3': -20.0, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	---in step 2, step name= low pressing , action= MODIFIED , BC name= punch
##	** settings = {'amplitude': 'amp_lowpressing', 'u1': 0.0, 'u3': -25.0, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	---in step 3, step name= up pressing , action= MODIFIED , BC name= punch
##	** settings = {'amplitude': 'amp_uppressing', 'u1': 0.0, 'u3': -0.759, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	---in step 4, step name= ejection , action= MODIFIED , BC name= punch
##	** settings = {'amplitude': 'amp_uppressing', 'u1': 0.0, 'u3': 1.0, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	{'u1': [0.0, 0.0, 0.0, 0.0], 'u3': [-20.0, -25.0, -0.759, 1.0], 'u2': [0.0, 0.0, 0.0, 0.0], 'ur1': [0.0, 0.0, 0.0, 0.0], 'ur2': [0.0, 0.0, 0.0, 0.0], 'ur3': [0.0, 0.0, 0.0, 0.0]}
##  >>>
##	>>> displacement_BC_of_inst('punch_A1',finish_step=3)
##	---in step 1, step name= under filling , action= CREATED , BC name= punch
##	** settings = {'amplitude': 'amp_underfilling', 'u1': 0.0, 'u3': -20.0, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	---in step 2, step name= low pressing , action= MODIFIED , BC name= punch
##	** settings = {'amplitude': 'amp_lowpressing', 'u1': 0.0, 'u3': -25.0, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	---in step 3, step name= up pressing , action= MODIFIED , BC name= punch
##	** settings = {'amplitude': 'amp_uppressing', 'u1': 0.0, 'u3': -0.759, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	---in step 4, step name= ejection , action= MODIFIED , BC name= punch
##	** settings = {'amplitude': 'amp_uppressing', 'u1': 0.0, 'u3': 1.0, 'u2': 0.0, 'ur1': 0.0, 'ur2': 0.0, 'ur3': 0.0}
##
##	{'u1': [0.0, 0.0, 0.0], 'u3': [-20.0, -25.0, -0.759], 'u2': [0.0, 0.0, 0.0], 'ur1': [0.0, 0.0, 0.0], 'ur2': [0.0, 0.0, 0.0], 'ur3': [0.0, 0.0, 0.0]}
##	>>>

##	>>> displacement_BC_of_inst('die_A1')
##	---in step 1, step name= move , action= CREATED , BC name= fix_RP_die_A1
##	** settings = {'u1': 0.0, 'ur3': 0.0}
##
##	---in step 1, step name= move , action= CREATED , BC name= fix_RP_die_A2
##	** settings = {'amplitude': 'die_move', 'u2': 1.0}
##
##	['displacement_BC_of_inst', 35] amplitude= ((0.0, 0.0), (0.1, 0.0), (0.5, -21.0), (1.0, -21.0))
##	['displacement_BC_of_inst', 36] step_time= 1.0
##	{'u2': [-21.0], 'u1': [0.0], 'ur3': [0.0]}
##	>>> displacement_BC_of_inst('tpunch_A1')
##	---in step 1, step name= move , action= CREATED , BC name= fix_RP_tpunch_A1
##	** settings = {'u1': 0.0, 'ur3': 0.0}
##
##	---in step 1, step name= move , action= CREATED , BC name= fix_RP_tpunch_A2
##	** settings = {'amplitude': 'top_move', 'u2': 1.0}
##
##	['displacement_BC_of_inst', 35] amplitude= ((0.0, 0.0), (0.1, -4.0), (0.5, -25.0), (1.0, -45.4))
##	['displacement_BC_of_inst', 36] step_time= 1.0
##	{'u2': [-45.4], 'u1': [0.0], 'ur3': [0.0]}
##	>>>

##	>>> displacement_BC_of_inst('tpunch_A1',dir1='y')
##	---in step 1, step name= move , action= CREATED , BC name= fix_RP_tpunch_A1
##	** settings = {'u1': 0.0, 'ur3': 0.0}
##
##	---in step 1, step name= move , action= CREATED , BC name= fix_RP_tpunch_A2
##	** settings = {'amplitude': 'top_move', 'u2': 1.0}
##
##	['displacement_BC_of_inst', 57] amplitude= ((0.0, 0.0), (0.1, -4.0), (0.5, -25.0), (1.0, -45.4))
##	['displacement_BC_of_inst', 58] step_time= 1.0
##	-45.4
##	>>>

	inst = check_inst(inst)
	dict1 = {}
	BCs = ['u1','u2','u3','ur1','ur2','ur3']
	BCs1 = valid_BCs()
	for BC in BCs1:
		insts = instances_of_BC(BC)
		if inst in insts:
			settings = settings_of_BC(BC)
			for step in settings.keys():
				if is_number(finish_step) and step > finish_step:  ## 0:Initial, 1:under filling, 2: lower pressing, 3: upper pressing, 4: ejection, 此时finish_step=3
					break

				if is_number(step) == False:  ## such as key: insts
					continue

				step1 = _m.steps.values()[step]
##				print fnln(),'BC=',BC

				dict2 = settings[step]
				amplitude = None
				if 'amplitude' in dict2.keys():
##					print fnln(),'BC=',BC
					am1 = dict2['amplitude']
					if am1 not in empty:  ## 有时，am1=''，比如，created时有amplitude, modify之后没有amplitude了
##						print fnln(),dict2.keys()
##						print fnln(),'am1=',am1
						amplitude = _m.amplitudes[am1]

				for key in dict2.keys():
					if key in BCs:
						step_time = step1.timePeriod   ## Initial step没有step time，当然也不会有timePeriod
						if key not in dict1.keys():
							dict1[key] = []

						if amplitude == None:
							dict1[key].append(dict2[key])
						else:
							magnitude = dict2[key]   ## 通常factor=1
							time1 = mapping(amplitude.data,index=0)
							disp = mapping(amplitude.data,factor=magnitude, index=1)

##							print fnln(),'amplitude=',amplitude.data
##							print fnln(),'step_time=',step_time

							if step_time in time1:
								index = get_sequence_index(time1,step_time)
								dict1[key].append(disp[index])
							elif step_time > time1[-1]:
								dict1[key].append(disp[-1])
							else:
								for i in range(len(time1)-1):
									t1 = time1[i];	t2=time1[i+1]
									if t1 < step_time < t2:
										v1 = disp[i];	v2=disp[i+1]
										v = (v2-v1)/(t2-t1)*(step_time - t1) + v1
										dict1[key].append(v)

##	for i in range(len(_m.steps))[1:]:  ## step index
##		if i not in dict1.keys():
##			dict1[i] = {'u1':0,'u2':0,'u3':0,'ur1':0,'ur2':0,'ur3':0}

##	print fnln(),'dict1=',dict1  ## dict1= {'u1': [0.0, 0.0, 0.0], 'u3': [0.0, 3.15, 0.0], 'u2': [0.0, 0.0, 0.0], 'ur1': [0.0, 0.0, 0.0], 'ur2': [0.0, 0.0, 0.0], 'ur3': [0.0, 0.0, 0.0]}
##	print dict1.keys()  ## ['u1', 'u3', 'u2', 'ur1', 'ur2', 'ur3']
##	raise Exception

	## to avoid
	if is_number(finish_step) == False:
		for dof in dict1:
			list1 = dict1[dof]
			if list1[0] != 0:
				while len(list1) > 0:
					if list1[-1]*list1[0] < 0:
						list1 = list1[:-1]
					else:
						break
			dict1[dof] = list1

	result = dict1
	if type_of(dir1) == 'STR':
		dir1 = dir1.lower()
		if dir1 == 'x':
			dir1 = 'u1'
		elif dir1 == 'y':
			dir1 = 'u2'
		elif dir1 == 'z':
			dir1 = 'u3'

		if dir1 not in dict1.keys():
			raise Exception('*** Invalid dir1')

		result = sum(dict1[dir1])  ## a value

	return result

def displacement_of_node(label,inst=None,frame=-1,step=-1,frame_values=None):
	## VER: 2015-07-29, v1.1, get the displacement of node, cannot get the coord of node.
	## reference: coord_of_node(), 获得指定step and 指定frame的node的coord

##	>>> displacement_of_node(34471)
##	(1.1352899, 0.031021599, -0.97657216)
##	>>>

##	>>> frame
##	session.openOdb(r'E:/FEM/A0242_sintering_simple/D0235-insert_original_2784_increment.odb').steps['uppressing'].frames[10]
##	>>> Uset = frame.fieldOutputs['U'].values
##	>>> type_of(frame)
##	'ODBFRAME'
##	>>>
##	>>> type_of(Uset)
##	'FIELDVALUEARRAY'
##	>>>

##	>>> Uset[0]
##	session.openOdb(r'E:/FEM/A0242_sintering_simple/D0235-insert_original_2784_increment.odb').steps['uppressing'].frames[10].fieldOutputs['U'].values[0]
##	>>> Uset[0].label
##	AttributeError: 'FieldValue' object has no attribute 'label'
##	>>>
##	>>> Uset[0].nodeLabel
##	332
##	>>> Uset[0].instance.name
##	'ORINGIAL_POWDER-1'
##	>>> Uset[2].nodeLabel
##	334
##	>>> x,y,z = Uset[0].data
##	>>> x,y,z
##	(-0.063416742, -1.3753288, -10.197838)
##	>>>
##	>>> inst = 'ORINGIAL_POWDER-1'
##	>>>
##	>>> displacement_of_node(Uset,inst=inst,label=1)
##	(-0.014415227, 0.023792325, -7.8206434)
##	>>>

	if inst in empty:
		inst = oa.instances.keys()[0]

	if type_of(frame_values) == 'ODBFRAME':
		frame = frame_values
		frame_values = frame.fieldOutputs['U'].values

	else:
		step_id, frame_id = set_step_and_frame(step=step,frame=frame)
		frame_values = odb.steps.values()[step_id].frames[frame_id].fieldOutputs['U'].values

	if type_of(frame_values) != 'FIELDVALUEARRAY':
		raise Exception('*** Field value array is required.')

	if type_of(inst) == 'INT' and type_of(label) == 'STR':
		label,inst = inst,label

	for item in frame_values:
		if item.instance.name == inst and item.nodeLabel == label:
			x,y,z = item.data

	return x,y,z

def xdist_of_nodes(node1,node2,p=None,frame=-1,step=-1):
	## VER: 2015-09-30, v1.0

##	>>> xdist_of_nodes(1,100)
##	9.3739
##	>>>

	if is_pia(p):
		p = check_pia(p)

	dpo = get_dpo()
	if type_of(dpo) == 'PART' and p in empty:    ## maybe imported part
		p = dpo

	if type_of(p) == 'PART':
		if is_number(node1):
			loc1 = p.nodes[node1-1].coordinates
		elif type_of(node1) == 'nodes':
			loc1 = node1.coordinates
		else:
			raise Exception('*** a node or node label is required.')

		if is_number(node2):
			loc2 = p.nodes[node2-1].coordinates
		elif type_of(node2) == 'nodes':
			loc2 = node2.coordinates
		else:
			raise Exception('*** a node or node label is required.')

	elif type_of(dpo) == 'ODB':
		if type_of(node1) == 'ODBMESHNODE':
			node1 = node1.label
		if type_of(node2) == 'ODBMESHNODE':
			node2 = node2.label

		if is_numbers(node1,node2) == False:
			raise Exception('*** Two node labels are required.')

		loc1 = coord_of_node(node1,inst=p,frame=frame,step=step)
		loc2 = coord_of_node(node2,inst=p,frame=frame,step=step)

	else:
		raise Exception('*** a part viewport or odb viewport is required.')

	D = abs(loc1[0] - loc2[0])
	D = smart_round(D)

	return D

def ydist_of_nodes(node1,node2,p=None,frame=-1,step=-1):
	## VER: 2015-09-30, v1.0

##	>>> xdist_of_nodes(1,100)
##	9.3739
##	>>>

	if is_pia(p):
		p = check_pia(p)

	dpo = get_dpo()
	if type_of(dpo) == 'PART' and p in empty:    ## maybe imported part
		p = dpo

	if type_of(p) == 'PART':
		if is_number(node1):
			loc1 = p.nodes[node1-1].coordinates
		elif type_of(node1) == 'nodes':
			loc1 = node1.coordinates
		else:
			raise Exception('*** a node or node label is required.')

		if is_number(node2):
			loc2 = p.nodes[node2-1].coordinates
		elif type_of(node2) == 'nodes':
			loc2 = node2.coordinates
		else:
			raise Exception('*** a node or node label is required.')

	elif type_of(dpo) == 'ODB':
		if type_of(node1) == 'ODBMESHNODE':
			node1 = node1.label
		if type_of(node2) == 'ODBMESHNODE':
			node2 = node2.label

		if is_numbers(node1,node2) == False:
			raise Exception('*** Two node labels are required.')

		loc1 = coord_of_node(node1,inst=p,frame=frame,step=step)
		loc2 = coord_of_node(node2,inst=p,frame=frame,step=step)

	else:
		raise Exception('*** a part viewport or odb viewport is required.')

	D = abs(loc1[1] - loc2[1])
	D = smart_round(D)

	return D

def zdist_of_nodes(node1,node2,p=None,frame=-1,step=-1):
	## VER: 2015-09-30, v1.0

##	>>> xdist_of_nodes(1,100)
##	9.3739
##	>>>

	if is_pia(p):
		p = check_pia(p)

	dpo = get_dpo()
	if type_of(dpo) == 'PART' and p in empty:    ## maybe imported part
		p = dpo

	if type_of(p) == 'PART':
		if is_number(node1):
			loc1 = p.nodes[node1-1].coordinates
		elif type_of(node1) == 'nodes':
			loc1 = node1.coordinates
		else:
			raise Exception('*** a node or node label is required.')

		if is_number(node2):
			loc2 = p.nodes[node2-1].coordinates
		elif type_of(node2) == 'nodes':
			loc2 = node2.coordinates
		else:
			raise Exception('*** a node or node label is required.')

	elif type_of(dpo) == 'ODB':
		if type_of(node1) == 'ODBMESHNODE':
			node1 = node1.label
		if type_of(node2) == 'ODBMESHNODE':
			node2 = node2.label

		if is_numbers(node1,node2) == False:
			raise Exception('*** Two node labels are required.')

		loc1 = coord_of_node(node1,inst=p,frame=frame,step=step)
		loc2 = coord_of_node(node2,inst=p,frame=frame,step=step)

	else:
		raise Exception('*** a part viewport or odb viewport is required.')

	D = abs(loc1[2] - loc2[2])
	D = smart_round(D)

	return D

def coord_of_node(label,inst=None,frame=-1,step=-1,frame_values=None):
	## VER: 2015-07-29, v1.1, get the coord of node at specified frame(frame=0 means original coord, that is, base coord).
	## Reference: displacement_of_node()
	## reference: distance_of_odb_nodes()
	## reference: span_of_odb_nodes()

##	>>> coord_of_node(34471)
##	(-5.3718939, -0.13596405, -8.4755602)

	if inst in empty:
		inst = oa.instances.keys()[0]

	if type_of(frame_values) == 'ODBFRAME':
		frame = frame_values
		frame_values = frame.fieldOutputs['COORD'].values

	else:
		step_id, frame_id = set_step_and_frame(step=step,frame=frame)
		frame_values = odb.steps.values()[step_id].frames[frame_id].fieldOutputs['COORD'].values

	if type_of(frame_values) != 'FIELDVALUEARRAY':
		raise Exception('*** Field value array is required.')

	if type_of(inst) == 'INT' and type_of(label) == 'STR':
		label,inst = inst,label

	for item in frame_values:
		if item.instance.name == inst and item.nodeLabel == label:
			x,y,z = item.data

	return x,y,z

def draw_lines_in_sketch(sketch,points,ndir='z',closed=False):
	## 2013-05-22, v1.3

	if type_of(sketch) == 'DICT' and 'ndir' in sketch.keys():
		ndir = sketch['ndir']

	sketch = check_sketch(sketch)

	x = 0;	y = 1;	z = 2
	sec_x = 0;	sec_y = 1

	ndir = ndir.lower()

	newlist = []
	for point in points:
		if 'sketch' in totext(point) and 'vertices' in totext(point):
			x1,y1 = point.coords
			newlist.append((x1,y1,0))
		elif is_location(point):
			newlist.append(point)
		else:
			raise Exception('**** Error point info, should be vertice or location.')
	points = newlist

	num = len(points)
	for i in range(num):
		points[i] = tolist(points[i])

	for point in points:
		p1 = copy.deepcopy(point)
		if ndir == 'x':
			point[sec_x] = p1[y]
			point[sec_y] = p1[z]

		elif ndir == 'y':
			point[sec_x] = p1[x]
			point[sec_y] = -p1[z]

		elif ndir == 'z':
			point[sec_x] = p1[x]
			point[sec_y] = p1[y]

	for i in range(num):
		points[i].pop(2)
		points[i] = tuple(points[i])

	for i in range(num - 1):
		sketch.Line(point1 = points[i], point2 = points[i+1])

	if closed == True:
		sketch.Line(point1 = points[num-1], point2 = points[0])

	return sketch

def drill_hole(pois,ndir=None,center=(0,0,0),x=None,y=None,z=None, D=16, radius=None, depth=None,via_hole=True,divide_extension=1.2, divide_through='no',hole_name='',divide_dir=()):
	## VER: ('VER: 2017-07-13, v3.4')
	## reference: radial_cut()

	## Example:
##	drill_hole(stamp,ndir='z',D=cylind_D,x=MID,y=-pin2end)

	global default_plot, part_holes

	pois = check_pias(pois,force_list=True)
	if type_of(radius) not in numerics:
		radius = D/2
	else:
		D = 2*radius

	print 'radius=',radius
##	raise Exception

	if x != None or y != None or z != None:
		if x == None:
			ndir = 'x'
			x = MIN
		elif y == None:
			ndir = 'y'
			y = MIN
		elif z == None:
			ndir = 'z'
			z = MIN
		center = [x,y,z]

	## backup
	depth0 = depth
	hole_name0 = hole_name
	center_bak = eval(repr(center))

	for p in pois:
		depth = depth0
		hole_name = hole_name0
		x0,y0,z0 = center_bak   ## 在instance上的位置
		x0,y0,z0 = real_xyz(p,x0,y0,z0)
		center = (x0,y0,z0)

		if type_of(p) == 'PINSTANCE':
			dx,dy,dz = p.getTranslation()
			center = (x0 - dx, y0 - dy, z0 - dz)
			p = p.part

		center = tolist(center)
		center_bak = backup(center)
		print 'center=',center

		if type_of(p) != 'PART':
			raise Exception('******part or instance is required for drill_hole().')

		if p.name not in part_holes.keys():
			part_holes[p.name] = []

		if via_hole == True and depth0 in empty:
			depth = -1e4

		if depth < 0:
			if ndir == 'x':
				center[0] += depth
			elif ndir == 'y':
				center[1] += depth
			elif ndir == 'z':
				center[2] += depth

		if via_hole == True and depth0 in empty:
			depth = 2*abs(depth)

		flip = ON

		if ndir == 'x':
			offset = center[0]
		elif ndir == 'y':
			offset = center[1]
		elif ndir == 'z':
			offset = center[2]

		## conver 3D points to sketch points
		center = threeD_to_sketch_points(center,ndir)
		x0 = center[0];	y0 = center[1]

		## create blank sketch
		sketch1 = create_part_sketch(p,name='temp_sketch1',ndir=ndir,offset=offset)

		s = sketch1['sketch']
		datum_plane1 = sketch1['datum_plane']
		right_edge1 = sketch1['right_edge']
		side = sketch1['side']

		## draw lines
		s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + radius, y0))

		p.CutExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1, sketchPlaneSide=side,
			sketchOrientation=RIGHT, sketch=s, depth=abs(depth), flipExtrudeDirection=flip)

		if len(p.cells) == 0:
			return p.name

##		globals()['debug'] = True
		faces = face_select(p,RP=tuple(center_bak),radius=D/2,axis=ndir)
		if hole_name in empty:
			hole_name = 'f_' + p.name + '_hole_1'

		set1 = create_set(p,objs=faces, name=hole_name,check_name=True)
		face_set = name_of_set(set1)

##		edges = edge_select(p,RP=tuple(center_bak),radius=D/2,axis=ndir)
		edges = find_circular_edges(p,RP=tuple(center_bak),radius=D/2,axis=ndir)
		edge_setname = 'e_hole_1'
		set1 = create_set(p,objs=edges, name=edge_setname,check_name=True)
		edge_set = name_of_set(set1)

		if divide_through == 'yes':
			faces = face_select(p,radius=radius)
			divide_by_face(p,face=faces[0])

		dict1 = {'face_set':face_set, 'edge_set':edge_set, 'divide_dir':None, 'center':center_bak, 'D':D, 'axis':ndir}

		if divide_dir not in empty:
			dict1['divide_dir'] = divide_dir
			x1,y1,z1 = center_bak
			if 'x' in divide_dir and 'x' != ndir:
				batch_divide(p,x=[x1 - divide_extension*D,x1,x1 + divide_extension*D])

			if 'y' in divide_dir and 'y' != ndir:
				batch_divide(p,y=[y1 - divide_extension*D,y1,y1 + divide_extension*D])

			if 'z' in divide_dir and 'z' != ndir:
				batch_divide(p,z=[z1 - divide_extension*D,z1,z1 + divide_extension*D])

		part_holes[p.name].append(dict1)

	print ' '
	print '--->Performed drill_hole for',p.name,', D=',D,'mm, axis dir=',ndir

	default_plot = p.name

	return edge_setname, hole_name

def drill_hole_and_install_bolt():

	## VER: ('VER: 2012-08-26, v1.0')

	## drill hole
	global hole_x,hole_y1,hole_y2
	hole_x = _xmax(frL) - legs_span - bot_flange_hange/2
	hole_y1 = _ymax(frL) - hole2corner1
	hole_y2 = _ymax(frL) - hole2corner2

	drill_hole(frL,x=hole_x,y=hole_y1,D=mhole_D)
	drill_hole(frL,x=hole_x,y=hole_y2,D=mhole_D)

	## rail
	drill_hole(rail,x=MID,y=MID,D=mhole_D)
	move_part(rail,x1=MID,x2=hole_x,y1=MID,y2=hole_y1,z1=MAX,z2=_zmin(frL))
	circular_divide(rail,ndir='z',center=part_holes['rail'][0]['center'],D=2*bolt_pin_D)

	divide(rail,y=hole_y1)
	batch_divide(rail,x=[_xmax(frL),_xmax(frL) - outer_wall_thick, _xmax(frL) - frame_bot_width, _xmax(frL) - legs_span])
	batch_divide(rail,y=(hole_y1 - 1.2*mhole_D, hole_y1 + 1.2*mhole_D))

	new_instance(rail)
	new_instance(rail,dy=hole_y2 - hole_y1)

	batch_divide(frL,y=[_ymin(rail_A1) - 5, _ymax(rail_A1) + 5, _ymin(rail_A2) - 5, _ymax(rail_A2) + 5])
##		batch_divide(frL,y=[_ymin(rail_A1) - 5, _ymax(rail_A1) + 5])
	circular_divide(frL,ndir='z',center=part_holes['frL'][1]['center'],D=2*bolt_pin_D)
	circular_divide(frL,ndir='z',center=part_holes['frL'][2]['center'],D=2*bolt_pin_D)
	batch_divide([rail,frL],x=hole_x)

	please_check
	batch_divide(frL,y=[_ymin(rail_A1), _ymax(rail_A1), _ymin(rail_A2), _ymax(rail_A2)])

	## bolt
	create_I_bolt(D1=bolt_pin_D, D0=2*bolt_pin_D, L=base_thick + rail_thick)

	move_part(bolt,x1=0,x2=hole_x,y1=0,y2=_ymax(frL) - hole2corner1,z1=0,z2=_zmin(frL) - rail_thick)
	divide(bolt,z=_zmin(frL))
	new_instance(bolt)
	new_instance(bolt,dy=hole_y2 - hole_y1)

	return

def duplicate_inst(inst,inst_name=None):

	## VER: ('VER: 2011-11-05, v1.2')

	inst = check_inst(inst)
	part = inst.part

	position = get_poi_position(inst)

	if position['eqv_action'] == 'translation':
		inst_name = new_instance(part,inst_name = inst_name, vector=position['translation'])
	elif position['eqv_action'] == 'rotation':
		inst_name = new_instance(part,inst_name)
		rotate_instances(inst_name,rotation=position['rotation'])
	else:
		inst_name = new_instance(part,inst_name)		## '没有平动和转动'

##	position1 = get_poi_position(inst_name)
##	if position1 != position:
##		print ' '
##		print '****instance复制错误!'
##		print 'before rotation: position=',position
##		print ' '
##		print 'after rotation: position=',position1
##		raise Exception('****instance复制错误!')

	return inst_name

function_labels['easy_print'] = 'file','image','save','viewport'
def easy_print(filename='_1'):
	## VER: 2016-09-30, v1.0

	refresh()
	try:  ## length of 'PDFCreater' is 10
		if len(session.viewports) == 1:
			session.printToPrinter(printCommand='PRINTER[10]:PDFCreator', numCopies=1, canvasObjects=tuple(session.viewports.values()))
		else:
			raise Exception
	except:
		session.printToFile(fileName=filename, format=PNG, canvasObjects=tuple(session.viewports.values()))
		work_dir = get_work_dir()

		print ' '
		print 'file name =',filename + '.PNG'
		print 'saved in:',work_dir
		print ' '
		open_dir(work_dir)

	return

function_labels['easyExcel'] = 'excel','xlsx','csv'
class easyExcel: ## def easyExcel
	## VER: 2017-06-28, 1.6

	"""A utility to make it easier to get at Excel.	Remembering
	to save the data is your problem, as is	error handling.
	Operates on one workbook at a time."""
	## 每次使用后需要运行诸如wb.close()，而不是手动关闭excel。否则退出abaqus会有问题。

	## wb = easyExcel('testbook3')
	## ...
	## wb.close()

##	import win32com.client as win32

##	>>> wb.filename
##	'testbook3.xlsx'
##	>>>

##	>>> wb.sheet_names()
##	['new data', 'python data']

##	>>> wb = easyExcel('testbook3')
##	>>> wb.setCell(0,1,1,5)
##	>>>

	def __init__(self, filename=None,subdir=''):#打开文件或者新建文件（如果不存在的话）
		excel = win32.gencache.EnsureDispatch('Excel.Application')  ## Good. ## excel软件

		self.app = excel
		self.subdir = subdir

		self.app.DisplayAlerts = False
		self.app.Visible = True  ## 前台运行
		self.app.ScreenUpdating = True

		if filename not in empty:
			if type_of(filename) != 'STR':
				raise Exception('*** Error filename')

			loc = filename.rfind('.')
			if loc == -1:
				filename = filename + '.xlsx'

			self.filename = filename

			cur_dir = get_work_dir()
			filename1 = real_dir(cur_dir + '/' + subdir + '/' + filename,tilt='left')
			try:
				self.book = self.app.Workbooks.Open(filename1)  ## wb = excel.Workbooks.Open('c:\\tmp\\add_a_workbook.xlsx')
			except:
				self.book = self.app.Workbooks.Add()
				self.filename = filename

		else:
			self.book = self.app.Workbooks.Add()
			self.filename = '_data.xlsx'

		self.book.Activate()
		self.sheets = self.book.Sheets
		self.sheetnum = self.book.Sheets.Count

	def save(self, filename=None):#保存文件
		if filename not in empty:
			if type_of(filename) != 'STR':
				raise Exception('*** Error filename')

			loc = filename.rfind('.')
			if loc == -1:
				filename = filename + '.xlsx'

			self.filename = filename

			cur_dir = get_work_dir()
			filename1 = real_dir(cur_dir + '/' + subdir + '/' + filename,tilt='left')
			self.filename = filename
			self.book.SaveAs(filename1)   ## wb.SaveAs('c:\\tmp\\add_a_workbook.xlsx')
		else:
			self.book.Save()

	def close(self):#关闭文件
	## wb = easyExcel('testbook3')
	## wb.close()

		self.book.Close(SaveChanges=True)
		self.app.DisplayAlerts = True
		self.app.Application.Quit()
		for var in globals().keys():
			if repr(globals()[var]) == repr(self):
				del globals()[var]   ## 必须释放内存，否则退出abaqus有问题。

	def sheet_names(self):
		names = []
		for i in range(len(self.book.Sheets)):
			sht = self.book.Sheets(i+1)
			name = str(sht.Name)
			names.append(name)
		return names

	def sheet_objs(self):
		objs = []
		for i in range(len(self.book.Sheets)):
			sht = self.book.Sheets(i+1)
			objs.append(sht)
		return objs

	def check_sheet(self,sheet):
		if type_of(sheet) == 'STR':
			if sheet in self.sheet_names():
				sht = self.book.Worksheets(sheet)
			else:
				raise Exception('*** Error sheet name')

		elif type_of(sheet) == 'INT':
			num = sheet    ## VBA的序号从1开始
			if num <= 0:
				index = num
			else:
				index = num - 1  ## 默认情况

##			print 'index=',index
			if index >= len(self.sheets):
				raise Exception('*** index exceeds.')

			sht = self.sheet_objs()[index]

		elif sheet in self.sheet_objs():
			sht = sheet
		else:
			raise Exception('*** Error sheet name or index')

		return sht

	def check_rowcol(self,row,col):
		row = tolist(row)
		col = tolist(col)
		if len(row) == 1:
			row = [row[0],row[0]]
		if len(col) == 1:
			col = [col[0],col[0]]
		if len(row) != 2:
			raise Exception('*** error row range, should be (row1,row2)')
		if len(col) != 2:
			raise Exception('*** error col range, should be (col1,col2)')

		row1,row2 = row
		if row2 < row1:
			row1,row2 = row2,row1

		col1,col2 = col
		if col2 < col1:
			col1,col2 = col2,col1

		return row1,row2,col1,col2

	def sheet(self,sheet_name):
##		>>> wb = easyExcel('testbook3')
##		>>> ws1 = wb.sheet(-1)  ## 最后一个工作簿
##		>>> ws1 = wb.sheet(0) ## 第一个工作簿

		return self.check_sheet(sheet_name)

	def getCell(self, sheet, row, col):#获取单元格的数据
		"Get value of one cell"
##		>>> wb.getCell(1,3,1)
##		u'None'  ## unicode
##		>>> wb.getCell(1,3,1) == 'None'
##		True
##		>>>
##		>>> wb.getCell(1,4,1)
##		>>> wb.getCell(1,4,1) == None   ## null, 空白
##		True
##		>>>

		sheet = self.check_sheet(sheet)
		value = sheet.Cells(row, col).Value
		if type_of(value) == 'UNICODE':
			try:
				value1 = eval(value)
				if is_numbers(value1):
					value = value1
			except:
				pass

		return value

	def setCell(self, sheet, row, col, value):#设置单元格的数据
		"set value of one cell"
		sheet = self.check_sheet(sheet)
		if type_of(value) == 'STR' and value[0] == '=' and len(value) >1:
			sheet.Cells(row, col).Formula = value.upper()
		else:
			sheet.Cells(row, col).Value = str(value)
		self.save()

	def getRange(self, sheet, row,col):#获得一块区域的数据，返回为一个二维元组
		"return a 2d array (i.e. tuple of tuples)"

##		>>> wb.getRange(1,3,1,3,4)
##		((5.0, 6.0, 7.0, 8.0),)   ## 一行就存储在一个元素中。所以，range中y有几行，就有几个元素。
##		>>> wb.getRange(1,4,1,4,4)
##		((None, None, None, None),)

		sheet = self.check_sheet(sheet)
		row1,row2,col1,col2 = self.check_rowcol(row,col)

		return sheet.Range(sheet.Cells(row1, col1), sheet.Cells(row2, col2)).Value

	def getRow(self,sheet,row,col=1):
##		>>> wb.getRow(1,2)
##		[1.0, (2, 3), 4.0, (5, 6, 7)]

		sheet = self.check_sheet(sheet)
		if type_of(row) != 'INT':
			raise Exception('*** row number is required.')
		if type_of(col) != 'INT':
			raise Exception('*** col number is required.')

		list1 = []
		num = 0
		for i in range(500):
			value = self.getCell(sheet,row,col+i)
			list1.append(value)
			if list1[-10:] == [None]*10:
				break
		list1 = list1[:-10]
		if list1 == len(list1)*[None]:
			list1 = []

		return list1

	def getCol(self,sheet,col,row=1):
##		>>> wb.getCol(1,1)
##		[None, 1.0, None, None, None, None, 1.0, 2.0, 4.0, 5.0]
##		>>> wb.getCol(1,1,row=7)
##		[1.0, 2.0, 4.0, 5.0]

		sheet = self.check_sheet(sheet)
		if type_of(row) != 'INT':
			raise Exception('*** row number is required.')
		if type_of(col) != 'INT':
			raise Exception('*** col number is required.')

		list1 = []
		num = 0
		for i in range(500):
			value = self.getCell(sheet,row+i,col)
			list1.append(value)
			if list1[-10:] == [None]*10:
				break
		list1 = list1[:-10]
		if list1 == len(list1)*[None]:
			list1 = []

		return list1

	def setRange(self, sheet, row,col,value):#获得一块区域的数据，返回为一个二维元组
##		>>> wb = easyExcel('testbook3')
##		>>> ws1 = wb.sheet(0)
##		>>> wb.setRange(ws1,(3,3),(1,4),[5,6,7,8])   ## 正确，横向赋值

		sheet = self.check_sheet(sheet)
		row1,row2,col1,col2 = self.check_rowcol(row,col)
		num = len(value)

		if row1 == row2 and col2 > col1:  ## 横向
			for i in range(len(value)):
				sheet.Cells(row1,col1 + i).Value = str(value[i])
		elif col1 == col2 and row2 > row1:  ## 纵向
			for i in range(len(value)):
				sheet.Cells(row1 + i, col1).Value = str(value[i])
		elif row1 == row2 and col1 == col2:  ## 横向
			for i in range(len(value)):
				sheet.Cells(row1,col1 + i).Value = str(value[i])
		else:
			for i in range(len(value)):
				value1 = tolist(value[i])
				for j in range(len(value1)):
					sheet.Cells(row1 + i, col1 + j).Value = str(value1[j])

	def xfill(self,sheet,row,col,value):  ## 横向
		## wb.xfill(1,(2,3),(1,2),[1,(2,3),4,(5,6,7)])    ## 1	(2, 3)	4	(5, 6, 7)

		sheet = self.check_sheet(sheet)
		row1,row2,col1,col2 = self.check_rowcol(row,col)
		self.setRange(sheet,row1,(col1,col1 + 1),value)

	def yfill(self,sheet,row,col,value):  ## 纵向
		sheet = self.check_sheet(sheet)
		row1,row2,col1,col2 = self.check_rowcol(row,col)
		self.setRange(sheet,(row1,row1+1),col1,value)

	def xyfill(self,sheet,row,col,value):  ## value中的每一个元素就占一行
		## wb.xfill(1,(2,3),(1,2),[1,(2,3),4,(5,6,7)])
		## wb.xyfill(1,7,1,[1,(2,3),4,(5,6,7)])  ## 从单元(7,1)开始写数据，有多少就多少，xy方式
		## wb.xyfill(1,1,1,[('x1','value'),(1,23),(1.5,26),(2.0,20),(2.5,27)])  ## 从单元(1,1)开始写数据，共有两列数据

		sheet = self.check_sheet(sheet)
		row1,row2,col1,col2 = self.check_rowcol(row,col)
		self.setRange(sheet,(row1,row1+1),(col1,col1+1),value)

	def addPicture(self, sheet, pictureName, Left, Top, Width, Height):#插入图片
		"Insert a picture in sheet"
		sheet = self.check_sheet(sheet)
		sheet.Shapes.AddPicture(pictureName, 1, 1, Left, Top, Width, Height)

	def copy_sheet(self, sheet,label='',before=None,after=None):#复制工作表
##		>>> wb = easyExcel('testbook3')
##		>>> wb.copy_sheet(sheet=-1,before=-1)
##		>>> wb.copy_sheet(sheet=-1,after=-1)
##		>>>

		if (before,after) == (None,None):
			after = -1

		sheet = self.check_sheet(sheet)

		if label in self.sheet_names():
			print '*** sheet',label,'already exists'
		else:
			if before not in empty:
				before = self.check_sheet(before)
				sheet2 = sheet.Copy(Before=before)
				if label not in empty:
					sheet2.Name = label

			elif after not in empty:
				after = self.check_sheet(after)
				sheet2 = sheet.Copy(After=after)
				if label not in empty:
					sheet2.Name = label

	def move(self,sheet,before=None,after=-1):
		sheet = self.check_sheet(sheet)
		if before not in empty:
			before = self.check_sheet(before)
			sheet.Move(Before=before)

		elif after not in empty:
			after = self.check_sheet(after)
			sheet.Copy(After=after)

	def new_sheet(self,label='',before=None,after=-1):
##		>>> wb = easyExcel('testbook3')
##		>>> wb.new_sheet('label1',after=1)
##		>>> wb.new_sheet('label1',after=1)
##		*** sheet label1 already exists
##		>>>
##		>>> wb = easyExcel('testbook3')
##		>>> wb.new_sheet('label1',before=-1)
##		>>>

		after = self.check_sheet(after)
		if label in self.sheet_names():
			print '*** sheet',label,'already exists'
		else:
			if before in empty:
				sheet2 = self.sheets.Add(After=after)
				if label not in empty:
					sheet2.Name = label
			else:
				before = self.check_sheet(before)
				sheet2 = self.sheets.Add(Before=before)
				if label not in empty:
					sheet2.Name = label

def edel(num=10,removed=MAX,step_num=-1,frame_num=-1,redo=False):
	## VER: ('VER: 2014-08-14, v5.1')
	## For single element removal, use remove_minmax()
	## applicable for nodal delete.
	## 注意，model change 之后，被删除的单元的displacement云图信息仍然存在，max loc可能就位于被删除的单元中，所以要只显示余下的cells。

	## Example:
	## edel(removed=MIN)  ## U1

	global odb, assembly
	global edels

	print "Usage: edel(num=8,removed=MAX,step_num=-1,frame_num=-1,redo=False)"
	print ' '

	if num <= 4:
		raise Exception('num should >= 5')

	if redo == True:
		if 'edels' in globals().keys() and edels not in empty:
			plot(0)

	edels = {}
	edels['dgs'] = {}

	refresh()
	vpnow = get_vpnow()
	display = vpnow.odbDisplay
##	display.contourOptions.setValues(showMaxLocation=ON)
	display.commonOptions.setValues(visibleEdges=FEATURE)
	display.commonOptions.setValues(uniformScaleFactor=5)
	vpnow.viewportAnnotationOptions.setValues(state=OFF)

	variable = display.primaryVariableLabel
	if 'S, Max. Principal' in variable:
		variable = 'S1'
		plot_variable('Mises')
		Mises_max = display.contourOptions.autoMaxValue
		plot_variable('S1')

##	step1,frame1,time1 = get_step_frame_time()
##	set_step_and_frame(stepname=step1[0],frame_num=frame1[0])

	addup = 0
	star_v = 0
	suggested = False

	_values = []
##	raise Exception

	print 'Begin the elements removing...'
##	edels['dgs'][0] = dgo.LeafFromElementVarRange()
	edels['dgs'][0] = dg_now()

	for i in range(1,num + 1):
		PEEQ_before = get_PEEQ()*100
		value_before,value_after,view = remove_minmax(removed=removed)
		PEEQ_after = get_PEEQ()*100

		if PEEQ_before > 10000:
			PEEQ_before = 0
		if PEEQ_after > 10000:
			PEEQ_after = 0

		PEEQ_before = 'PEEQ= ' + str(PEEQ_before)
		PEEQ_after = 'PEEQ= ' + str(PEEQ_after)

##		edels['dgs'][i] = view
		edels['dgs'][i] = dg_now()
		if i == 1:
##			print '_ndel=0  : value=',round(value_before,2), ',',PEEQ_before,'****appended to suggests.'
			suggests = [[0, round(value_before,2), 0, PEEQ_before]]
			_values = [[0, round(value_before,2),0,PEEQ_before,0]]
			value0 = value_before

		delta = round((abs(value0) - abs(value_after))/abs(value0)*100,2)
		int1 = int(delta)
		if int1 < 0:
			int1 = 0		;please_check
		_values.append([i, round(value_after,2),delta,PEEQ_after,int1])

	edels['num'] = num	## 记录有多少个单元被去除。
	num = num + 1
	for i in range(num)[1:]:
		if _values[i][-1] < _values[i-1][-1]:   ## correct int1
			_values[i][-1] = _values[i-1][-1]

	## find seq
	for i in range(num):
		_values[i].append(0)

	for i in range(num)[1:]:
		if _values[i][-2] == _values[i-1][-2]:
			_values[i][-1] = _values[i-1][-1]
		else:
			_values[i][-1] = i

	## find star
	for i in range(num):
		_values[i].append('')

	for i in range(num -1)[1:]:
		if _values[i][-2] > _values[i-1][-2]:
			_values[i][-1] = 'V'

	## count V
	for i in range(num):
		_values[i].append(0)

	for i in range(num - 1):
		if _values[i][-2] == 'V':
			qty = 1
			for j in range(i + 1, num):
				if _values[j][-2] == '':
					qty += 1
				else:
					break

			_values[i][-1] = qty

	## correct V
	for i in range(num - 1):
		if _values[i][-2] == 'V':
			for j in range(i + 1, num):
				if _values[j][-2] == 'V':
					if _values[j][2] - _values[i][2] <= 1:
						_values[i][-1] = _values[i][-1] + _values[j][-1]
						_values[j][-2] = ''
						_values[j][-1] = 0

					break

	edels['values'] = _values

	V_results = []
	for item in _values:
		if item[-1] >= 1:
			V_results.append(item)

	## Remove
	V_results1 = []
	for item in V_results:
		if item[-1] == 1 and item[-4] < 2:
			continue				;please_check
		else:
			V_results1.append(item)

	V_results = V_results1
	V_results.insert(0,_values[0])

	edels['V_results'] = V_results

	for i in range(len(V_results))[1:]:
		item = V_results[i]
		_ndel = item[0]
		delta = item[2]
		addup = item[-1]

		if _ndel >= 5 or suggested == True:    ##有效的单元删除不超过4个，否则视为特例，这里不予包括。
			break

		if addup >= 2:
			if len(suggests) < 3:
				suggests.append(item)
				print fnln_fnln(),'****appended to suggests by addup. _ndel=',_ndel,', addup=',addup, ', delta=',delta

				if len(suggests) == 3:
					suggested = True
					print fnln_fnln(), '****Finished suggests.'

		elif addup == 1:
			if len(suggests) == 1:
				if delta >= 3 and _ndel <= 3:
					suggests.append(item)
					print fnln_fnln(),'****appended to suggests by delta. _ndel=',_ndel, ', delta=',delta
				elif delta >= 4 and _ndel <=4:
					suggests.append(item)
					print fnln_fnln(),'****appended to suggests by delta. _ndel=',_ndel, ', delta=',delta
				elif delta >= 5 and _ndel <=5:
					suggests.append(item)
					print fnln_fnln(),'****appended to suggests by delta. _ndel=',_ndel, ', delta=',delta

			elif len(suggests) == 2:
##				if delta >=5 and int(delta) >= 2*int(suggests[-1][2]):  ## 两倍以上
				delta_prev = _values[_ndel - 1][2]
##				if delta >= 5 and delta - suggests[-1][2] >= 5 and delta >= 2*suggests[-1][2]:
				if delta >= 5 and delta - delta_prev >= 5 and delta >= 2*delta_prev:
					suggests.append(item)
					print fnln_fnln(),'****appended to suggests by delta. _ndel=',_ndel, ', delta=',delta

					suggested = True
					print '****Finished suggests.'

				elif delta >= 4 and int(suggests[-1][2]) == 1:
					suggests.append(item)
					print fnln_fnln(),'****appended to suggests by delta. _ndel=',_ndel, ', delta=',delta

					suggested = True
					print '****Finished suggests.'

	suggests[0] = V_results[0]
	edels['suggests'] = suggests

	## suggests的 Format: [_ndel,stress,delta, PEEQ]'
	if len(suggests) == 1:
		suggest_edel_num = 0
		print ' '
		print fnln_fnln(),'suggest_edel_num= 0 due to len(suggests) = 1'
	elif len(suggests) == 2:
		delta = suggests[1][2]
		if delta >= 2:
			suggest_edel_num = suggests[1][0]
			print fnln_fnln(),'suggest_edel_num=',suggest_edel_num, 'due to len(suggests) = 2 and _ndel >= 2'
		elif delta >= 1 and suggests[1][0] == 1 and suggests[1][-1] >= 3: ## 3颗星以上
			suggest_edel_num = 1
			print fnln_fnln(),'suggest_edel_num=',suggest_edel_num, 'delta >= 1 且具有3颗星以上。'
		elif delta >= 1 and suggests[1][0] == 2 and _values[1][2] < 0.2 and suggests[1][-1] >= 3: ## ndel=1,且3颗星以上
			suggest_edel_num = 2
			print fnln_fnln(),'suggest_edel_num=',suggest_edel_num, 'delta >= 1 且具有3颗星以上。'
		else:
			suggest_edel_num = 0
			print fnln_fnln(),'suggest_edel_num= 0 due to V_results[1] not meet requirement.'

	elif len(suggests) == 3:
		if suggests[2][2] - suggests[1][2] >= 5 and suggests[1][2] < 10:   ##也即suggests[1]优先
			suggest_edel_num = suggests[2][0]
			print fnln_fnln(),'suggest_edel_num=',suggest_edel_num,'due to big delta'
##		elif round(suggests[1][2]) >= 2:
		elif suggests[1][2] >= 2:
			suggest_edel_num = suggests[1][0]			;please_check
			print fnln_fnln(),'suggest_edel_num=',suggest_edel_num,'due to suggests[2] not meet requirement.'
		else:
			suggest_edel_num = 0
			print fnln_fnln(),'suggest_edel_num= 0 due to suggests[1] and suggests[2] not meet requirement.'

	delta1 = _values[1][2]
	delta2 = _values[2][2]
	delta3 = _values[3][2]
	delta4 = _values[4][2]

	if suggest_edel_num == 1 and delta2 >= 5 and delta2 - delta1 >=3:
		suggest_edel_num = 2
		print fnln_fnln(),'**suggest_edel_num由1改为2，因为默认情况下删除2个单元很正常.'

	elif suggest_edel_num >= 4:
		delta = _values[suggest_edel_num][1]
		if int(delta) in [1,2]:
			print fnln_fnln(),'forced suggest_edel_num=0, due to suggest_edel_num >=4 but delta < 3%'
			suggest_edel_num = 0

		please_check('下面不再修改')
		if _values[1][2] < 0.5 and _values[2][2] < 0.5 and _values[3][2] < 0.5 and delta4 < 5: ## case: V系列,leg=1.8, job#= I21_23Opt_V_leg18_noclm_clm120_top5400
			print fnln_fnln(),'forced suggest_edel_num=0, due to delta < 0.5 for _ndel=1,2,3 and delta4 < 5%'   ## 注意：去除4个单元足以消除一个本应存在的节点的值（四个单元围绕一个节点）。
			suggest_edel_num = 0

	print ' '
	print '**Element del results: _values='
	myprint(_values)

	print '**suggests='
	myprint(suggests)
	print '--->**suggest_edel_num=',suggest_edel_num, ':',_values[suggest_edel_num][:4]
	print 'Format: [_ndel,stress,delta%, PEEQ]'
	print ' '

	result = _values[suggest_edel_num][:4]		## [_ndel,stress,delta%, PEEQ]
	edels['result'] = result

	print '**star results: V_results='
	myprint(V_results)
	print ' '

	plot(result[0])
	refresh()

	return result

def edel_of_frame():
	## VER: 2012-01-10, v1.1

	vpnow = get_vpnow()
	vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))
	refresh()
	plotset('frame')
	edel()

	return

function_labels['edel_of_glass'] = 'PV','suntech','result','postprocessing','element','delete'
def edel_of_glass():

	## VER: ('VER: 2012-05-04, v1.1')

	vpnow = get_vpnow()
	vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))
	refresh()
	plotset('glass')
	plot_variable('S1')
	edel(8)

	return

def edel_of_set(setname='frame',stress='Mises'):

	## VER: ('VER: 2012-05-04, v1.8')

	##初始状态：刚刚open一个新的odb文件。
	refresh()
	plotset(setname)

	vpnow = get_vpnow()
	vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))
	if stress in ['Mises', 'mises', 'Mise', 'mise']:
		plot_variable('Mises')
	elif stress == 'S1':
		plot_variable('S1')
	else:
		raise Exception('Incorrect stress variable.')

	suggest = edel(8)

	return suggest

def edge_to_vector(edge):
	## VER: 2013-03-20, v1.1, 获得从起点到终点方向的矢量。可能指向正方向，也可能指向负方向。

	if type_of(edge) != 'edges':
		raise Exception('*** an edge is required.')

	loc1, loc2 = two_points_of_edge(edge)
	poi = get_poi(edge)

	datum_axis = create_datum_axis_by_2points(poi,start=loc1,end=loc2)
##	print type_of(get_parent(datum_axis))
##	edir = edir_of_vector(datum_axis)
##	if edir[0] == '-':
##		datum_axis = create_datum_axis_by_2points(poi,start=loc2,end=loc1)

	x0,y0,z0 = datum_axis.direction
	x0,y0,z0 = round6(x0,y0,z0)

	return (x0,y0,z0)

def edges_at(p,loc=(),dx=0,dy=0,dz=0, x=None,y=None,z=None,groupX=None, groupY=None, groupZ=None, shape='all', radius='all',exterior=True):
	## VER: 2015-11-16, v1.9  Results are list type
	## Example: edges = edges_at(nib_A1,x=MIN,groupY=MAX)

##	edges = edges_at(powder, x=MAX1,groupY=MIN)
##	edges = edges_at('base',(0,175.5,0))

	## 对于定点选线，edges_at()比edge_select好，因为后者可能存在objs_space()的错误。
	## 例如：edges_at(powder,x=MIN1,y=MAX) 比 edge_select(powder, x=MIN1, y=MAX)好。

	p = check_pias(p)
	if _len(p.edges) == 0:
		raise Exception('*** No geometry edge in ' + p.name)

	if loc in empty:
		loc = find_loc(p, x=x, y=y, z=z, groupX=groupX, groupY=groupY, groupZ=groupZ)
##		vertices = vertice_select(p,x=x, y=y, z=z, groupX=groupX, groupY=groupY, groupZ=groupZ)
##		if vertices not in empty:
##			loc = vertices[0].pointOn[0]
##		else:
##			raise Exception('*** No vertice found, please provide the loc.')

	if is_location(loc) == False:
		raise Exception('*** Error location.')

	loc = (loc[0]+dx, loc[1]+dy, loc[2]+dz)
	point = point_at(p,loc)
	edges = []
	pt_type = type_of(point)
	if pt_type == 'vertices':
		edges1 = point.getEdges()
		for index in edges1:
			edges.append(p.edges[index])

	elif pt_type == 'DATUMPOINT':
		edge1 = p.edges.findAt(coordinates=loc, printWarning=False)
		if type_of(edge1) == 'edges':
			edges = [edge1]
		elif type_of(edge1) == 'None':
			print 'No edge was found at' + str(loc)

	final_edges = edges
	if len(final_edges) > 0:
		if shape != 'all':
			newlist = []
			for edge in final_edges:
				shape1 = edge_shape(edge)
				if shape == shape1:
					newlist.append(edge)

			final_edges = newlist

		if radius != 'all':
			newlist = []
			for edge in final_edges:
				R = get_radius(edge)
				if R == radius:
					newlist.append(edge)
			final_edges = newlist

	if exterior == True:
		pshape = part_shape(p)[1]

		newlist = []
		if 'shell' in pshape:
			for edge in final_edges:
				if len(edge.getFaces()) == 1:
					newlist.append(edge)
		elif 'solid' in pshape:
			for edge in final_edges:
				if len(edge.getFaces()) == 2:
					newlist.append(edge)
		final_edges = newlist

##	if len(final_edges) == 0:
##		print fnln_fnln(),'****Selection of edges failed.'
##	else:
##		print len(final_edges),'edges selected by edges_at(), loc=',loc,', shape=',shape,', radius=',radius

	return final_edges

def edge_angle(edge,axis='x'):
	## VER: 2013-02-26, v1.0

##	>>> edge_angle(v1,axis='y')
##	The angle between the arrows is 10.000070 degrees
##	(10.0000704722472, 1)
##	>>>

	if type_of(edge) not in ['edges', 'DATUMAXIS']:
		raise Exception('*** An edge or datumaxis is required.')

	axis = axis.lower()
	if axis not in ['x','y','z']:
		raise Exception('*** axis should be x, y, or z')

	angle = get_intersect_angle(obj1=edge, axis=axis)

	return angle

def edge_dir(edge):
	## VER: ('VER: 2014-09-14, v2.2')

	## Example:
	## edges = edge_select('cylind',x=MIN,edir='circular')

	if type_of(edge) != 'edges':
		raise Exception('one edge object is required.')

	shape = edge_shape(edge)  ## circle, arc, line, spline

	dir1 = 'NA'
	if shape in ['arc','circle']:
		dir1 = 'circular'
	elif shape in ['spline','ellipse']:
		dir1 = shape   ## 一个ellipse即使被劈分成很多段，每一分段的curveType仍然是ellipse。spline也是如此。
	elif shape == 'line':
		p = get_poi(edge)
		inds = edge.getVertices()

		x1,y1,z1 = p.vertices[inds[0]].pointOn[0]
		x2,y2,z2 = p.vertices[inds[1]].pointOn[0]
		comp = [abs(x1-x2),abs(y1-y2),abs(z1-z2)]

		if comp[0] < 1e-6 and comp[1] < 1e-6:
			dir1 = 'z'
		elif comp[1] < 1e-6 and comp[2] < 1e-6:
			dir1 = 'x'
		elif comp[2] < 1e-6 and comp[0] < 1e-6:
			dir1 = 'y'
		else:
			dir1 = 'slope'

	return dir1

def edge_dir_ends(edge,axis='x'):
	## VER: 2013-10-12, v1.0
	## 获取edge的end1点到end2点的朝向，如果正向或相等，为FORWARD，否则为REVERSE

	## Example
##	for edge in edges:
##		seq = obj2sequence(edge)
##		dir1 = edge_dir_ends(edge,axis='z')
##		if dir1 == FORWARD:
##			part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
##		else:
##			part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)


	poa = get_poi(edge)
	if type_of(poa) == 'PINSTANCE':
		poa = a

	dp1 = poa.DatumPointByEdgeParam(edge=edge,parameter=0)
	id = poa.datums.keys()[-1]
	x1,y1,z1 = poa.datums[id].pointOn

	dp2 = poa.DatumPointByEdgeParam(edge=edge,parameter=1)
	id = poa.datums.keys()[-1]
	x2,y2,z2 = poa.datums[id].pointOn

	dir1 = FORWARD
	if axis in ['x',0]:
		if PK(x1,x2) == '>':
			dir1 = REVERSE
	elif axis in ['y',1]:
		if PK(y1,y2) == '>':
			dir1 = REVERSE
	elif axis in ['z',2]:
		if PK(z1,z2) == '>':
			dir1 = REVERSE

	return dir1

def edge_length(edge):
	## VER: 2011-05-17, v1.4

	if type_of(edge) == 'LIST':
		edge = edge[0]

	if type_of(edge) != 'edges':
		raise Exception('******An edge is required to calculate edge_length.')

	length = edge.getSize(printResults=False)
	length = round(length,6)

	return length

def edge_loops_of_faces(faces):
	## VER: 2016-07-29, v1.0

	faces = tolist(faces)
	poi = get_poi(faces[0])

	if len(poi.cells) > 0:
		shellpart = faces_to_shellpart(faces)
	else:
		shellpart = poi

	loops = find_edge_loops(shellpart)

	if len(poi.cells) > 0:
		newlist = []
		for i in range(len(loops)):
			newlist1 = []
			for edge in loops[i]:
				loc = edge.pointOn[0]
				edge1 = edges_at(poi,loc=loc)
				newlist1.append(edge1[0])
			newlist.append(newlist1)

		loops = newlist
		del_parts(shellpart)

	return loops


def edge_select(p,x=(),y=(),z=(),groupX=None, groupY=None, groupZ=None, thenX=None,thenY=None,thenZ=None,xpos=None,ypos=None,zpos=None,thenXseq=None,thenYseq=None,thenZseq=None,
	space=(),poiRefX=(),poiRefY=(),poiRefZ=(),lenx=None,leny=None,lenz=None,ref_locx=(),ref_locy=(),ref_locz=(), base=None, RP=None, axis=None,
	through_x=None,through_y=None,through_z=None, edir=None,nx=None,ny=None,nz=None,dx=0,dy=0,dz=0,edges=None, faces=None, setname=None,
	pointx=None,pointy=None,pointz=None, corner1=None,corner2=None,include_ends=True,mark_select=True,
	shape=None, radius=None, diameter=None, D=None, length=(),dims=[],_xlength=None, xD=None, exterior=None):
	## VER: 2017-07-28, v6.8
	## 如果输入xpos,ypos, or zpos, 注意弧度也会产生位置点。

	## possible edir: circular, spline, 'x','y','z','slope'.  通过edge_dir(edge)可以知道其edir
	## possible edge shape: circle(完整的), arc(不完整的), line, spline
##	edges = edge_select('pocket_A1',y=MIN,diameter='smaller')   ## 含糊的半径

	## 如果选择某个点处的线，用edges_at()更好。
	## Example:
	## edges = edge_select(powder, y=(0,MIN),x=(MIN1,MAX1))
	## edges = edge_select('nib_A1',poiRefX=(MIN,0.1))
	## edges = edge_select(carbide_A1,poiRefX=(MAX,-corner_radius - 1),y=(MAX,MIN1))
	## edges = edge_select(CRC,faces=f1, edir='circular')
	## edges = edge_select(diamond,faces=faces,groupY=MIN)
	## edges = edge_select(ejector,y=MAX,edir='circular',xD=punch_D)
	## edges = edge_select(case_A1,y=(MID,MIN),ny=1)
	## edges = edge_select(case_A1,ny=1,groupY=MIN)
	## powder_bot = edge_select(powder,ny=-1)
	## edges = edge_select('carbide',x=MIN1,thenYseq=-2)  ## for carbide linner in pressing tool design

	## Results type: list, Region
	## edge shape:axis_line, slope_line, O_curve, O/2_curve, O/8_curve, other_O_curve, unknown_curve
	## edge dir: x,y,z,slope,circular,unknown

	global additional_datum, slow_caller

	time1 = time.time()

	print ' '
	print '****>>>>>Start edge_select(), caller=',get_traceback()[2:-2]
##	print '****>>>>>Start edge_select(), caller=',caller_fnln()

	locals1 = eval(repr(locals()))
	inputs = get_inputs(locals1)

	if thenX not in empty:
		groupX = thenX
	if thenY not in empty:
		groupY = thenY
	if thenZ not in empty:
		groupZ = thenZ

	if shape == 'flat':
		shape = 'line'
	elif shape == 'circular':
		edir = 'circular'
		shape = None

	p = check_pias(p)

	if faces not in empty:
		edges = faces_to_edges(faces)

	if _len(p.edges) == 0:
		raise Exception('*** no geometry edges in ' + p.name)

	if D not in empty:
		diameter = D

	if type_of(diameter) in numerics:
		radius = diameter/2.0

	compare_D = None
	if type_of(diameter) == 'STR':
		diameter = diameter.lower()
		if diameter in ['smaller','inner']:
			compare_D = 'smaller'
		elif diameter in ['bigger','outer','greater']:
			compare_D = 'bigger'

	elif type_of(radius) == 'STR':
		radius = radius.lower()
		if radius in ['smaller','inner']:
			compare_D = 'smaller'
		elif radius in ['bigger','outer','greater']:
			compare_D = 'bigger'

	if compare_D in ['smaller','bigger']:
		edir = 'circular'
		radius = None
		diameter = None

##	print fnln(),'compare_D=',compare_D

	if is_empties(pointx,pointy,pointz) == False:
		if len(remove_empty(pointx,pointy,pointz)) == 1:
			raise Exception('*** lack of point loc coordinates')

		if pointx in empty:
			pointx = MIN
		if pointy in empty:
			pointy = MIN
		if pointz in empty:
			pointz = MIN

		pointx,pointy,pointz=real_xyz(p,pointx,pointy,pointz)

		edges = edges_at(p,loc=(pointx,pointy,pointz))

		return edges

	if is_number(xpos) and x in empty:
		locs_x = xlocs(p)
		x = locs_x[xpos]

	if is_number(ypos) and y in empty:
		locs_y = ylocs(p)
		y = locs_y[ypos]

	if is_number(zpos) and z in empty:
		locs_z = zlocs(p)
		z = locs_z[zpos]

	print fnln(),'z=',z

	if x in [MIN1,MAX1] or y in [MIN1,MAX1] or z in [MIN1,MAX1]:
		mark_select = True

	x_bak = eval(repr(x))
	y_bak = eval(repr(y))
	z_bak = eval(repr(z))

	dims = tolist(dims)

	pshape = part_shape(p)[1]
	if '2D' in pshape and 'shell' in pshape and exterior == None:
		exterior = True

	if edir in ['circle','arc']:
		edir = 'circular'
	elif edir == 'tilt':
		edir = 'slope'

	if len(space) == 6:
		x1,x2,y1,y2,z1,z2 = space

	elif corner1 not in empty:
		if type_of(corner1) == 'STR':
			corner1 = KPxyz(p,corner2)
		x1,y1,z1 = corner1

		if type_of(corner2) == 'STR':
			corner2 = KPxyz(p,corner2)
		if corner2 not in empty:
			x2,y2,z2 = corner2
		else:
			x2,y2,z2 = x1,y1,z1
			if lenx not in empty:   ## lenx, leny, lenz are numbers
				x2 = x1 + lenx
			if leny not in empty:
				y2 = y1 + leny
			if lenz not in empty:
				z2 = z1 + lenz

		if x1 > x2: x1,x2 = x2,x1
		if y1 > y2: y1,y2 = y2,y1
		if z1 > z2: z1,z2 = z2,z1

	else:
##		x,y,z = real_xyz(p,x,y,z)
####		print 'x,y,z=',(x,y,z)
##		x1,x2,y1,y2,z1,z2 = tospace(x,y,z)

		if through_x != None:
			x = through_x
##			allow_mark_select_x = True

		if through_y != None:
			y = through_y
##			allow_mark_select_y = True

		if through_z != None:
			z = through_z
##			allow_mark_select_z = True

		please_check	## 要求empty2space = False，至少对于2D 的nib是这样的。
		x1,x2,y1,y2,z1,z2 = real_space(p,x=x,y=y,z=z,space=space,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ,ref_locx=ref_locx,ref_locy=ref_locy,ref_locz=ref_locz,empty2space=False)   ## origin: True

##	raise Exception

	if RP not in empty:
		x0 = y0 = z0 = 0
		type1 = type_of(RP)
		if type1 == 'vertices':
			x0,y0,z0 = RP.pointOn[0]
		elif type1 == 'TUPLE':
			x0,y0,z0 = RP

		if x1 not in [_min,_max]:
			x1 = x1 + x0
		if x2 not in [_min,_max]:
			x2 = x2 + x0
		if y1 not in [_min,_max]:
			y1 = y1 + y0
		if y2 not in [_min,_max]:
			y2 = y2 + y0
		if z1 not in [_min,_max]:
			z1 = z1 + z0
		if z2 not in [_min,_max]:
			z2 = z2 + z0

		if type_of(radius) in ['INT','FLOAT']:
			if axis in empty:
				raise Exception('******edge_select(): both radius and RP are provided, require aixs')

			if axis == 'x':
				y1 = y0 - radius - _nearby
				y2 = y0 + radius + _nearby
				z1 = z0 - radius - _nearby
				z2 = z0 + radius + _nearby
			elif axis == 'y':
				x1 = x0 - radius - _nearby
				x2 = x0 + radius + _nearby
				z1 = z0 - radius - _nearby
				z2 = z0 + radius + _nearby
			elif axis == 'z':
				x1 = x0 - radius - _nearby
				x2 = x0 + radius + _nearby
				y1 = y0 - radius - _nearby
				y2 = y0 + radius + _nearby

	x = (x1,x2)
	y = (y1,y2)
	z = (z1,z2)

	if base not in empty and type_of(base) == 'STR':
		type1 = type_of(p)
		if type1 == 'PART':
			part = p
		elif type1 == 'PINSTANCE':
			part = _m.parts(p.partName)

		setname = 'e_' + part.name + '_' + base
		if setname in part.sets.keys():
			edges = set2objs(p,setname)
		else:
			print fnln_fnln(),'******',part.name,': No such edge setname=',setname

##	print fnln(),'edges=',edges

	if edges in empty:
##		edges = p.edges
		if is_empties(x_bak,y_bak,z_bak,space):
			edges = p.edges
		else:
##			print fnln(),'x,y,z=',(x,y,z)
			vertices = vertice_select(p,x=x,y=y,z=z)
##			create_set(p,setname='set1',vertices=vertices)
##			raise Exception
			edges = vertices_to_edges(vertices)   ## 点的位置可能是不够精确的。

##			print fnln(),len(edges)
##			print fnln(),len(vertices)
##			light(edges)
##			raise Exception

			if edges in empty:
				edges = p.edges

	elif type_of(edges) == 'STR':
		edges = set2objs(p,edges)
	elif type_of(setname) == 'STR':
		edges = set2objs(p,setname)

	edges = tolist(edges)
##	print fnln(),len(edges)
##	light(edges)
##	raise Exception

	if exterior == True:
		pshape = part_shape(p)[1]

		newlist = []
		if 'shell' in pshape:
			for edge in edges:
				if len(edge.getFaces()) == 1:
					newlist.append(edge)
		elif 'solid' in pshape:
			for edge in edges:
				if len(edge.getFaces()) == 2:
					newlist.append(edge)
		edges = newlist

	if shape not in empty:
		newlist = []
		for edge in edges:
			shape1 = edge_shape(edge)		##??****
			if shape1 == shape:
				newlist.append(edge)
			elif shape in shape1:
				newlist.append(edge)
		edges = newlist

	if radius not in empty:
		newlist = []
		for edge in edges:
			R = get_radius(edge)
			if is_number(R) and within_range(R,radius):
				newlist.append(edge)
		edges = newlist


	if edir not in empty:
		newlist = []
		for edge in edges:
			edir1 = edge_dir(edge)   ## circular, spline, 'x','y','z','slope'
##			print2('edir of edge=',edir1)
			if edir not in edir1:   ##??****
				continue
			newlist.append(edge)
		edges = newlist

##	print fnln(),'edir=',edir
##	print fnln(),len(edges)

	if edges not in empty and get_real_input(nx,ny,nz) not in empty:
		edges = edge_select_by_facing(p,edges=edges,nx=nx,ny=ny,nz=nz)

##	raise Exception

	if length not in empty:
		newlist = []
		for edge in edges:
			len1 = edge_length(edge)
			if within_range(len1,length):
				newlist.append(edge)
		edges = newlist

	if dims not in empty:
		newlist = []
		for edge in edges:
			len1 = edge_length(edge)
			if within_list(len1,dims):  ##???****
				newlist.append(edge)
		edges = newlist

	if _xlength not in empty:
		newlist = []
		for edge in edges:
			len1 = edge_length(edge)
			if not within_range(len1,_xlength):
				newlist.append(edge)
		edges = newlist

	fix_DOFs = []   ## 对x,y,z的约束情况. (_min,_max)为无约束。
	fix_x = fix_y = fix_z = False
	if x != (_min,_max):
		fix_DOFs.append('x')
		fix_x = True
	if y != (_min,_max):
		fix_DOFs.append('y')
		fix_y = True
	if z != (_min,_max):
		fix_DOFs.append('z')
		fix_z = True

##	print x,y,z
##	print (_min,_max)
##	raise Exception
##	print fnln(),(fix_x,fix_y,fix_z)
	if fix_DOFs not in empty:
		newlist = []
		for i in xrange(len(edges)):
			edge = edges[i]
			x01,x02,y01,y02,z01,z02 = objs_space(edge)
##			print 'y01,y02=',(y01,y02)
			if fix_x and not meet_search_range((x01,x02),(x1,x2),include_ends=include_ends,mark_select=mark_select):
				continue
			if fix_y and not meet_search_range((y01,y02),(y1,y2),include_ends=include_ends,mark_select=mark_select):
				continue
			if fix_z and not meet_search_range((z01,z02),(z1,z2),include_ends=include_ends,mark_select=mark_select):
				continue

			newlist.append(edge)
		edges = newlist

	if is_number(xD):  ## to exclude some diameters
		newlist = []
		for edge in edges:
			R1 = get_radius(edge)
			if is_number(R1):
				D1 = 2.0*R1
				if PK(D1,xD) == 0:
					continue

			newlist.append(edge)
		edges = newlist

##	print fnln(),len(edges)

	if len(edges) > 0:
		if groupX not in empty or groupY not in empty or groupZ not in empty:
			space = objs_space(edges)
			if groupX not in empty:
				groupX = real_xyz_in_space(space,x=groupX)
				edges = edge_select(p=p, edges=edges, x=groupX)
			elif groupY not in empty:
				groupY = real_xyz_in_space(space,y=groupY)
				edges = edge_select(p=p, edges=edges, y=groupY)
			elif groupZ not in empty:
				groupZ = real_xyz_in_space(space, z=groupZ)
				edges = edge_select(p=p, edges=edges, z=groupZ)

		if thenXseq not in empty or thenYseq not in empty or thenZseq not in empty:
			if is_number(thenXseq):
				locs = locs_of_objs(edges,index=0)
				edges = edge_select(p,edges=edges,x=locs[thenXseq])
			elif is_number(thenYseq):
				locs = locs_of_objs(edges,index=1)
				edges = edge_select(p,edges=edges,y=locs[thenYseq])
			elif is_number(thenZseq):
				locs = locs_of_objs(edges,index=2)
				edges = edge_select(p,edges=edges,z=locs[thenZseq])

	if additional_datum == True:
		clear_datum_points(p)
		additional_datum = False

##	print fnln(),'compare_D=',compare_D

	if compare_D in ['bigger','smaller']:
		dict1 = {}
		for edge1 in edges:
			D1 = get_diameter(edge1)
			D1 = smart_round(D1)
			if D1 not in dict1.keys():
				dict1[D1] = []

			dict1[D1].append(edge1)

		diameters = _sort(dict1.keys())
		if compare_D == 'smaller':
			edges = dict1[diameters[0]]
		else:
			edges = dict1[diameters[-1]]

	if len(edges) == 0:
		print fnln_fnln(),'****No edge was selected in ' + p.name
		print '        mark_select=',mark_select, ', include_ends=',include_ends
		print '        avoid divided by interger in GUI, such as: hole_D/2, should be hole_D/2.'
		print '        search range: x=',x,', y=', y, ', z=', z

	else:
		if 'edges' in inputs.keys():
			inputs['edges'] = 'edges'
		if 'faces' in inputs.keys():
			inputs['faces'] = 'faces'

		print 'In',p.name,':',len(edges),'edges selected. Parameters=',inputs,', called by',this_and_caller(to_print=False)[:2]

	print '****<<<<<End edge_select'
	print ' '

	if time.time() - time1 >= 0.1:
		slow_call.append(get_traceback())

	return edges

def edge_select_by_facing(poi,edges=None, nx=None,ny=None,nz=None):
	## VER: 2014-08-17, v1.0

	poi = check_poi(poi)
	if '2D' not in part_shape(poi)[1]:
		raise Exception('*** only applicable to 2D model.')

	if edges in empty:
		edges = poi.edges
	edges = tolist(edges)

	newlist = []
	for edge in edges:
		if edge.getFaces() not in empty:
			newlist.append(edge)
	edges = newlist

	if nx in [1,-1]:
		dx = nx*0.01

		newlist = []
		for edge in edges:
			loc = edge.pointOn[0]
			face = face_at(poi,loc=loc,dx=dx)
			if face == None:
				newlist.append(edge)
		edges = newlist

	if ny in [1,-1]:
		dy = ny*0.01

		newlist = []
		for edge in edges:
			loc = edge.pointOn[0]
			face = face_at(poi,loc=loc,dy=dy)
			if face == None:
				newlist.append(edge)
		edges = newlist

	if nz in [1,-1]:
		dz = nz*0.01

		newlist = []
		for edge in edges:
			loc = edge.pointOn[0]
			face = face_at(poi,loc=loc,dz=dz)
			if face == None:
				newlist.append(edge)
		edges = newlist

	print fnln(),'--->',len(edges),'edges selected by edge_select_by_facing().'

	return edges


def edge_shape(edge):
	## VER: 2014-09-14, v2.9   line,arc,circle,ellipse,spline
	## If the plane of projection is not parallel to the specified edge, the resultant sketch geometry may be of a different type.
	## 可以通过ndir_and_offset_of_curve()来获得该curve所在的平面的法线方向。
	## shape对line不细分，但对其他是细分的。
	## 草图中，curveType为：A SymbolicConstant specifying the geometry of the sketch entity. Possible values are ARC, CIRCLE, ELLIPSE, LINE, and SPLINE.

	## Results: circle(完整的), arc(不完整的), line, spline(一个圆孔在一个圆柱面上时为spline)


	if type_of(edge) != 'edges':
		raise Exception('edge object is required.')

	poi = get_poi(edge)
	index = edge.index

	if type_of(poi) == 'PINSTANCE':
		poi = poi.part
		edge = poi.edges[edge.index]
	part = poi

	radius = get_radius(edge)  ## 如果有raius，则为arc或circle

	if is_number(radius):  ## 草图中，为arc, circle两种
		circum = 2*pi*radius
		length = edge.getSize(printResults=False)
		if PK(circum,length) == 0:
			shape = 'circle'
		else:
			shape = 'arc'
	elif radius == 'flat': 	## 无穷大
##	elif radius == -1:	## 无穷大
		shape = 'line'
	else:
		shape = 'spline'
##	elif radius == 'complex':
##		shape = 'spline'
##	elif radius == 'loc-dependent':
##		shape = 'spline'

##	elif radius in empty:
##		curvature = None
##		try:
##			curvature = edge.getCurvature(0)  ## 样条曲线没有直线部分
##		except:
##			pass
##
##		if curvature in empty:
##			try:
##				curvature = edge.getCurvature(0.5)  ## 样条曲线没有直线部分
##			except:
##				pass
##
##		if curvature in empty:
##			shape = 'line'
##		else:
####			part1 = copy_part(part,'_temp')
####			part1 = _m.parts[part1]
##			shapes = []
##			for ndir in ['x','y','z']:
##				sketch1 = create_base_sketch(name='s_temp',ndir=ndir, return_sketch=True)
####				sketch1 = sketch1['sketch']
##				part.projectEdgesOntoSketch(sketch=sketch1,edges=(edge,),constrainToBackground=False)   ## If True, there may be a warning, such as:
##																										##	Warning: 1 edges which lie on planes perpendicular to the projection plane were projected as lines. These lines cannot be associated with the generating edges.
####				part1.projectEdgesOntoSketch(sketch=sketch1,edges=(part1.edges[index],),constrainToBackground=False)
##
##		##		if curves in empty:   ## ERROR
##				if len(sketch1.geometry) == 0:
##					shape1 = 'point'
##				else:
##					shape1 = totext(sketch1.geometry[2].curveType).lower()
##				shapes.append(shape1)
##				del _m.sketches[sketch1.name]
##
####			plot(part)
####			del_parts(part1)
##
##			if 'ellipse' in shapes:
##				shape = 'ellipse'
##			else:
##				shape = 'spline'

	return shape

def sheet_grow(part,x=None,y=None,z=None,dx=0,dy=0,dz=0,thx=None,thy=None,thz=None,mat=None,addRP=True):
	## VER: ('VER: 2012-09-06, v1.2')
	## Exmaple: sheet_grow(clamp,dx=clamp_thick + leg_gap_top,thx=clamp_thick)		## y,z不提供则默认取整个范围

	part = check_part(part)

	if thx not in empty:
		x = (dx, dx + thx)
	elif thy not in empty:
		y = (dy, dy + thy)
	elif thz not in empty:
		z = (dz, dz + thz)

##	print 'x,y,z=',[x,y,z]
##	stop(debug)

	create_block(part,x=x,y=y,z=z,mat=mat,addRP=addRP)	## 不提供则默认取整个范围. 缺省addRP=True

	return

def shift_table(table,dx=None,dy=None,absolute=False,xmin=None,xmax=None,ymin=None,ymax=None,zero_start=False):
	## VER: 2014-11-27, v1.1

##		temp_table = shift_table(temp_table,xmin=xmin)
##		press_table = shift_table(press_table,xmin=xmin)

	table = totable(table)
	newlist = []

	for x1,y1 in table:
		if is_number(dx):
			newlist.append((x1 + dx, y1))
		elif is_number(dy):
			newlist.append((x1,y1 + dy))
		elif absolute == True:
			newlist.append((x1,abs(y1)))
		elif is_number(xmin) and x1 >= xmin:
			newlist.append((x1,y1))
		elif is_number(xmax) and x1 <= xmax:
			newlist.append((x1,y1))
		elif is_number(ymin) and y1 >= ymin:
			newlist.append((x1,y1))
		elif is_number(ymax) and y1 <= ymax:
			newlist.append((x1,y1))

	if zero_start == True:
		if newlist not in empty and newlist[0][0] != 0:
			newlist = shift_table(newlist, dx=-newlist[0][0])

	newlist = totable(newlist)
	if newlist in empty:
		newlist = table

	return newlist


def short_edges_of_faces(part=None,faces=None,x=None,y=None,z=None,minimum=1.2):
	## VER: 2014-09-11, v1.5

	if is_part(faces):
		part,faces = faces,part

	if is_poi(part):
		part = check_part(part)

	if type_of(part) == 'PART' and (x,y,z) != (None,None,None):
		faces = faces_of_cut(part,x=x,y=y,z=z,exterior=None)
	else:
		faces = tolist(faces)

	if faces in empty:
		raise Exception('*** faces are required.')

	short_edges = []
	for face in faces:
		edges = edges_of_face(face,in_out='inner',long_short='short',minimum=minimum)
		if edges in empty:
			edges = edges_of_face(face,in_out='outer',long_short='short',minimum=minimum)

		if len(edges) > 0:
			short_edges = short_edges + edges[0:1]

	print fnln_fnln(),'--->',len(short_edges),'short edges are selected from the cross-section faces.'

	return short_edges

def get_mid_height1(insert,include_vertice=False):
	## VER: 2016-06-24, v1.1

	insert = check_part(insert)

##	faces0 = face_select(insert,z=MID,mark_select=True)

	faces1 = face_select(insert,nz=1)
##	faces1 = unselect(faces1,faces0)

	faces2 = face_select(insert,nz=-1)
##	faces2 = unselect(faces2,faces0)

	top1 = objs_space(faces1)[-2]
	bot1 = objs_space(faces2)[-1]

##	print top1
##	print bot1

	if top1 == bot1:
		mid = top1
	elif top1 > bot1:
		mid = round((top1 + bot1)/2.0, 3)
	else:
		raise Exception('*** Fail to get the mid height.')

##	## find mid
##	vertices = vertice_select(insert,z=(MID,MIN),groupZ=MAX)
##	bot2 = vertices[0].pointOn[0][2]
##
##	vertices = vertice_select(insert,z=(MID,MAX),groupZ=MIN)
##	top2 = vertices[0].pointOn[0][2]
##
##	if include_vertice == True:
##		top = min(top1,top2)
##		bot = max(bot1,bot2)
##	else:
##		top = top1
##		bot = bot1
##	mid = round((top + bot)/2.0, 3)  ## maybe error for bias_cut if use 5

##	if debug1 == True:
##		divide(insert,z=top)
##		divide(insert,z=bot)
##		divide(insert,z=mid)

	return mid


def get_mid_height(insert,include_vertice=False):
	## VER: 2016-06-24, v1.1

	insert = check_part(insert)

	faces0 = face_select(insert,z=MID,mark_select=True)

	faces1 = face_select(insert,nz=1)
	faces1 = unselect(faces1,faces0)

	faces2 = face_select(insert,nz=-1)
	faces2 = unselect(faces2,faces0)

	top1 = objs_space(faces1)[-2]
	bot1 = objs_space(faces2)[-1]

	## find mid
	vertices = vertice_select(insert,z=(MID,MIN),groupZ=MAX)
	bot2 = vertices[0].pointOn[0][2]

	vertices = vertice_select(insert,z=(MID,MAX),groupZ=MIN)
	top2 = vertices[0].pointOn[0][2]

	if include_vertice == True:
		top = min(top1,top2)
		bot = max(bot1,bot2)
	else:
		top = top1
		bot = bot1
	mid = round((top + bot)/2.0, 3)  ## maybe error for bias_cut if use 5

##	if debug1 == True:
##		divide(insert,z=top)
##		divide(insert,z=bot)
##		divide(insert,z=mid)

	return mid


def compress_height(insert,product_H):
	## VER: 2016-07-12, v1.1

	insert = check_part(insert)
	insert = insert.name

	mid = get_mid_height(insert)

	insert2 = copy_part(insert,'insert2')

	High0 = _zlength(insert)
	gap = High0 - product_H

	bias_cut(insert,z=mid+gap/2,cut_sides='-')
	bias_cut(insert2,z=mid-gap/2,cut_sides='+')
	move_part(insert2,z1=mid-gap/2,z2=mid+gap/2)

	merge_instances(parts=(insert,insert2),partname=insert,boundary='move')
	del_features(insert,names='O')
	del_parts(insert2)

	return

def shellpart_to_wirepart(part,partname='wirepart',ndir='z', pshape='3D',ptype='deformable'):
	## VER: 2014-09-08, v1.2

	sketch1 = shellpart_to_sketch(part=part)
	part_w = sketch_to_wire(sketch1,partname=partname,ndir=ndir, pshape=pshape, ptype=ptype)
	del _m.sketches[sketch1]

	return part_w

def wall_thickness(poi,csys='xy',inc=None,err=0.5):
	## VER: 2016-09-22, v1.1
	## for sintered part，可以获得诸如宽度的变化，厚度的变化等
	## 太小的err可能无法选到最边上的节点
	## Anders喜欢观察厚度上的变化

	## Example: wall_thickness(p1,csys='xy',inc=0.1,err=0.5)

##	wall_thickness(p1,csys='xz')
##	dists= [3.30966, 3.33756, 3.33583, 3.33516, 3.3291]
##	average= 3.329

	poi = check_poi(poi)
	x1,x2,y1,y2,z1,z2 = poi_space(poi)

	if type_of(csys) != 'STR':
		raise Exception('*** csys of wall should be xy, yz, or zx, etc')

	csys = csys.lower()
	dists = []

	if is_number(inc) and inc < 1:
		range1 = myrange(0,1,inc)
		range1 = [range1[0],0.05] + range1[1:-1] + [0.95,range1[-1]]
	else:
		range1 = [0.1,0.3,0.5,0.7,0.9]

	if csys[0] == 'x':
		for ratio in range1:
			loc = x1 + ratio*(x2-x1)
			nodes = node_select(poi,x=loc,err=err)
			if len(nodes) > 0:
##				seq = list2sequence(nodes)
##				leaf = dgm.LeafFromMeshNodeLabels(nodeSeq=seq)
##				highlight(dg)

				Lx,Ly,Lz = objs_span(nodes)
				if csys[1] == 'y':
					dists.append(Ly)
				elif csys[1] == 'z':
					dists.append(Lz)
	elif csys[0] == 'y':
		for ratio in range1:
			loc = y1 + ratio*(y2-y1)
			nodes = node_select(poi,y=loc,err=err)
			if len(nodes) > 0:
				Lx,Ly,Lz = objs_span(nodes)
				if csys[1] == 'x':
					dists.append(Lx)
				elif csys[1] == 'z':
					dists.append(Lz)
	elif csys[0] == 'z':
		for ratio in range1:
			loc = z1 + ratio*(z2-z1)
			nodes = node_select(poi,z=loc,err=err)
			if len(nodes) > 0:
				Lx,Ly,Lz = objs_span(nodes)
				if csys[1] == 'x':
					dists.append(Lx)
				elif csys[1] == 'y':
					dists.append(Ly)

	dist = round(sum(dists)/len(dists),3)
	print 'dists=',dists
	print 'average=',dist

	return dist

def wirepart_to_shellpart(part,partname='shellpart',ndir='z', pshape='3D',ptype='deformable',sym_axis='V'):
	## VER: 2013-05-23, v1.1

	global _m, a

	sketch1 = wirepart_to_sketch(part=part)
	part_s = sketch_to_shellpart(sketch1,partname=partname,ndir=ndir, pshape=pshape, ptype=ptype, sym_axis=sym_axis)

	del _m.sketches[sketch1]

	return part_s


def shellpart_to_sketch(part,ndir='z',sketchname='sk_temp',offset=0,datum_sketch=False):
	## VER: 2015-01-14, v1.1

##	s2 = shellpart_to_sketch('nib',sketchname='sk_nib')
##	print s2.name

	part = check_part(part)

	pshape = part_shape(part)[1]
	if 'shell' not in pshape:
		raise Exception('**** shell part is required.')

	edges = part.edges
	sketch1 = edges_to_sketch(edges,ndir=ndir,sketchname=sketchname,offset=offset,datum_sketch=datum_sketch)

	return sketch1

def wirepart_to_sketch(part,ndir='z',sketchname='s_temp',offset=0,datum_sketch=True):
	## VER: 2013-06-14, v1.1

	global _m, a

	part = check_part(part)

	pshape = part_shape(part)[1]
##	print 'pshape=',pshape
##	print 'partname=',part.name
	if 'wire' not in pshape:
		raise Exception('**** wire part is required.')

	edges = part.edges
	sketch1 = edges_to_sketch(edges,ndir=ndir,sketchname=sketchname,offset=offset,datum_sketch=datum_sketch)

	return sketch1['sketch'].name

def edges_to_nodes(edges):
	## VER: 2014-10-14, v1.0

	edges = tolist(edges)

	nodes = []
	for edge in edges:
		nodes1 = edge.getNodes()
		if _len(nodes1) > 0:
			nodes1 = tolist(nodes1)
			nodes = nodes + nodes1

	nodes = remove_repeated_items(nodes)

	return nodes

def edges_to_sketch(edges,ndir=None,sketchname='s_temp',offset=None,datum_sketch=True):
	## VER: 2014-01-02, v1.3 本函数将会生成sketch，并可能有临时的part生成。
	## 即使这些edges在ndir方向上有一个范围。

	## Example:
	## pick edges for set e1 => pick()
	## edges_to_sketch(e1,ndir='x',offset=0)

	## Example:
##	edges = edge_select(stamp,y=MIN)
##	sketch1 = edges_to_sketch(edges)

	## Example
##	edges = edge_select(powder,ny=-1)
##	s1 = edges_to_sketch(edges,sketchname='sk_bpunch', ndir='z',offset=0)
##	connect_points(s1,'xmax',('dx',0.5))
##	sketch_to_wire(s1,partname='bpunch',symmetric=True,ptype='discrete')
##	new_instance(bpunch)


	global _m, a

	edges = totuple(edges)

	if ndir in empty:
		ndir = edges_ndir(edges)

	if ndir in empty:
		raise Exception('*** edges ndir is required.')

	if offset in empty:
		offset = edges_offset(edges)

	poi = get_poi(edges[0])
	delete = False
	if type_of(poi) == 'PART':
		part = poi
	else:
		action = get_poi_position(poi)['eqv_action']
		if action != 'stay':
			print 'instance method=',action,', temp part will be created for',poi.name
			temp_part_name = temp_part_of_poi(poi)
			part = _m.parts[temp_part_name]
			delete = True
		else:
			part = poi.part

		new_list = []
		for edge in edges:
			new_list.append(part.edges[edge.index])
		edges = new_list   ## 转变成part edges

	if datum_sketch == True:	## sketch中含有partname,datum_plane和right_edge信息。
		sketch1 = create_part_sketch(part, name=sketchname,ndir=ndir,offset=offset)
		part.projectEdgesOntoSketch(sketch=sketch1['sketch'],edges=edges,constrainToBackground=False)
		print 'sketch1 ndir=',sketch1['ndir']
		print 'sketch1 name=',sketch1['name']

	else:
		sketch1 = create_base_sketch(name=sketchname,ndir=ndir,offset=offset, return_sketch=True)   ## 只投影到法线为x,y, or z的草图平面。
		part.projectEdgesOntoSketch(sketch=sketch1,edges=edges,constrainToBackground=False)   ## part只是辅助作用。
		if delete == True:
			del_parts(part.name)

		print 'sketch1 ndir=',ndir
		print 'sketch1 name=',sketchname

	return sketch1

def edges_to_wirepart(edges,ndir=None,offset=0,partname='wirepart',pshape='2D',ptype='deformable',sym_axis='V'):
	## VER: 2014-12-23, v1.2

	## Example:
##	edges = edge_select(powder,ny=-1)
##	edges_to_wirepart(edges,partname='bpunch',ptype='discrete',pshape='axisym')
##	new_instance('bpunch')

	edges = totuple(edges)

	x1,x2,y1,y2,z1,z2 = objs_space(edges)
##	print fnln(),(x1,x2,y1,y2,z1,z2 )

	if abs(z2 - z1) < 1e-6:
		ndir = 'z'

	if ndir in empty:
		ndir,offset = ndir_and_offset_of_curve(edges[0])
		if ndir == 'NA':
			raise Exception('Fail to get the ndir for one edge, may be it is line.')
	elif ndir not in ['x','y','z']:
		raise Exception('Please provide the ndir of edges.')

##	poi = get_poi(edges)
	sketch1 = edges_to_sketch(edges,ndir=ndir,datum_sketch=False,offset=offset)   ## offset没用。wire part总是在ndir的空间范围为(0,0)

	sketch1 = check_sketch(sketch1)
	if len(sketch1.geometry) == 0:
		raise Exception('Fail to create the wire in the sketch by project of edges. ')

##	print fnln(),ptype
##	raise Exception
	wirepart = sketch_to_wire(sketch=sketch1,partname=partname,pshape=pshape,ptype=ptype)

	return wirepart


def edges_length(edges):
	## VER: 2013-09-18, v1.5

	edges = tolist(edges)

	length = 0
	for edge in edges:
		length = length + edge.getSize(printResults=False)

##	length = round(length,6)  ## 不能近似，否则可能有误，如算半径时。

	return length

def edges_ndir(edges):
	## VER: 2014-01-02, v1.0

	x1,x2,y1,y2,z1,z2 = objs_space(edges)

	ndir = None
	if PK(x1,x2) == 0:
		ndir = 'x'
	elif PK(y1,y2) == 0:
		ndir = 'y'
	elif PK(z1,z2) == 0:
		poi = get_poi(edges)
		if '3D' in part_shape(poi)[1]:
			ndir = 'z'

	return ndir

def edges_offset(edges):
	## VER: 2014-12-24, v1.1

	x1,x2,y1,y2,z1,z2 = objs_space(edges)

	offset = None
	if PK(x1,x2) == 0:
		offset = x1
	elif PK(y1,y2) == 0:
		offset = y1
	elif PK(z1,z2) == 0:
		offset = z1
##		poi = get_poi(edges)
##		if '3D' in part_shape(poi)[1]:
##			offset = z1

	if offset == None:
		raise Exception('*** fail to get the offset of edges.')

	return offset

def edges_of_cells(cells,edir=None,exterior=None):

	## VER: ('VER: 2012-08-07, v1.2')

	cells = tolist(cells)
	poi = get_poi(cells)

	edges = []
	for cell in cells:
		indexs = cell.getEdges()
		for index in indexs:
			edge = poi.edges[index]
			if edge not in edges:
				edges.append(edge)

	for edge in edges:
		if edir != None and edir != edge_dir(edge):
			continue
		if exterior == True and len(edge.getFaces()) not in [2,3]:
			continue

		edges.append(edge)

	return edges

def edges_of_face(face,in_out=None,long_short=None,minimum=1.2):
	## VER: 2011-12-06, v1.1，注意与faces_to_edges()不同，本函数主要用于mesh时，寻找长边和短边。

	if type_of(face) != 'faces':
		raise Exception('****** A face is required.')

	poi = get_poi(face)
	ids = face.getEdges()

	if in_out == 'outer':
		in_out = 'exterior'

	edges1 = []
	if len(ids) == 4:
		edges = []
		for id in ids:
			edge = poi.edges[id]
			edges.append(edge)

		area = get_area(face)
		area = round(area,5)

		for edge in edges:
			select1 = False
			if in_out != None:
				faces = edge.getFaces()
				if in_out == 'inner' and len(faces) > 2:
					select1 = True
				elif in_out == 'exterior' and len(faces) == 2:
					select1 = True

				if select1 == False:
					continue

			select2 = False
			if long_short != None:
				length = edge_length(edge)
				if length >= minimum:
					area2 = round(length*length,5)

					if long_short == 'long' and area2 > area:
						select2 = True
					elif long_short == 'short' and area2 < area:
						select2 = True

				if select2 == False:
					continue

			edges1.append(edge)   ## passed

	return edges1

def edges_of_cut(poi,x=None,y=None,z=None, edir=None,tryone=False, exterior=None, inplane=False,mark_select=True,include_ends=True):
	## VER: ('VER: 2014-06-17, v1.5')		## 注意：用cell_select的方法很慢。
	## inplane: 只选切割面的面内的edges。可以想象，此时其实没有真正的切割，因为在切割面处已经有vertices。

	poi = check_pias(poi)
	x,y,z=real_xyz(poi,x,y,z)
	x,y,z = real_xyz(poi,x,y,z)

	floats = {}
	ranges = {}
	if type_of(x) in ['FLOAT','INT']:
		floats[0] = x
	elif type_of(x) in ['LIST','TUPLE'] and x not in empty:
		ranges[0] = x

	if type_of(y) in ['FLOAT','INT']:
		floats[1] = y
	elif type_of(y) in ['LIST','TUPLE'] and y not in empty:
		ranges[1] = y

	if type_of(z) in ['FLOAT','INT']:
		floats[2] = z
	elif type_of(z) in ['LIST','FLOAT'] and z not in empty:
		ranges[2] = z

	if len(floats) not in [1,2]:
		raise Exception('Unknow cut_offset offset, len(floats)=',len(floats))

	print 'floats=',floats
	print 'ranges=',ranges

##	raise Exception

	dirs = floats.keys()
	cut_axis = dirs[0]
	cut_offset = floats[cut_axis]

##	print 'cut_offset=',cut_offset
##	print 'cut_axis=',cut_axis

	refine_axis = None
	if len(dirs) == 2:
		refine_axis = dirs[1]
		refine_loc = floats[refine_axis]

##		print 'refine_loc=',refine_loc
##
##	print 'refine_axis=',refine_axis

	## check ndir
	if edir not in [None,'x','y','z']:
		raise Exception('edir should be x, y, or z')

	pshape = part_shape(poi)[1]
	if '2D_shell' in pshape and exterior == None:
		exterior = True


##	print 'edir=',edir

##	raise Exception

	if inplane == False: ##要切断edges
		if type_of(poi) == 'PART':
			temp_part = copy_part(poi,'_ptemp')
		else:
			temp_part = temp_part_from_inst(poi)

		if cut_axis == 0:
			divide(temp_part,x=cut_offset)
		elif cut_axis == 1:
			divide(temp_part,y=cut_offset)
		elif cut_axis == 2:
			divide(temp_part,z=cut_offset)

		part1 = _m.parts[temp_part]

		locs = []
		for vertice in part1.vertices:
			loc = vertice.pointOn[0]
			if not equal(loc[cut_axis],cut_offset):
				continue
			if refine_axis != None and not equal(loc[refine_axis],refine_loc):
				continue
			locs.append(loc)

##		del _m.parts[temp_part]
##		del part1

		del_parts(temp_part)

	else:  ## 没有cut的动作
		locs = []
		for vertice in poi.vertices:
			loc = vertice.pointOn[0]
			if not equal(loc[cut_axis],cut_offset):
				continue
			if refine_axis != None and not equal(loc[refine_axis],refine_loc):
				continue
			locs.append(loc)

##	print 'locs=',locs

	edges = []
	for loc in locs:
		vertice = poi.vertices.findAt(loc,printWarning=False)
		if type_of(vertice) == 'vertices':
			indexs = vertice.getEdges()
			for index in indexs:
				edge = poi.edges[index]
				if edge not in edges:
					edges.append(edge)
		else:
			edge = poi.edges.findAt(loc,printWarning=False)
			if type_of(edge) == 'edges' and edge not in edges:
				edges.append(edge)

	if refine_axis != None:
		edges1 = []
		for edge in edges:
			pointOn = edge.pointOn[0]
			if not equal(pointOn[refine_axis],refine_loc):
				continue
			if not equal(pointOn[cut_axis],cut_offset):
				continue
			edges1.append(edge)
		edges = edges1

	if edir not in empty:
		newlist = []
		for edge in edges:
			if edir not in edge_dir(edge):   ##??****
				continue
			newlist.append(edge)
		edges = newlist

	if cut_axis == 0:
		cut_axis = 'x'
	elif cut_axis == 1:
		cut_axis = 'y'
	elif cut_axis == 2:
		cut_axis = 'z'

##	print 'len(edges)=',len(edges)
##	print 'cut_axis=',cut_axis
##	raise Exception

	if inplane == True:
		newlist = []
		for edge in edges:
			dir1 = edge_dir(edge)
			if dir1 != cut_axis:
				newlist.append(edge)
		edges = newlist

##	light(edges)
##	raise Exception

	if exterior == True:
		pshape = part_shape(poi)[1]

		newlist = []
		if 'shell' in pshape:
			for edge in edges:
				if len(edge.getFaces()) == 1:
					newlist.append(edge)
		elif 'solid' in pshape:
			for edge in edges:
				if len(edge.getFaces()) == 2:
					newlist.append(edge)
		edges = newlist

	if ranges not in empty:
		newlist = []
		for edge in edges:
			space = space_of_edges(edge)
			meet = True
			for dir1,search_range in ranges.items():
				obj_range = (space[2*dir1],space[2*dir1 + 1])
				if not meet_search_range(obj_range, search_range,include_ends=include_ends,mark_select=mark_select):
					meet = False
					continue
##				else:
##					print 'obj_range=',obj_range,', search_range=',search_range,'meet'

			if meet == True:
				newlist.append(edge)
		edges = newlist

	if tryone == True and len(edges) > 0:
		edges	= [edges[0]]

	print '--->',len(edges),'edges was selected. cut_axis=',cut_axis,', refine_axis=',refine_axis,', edir=',edir

	return edges

def faces_to_edges(faces,edir=None,exterior=None):
	## VER: 2016-06-15, v1.1

##	>>> edges = faces_to_edges(faces,exterior=True)

	faces = tolist(faces)
	poi = get_poi(faces)

	ids = []
	for face in faces:
		edges1 = tolist(face.getEdges())
		ids = ids + edges1

	ids.sort()

	edges = []
	for id1 in ids:
		edge = poi.edges[id1]
		if edge in edges:
			continue
		if edir != None and edir != edge_dir(edge):
			continue

		edges.append(edge)

	if exterior == True:
		newlist = []
		for edge in edges:
			if len(edge.getFaces()) == 2:
				newlist.append(edge)
		edges = newlist

	return edges

def expansion(alpha,deltaT,length):
	## VER: 2014-09-03, v1.0

	if alpha > 0.01 and deltaT > 0.01:
		alpha,deltaT = _sort(alpha,deltaT)

	if alpha > 0.01:
		alpha = alpha*1e-6

	expan = alpha*deltaT*length
	expan = smart_round(expan)
	print '--->expansion=',expan,', unit is the same as length input'

	return expan

function_labels['extend_faces_by_edges'] = 'faces','extend','extrude','edges'
def extend_faces_by_edges(edges,distance=0.5):
	## VER: 2016-05-13, v1.0
	## GUI: Tools->Geometry Edit->Faces->Extend->Specify edges of faces to extend
	## Sometimes run this command in GUI is also high efficient
	## 如果distance=1失败，则distance=0.5可能成功。
	## reference: faces_extrude()

	## create die
##	length0 = _zlength(die)
##	edges = find_edge_loops(die,sort='z')
##
##	extend_faces_by_edges(edges[0],distance=1)   ## bottom extend
##	length1 = _zlength(die)
##
##	edges = find_edge_loops(die,sort='z')   ## 编号改变了
##	extend_faces_by_edges(edges[1],distance=1)   ## top extend
##	length2 = _zlength(die)


	## For tpunch in powder compaction
##	faces = face_select('powder2',nz=1,z=MAX)
##	tpunch = faces_to_shellpart(faces,name='tpunch',rigid=True)
##	edges = edge_select('tpunch',radius=7.1515)
##	edges1 = edge_select('tpunch',exterior=True)
##	edges = unselect(edges1,edges)
##	extend_faces_by_edges(edges,distance=1)

	## For die in powder compaction
##	edges = edge_select('die',z=MAX)
##	extend_faces_by_edges(edges,distance=1)

	if is_number(distance) == False:
		raise Exception('*** extend distance is required.')

	part = get_poi(edges)
	part = check_part(part)

	faces = face_select(part)
	area0 = get_area(faces)

	edge_seq = list2sequence(edges)
	part.ExtendFaces(extendAlong=edge_seq,distance=distance)

	faces = face_select(part)
	area1 = get_area(faces)

	print ' '
	print 'area0=',area0
	print 'area1=',area1
	if area1>area0:
		print '--->Extend faces successfully by edges of faces.'
	else:
		print '*** Fail to extend the faces by edges of faces.'

	return

function_labels['extend_two_nodes'] = 'profile','select'
def extend_two_nodes(nodes,angle=20):
	## VER: 2017-06-08, v1.0

	## pick two nodes and create set v1
	## nodes = extend_two_nodes(v1)

	nodes = exterior_nodes(nodes)
	if len(nodes) != 2 and type_of(nodes) != 'LIST':
		raise Exception('*** 2 nodes are required.')

	vector1 = vector_of_2nodes([nodes[-2],nodes[-1]])
	angle1 = vector_angle(vector1=vector1,axis='x')
	angle2 = vector_angle(vector1=vector1,axis='y')
	angle3 = vector_angle(vector1=vector1,axis='z')
	angle1 = round(angle1,2)
	angle2 = round(angle2,2)
	angle3 = round(angle3,2)
	dict1 = {angle1:'x',angle2:'y',angle3:'z'}
	min_angle = min(dict1.keys())
	dir1 = dict1[min_angle]

	nodes1 = extend_two_nodes_in_direction(nodes,dir1='+' + dir1, angle=angle)
	nodes2 = extend_two_nodes_in_direction(nodes,dir1='-' + dir1, angle=angle)

	nodes = nodes1 + nodes2
	nodes = remove_repeated_items(nodes)

	return nodes

def extend_two_nodes_in_direction(nodes,dir1='+x',angle=20):
	## VER: 2017-06-08, v1.0

	if len(nodes) != 2 and type_of(nodes) != 'LIST':
		raise Exception('*** 2 nodes are required.')

	dir1 = dir1.lower()
	if dir1 == 'x+':
		dir1 = '+x'
	elif dir1 == 'x-':
		dir1 = '-x'
	elif dir1 == 'y+':
		dir1 = '+y'
	elif dir1 == 'y-':
		dir1 = '-y'
	elif dir1 == 'z+':
		dir1 = '+z'
	elif dir1 == 'z-':
		dir1 = '-z'

	if dir1[0] not in ['+','-']:
		raise Exception('*** Error direction')

	reverse = False
	if dir1[0] == '-':
		reverse = True

	if 'x' in dir1:
		nodes = nodes_sort_byx(nodes,reverse=reverse)
	elif 'y' in dir1:
		nodes = nodes_sort_byy(nodes,reverse=reverse)
	elif 'z' in dir1:
		nodes = nodes_sort_byz(nodes,reverse=reverse)

	while True:
		nodes1 = adjacent_nodes(nodes[-1],dir1=dir1)

		if len(nodes1) == 1:
			if nodes1[0] in nodes:
				nodes1 = []

		if len(nodes1) > 0:
			dict1 = {}
			for node in nodes1:
				vector1 = vector_of_2nodes([nodes[-1],node])
				vector2 = vector_of_2nodes([nodes[-2],nodes[-1]])
				angle1 = vector_angle(vector1,vector2)
				angle1 = round(angle1,2)
				dict1[angle1] = node
			min_angle = min(dict1.keys())
			if min_angle < angle:
				nodes.append(dict1[min_angle])
			else:
				break
		else:
			break

	return nodes

def exterior_edges(poi=None,faces=None,edges=None):
	## VER: ('VER: 2016-07-28, v1.3')

##	print ' '
##	print '****>>>>>Start exterior_edges(), caller=',caller_fnln()

	## edges = exterior_edges('powder')

	if poi not in empty and (faces,edges) == (None,None):  ## only provide one parameter
		if is_pia(poi) == False:
			objs = tolist(poi)
			poi = None
			if type_of(objs[0]) == 'faces':
				faces = objs
			elif type_of(objs[0]) == 'edges':
				edges = objs
		else:
			poi = check_pia(poi)

	if is_pia(faces):
		faces,poi = poi,faces
	elif is_pia(edges):
		edges,poi = poi,edges

##	if is_pia(poi) == False and poi not in empty:
##		objs = tolist(poi)
##		if type_of(objs[0]) == 'faces':


##	if is_pia(faces):
##		faces,poi = poi,faces

	if is_pia(poi):
		poi = check_pia(poi)

	if type_of(poi) in ['PART','PINSTANCE']:
		if type_of(faces) == 'STR':
			faces = set2objs(faces,poi)
		elif type_of(edges) == 'STR':
			edges = set2objs(edges,poi)

	faces = tolist(faces)
	edges = tolist(edges)
	if faces in empty and edges in empty:
		edges = tolist(poi.edges)
##		raise Exception('****** faces list or edges list is required.')

	if poi in empty:
		if faces not in empty:
			poi = get_poi(faces)
		elif edges not in empty:
			poi = get_poi(edges)

	if is_solid_list(edges) and type_of(edges[0]) == 'faces':
		faces = edges
		edges = []
	elif is_solid_list(faces) and type_of(faces[0]) == 'edges':
		edges = faces
		faces = []

	ext_edges = []

	if is_solid_list(faces):  ## Exterior edges of faces
		edges = faces_to_edges(faces)

		for edge in edges:
			ids = edge.getFaces()
			faces1 = []
			for id in ids:
				faces1.append(poi.faces[id])

			if len(get_common(faces,faces1)) == 1:
				ext_edges.append(edge)

		print len(ext_edges),'exterior edges of faces are selected in',poi.name

	elif is_solid_list(edges):  ## exterior edges of edges
		pshape = part_shape(poi)[1]

		newlist = []
		if 'shell' in pshape:
			for edge in edges:
				if len(edge.getFaces()) == 1:
					newlist.append(edge)
		elif 'solid' in pshape:
			for edge in edges:
				if len(edge.getFaces()) == 2:
					newlist.append(edge)
		ext_edges = newlist

##	print '****<<<<<End exterior_edges'
##	print ' '

	return ext_edges

def edges_of_insts(insts=None,x=(),y=(),z=(),parts=None, exclude=None, edges=None, edir=None,setname=None,
	include_ends=True,mark_select=True, shape=None, radius=None, diameter=None, exterior=None):
	## VER: ('VER: 2014-06-17, v1.0')
	## Example:
	## apply_disp_symm('x',edges=edges_of_insts(x=0))

	if exclude not in empty:
		exclude = real_insts(exclude)

	if parts not in empty:
		parts = real_parts(parts)
		insts = insts_of_parts(parts)

	if insts != None or parts != None:
		inst_specify = True
	else:
		inst_specify = False


	insts = real_insts(insts)
	if insts in empty:
		if inst_specify == False:
			insts = all_valid_insts()
			insts = real_insts(insts)
		else:		## insts or parts有输入，但是无效。
			print '****Empty insts, no edge was selected.'
			return []

	if exclude not in empty:
		insts = unselect(insts,exclude)

	if type_of(insts) != 'LIST':
		raise Exception('instances list is required. ')   ## ********

	x = totuple(x)
	y = totuple(y)
	z = totuple(z)
	if x not in empty and is_location(x) == False:
		raise Exception('*** specific location x is required.')

	if y not in empty and is_location(y) == False:
		raise Exception('*** specific location y is required.')

	if z not in empty and is_location(z) == False:
		raise Exception('*** specific location z is required.')

	edges1 = []
	for inst in insts:
		edges2 = edge_select(inst.name,x=x, y=y, z=z, edir=edir,edges=edges, setname=setname,
			mark_select=mark_select,include_ends=include_ends, shape=shape, radius=radius, diameter=diameter, exterior=exterior)
		edges1 = edges1 + edges2
	edges = edges1

	if len(edges) > 0:
		print '--->Totally', len(edges),'edges are selected in the model assembly.'
	else:
		raise Exception('Selection of edges failed from the model assembly. ')		## **********

	return edges

def vertices_sort_byx(vertices,return_obj=False):
	## VER: 2017-10-27, v1.1

##	>>> vertices = vertice_select('punch_A1',z=MAX)
##	>>> vertices = vertices_sort_byx(vertices)
##	>>> vertices[-1]
##	(17.479, [mdb.models['Model-1'].rootAssembly.instances['punch_A1'].vertices.findAt((17.478991, -10.0915, 15.0),)])
##	>>>

	if is_poi(vertices):
		poi = check_poi(vertices)
		vertices = poi.vertices

	vertices = tolist(vertices)
	list1 = map(lambda vertice:(round(vertice.pointOn[0][0],4),vertice),vertices)
	dict1 = {}
	for loc,vertice in list1:
		if loc not in dict1.keys():
			dict1[loc] = []
		dict1[loc].append(vertice)

	list2 = sort_by_key(dict1)

	if return_obj == True:
		newlist = []
		for item in list2:
			newlist = newlist + item[1]
		list2 = newlist

	return list2

def vertices_sort_byy(vertices,return_obj=False):
	## VER: 2017-10-27, v1.1

	## for sweep mesh
##	vertices = edges_to_vertices(edges)
##	vertices = vertices_sort_byy(vertices,return_obj=True)[1:-1]
##	ignore_vertices(nib,vertices=vertices)

	if is_poi(vertices):
		poi = check_poi(vertices)
		vertices = poi.vertices

	vertices = tolist(vertices)
	list1 = map(lambda vertice:(round(vertice.pointOn[0][1],4),vertice),vertices)
	dict1 = {}
	for loc,vertice in list1:
		if loc not in dict1.keys():
			dict1[loc] = []
		dict1[loc].append(vertice)

	list2 = sort_by_key(dict1)

	if return_obj == True:
		newlist = []
		for item in list2:
			newlist = newlist + item[1]
		list2 = newlist

	return list2

def vertices_sort_byz(vertices,return_obj=False):
	## VER: 2017-10-27, v1.0

	if is_poi(vertices):
		poi = check_poi(vertices)
		vertices = poi.vertices

	vertices = tolist(vertices)
	list1 = map(lambda vertice:(round(vertice.pointOn[0][2],4),vertice),vertices)
	dict1 = {}
	for loc,vertice in list1:
		if loc not in dict1.keys():
			dict1[loc] = []
		dict1[loc].append(vertice)

	list2 = sort_by_key(dict1)

	if return_obj == True:
		newlist = []
		for item in list2:
			newlist = newlist + item[1]
		list2 = newlist

	return list2

def vertices_to_edges(vertices,edir=None):
	## VER: 2011-11-29, v1.0

	vertices = tolist(vertices)
	if vertices in empty:
		print fnln_fnln(), 'No vertice selected, so no edge is found.'
		return []

##	print fnln(),'vertices=',vertices
##	print fnln(),'len(vertices)=',len(vertices)
	poi = get_poi(vertices)

	ids = []
	for vertice in vertices:
		edges1 = tolist(vertice.getEdges())
		ids = ids + edges1

	ids.sort()

	edges = []
	for id1 in ids:
		edge = poi.edges[id1]
		if edge in edges:
			continue
		if edir != None and edir != edge_dir(edge):
			continue

		edges.append(edge)

	return edges

def elements_of_faces(faces,poi=None):
	## VER: 2013-05-31, v1.0
	## 注意，node和element的label比起index大1.
	## 例如，mdb.models['Model-1'].parts['anvil'].nodes[24]，起label为25。

	## faces = face_select(part1,ndir='cylindrical')
	## elements = elements_of_faces(faces)

	if type_of(faces) == 'STR':
		faces = set2objs(faces,p=poi)

	elements = []
	faces = tolist(faces)
	for face in faces:
		elems = list(face.getElements())
		elements = elements + elems

	return elements

def elements_region_of_faces(faces,poi=None):
	## VER: 2013-05-31, v1.0

	elements = elements_of_faces(faces=faces,poi=poi)

	if elements not in empty:
		region = list2region(elements,region_type='surface')	;please_check
	else:
		raise Exception('**** Cannot get elements of unmeshed faces.')

	return region

def elements_sequence_of_faces(faces,poi=None):
	## VER: 2013-05-31, v1.0

	elements = elements_of_faces(faces=faces,poi=poi)

	if elements not in empty:
		seq = list2sequence(elements)
	else:
		raise Exception('**** Cannot get elements of unmeshed faces.')

	return seq

def elements_to_labels(elems):
	## VER: 2016-12-07, v1.0

	elems = tolist(elems)
	labels = []
	for elem in elems:
		label = elem.label
		if label not in labels:
			labels.append(label)

	return labels

def elements_to_labels_dict(elements):
	## VER: 2013-05-31, v1.0

	elements = tolist(elements)
	if elements[0].instanceName == None:
		raise Exception('**** Elements from instance is required.')

	dict1 = {}
	for elem in elements:
		inst = elem.instanceName
		label = elem.label

		if inst not in dict1.keys():
			dict1[inst] = [label]
		else:
			dict1[inst].append(label)

	for inst in dict1.keys():
		dict1[inst] = totuple(dict1[inst])

	return dict1

def elements_to_model_element_labels(elements):

	## VER: ('VER: 2012-04-26, v1.0')

	elements = tolist(elements)

	dict1 = {}
	for element in elements:
		inst = element.instanceName
		label = element.label
		if inst not in dict1.keys():
			dict1[inst] = [label]
		else:
			dict1[inst].append(label)

	for key in dict1.keys():
		dict1[key] = totuple(dict1[key])

	items = totuple(dict1.items())
	if len(dict1) == 1:
		label_seq = (items,)

	elif len(dict1) > 1:
		label_seq = items

	return label_seq

function_labels['is_empties'] = 'empty','None','list','length'
def is_empties(*list1):
	## VER: ('VER: 2016-10-25, v1.6')	## 判断列表中的元素是否全部为空，例如[None,[],(),{}]
	## 这是可变参数，本函数判断所接受的参数是不是都是empty
	## reference: is_empty()

##	>>> list1
##	[None, []]
##	>>> list2
##	[None, []]
##	>>> is_empties(list1,list2)
##	True
##	>>> is_empties(list1)
##	True
##	>>> is_empties({})
##	True
##	>>> is_empties([])
##	True
##	>>>

	if list1 == ():
		raise Exception('variable is required to judge in empty or not')

	list1 = tolist(list1)
	if type_of(list1) != 'LIST':
		list1 = [list1]   ## 得到的的是参数列表

##	print 'list1=',list1
	result = True
	for obj in list1:
		if is_empty(obj) == False:
			result = False
			if type_of(obj) in ['LIST','LIST'] and is_empties(obj):
				result = True
		if result == False:
			break

	return result

def all_is_type(list1,type):
	## VER: 2013-05-21, v1.0

	if type_of(list1) not in ['LIST','TUPLE']:
		raise Exception('**** A data list or tuple is require.')

	if type_of(type) not in ['STR', 'LIST','TUPLE']:
		raise Exception('**** element type is required.')

	same = True
	if list1 in empty:
		same = False

	for element in list1:
		if type_of(element) not in type:
			same = False
			break

	return same

def all_is_value(list1,value):
	## VER: 2013-10-01, v1.1

	if type_of(list1) not in ['LIST','TUPLE']:
		raise Exception('**** A data list or tuple is require.')

	same = True
	if list1 in empty:
		same = False

	if type_of(value) in numerics:
		pk = True
	else:
		pk = False

	if pk == False:
		for element in list1:
			if element != value:
				same = False
				break
	else:
		for element in list1:
			if PK(element,value) != 0:
				same = False
				break

	return same

def elements_to_nodes(elements):
	## VER: 2014-10-13, v1.0

	elements = tolist(elements)
	if elements in empty:
		raise Exception('*** elements are required.')

	nodes = []
	for elem in elements:
		nodes0 = elem.getNodes()
		for node in nodes0:
			if node not in nodes:
				nodes.append(node)

	return nodes

def elems_nodes_by_face(poi,elements=None,x=(),y=(),z=(),poiRefX=(), poiRefY=(),poiRefZ=(), space=(),
	nx=0,ny=0,nz=0,angle=40,err=1,err0=None):
	## VER: 2016-09-28, v2.0
	## reference: elements = seq.getByBoundingBox()   ## seq is a sequence of elements, such as _part(powder).elements[:]

##	elems,nodes = elems_nodes_by_face(p1,z=MAX,nz=1,err=1,angle=1)  ## p1 is the deformed insert part with only mesh

##	>>> elems,nodes = elems_nodes_by_face('green',nx=1,x=MAX)
##	['element_select', 48957] poiRefX= (4.312329, 6.312329)
##	---> 2948 elements selected by element_select()
##	---> 2584 elements selected by elems_nodes_by_face()
##	---> 2695 nodes selected by elems_nodes_by_face()
##	>>> light(elems)

	poi = check_poi(poi)

	if elements in empty:
		elements = poi.elements[:]
	else:
		elements = tolist(elements)

##	print fnln(),'x,y,z=',x,y,z
	x0,y0,z0 = x,y,z   ## 如果在real_xyz之前，指定了x,y,或z的具体值，那么需要进行精细化选择
	if is_number(err0) == False:
		err0 = 0.1		;please_check

	refine = False
	if is_number(x0):
		x0 = x0-err0,x0+err0
		refine = True

	if is_number(y0):
		y0 = y0-err0,y0+err0
		refine = True

	if is_number(z0):
		z0 = z0-err0,z0+err0
		refine = True

	x,y,z = real_xyz(poi,x,y,z,space=space,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ)
##	print fnln(),'x,y,z=',x,y,z

	if is_number(x):
		x = x-err,x+err
	if is_number(y):
		y = y-err,y+err
	if is_number(z):   ## such as z=MAX
		z = z-err,z+err

##	print fnln(),'err=',err
##	print fnln(),'so, x,y,z=',x,y,z
	print fnln(),'input angle=',angle

##	print fnln(),'x,y,z=',x,y,z

	if (nx,ny,nz) == (0,0,0):
		raise Exception('*** nx,ny,or nz is required.')

##	print fnln(),poiRefZ

	myelements = []
	if x in empty and y in empty and z in empty:
		myelements = elements
	else:
		myelements = element_select(poi,x=x,y=y,z=z,elements=elements)

	if myelements not in empty:
		myelements = exterior_elements(poi,myelements)

##	light(myelements)
##	raise Exception

	nodes = []
	elems = []
	if myelements not in empty:
		shape = get_element_shape(myelements[0])
		faces = get_an_element_face(myelements,nx=nx,ny=ny,nz=nz)  ## only find one face

		if faces not in empty:
			if shape == '3D':
				face0 = faces[0]
				nodes = face0.getNodesByFaceAngle(angle)
				elems = face0.getElementsByFaceAngle(angle)
				nodes = tolist(nodes)
				elems = tolist(elems)

			elif shape == '2D':  ## 2D element without  the getNodesByEdgeAngle() and getElementsByFaceAngle()
				for face0 in faces:
					nodes1 = face0.getNodes()
					nodes1 = tolist(nodes1)

					elems1 = face0.getElements()
					elems1 = tolist(elems1)

					nodes = nodes + nodes1
					elems = elems + elems1

				nodes = remove_repeated_items(nodes)
				elems = remove_repeated_items(elems)

##	例如: elems,nodes = elems_nodes_by_face(p1,z=MAX,nz=1,err=1,angle=1)
##	此时light(elems)可看到表面的elements
##	此时light(nodes)可看到表面的nodes
##	raise Exception

##	raise Exception

##	print fnln(),'x,y,z=',x,y,z
	print '--->',len(elems),'elements selected by elems_nodes_by_face()'
	print '--->',len(nodes),'nodes selected by elems_nodes_by_face()'

	if nodes not in empty and refine == True:
		nodes = node_select(poi,x=x0,y=y0,z=z0,nodes=nodes)

		print fnln(),'after refine node select,'
		print '--->',len(nodes),'nodes selected by elems_nodes_by_face()'

	return elems,nodes

def end_edges(p,*ends):
	## VER: 2010-10-06, v1.0

	if ends == ():
		ends = ['xmin','xmax','ymin','ymax','zmin','zmax']
	elif len(ends) == 1:
		if type_of(ends[0]) in ['LIST','TUPLE']:
			ends = ends[0]

	ends = list(ends)
	for i in range(len(ends)):
		ends[i] = ends[i].lower()
		if ends[i] == 'minx':	ends[i] = 'xmin'
		if ends[i] == 'maxx':	ends[i] = 'xmax'
		if ends[i] == 'miny':	ends[i] = 'ymin'
		if ends[i] == 'maxy':	ends[i] = 'ymax'
		if ends[i] == 'minz':	ends[i] = 'zmin'
		if ends[i] == 'maxz':	ends[i] = 'zmax'

	if len(ends) > 0:
		x1,x2,y1,y2,z1,z2 = poi_space(p)

	if 'xmin' in ends:
		edges = edges_of_cut(p,x=x1)
		if len(edges) > 0:
			create_set(p, objs=edges, name='e_'+p.name+'_xmin')

	if 'xmax' in ends:
		edges = edges_of_cut(p,x=x2)
		if len(edges) > 0:
			create_set(p,objs=edges, name='e_'+p.name+'_xmax')

	if 'ymin' in ends:
		edges = edges_of_cut(p,y=y1)
		if len(edges) > 0:
			create_set(p, objs=edges, name='e_'+p.name+'_ymin')

	if 'ymax' in ends:
		edges = edges_of_cut(p,y=y2)
		if len(edges) > 0:
			create_set(p, objs=edges, name='e_'+p.name+'_ymax')

	if 'zmin' in ends:
		edges = edges_of_cut(p,z=z1)
		if len(edges) > 0:
			create_set(p,objs=edges, name='e_'+p.name+'_zmin')

	if 'zmax' in ends:
		edges = edges_of_cut(p,z=z2)
		if len(edges) > 0:
			create_set(p, objs=edges, name='e_'+p.name+'_zmax')

	return

def end_faces(p,*ends):
	## VER: 2010-09-30, v1.1

	if ends == ():
		ends = ['xmin','xmax','ymin','ymax','zmin','zmax']
	elif len(ends) == 1:
		if type_of(ends[0]) in ['LIST','TUPLE']:
			ends = ends[0]

	ends = list(ends)
	for i in range(len(ends)):
		ends[i] = ends[i].lower()
		if ends[i] == 'minx':	ends[i] = 'xmin'
		if ends[i] == 'maxx':	ends[i] = 'xmax'
		if ends[i] == 'miny':	ends[i] = 'ymin'
		if ends[i] == 'maxy':	ends[i] = 'ymax'
		if ends[i] == 'minz':	ends[i] = 'zmin'
		if ends[i] == 'maxz':	ends[i] = 'zmax'

	if len(ends) > 0:
		x1,x2,y1,y2,z1,z2 = poi_space(p)

	if 'xmin' in ends:
		faces = faces_of_cut(p,x=x1)
		if len(faces) > 0:
			create_set(p, objs=faces, name='f_'+p.name+'_xmin')

	if 'xmax' in ends:
		faces = faces_of_cut(p,x=x2)
		if len(faces) > 0:
			create_set(p, objs=faces, name='f_'+p.name+'_xmax')

	if 'ymin' in ends:
		faces = faces_of_cut(p,y=y1)
		if len(faces) > 0:
			create_set(p, objs=faces, name='f_'+p.name+'_ymin')

	if 'ymax' in ends:
		faces = faces_of_cut(p,y=y2)
		if len(faces) > 0:
			create_set(p, objs=faces, name='f_'+p.name+'_ymax')

	if 'zmin' in ends:
		faces = faces_of_cut(p,z=z1)
		if len(faces) > 0:
			create_set(p, objs=faces, name='f_'+p.name+'_zmin')

	if 'zmax' in ends:
		faces = faces_of_cut(p,z=z2)
		if len(faces) > 0:
			create_set(p, objs=faces, name='f_'+p.name+'_zmax')

	return

def end_locs_of_edge(edge):
	## VER: 2014-7-10, v1.0
	## reference: two_points_of_edge()

	if type_of(edge) != 'edges':
		raise Exception('*** an edge is required.')

	poi = get_poi(edge)
	ids = edge.getVertices()
	loc1 = poi.vertices[ids[0]].pointOn[0]
	if len(ids) == 1:
		loc2 = loc1
	else:
		loc2 = poi.vertices[ids[-1]].pointOn[0]  ## 一根圆弧，也只有两个点，没有圆心点和中点。

	return loc1, loc2


def equal(value1,value2):

	## VER: ('2012-08-14, v1.0')		## equal则True, 否则返回False

##	if type_of(value1) not in ['FLOAT','INT'] or type_of(value2) not in ['FLOAT','INT']:
##		raise Exception('Digital value is required.')

	if abs(value1 - value2) < 1e-6:
		result = True
	else:
		result = False

	return result

def error_info(infos,msg=''):
	## VER: 2015-04-28, v1.0

	infos = totable(infos)

	print ' '
	print '==============================='
	print fnln234()
	for item in infos:
		print item

	if msg not in empty:
		if msg[0] != '*':
			msg = '*** ' + msg

		print msg
		print ' '
		raise Exception(msg)
	else:
		print ' '
		raise Exception

	return

def error_record(info):
	##VER: 2010-01-22
	global _err_info

	_err_info.append(info)

	return

def expand(part,inst_name='',mirror_axis='x'):
	## VER: 2010-04-27
	global default_plot

	if type_of(mirror_axis) == 'STR':
		mirror_axis = mirror_axis.upper()

	if inst_name == '':
		inst = insts_of_parts(part)
		inst_name = inst[0].name
		print 'inst_name=',inst_name

	if 'tempP_exp' in _m.parts.keys():
		raise Exception('******tempP_exp has been existed. Cannot create annother part with the same name.')

	tempP_exp = copy_part(part,'tempP_exp',mirror_axis=mirror_axis)
	merge_instances(partname = part.name,insts=inst_name,parts=[part,tempP_exp],csys_KP=KPxyz(part))
	default_plot = part.name
##	default_plot = part

	del_parts(tempP_exp)

	return

function_labels['wait'] = 'job','submit','running','postprocessing','inp','status'
def wait():
	## VER: 2016-10-26, v1.0

	for odb_title1 in mdb.jobs.keys():
		job1 = mdb.jobs[odb_title1]
		if job1.status in [RUNNING,SUBMITTED]:
			mdb.jobs[odb_title1].waitForCompletion()
			break

	return odb_title1

def wall_faces(p,faces,ndir=None,nx=None,ny=None,nz=None):

	## VER: ('VER: 2012-07-30, v1.2')

	p = check_pias(p)

	faces2 = []
	for face in faces1:
		if len(face.getCells()) == 1:
			faces2.append(face)

	if not (ndir==nx==ny==nz==None):
		faces2 = face_select(p,faces=faces2,ndir=ndir,nx=nx,ny=ny,nz=nz)

	print len(faces2),'exterior faces are selected'

	return faces2

def export_parts(caename='_export_parts',parts=None,numbers=None):
	## VER: 2014-12-12, v1.4
	## such as: export some parts from a full rotary cutter model to created a new cae file.
	## refrecne: part2cae()

	## Example:
	## export_parts(numbers=[161,162,163,164,165,166,167,256,257,258])

	if caename[-4:] == '.cae':
		caename = caename[:-4]

	get_current_model()

	if is_numbers(numbers):
		numbers = tolist(numbers)
		parts = []
		for number in numbers:
			for partname in _m.parts.keys():
				num1 = str(number)
				loc1 = len(num1) + 1
				if partname.endswith(num1) and partname[-loc1].isdigit() == False:
					if partname not in parts:
						parts.append(partname)
						break

		if len(numbers) == 1 and str(numbers[0]) not in cae_name:
			cae_name = cae_name + '_' + str(numbers[0])

	if parts in empty:
		dpo = get_dpo()
		if type_of(dpo) == 'PART':
			parts = dpo
		elif type_of(dpo) == 'ASSEMBLY':
			insts = objs_of_dg()
			insts = real_insts(insts)   ## if some insts has transition or rotation from its part, assembly later may be error.
			parts = parts_of_insts(insts)

	parts = real_parts(parts)

	mdb.saveAs(caename)
	get_current_model()

	if a.sets.keys() not in empty:
		a.deleteSets(setNames=totuple(a.sets.keys()))

	if a.surfaces.keys() not in empty:
		a.deleteSurfaces(surfaceNames=totuple(a.surfaces.keys()))

	if a.features.keys() not in empty:
		a.deleteFeatures(totuple(a.features.keys()))

	parts1 = unselect(_m.parts.values(),parts)
	del_parts(parts1)

	get_current_model()
	mdb.save()

	return caename

def exterior_edges_of_element(element):
	## VER: 2014-10-19, v1.0

	if type_of(element) != 'elements':
		raise Exception('*** an element is required.')

	edges = []
	for edge in element.getElemEdges():
		if _len(edge.getElements()) == 1:
			edges.append(edge)

	return edges

def exterior_elements(elements=None,poi=None):
	## VER: 2016-01-08, v1.5

	if is_poi(elements):
		poi,elements = elements,poi

	if poi not in empty:
		poi=  check_poi(poi)

		if len(poi.elements) == 0:
			raise Exception('*** No element in ' + poi.name)

		if elements in empty:
			elements = poi.elements

		elements = tolist(elements)

	else:
		elements = tolist(elements)
		poi = get_parent(elements[0])

	shape = get_element_shape(elements[0])

	elems = []
	if shape == '3D':
		for element in elements:
			if len(element.getAdjacentElements()) < len(element.getElemFaces()):
				elems.append(element)
	elif shape == '2D':
		for element in elements:
			if len(element.getAdjacentElements()) < len(element.getElemEdges()):
				elems.append(element)

	return elems

def is_exterior_element(element):
	## VER: 2015-06-05, v1.0

	if type_of(element)!= 'elements':
		raise Exception('*** Element is required.')

	if len(element.getAdjacentElements()) < len(element.getElemFaces()): 	## 有裸露的element face
		result = True
	else:
		result = False

	return result


def exterior_faces_of_faces(faces):

	## VER: ('VER: 2012-07-30, v1.0')

	faces = tolist(faces)

	ext_edges = exterior_edges(faces)
	ext_vertices = edges_to_vertices(ext_edges)

	ext_indexs = []
	for vertice in ext_vertices:
		ext_indexs.append(vertice.index)

	ext_faces = []
	for face in faces:
		indexs = face.getVertices()
		if have_common(indexs,ext_indexs):
			ext_faces.append(face)

	print '--->',len(ext_faces),'boundary faces are selected.'

	return ext_faces

def exterior_nodes(nodes):
	## VER: 2016-05-05, v1.3
	## Example: nodes1 = exterior_nodes(nodes)

##	>>> nodes = nbox_select('green',z=MIN)
##	---> 6882 nodes are selected by box_select().
##	>>> nodes1 = exterior_nodes(nodes)
##	>>> len(nodes1)
##	6882
##	>>>

	nodes = tolist(nodes)
	if nodes in empty:
		return []
	else:
		elem0 = nodes[0].getElements()[0]
		shape = get_element_shape(elem0)

##		print fnln(),'shape=',shape

		if shape=='2D':  ## 2D
			newlist = []
			for node in nodes:
				edges = node.getElemEdges()
				for edge in edges:
					if len(edge.getElements()) == 1:
						newlist.append(node)
						break
			nodes = newlist

		else:
			newlist = []
			for node in nodes:
				elems = node.getElements()
				edges = node.getElemEdges()
				faces = node.getElemFaces()
				if len(elems) in [1,2]:
					newlist.append(node)
				elif len(elems) < len(edges):  ## please check
					newlist.append(node)
				elif len(elems) == len(edges):
					for face in faces:
						if len(face.getElements()) == 1:  ## this node reside in external element face
							newlist.append(node)
							break

			nodes = newlist

##	print '--->',fnln(),len(nodes),'exterior nodes'

	return nodes

def exterior_objs(poi):
	## VER: 2014-05-23, v1.0

	poi = check_poi(poi)
	objs = []
	if len(poi.cells) > 0:
		for cell in poi.cells[:]:
			indexs = tolist(cell.getFaces())
			for index in indexs:
				face = poi.faces[index]
				if face not in objs:
					objs.append(face)
	elif len(poi.faces) > 0:
		objs = poi.faces[:]
	elif len(poi.edges) > 0:
		objs = poi.edges[:]
	else:
		objs = poi.vertices[:]

	return objs

def extrude_sketch_to_part(part='ext_part',sketch='sketch1',length=50,direction='forward',expansion=None,half_angle=0,twist_angle=0):
	## VER: 2014-04-19, v1.7. sketch是一个信息集合体，类型为dict
	## if partname not exist, will create a new part
	## reference: sketch_to_shellpart()

	## 接受datum_sketch, 例如：

	## Example:
##	edges = edge_select(stamp,y=MIN)
##	sketch1 = edges_to_sketch(edges=edges,ndir='y',offset=_ymin(stamp))
##	extrude_sketch_to_part(stamp,sketch=sketch1,length=5,direction='reverse',half_angle=-20)

##	faces = face_select(p2_powder,nz=-1)   ## 此时, p2_powder尚未有沉头孔
##	loops = edge_loops_of_faces(faces)
##	sk_wall = edges_to_sketch(loops[0],ndir='z',offset=0)  ## datum sketch
##	p2_wall = extrude_sketch_to_part('p2_wall',sketch=sk_wall,length=50)

	global _m, a

	if part in _m.sketches.keys() or part in _m.sketches.values() or type_of(part) == 'DICT' and 'sketch' in part.keys():
		part,sketch = sketch,part
	elif type_of(sketch) == 'PART' or sketch in _m.parts.keys():
		part,sketch = sketch,part

	if type_of(part) == 'STR' and part not in _m.parts.keys():
		part = blank_part(part)   ## create new part

	part = check_part(part)
	length = abs(length)

	if type_of(expansion) in numerics and expansion != 0:
		half_angle = atan(expansion/length)    ## expansion > 0表示末端放大，expansion < 0表示末端缩小。
		half_angle = half_angle*180/pi        ## 角度单位
		print fnln_fnln(),'half_angle =',half_angle

	print fnln(),'type_of(sketch)=',type_of(sketch)
##	stop1()

	if len(part.cells) > 0:
		last_cell = part.cells[-1].index
	else:
		last_cell = -1

		changing   ## 有疑问
##		if type_of(sketch) == 'DICT':
##			sketch = sketch['sketch']

	print fnln(),'type_of(sketch)=',type_of(sketch)
	print fnln(),'space_of_sketch=',space_of_sketch(sketch)
##	stop1()
##	raise Exception

	if type_of(sketch) == 'DICT':  ## use create_part_sketch
		if length < 0 or direction == 'reverse':
			flip = ON   ## 即reverse=True
		else:
			flip = OFF

		if half_angle == 0 and twist_angle == 0:
			part.SolidExtrude(sketchPlane=sketch['datum_plane'], sketchUpEdge=sketch['right_edge'], sketchPlaneSide=sketch['side'],
				sketchOrientation=RIGHT, sketch=sketch['sketch'], depth=abs(length), flipExtrudeDirection=flip,
				keepInternalBoundaries=ON)

		elif half_angle != 0:   ## 梯形生长。angle > 0则末端放大。 loft grow
			part.SolidExtrude(sketchPlane=sketch['datum_plane'], sketchUpEdge=sketch['right_edge'], sketchPlaneSide=sketch['side'],
				sketchOrientation=RIGHT, sketch=sketch['sketch'], depth=abs(length), flipExtrudeDirection=flip,
				keepInternalBoundaries=ON,draftAngle=half_angle)

		elif twist_angle != 0:
			part.SolidExtrude(sketchPlane=sketch['datum_plane'], sketchUpEdge=sketch['right_edge'], sketchPlaneSide=sketch['side'],
				sketchOrientation=RIGHT, sketch=sketch['sketch'], depth=abs(length), flipExtrudeDirection=flip,
				keepInternalBoundaries=ON,twistAngle=twist_angle)

	else:  ## use simple sketch
		sketch = check_sketch(sketch)
##		print fnln(),half_angle
##		print fnln(),twist_angle

		if half_angle == 0 and twist_angle == 0:
			part.BaseSolidExtrude(sketch=sketch, depth=abs(length))
		elif half_angle != 0:   ## 梯形生长。angle > 0则末端放大。
			part.BaseSolidExtrude(sketch=sketch, depth=abs(length),draftAngle=half_angle)
		elif twist_angle != 0:
			part.BaseSolidExtrude(sketch=sketch, depth=abs(length),twistAngle=twist_angle)

	if part.cells not in empty:
		if part.cells[-1].index != last_cell:
			print '--->Performed rect growth for',part.name,', called by',this_and_caller(to_print=False)[:2]
		else:
			raise Exception('******Fail to extrude the sketch.')
	else:
		raise Exception('******Fail to extrude the sketch.')

	return part.name

def F2C(degF):
	## VER: 2016-03-22, v1.0

	degC = (degF - 32)*5/9
	degC = smart_round(degC)

	return degC

def C2F(degC):
	## VER: 2016-03-22, v1.0

	degF = degC*1.8 + 3.2

	return degF

def face2face(move_face,fix_face,flip=ON,clearance=0):
	## VER: 2012-11-16, v1.1. move_face类似于source，fix_face类似于target

	move_face = check_entity(move_face,'faces')
	fix_face = check_entity(fix_face,'faces',error_stop=False)

	type1 = 'faces'
	type2 = type_of(fix_face)

	if type2 not in ['DATUMPLANE','faces']:
		raise Exception('datumplane or face from instance is requried.')

	poi1 = get_poi(move_face)
	poi1.ConvertConstraints()

	if type2 == 'faces':
		poi2 = get_poi(fix_face)
		if poi1 == get_poi(fix_face):
			raise Exception('move_face and fix_face cannot come from the same instance.')
		else:
			poi2.ConvertConstraints()

	a.FaceToFace(movablePlane=move_face,fixedPlane=fix_face,flip=flip,clearance=clearance)

	poi1.ConvertConstraints()
	if type2 == 'faces':
		poi2.ConvertConstraints()

	print poi1.name,'is moved by face2face(). Please check.'

	return

def face_angle(face1,normal2=None,face2=None):
	## VER: 2011-01-20, v1.1, 考虑用part的方法getAngle(). 角度单位

	normal1 = face1.getNormal()

	if normal2 in empty and face2 in empty:
		normal2 = 'z'

	if type_of(face2) == 'faces':
		normal2 = face2.getNormal()

	elif normal2 not in empty:
		if normal2 == 'x':
			normal2 = (1,0,0)
		elif normal2 == 'y':
			normal2 = (0,1,0)
		elif normal2 == 'z':
			normal2 = (0,0,1)

	else:
		raise Exception('Error: face2 is needed for face_angle(). line=219, face_angle()')   ## **********

	a = sqrt(normal1[0]**2 + normal1[1]**2 + normal1[2]**2)
	b = sqrt(normal2[0]**2 + normal2[1]**2 + normal2[2]**2)
	c = sqrt((normal2[0] - normal1[0])**2 + (normal2[1] - normal1[1])**2 + (normal2[2] - normal1[2])**2)

	angle = acos((a*a + b*b - c*c)/(2*a*b))

	if angle > pi/2:
		angle = pi - angle

	angle = pi/2 - angle  ## 余角  ##???******

	angle = angle/pi*180

	return angle   ## deg

def face_at(p,loc=(0,0,0),dx=0,dy=0,dz=0):
	## VER: 2010-12-02, v1.7

##	faces = face_select(mid,D=holeD)
##	loc = faces[1].pointOn[0]
##	divide_by_face(mid,faces[0])
##	divide_by_face(mid,face_at(mid,loc=loc))   ## 不能用divide_by_face(mid,faces[1]) 因为编号变了

	p = check_pias(p)
	if p in empty:
		print fnln_fnln(),'******Invalid poi, face_at() return None.'
		return None

	if type_of(loc) == 'TUPLE':
		if type_of(loc[0]) == 'TUPLE':
			loc = loc[0]

	loc = (loc[0]+dx, loc[1]+dy, loc[2]+dz)
	face = p.faces.findAt(coordinates = loc, printWarning=False)
	if face != None:
		face = p.faces.findAt(coordinates=face.pointOn[0], printWarning=False)

	return face

def face_at_range_grids(p,range_x,range_y,range_z,size='',num=''):
	## VER: 2010-08-10, v1.0

	if type_of(range_x) == 'TUPLE':
		x1,x2 = range_x
	else:
		x1 = x2 = range_x

	if type_of(range_y) == 'TUPLE':
		y1,y2 = range_y
	else:
		y1 = y2 = range_y

	if type_of(range_z) == 'TUPLE':
		z1,z2 = range_z
	else:
		z1 = z2 = range_z

	if abs(x1 - x2) < 1e-6:
		ndir = 'x'
		ndir1 = (1,0,0)
		ndir2 = (-1,0,0)
		list1 = intervals(y1,y2,size=size,num=num)
		list2 = intervals(z1,z2,size=size,num=num)

	elif abs(y1 - y2) < 1e-6:
		ndir = 'y'
		ndir1 = (0,1,0)
		ndir2 = (0,-1,0)
		list1 = intervals(x1,x2,size=size,num=num)
		list2 = intervals(z1,z2,size=size,num=num)

	elif abs(z1 - z2) < 1e-6:
		ndir = 'z'
		ndir1 = (0,0,1)
		ndir2 = (0,0,-1)
		list1 = intervals(x1,x2,size=size,num=num)
		list2 = intervals(y1,y2,size=size,num=num)

	else:
		raise Exception('A flat area is needed. line=3922, match_faces_range().')    ## ********

	faces = []
	for v1 in list1:
		for v2 in list2:
			if ndir == 'x':
				pointOn = (x1,v1,v2)
			elif ndir == 'y':
				pointOn = (v1,y1,v2)
			elif ndir == 'z':
				pointOn = (v1,v2,z1)

			face = face_at(p,pointOn)
			if type_of(face) == 'faces':
				normal = face.getNormal()
				if normal == ndir1 or normal == ndir2:
					if face not in faces:
						faces.append(face)

	print 'Found',len(faces),'matched faces in',p.name

	return faces

def face_dirx(face):
	## VER: 2011-04-16, v1.2
	return facing_dir(face)[0]

def face_diry(face):
	## VER: 2011-04-16, v1.6
	return facing_dir(face)[1]

def face_dirz(face):
	## VER: 2011-04-16, v1.6
	return facing_dir(face)[2]

def face_normal_by_num(face):
	## VER: ('VER: 2011-05-17, v1.6')	## 只能获取一个点的法向
	## reference: vector_in_01()

	err = 1e-6

	x,y,z = face.getNormal()
	dir1 = [0,0,0]
	if x > err:
		dir1[0] = 1
	elif x < -err:
		dir1[0] = -1

	if y > err:
		dir1[1] = 1
	elif y < -err:
		dir1[1] = -1

	if z > err:
		dir1[2] = 1
	elif z < -err:
		dir1[2] = -1

	return dir1

def face_ndir(face):
	## VER: 2014-12-11, v2.3
	## 观察lap_joint模型，里面有倒角和圆锥角。

	## Results: 'x','y','z','slope','cylindrical','conical','sphere','ellipse','unknow'

	## 参考：bending_dirs = ['unknown','cylindrical'(圆柱面),'conical'(圆锥面), 'sphere'(球面)]
	## Example:
	## ndir = face_ndir(side1_faces[0])

##	faces1 = face_select(shaft_A1,ndir='conical')
##	faces2 = face_select(bear_A1,ndir='conical')
##	s2s_tie('tie_shaft_bear',mfaces=faces1,sfaces=faces2)

	radius, curvature, shape = RC_shape(face)	## 确定是否是平面   edge被倒角之后，可能没有radius，但有curvature

##	print ' '
##	print fnln(),'radius=',radius
##	print fnln(),'curvature=',curvature
##	print fnln(),'shape=',shape

##	raise Exception
##	if radius == 'flat' and curvature == None:   ## 圆形倒角也会没有radius, 如lap_joint
	if shape == 'flat':
		normal = get_normal(face)
##		print fnln(),'normal=',normal
		if normal in xdir:
			ndir = 'x'
		elif normal in ydir:
			ndir = 'y'
		elif normal in zdir:
			ndir = 'z'
		else:
			ndir = 'slope'
	else:
		## Example: f1.getCurvature(uParam=0.2, vParam=0.2)
		curvatures = []

		## 注意：曲率要取绝对值来获得半径
		cur0 = face.getCurvature(uParam=0.2,vParam=0.2); c01,c02 = _sort(abs(cur0['curvature1']), abs(cur0['curvature2']))
		cur1 = face.getCurvature(uParam=0.4,vParam=0.6); c11,c12 = _sort(abs(cur1['curvature1']), abs(cur1['curvature2']))
		cur2 = face.getCurvature(uParam=0.6,vParam=0.4); c21,c22 = _sort(abs(cur2['curvature1']), abs(cur2['curvature2']))
		cur3 = face.getCurvature(uParam=0.8,vParam=0.8); c31,c32 = _sort(abs(cur3['curvature1']), abs(cur3['curvature2']))

		## c01,c11,c21,c31 相当于轴向，曲率较小。即曲率半径较大，即伸展较大的方向。
		## c02,c12,c22,c32 相当于径向，曲率较大。即曲率半径较小，即伸展较小的方向。

		if all_equal(c01,c11,c21,c31) == True:
			axis_equal = True
		else:
			axis_equal = False

		if all_equal(c02,c12,c22,c32) == True:
			radial_equal = True
		else:
			radial_equal = False

##		print ' '
##		print fnln(),'c01,c11,c21,c31=',(c01,c11,c21,c31)
##		print fnln(),'axis_equal=',axis_equal
##		print ' '
##		print fnln(),'c02,c12,c22,c32=',(c02,c12,c22,c32)
##		print fnln(),'radial_equal=',radial_equal

		ndir = 'complex'
		if axis_equal == True and radial_equal == True:
			if PK(c01,c02) == 0:  ## 轴向和径向相等
				ndir = 'sphere'
			else:
				if c01 == 0:   ##轴向的弯曲率为0
					ndir = 'cylindrical'
				else:
					ndir = 'tube'   ## a tube along a spline
		elif axis_equal == True:  ## 轴向相等，径向不等
			if c01 == 0:
				ndir = 'conical'
		elif radial_equal == True:  ## 径向相等，轴向不等, along a spline wire
			ndir = 'tube'   ## 如自来水管,或者edge被round_corner之后。
		else:   ## 轴向和径向均不等。
			shapes = []
			for edge in faces_to_edges(face):
				shape = edge_shape(edge)
				if shape not in shapes:
					shapes.append(shape)

			if 'spline' in shapes:
				ndir = 'spline'    ## usually corresponding to spline edges.

	return ndir

def faces_of_cut(poi,x=None,y=None,z=None,poiRefX=(),poiRefY=(),poiRefZ=(),ref_locx=(),ref_locy=(),ref_locz=(),exterior=True,nx=None,ny=None,nz=None,ndir=None):
	## VER: ('VER: 2013-01-10, v1.3')

	poi = check_pias(poi)
	if is_empties(poiRefX,poiRefY,poiRefZ,ref_locx,ref_locy,ref_locz) == True:
		x,y,z=real_xyz(poi,x,y,z)
	else:
		x1,x2,y1,y2,z1,z2 = real_space(poi,x=x,y=y,z=z,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ,ref_locx=ref_locx,ref_locy=ref_locy,ref_locz=ref_locz,empty2space=False)
		x = (x1,x2)
		y = (y1,y2)
		z = (z1,z2)

		if PK(x1,x2) == 0:
			x = x1
		if PK(y1,y2) == 0:
			y = y1
		if PK(z1,z2) == 0:
			z = z1

	## check cut
	cuts = []
	if type_of(x) in ['FLOAT','INT']:
		cuts.append(x)
	if type_of(y) in ['FLOAT','INT']:
		cuts.append(y)
	if type_of(z) in ['FLOAT','INT']:
		cuts.append(z)

	if len(cuts) != 1:
		raise Exception('confusing cut offset.')

##	print 'cuts=',cuts

	## check ndir
	if ndir not in [None,'x','y','z']:
		raise Exception('ndir should be x, y, or z')

	## check ndir and cut
	if ndir == 'x':
		if type_of(x) not in ['FLOAT','INT']:
			raise Exception('cut offset in x should be provided.')
		ndir = 0
		offset = x
	elif ndir == 'y':
		if type_of(y) not in ['FLOAT','INT']:
			raise Exception('cut offset in y should be provided.')
		ndir = 1
		offset = y
	elif ndir == 'z':
		if type_of(z) not in ['FLOAT','INT']:
			raise Exception('cut offset in z should be provided.')
		ndir = 2
		offset = z
	else:	  ## 未提供ndir
		if type_of(x) in ['FLOAT','INT']:
			ndir = 0
			offset = x
		elif type_of(y) in ['FLOAT','INT']:
			ndir = 1
			offset = y
		elif type_of(z) in ['FLOAT','INT']:
			ndir = 2
			offset = z
		else:
			raise Exception('Unknown ndir')

	print fnln_fnln(),'ndir=',ndir, ', offset=',offset

##	stop(debug)

	vertices = []
	for vertice in poi.vertices:
		if equal(vertice.pointOn[0][ndir],offset):
			if vertice not in vertices:
				vertices.append(vertice)

	if len(vertices) == 0:
		print '****No vertice was found with z=',offset
		return []

	## find edges
	edges = []
	indexs = []
	for vertice in vertices:
		indexs0 = vertice.getEdges()
		for index in indexs0:
			if index not in indexs:
				indexs.append(index)

	for index in indexs:
		edge = poi.edges[index]
		if equal(edge.pointOn[0][ndir],offset):
			if edge not in edges:
				edges.append(edge)

	if len(edges) == 0:
		print '**No edge was found with offset in pointOn'
		return []

	## find faces
	faces = []
	indexs = []
	for edge in edges:
		indexs0 = edge.getFaces()
		for index in indexs0:
			indexs.append(index)

	for index in indexs:
		face = poi.faces[index]
		if equal(face.pointOn[0][ndir],offset):
			if face not in faces:
				cells = face.getCells()
				if exterior == False:
					faces.append(face)
				else:
					if len(cells) == 1:
						faces.append(face)

	if len(faces) == 0:
		return []

	if not (nx==ny==nz==None):
		ndirs = [nx,ny,nz]

		faces2 = []
		for face in faces:
			normal = face.getNormal()
			if normal[ndir] == ndirs[ndir]:
				faces2.append(face)

		faces = faces2

	if len(faces) == 0:
		return []

	if ndir == 0 and (y not in empty or z not in empty):
		faces2 = []
		for face in faces:
			x01,x02,y01,y02,z01,z02 = objs_space(face)
			if y not in empty:
				if not meet_search_range((y01,y02), y):
					continue
			if z not in empty:
				if not meet_search_range((z01,z02),z):
					continue
			faces2.append(face)

		faces = faces2

	elif ndir == 1 and (z not in empty or x not in empty):
		faces2 = []
		for face in faces:
			x01,x02,y01,y02,z01,z02 = objs_space(face)
			if x not in empty:
				if not meet_search_range((x01,x02),x):
					continue
			if z not in empty:
				if not meet_search_range((z01,z02),z):
					continue
			faces2.append(face)

		faces = faces2

	elif ndir == 2 and (x not in empty or y not in empty):
		faces2 = []
		for face in faces:
			x01,x02,y01,y02,z01,z02 = objs_space(face)
			if x not in empty:
				if not meet_search_range((x01,x02),x):
					continue
			if y not in empty:
				if not meet_search_range((y01,y02),y):
					continue
			faces2.append(face)

		faces = faces2

	print '--->',len(faces),'faces selected with offset=',offset,'in',['x','y','z'][ndir]

	return faces

def edges_to_faces(edges,ndir=None,nx=None,ny=None,nz=None,parallel=None):
	## VER: ('VER: 2016-06-27, v1.2')

	edges = tolist(edges)
	if edges in empty or type_of(edges[0]) != 'edges':
		raise Exception('list of edges are required.')

	poi = get_poi(edges)
	faces = []
	for edge in edges:
		faces_index = edge.getFaces()
		for index in faces_index:
			face = poi.faces[index]
			if face not in faces:
				faces.append(face)

	if ndir not in empty:
		faces = face_select(poi,faces=faces,ndir=ndir,nx=nx,ny=ny,nz=nz)

	if parallel in ['x','y','z']:
		faces1 = []
		for face in faces:
			if parallel_to_axis(face,axis=parallel) == True:
				faces1.append(face)
		faces = faces1

	return faces

def faces_of_insts(insts=None,parts=None,exclude=None, x=(),y=(), z=(), ndir = None, exterior=True, shape=None, radius=None, nx=None, ny=None, nz=None):
	## VER: ('VER: 2012-12-11, v2.0')
	## Example:
	## apply_disp_symm('x',faces=faces_of_insts(x=0))

	if exterior == 'NA':
		exterior = None

	locals1 = eval(repr(locals()))
	inputs = get_inputs(locals1)

	if exclude not in empty:
		exclude = real_insts(exclude)

	if parts not in empty:
		parts = real_parts(parts)
		insts = insts_of_parts(parts)

	if insts != None or parts != None:
		inst_specify = True
	else:
		inst_specify = False

	insts = real_insts(insts)
	if insts in empty:
		if inst_specify == False:
			insts = a.instances.values()
		else:		## insts or parts有输入，但是无效。
			print '****Empty insts, no face was selected.'
			return []

	if exclude != []:
		insts = unselect(insts,exclude)

	if type_of(insts) != 'LIST':
		raise Exception('instances list is required. ')   ## ********

	faces = []
	if shape == None and radius == None:
		for inst in insts:
			faces1 = faces_of_cut(inst,x=x, y=y, z=z, ndir=ndir, exterior=exterior, nx=nx, ny=ny, nz=nz)
			faces = faces + faces1
	else:
		for inst in insts:
			faces1 = face_select(inst,x=x, y=y, z=z, ndir=ndir, exterior=exterior, shape=shape, radius=radius, nx=nx, ny=ny, nz=nz)
			faces = faces + faces1

	if len(faces) > 0:
		print '--->Totally', len(faces),'faces are selected in the model assembly.'
	else:
		raise Exception('Selection of faces failed from the model assembly. ')		## **********

	return faces

def face_normal_vector_angle(face,axis='x'):
	## VER: 2015-08-14, v1.0
	## To ensure: len(face.getElements) = 1, i.e, exterior element face

##	>>> p = _inst('green_A1')
##	>>> e1 = p.elements[26932]
##	>>> f1 = e1.getElemFaces()[2]
##	>>> light(f1)
##	>>> face_normal_vector_angle(f1,axis='y')
##	0.833  ## f1 almost vertical to axis y
##	>>>

	if type_of(face) == 'faces':
		vector = face.getNormal()
	elif type_of(face) == 'elemFaces':
		nodes = face.getNodes()
		elem = face.getElements()[0]
		center = element_center(elem)
		vector = normal_vector_of_three_points_plane(nodes[0],nodes[1],nodes[2],reference=center)
	else:
		raise Exception('*** geometry face or element face is required.')

	angle = vector_angle(vector1=vector, axis=axis)

	return angle


def face_seeds(p,face):
	## VER: 2011-04-01, v1.4

	pointOn = face.pointOn[0]
	seeds = [pointOn]

	shape1 = face_shape(face)
	if shape1 in ['axis_plane','slope_plane']:
		center = face.getCentroid()[0]

		if pointOn != center:
			seeds.append(center)

		vertices = []
		for index1 in face.getVertices():
			vertices.append(p.vertices[index1].pointOn[0])

		for pt in vertices:
			loc = []
			dist = get_distance(center,pt)
			for i in [0,1,2]:
				sign = center[i] - pt[i]
				if sign > 0:
					sign = 1
				elif sign < 0:
					sign = -1
				elif sign == 0:
					sign = 0
				angle = vector_angle(end1=pt,start1=center,axis=i)
				val = pt[i] + sign*dist*0.1*cosD(angle)

				if within_range(val,(pt[i],center[i])):
					loc.append(val)
				else:
					raise Exception('Interpolation failed. line=3724, face_seeds()')   ## **********

			loc = tuple(loc)
			seeds.append(loc)

	return seeds

def face_select(p,x=(),y=(),z=(),poiRefX=(),poiRefY=(),poiRefZ=(),mark_x=None, mark_y=None, mark_z=None, mark_select=False, center_vector=None,
	ref_locx=(),ref_locy=(),ref_locz=(),space=(),faces=(),cells=(),mat=None, setname=None,exterior=True,internal=None,ndir=None,ao_tu=None,
	shape=None, no_shape=None,radius=None, diameter=None, R=None, D=None, parallel=None, nx=None,ny=None,nz=None,inbound=None,include_ends=True,
	RP=None,axis=None, tryone=None, connect_faces=False, connect_angle=20,
	xbigger=None,xsmaller=None,ybigger=None,ysmaller=None,zbigger=None,zsmaller=None,var_dict={}):
	##	VER: 2017-08-11, v11.1

	## faces2 = face_select('ring',faces=faces,xbigger=True)  ## 对于多个同心圆的情形比较合适。
	## faces = face_select('nib_A1',diameter='bigger') 模糊选择
	## faces = face_select('diamond_A1',y=(MAX,MAX1),connect_faces=True,include_ends=True)
	## faces = face_select('insert',shape='conical')
	## faces = face_select('powder_A1',nz=-1,poiRefZ=(MIN,0.5),no_shape=['conical','cylindrical'])

	## faces = face_select(carbide0, y=(MIN, _ymin(carbide0) + 1))
	##  Because by default, include_endes=False, so the face at y=MIN will not be selected.

##	ycell1 = cells_in_y(carbide_A1)[1]
##	faces = face_select(carbide_A1,cells=ycell1,y=carbide_cut + _ymin(carbide_A1))  ## 可以选出face，即使不是exterior face

	## Example: faces = face_select(carbide0, poiRefY=(MIN,1),include_ends=True)

##	faces = face_select(PCD_A1, y=(MAX, MAX1), include_ends=True)
##	surf_PCD = unselect(PCD_A1.faces, faces)

	## Example: faces = face_select(powder_s,x=MAX1,y=0.1)   ## 可以这么理解，选择(x,y) = (MAX1,0.1)的点所在的面。
	## faces = face_select(stamp,parallel='z',z=MID)  ## 平行于z轴

	## 对于倾斜平面，ndir='slope'. 注意没有ndir='tilt'了。
	## ndir的可能结果有：'x','y','z','slope','unknown','cylindrical'(圆柱面),'conical'(圆锥面), 'sphere'(球面)
	## shape的可能结果有:plane,'cylindrical','conical','sphere','ellipse','unknow'

	## 注意：假如y应该是一个范围，却只提供了一个值，则相当于cut_through。此时最好辅助ndir。
	## 例如：faces = face_select(clamp_top_A1,z=MIN,ndir='z',y=_ymin(frL) + _nearby)  ## 这里，y和z提供的都是一个值，而不是范围。
	## 例如：hex_cut(plate,poiRefX=(span_x1,-plate_thick -1, plate_thick + 2),poiRefY=(MIN,plate_thick))

##	edges = edge_select('pocket_A1',D=pocket_D1_top)
##	faces = edges_to_faces(edges)
##	sfaces = face_select('pocket_A1',faces=faces,ndir='cylind or conical')

	time1 = time.time()

	global insts_space, additional_datum, slow_call

	print ' '
	print '****>>>>>Start face_select(), caller=',get_traceback()[2:-2]

##	allow_mark_select_x = allow_mark_select_y = allow_mark_select_z = False

##	print fnln(),'ndir=',ndir
##	stop1()

	if shape == 'flat':
		shape = 'plane'

	for k,v in var_dict.items():
		exec(k + '=' + repr(v))

	if internal == True:
		exterior = False

	if exterior == 'NA':
		exterior = None

	if ndir in ['circle','circular']:	## please_check
		ndir = 'cylindrical'
	elif ndir == 'tilt':
		ndir = 'slope'
	elif ndir == 'cornical':
		ndir = 'conical'
	elif type_of(ndir) == 'STR':
		if 'con' in ndir and 'cylind' in ndir:
			ndir = 'cylindrical or conical'

	if diameter in ['MAX',MAX,'MIN',MIN]:
		diameters = get_diameters(p)
		if diameter in ['MAX',MAX]:
			diameter = diameters[-1]
		else:
			diameter = diameters[0]

	if is_number(D):
		diameter = D
	if is_number(R):
		radius = R

	if type_of(diameter) in numerics:
		radius = diameter/2.0

	compare_D = None
	if type_of(diameter) == 'STR':
		diameter = diameter.lower()
		if diameter in ['smaller','inner']:
			compare_D = 'smaller'
		elif diameter in ['bigger','outer','greater']:
			compare_D = 'bigger'

	elif type_of(radius) == 'STR':
		radius = radius.lower()
		if radius in ['smaller','inner']:
			compare_D = 'smaller'
		elif radius in ['bigger','outer','greater']:
			compare_D = 'bigger'

	if compare_D in ['smaller','bigger']:
		ndir = 'cylindrical'
		radius = None
		diameter = None

	## 也可以用get_func_defaults()函数获取，结果为dict
	locals1 = eval(repr(locals()))
	inputs = get_inputs(locals1)

	try:
		p = check_pias(p)
	except:
		print fnln_fnln(),'****No such part or instance, by below calling code:'
		return []

##	raise Exception

	space = tolist(space)
	if faces in empty:
		if space not in empty:		## 会变慢
			cells = cell_select_by_container(p,space=space)

		if type_of(mat) == 'STR':
			cells = cell_select(p,cells=cells,mat=mat)

		if cells not in empty:
			faces = faces_of_cells(cells,exterior=exterior)
		else:
			if space not in empty or type_of(mat) == 'STR':
				return []
	elif type_of(faces) == 'STR':
		faces = set2objs(p,faces)

	if faces not in empty:
		exterior = None
		faces = tolist(faces)

##	raise Exception

	inputs0 = remove_empty(x,y,z)
	if len(inputs0) == 1 and inputs0[0] in [MAX1,MIN1,MID]:
		mark_select = True

	mark_x, mark_y, mark_z = real_xyz(p,mark_x,mark_y,mark_z)
	if is_number(mark_x):
		x = mark_x
		mark_select = True

	if is_number(mark_y):
		y = mark_y
		mark_select = True

	if is_number(mark_z):
		z = mark_z
		mark_select = True

##	print fnln(),'mark_select=',mark_select

	x0,y0,z0 = real_xyz(p,x,y,z)
##	print fnln(),'y0=',y0

	x1,x2,y1,y2,z1,z2 = real_space(p,x=x,y=y,z=z,space=space,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ,ref_locx=ref_locx,ref_locy=ref_locy,ref_locz=ref_locz,empty2space=False)

	if type_of(ndir) == 'STR':
		ndir = ndir.lower()
		if ndir == '+x':
			ndir = 'x'
			nx = 1
		elif ndir == '-x':
			ndir = 'x'
			nx = -1
		elif ndir == '-y':
			ndir = 'y'
			ny = -1
		elif ndir == '+y':
			ndir = 'y'
			ny = 1
		elif ndir == '-z':
			ndir = 'z'
			nz = -1
		elif ndir == '+z':
			ndir = 'z'
			nz = 1

	## determin nx, ny, nz
		if x in ['min',MIN]:
			nx = -1
		elif x in ['max',MAX]:
			nx = 1

		if y in ['min',MIN]:
			ny = -1
		elif y in ['max',MAX]:
			ny = 1

		if z in ['min',MIN]:
			nz = -1
		elif z in ['max',MAX]:
			nz = 1


	if RP not in empty:
		x0 = y0 = z0 = 0
		type1 = type_of(RP)
		if type1 == 'vertices':
			x0,y0,z0 = RP.pointOn[0]
		elif type1 == 'TUPLE':
			x0,y0,z0 = RP

		if x1 not in [_min,_max]:
			x1 = x1 + x0
		if x2 not in [_min,_max]:
			x2 = x2 + x0
		if y1 not in [_min,_max]:
			y1 = y1 + y0
		if y2 not in [_min,_max]:
			y2 = y2 + y0
		if z1 not in [_min,_max]:
			z1 = z1 + z0
		if z2 not in [_min,_max]:
			z2 = z2 + z0

		if type_of(radius) in ['INT','FLOAT']:
			if axis in empty:
				raise Exception('******face_select(): both radius and RP are provided, require aixs')

			if axis == 'x':
				y1 = y0 - radius - _nearby
				y2 = y0 + radius + _nearby
				z1 = z0 - radius - _nearby
				z2 = z0 + radius + _nearby
			elif axis == 'y':
				x1 = x0 - radius - _nearby
				x2 = x0 + radius + _nearby
				z1 = z0 - radius - _nearby
				z2 = z0 + radius + _nearby
			elif axis == 'z':
				x1 = x0 - radius - _nearby
				x2 = x0 + radius + _nearby
				y1 = y0 - radius - _nearby
				y2 = y0 + radius + _nearby

##	x10,x20,y10,y20,z10,z20 = poi_space(p)
##	print 'poi_space=',(x10,x20,y10,y20,z10,z20)

	## Example for the solid carbide model
##	faces = face_select(steel,x=(MIN,_xmin(steel,y=MIN)),y=(MIN,_ymin(steel,x=MIN)),inbound=True)
##	create_set(steel,faces=faces,name='f_steel_contact')

	if inbound == True:   ## modify the range
		x10,x20,y10,y20,z10,z20 = poi_space(p)
##		print (x10,x20,y10,y20,z10,z20)
		if PK(x1,x10) != '>':
			x1 = x10 + _nearby
		if PK(x2,x20) != '<':
			x2 = x20 - _nearby
		if PK(y1,y10) != '>':
			y1 = y10 + _nearby
		if PK(y2,y20) != '<':
			y2 = y20 - _nearby
		if PK(z1,z10) != '>':
			z1 = z10 + _nearby
		if PK(z2,z20) != '<':
			z2 = z20 - _nearby

##	print 'after inbound: ',x1,x2,y1,y2,z1,z2

	## modified x,y,z
	x = (x1,x2)
	y = (y1,y2)
	z = (z1,z2)

##	if debug1 == True:
##		print fnln(),'x,y,z=',x,y,z
##		raise Exception

	if faces in empty:
		faces = p.faces
	elif type_of(faces) == 'STR':
		faces = set2objs(p,faces)

##	print2('len(faces)=',len(faces))

	if type_of(p) == 'PINSTANCE' and p.name in insts_space.keys():
		cross = cross_of_spaces((x1,x2,y1,y2,z1,z2),poi_space(p),mark_select=mark_select)
		if cross['no_cross'] == True:
			print fnln_fnln(),'cross=',cross
			print fnln_fnln(),'****No face was selected. cross=',cross
			return []

##	print2('len(faces)=',len(faces))
##	print2(ndir,exterior,nx,ny,nz)


##	faces = check_facing_dir(faces,ndir=ndir,exterior=exterior,nx=nx,ny=ny,nz=nz)
##	print fnln(),'ndir=',ndir
##	raise Exception

	faces = check_facing_dir(faces,ndir=ndir,exterior=exterior)	## 排除掉不符合的ndir, by face_ndir()

##	light(faces)
##	raise Exception

	if shape != None:
		faces1 = []
		for face in faces:
			shape1 = face_shape(face)
			if shape == shape1:
				faces1.append(face)
		faces = faces1

	if no_shape != None:
		no_shape = tolist(no_shape)
		faces1 = []
		for face in faces:
			shape1 = face_shape(face)
			if shape1 not in no_shape:
				faces1.append(face)
		faces = faces1


	if radius != None:
		faces1 = []
		for face in faces:
			radius0 = get_radius(face)
			if is_number(radius0) and PK(radius0,radius) == 0:
				faces1.append(face)
		faces = faces1


	if parallel in ['x','y','z']:
		faces1 = []
		for face in faces:
			if parallel_to_axis(face,axis=parallel) == True:
				faces1.append(face)
		faces = faces1

	if ao_tu not in empty:   ## U, A, or flat
		faces1 = []
		for face in faces:
			status = AV_shape(face)
			if status == ao_tu:
				faces1.append(face)
		faces = faces1

	## empty2space = False, then empty=(_min, _max)
	fix_DOFs = []   ## 对x,y,z的约束情况. (_min,_max)为无约束。
	if x != (_min,_max):
		fix_DOFs.append('x')
	if y != (_min,_max):
		fix_DOFs.append('y')
	if z != (_min,_max):
		fix_DOFs.append('z')

	print fnln_fnln(),'fix_DOFs=',fix_DOFs

	for dof in fix_DOFs:
		faces1 = []
		if dof == 'x':
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face)
				if meet_search_range((x01,x02),(x1,x2), include_ends=include_ends,mark_select=mark_select) == True:
					faces1.append(face)

		elif dof == 'y':
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face)
##				print fnln(),'include_ends=',include_ends
##				print fnln(),'mark_select=',mark_select
				if meet_search_range((y01,y02),(y1,y2),include_ends=include_ends,mark_select=mark_select) == True:
					faces1.append(face)

		elif dof == 'z':
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face)
				if meet_search_range((z01,z02),(z1,z2), include_ends=include_ends,mark_select=mark_select) == True:
					faces1.append(face)

		faces = faces1

	faces = check_facing_dir(faces,nx=nx,ny=ny,nz=nz,exterior=None)

	if is_locations(center_vector):
		center,vector = center_vector
##		print fnln(),'center=',center,', vector=',vector
		newlist = []
		for face in faces:
			center1,vector1,axis1 = center_axis_of_cylind_face(face)
##			print fnln(),'center1=',center1,', center=',center
			if center1 == center:
				vector2 = vector1
			else:
				vector2 = vector_of_two_points(center1,center)
##			print fnln(),'vector2=',vector2
			if vector == vector1==vector2:
				newlist.append(face)
		faces = newlist

	if len(faces) > 0 and connect_faces == True:
		newlist = []
		for face in faces:
			list1 = connect_all_faces(face,angle=connect_angle)
			newlist = newlist + list1

		faces = remove_repeated_items(newlist)

	if compare_D in ['bigger','smaller'] and len(faces) > 0:
		dict1 = {}
		for face in faces:
			D1 = get_diameter(face)
			D1 = smart_round(D1)
			if D1 not in dict1.keys():
				dict1[D1] = []

			dict1[D1].append(face)

		diameters = _sort(dict1.keys())
		if compare_D == 'smaller':
			faces = dict1[diameters[0]]
		else:
			faces = dict1[diameters[-1]]

	if xbigger == True or xsmaller == True:
		dict1 = {}
		for face in faces:
			space = objs_space(face)
			if xbigger == True:
				x0 = smart_round(space[1])
			else:
				x0 = smart_round(space[0])

			if x0 not in dict1.keys():
				dict1[x0] = []
			dict1[x0].append(face)
		locx = _sort(dict1.keys())
		if xbigger == True:
			faces = dict1[locx[-1]]
		elif xsmaller == True:
			faces = dict1[locx[0]]

	elif ybigger == True or ysmaller == True:
		dict1 = {}
		for face in faces:
			space = objs_space(face)
			if xbigger == True:
				y0 = smart_round(space[3])
			else:
				y0 = smart_round(space[2])

			if y0 not in dict1.keys():
				dict1[y0] = []
			dict1[y0].append(face)
		locy = _sort(dict1.keys())
		if ybigger == True:
			faces = dict1[locy[-1]]
		elif ysmaller == True:
			faces = dict1[locy[0]]

	elif zbigger == True or zsmaller == True:
		dict1 = {}
		for face in faces:
			space = objs_space(face)
			if zbigger == True:
				z0 = smart_round(space[5])
			else:
				z0 = smart_round(space[4])

			if z0 not in dict1.keys():
				dict1[z0] = []
			dict1[z0].append(face)
		locz = _sort(dict1.keys())
		if zbigger == True:
			faces = dict1[locz[-1]]
		elif zsmaller == True:
			faces = dict1[locz[0]]


	if len(faces) > 0:
		print len(faces),'faces selected in',p.name,'. Inputs=',inputs,', called by',this_and_caller(to_print=False)[:2]
	else:
		print fnln_fnln(),'******No face was selected in',p.name
		print '        inputs=',inputs
		print '        mark_select=',mark_select, ', include_ends=',include_ends
		print '        avoid divided by interger in GUI, such as: hole_D/2, should be hole_D/2.'

	if additional_datum == True:
		clear_datum_points(p)
		additional_datum = False

	print '****<<<<<End face_select'
	print ' '

	if time.time() - time1 >= 0.1:
		slow_call.append(get_traceback())

	return faces

def face_select_by_wire_through(poi,wire_dir,x=None,y=None,z=None):
	## VER: 2016-05-31, v1.1

##	 face_select_by_wire_through('insert',wire_dir='z',x=0,y=0)

##	>>> faces = face_select_by_wire_through(case_A1,wire_dir='y', x=0.5, z=-20)
##	Warning: Failed to attach mesh to part geometry.
##	10 vertices selected.
##	['face_select_by_wire_through', 23] ---> 10 faces selected by wire throught method.
##	>>>

	poi = check_poi(poi)
	if wire_dir not in ['x','y','z']:
		raise Exception('*** wire_dir should be in x,y or z')

	if wire_dir == 'x':
		locs = through_points_in_x(poi,x=x,y=y,z=z)
	elif wire_dir == 'y':
		locs = through_points_in_y(poi,x=x,y=y,z=z)
	elif wire_dir == 'z':
		locs = through_points_in_z(poi,x=x,y=y,z=z)

	faces = []
	if locs not in empty:
		for loc in locs:
			face = face_at(poi,loc=loc)
			if type_of(face) == 'faces' and face not in faces:
				faces.append(face)

	if len(faces) > 0:
		print fnln(),'--->',len(faces),'faces selected by wire throught method.'
	else:
		print fnln(),'*** No face was selected, the wire do not through the part.'

	return faces

def face_shape(faces):
	## VER: 2014-07-15, v1.1
	## 对于一个circular edge, face_shape(edge) = cylindrical

	faces = tolist(faces)
	face = faces[0]

	ndir = face_ndir(face)
	if ndir in ['x','y','z','slope']:
		shape = 'plane'
	else:
		shape = ndir

	return shape

def face_to_face_gap(face1,face2):
	## VER: 2013-02-25,v1.0, face1 is parallel to face2

	if type_of(face1) != 'faces':
		raise Exception('*** face1 is required.')

	if type_of(face2) != 'faces':
		raise Exception('*** face2 is required.')

	loc1 = face1.pointOn[0]
	poi = get_parent(face2)

	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	pt2 = get_project_point(poi, point=loc1, face=face2)
	loc2 = pt2.pointOn

	distance = get_distance(loc1,loc2)

	return distance

def face_with(p,loc=(0,0,0),dx=0,dy=0,dz=0):
	## VER: 2010-07-26, v1.5

	loc = (loc[0]+dx, loc[1]+dy, loc[2]+dz)

	face1 = None
	for i in xrange(len(p.faces)):
		face = p.faces[i]
##	for face in p.faces:
		if inside(p,loc,face) == True:
			face1 = face
			break

	return face1

function_labels['faces_to_shellpart'] = 'face','shell','rigid'
def faces_to_shellpart(faces,poi=None,name='shellpart',rigid=True, axisymmetric=False, symmetric=None, planar=False):
	## VER: 2017-07-17, v1.6

	## pick faces, create set, then pick() to get v1 variable
	## faces_to_shellpart(v1)  ## 2D planar
	## faces_to_shellpart(v1,planar=True) ## 2D planar
	## faces_to_shellpart(v1,symmetric=True) ## 2D, axisymmetric

##	faces_to_shellpart(v1,name='big_temp',rigid=False,axisymmetric=True)
##	s1 = shellpart_to_sketch('big_temp',sketchname='sk_big4')
##	sketch_to_shellpart(s1,partname='big',symmetric=True)

##	faces = face_select('powder2',nz=1,z=MAX)
##	tpunch = faces_to_shellpart(faces,name='tpunch',rigid=True)
##	edges = edge_select('tpunch',radius=7.1515)
##	edges1 = edge_select('tpunch',exterior=True)
##	edges = unselect(edges1,edges)
##	extend_faces_by_edges(edges,distance=2)

##	faces = face_select(nib1,x=(0,MAX),z=0)
##	faces_to_shellpart(faces,name='nib_s',axisymmetric=True)
##
##	faces = face_select(case1,x=(0,MAX),z=0)
##	faces_to_shellpart(faces,name='case_s',axisymmetric=True)

##	raise Exception

	if type_of(faces) in ['PART','PINSTANCE']:
		faces,poi = poi,faces

	if type_of(faces) == 'STR':
		faces = set2objs(faces,p=poi)

	faces = tolist(faces)
	poi = get_poi(faces)

	if symmetric not in empty:
		axisymmetric = symmetric

	if axisymmetric == True or planar == True:
		rigid = False

	p1 = temp_part_of_poi(poi,name=name + '_temp')
	p1 = _m.parts[p1]
	name = new_key(_m.parts,name)

	faces1 = []
	for face in faces:
		face1 = p1.faces[face.index]
		faces1.append(face1)

	faces2 = unselect(list(p1.faces),faces1)	## 去除感兴趣的face
	try:
		p1.RemoveFaces(faceList = tuple(faces2), deleteCells = True)   ## cell也删除之后，自动变成shell part
		p1.regenerate()
	except:
		pass

	update_part(p1)

	## 3D and discrete rigid
	if rigid == True:   ## 2D情况下, faces不可能是rigid，只有edges才可能是rigid。所以faces为rigid肯定是THREE_D
		shape = part_shape(p1)[0]   ## 结果为例如:THREE_D
		p1.setValues(space=shape, type=DISCRETE_RIGID_SURFACE)
		rename(p1,name)
	else: ## 2D
		temp_sketch = new_key(_m.sketches,'sk_shell')
		temp_sketch = shellpart_to_sketch(p1,sketchname=temp_sketch)
		if symmetric == True:
			sketch_to_shellpart(temp_sketch,partname=name,symmetric=True)
		else:
			sketch_to_shellpart(temp_sketch,partname=name)

		del_parts(p1)

	return name

faces_to_shell_part = faces_to_shellpart

def faces_extrude(part,faces=None,length=50,x=None,y=None,z=None,direction=None,expansion=None,half_angle=0,twist_angle=0,keep_boundary=False):
	## VER: 2016-08-22, v1.2
	## similar to VEXT in ANSYS. volume extend
	## extrude是法向的生长，extend是面内的延伸。

	## Example:
##	faces_extrude(faces=ymin_faces(stamp),length=5,expansion=-2)
	## 此方法可以用于压坯的中模部分（也就是填粉)的延长

##	faces = face_select(powder0,z=powder_mid)
##	faces_extrude(faces=faces,length=height)

	part = check_part(part)
	partname = part.name

	if faces in empty and (x,y,z) != (None,None,None):
		faces = face_select(part,x=x,y=y,z=z)

	faces = tolist(faces)

	if faces in empty:
		raise Exception('*** faces are required to extrude')

	edges = exterior_edges(faces)
	sketch1 = edges_to_sketch(edges)

	normal = get_normal(faces[0])
	if normal in [(1,0,0),(0,1,0),(0,0,1)]:
		direction = 'forward'
	elif normal in [(-1,0,0),(0,-1,0),(0,0,-1)]:
		direction = 'reverse'

	if direction in empty:
		direction = 'forward'

	if keep_boundary == True:
		extrude_sketch_to_part(part,sketch=sketch1,length=length,direction=direction,expansion=expansion, half_angle=half_angle, twist_angle=twist_angle)
	else:
		part1 = blank_part('extend')
		extrude_sketch_to_part(part1,sketch=sketch1,length=length,direction=direction,expansion=expansion, half_angle=half_angle, twist_angle=twist_angle)
		merge_instances(partname=partname,parts=(part,part1),boundary='remove')
		del_parts(part1)

	return


def faces_of_cells(cells,ndir=None,nx=None,ny=None,nz=None,exterior=True,x=(),y=(),z=()):
	## VER: ('VER: 2012-12-10, v1.2')

	cells = tolist(cells)
	poi = get_poi(cells)

	faces = []
	for cell in cells:
		indexs = tolist(cell.getFaces())
		for index in indexs:
			face = poi.faces[index]
			if face not in faces:
				faces.append(face)

	if (ndir,nx,ny,nz,exterior,x,y,z) != (None,None,None,None,True,(),(),()):
		space = objs_space(cells)
		faces = reselect_faces(faces,x=x,y=y,z=z,space=space, ndir=ndir, nx=nx, ny=ny, nz=nz, exterior=exterior)

	print fnln_fnln(),'--->',len(faces),'faces are found in cells.'

	return faces

def faceset2sequence(setname,p=''):
	##ver: 2010-02-01

	if p == '':
		instances = insts_by_set(setname)

		if len(instances) > 0:
			objs = instances[0].sets[setname].faces
			index1 = objs[0].index
			seq_sum = instances[0].faces[index1:index1+1]

			if len(objs) > 1:
				for obj in objs[1:]:
					index1 = obj.index
					seq_sum = seq_sum + instances[0].faces[index1:index1+1]

		if len(instances) > 1:
			for inst in instances:
				objs = inst.sets[setname].faces
				index1 = objs[0].index
				seq_sum = seq_sum + inst.faces[index1:index1+1]

				if len(objs) > 1:
					for obj in objs[1:]:
						index1 = obj.index
						seq_sum = seq_sum + inst.faces[index1:index1+1]

	elif type_of(p) == 'PART' or type_of(p) == 'PINSTANCE':
		objs = p.sets[setname].faces
		index1 = objs[0].index
		seq_sum = p.faces[index1:index1+1]

		if len(objs) > 1:
			for obj in objs[1:]:
				index1 = obj.index
				seq_sum = seq_sum + p.faces[index1:index1+1]

	return seq_sum

def facing_dir(face,ndir=None):
	## VER: ('VER: 2016-11-04, v1.5')
	## caller: parallel_to_axis()

	if type_of(face) != 'faces':
		raise Exception('******A face is required.')

	poi = get_poi(face)
	if ndir in empty:
		ndir = face_ndir(face)

	if ndir not in bending_dirs:
		return face_normal_by_num(face)
	else:
		normals = {0:[],1:[],2:[]}	## a dict
		if type_of(poi) == 'PINSTANCE':
			rotation = poi.getRotation()
			if rotation != ((0, 0, 0), (1, 0, 0), 0.0):
				temp_part = temp_part_from_inst(poi)
			else:
				temp_part = copy_part(poi.part,'temp_part')
		else:
			temp_part = copy_part(poi,'temp_part')

		part = _m.parts[temp_part]
		face = part.faces[face.index]

		cross_loc = face.getCentroid()[0]
		faces = divide_faces(faces=face,p=part,cross_loc=cross_loc)

		tups1 = []
		for face in faces:
			x,y,z = face_normal_by_num(face)
			x0,y0,z0 = face.pointOn[0]
			normals[0].append(x)
			normals[1].append(y)
			normals[2].append(z)
			tups1.append((x0,x,y0,y,z0,z))

		del_parts(part)

		side = [-11,-11,-11]   ## -11表示1和-1均有，例如一个圆柱面，在x方向有正有负
		for key1 in sorted(normals.keys()):		## [0,1,2]
			dirs = normals[key1]
			num = len(dirs)
			if dirs == [1]*num:
				side[key1] = 1
			elif dirs == [0]*num:
				side[key1] = 0
			elif dirs == [-1]*num:
				side[key1] = -1

		if side[0] == -11:
			list1 = sort_tuple_type_elements(tups1,index=0)
			if list1[0][1] == -1 and list1[-1][1] == 1:
				side[0] = 'OD'	## '-11-'
			elif list1[0][1] == 1 and list1[-1][1] == -1:
				side[0] = 'ID'	## '1--1'

		if side[1] == -11:
			list1 = sort_tuple_type_elements(tups1,index=2)
			if list1[0][3] == -1 and list1[-1][3] == 1:
				side[1] = 'OD'	## '-11-'
			elif list1[0][3] == 1 and list1[-1][3] == -1:
				side[1] = 'ID'	## '1--1'

		if side[2] == -11:
			list1 = sort_tuple_type_elements(tups1,index=4)
			if list1[0][5] == -1 and list1[-1][5] == 1:
				side[2] = 'OD'	## '-11-'
			elif list1[0][5] == 1 and list1[-1][5] == -1:
				side[2] = 'ID'	## '1--1'

##		print '--->facing dir=',side,', normals=',normals

	return side

def feature_to_datum(feature,poa=None):
	## VER: 2014-11-13, v1.0
	## Reference: feature_to_obj

##	>>> feature_to_obj('cylind_CSYS_1')
##	mdb.models['Model-1'].rootAssembly.datums[332]
##	>>>
##	>>> feature_to_datum('cylind_CSYS_1')
##	mdb.models['Model-1'].rootAssembly.datums[332]
##	>>>

	obj = feature_to_obj(feature,poa=poa)
	if type_of(obj).startswith('DATUM') == False:
		raise Exception('*** Fail to get the datum obj, check features of poa')

	return obj

def feature_to_obj(feature,poa=None):
	## VER: 2014-06-25, v1.0
	## 需要名字或obj作为feature的值

##	>>> p1.referencePoints.keys()
##	[1]
##	>>>

##>>> axis = feature_to_obj(p342,'Datum axis-2')
##>>> type_of(axis)
##'DATUMAXIS'
##>>>

##>>> obj = feature_to_obj(anvil,'RP')
##>>> obj
##mdb.models['Model-1'].parts['anvil'].referencePoints[6]
##>>> feature = obj_to_feature(obj)
##>>> feature
##mdb.models['Model-1'].parts['anvil'].features['RP']
##>>>

##>>> feature = a.features['Datum axis-1']
##>>> type_of(feature)
##'FEATURE'
##>>> obj = feature_to_obj(feature)
##>>> obj
##mdb.models['Model-1'].rootAssembly.datums[83]
##>>> type_of(obj)
##'DATUMAXIS'
##>>>

	if type_of(feature) in ['referencePoints', 'DATUMPOINT','DATUMAXIS','DATUMPLANE','DATUMCSYS']:
		obj1 = feature
		return obj1

	if type_of(feature) in ['PART','PINSTANCE','ASSEMBLY']:
		feature,poa = poa,feature

	if type_of(feature) == 'STR':
		if poa in empty:
			poa = a
		poa = check_pias(poa)
		if type_of(poa) not in ['PART','ASSEMBLY']:
			raise Exception('*** part or assembly is required.')
		if feature not in poa.features.keys():
			raise Exception('*** No such feature name')
		feature = poa.features[feature]

	if type_of(feature) != 'FEATURE':
		print fnln(),'*** a feature is required.'
		return

	obj = feature
	index = obj.id  ## feature有id

	poa = get_parent(feature)

	obj1 = None
	if index in poa.datums.keys():
		obj1 = poa.datums[index]
	elif index in poa.referencePoints.keys():
		obj1 = poa.referencePoints[index]
	elif poa == a and obj.name in a.instances.keys():
		obj1 = a.instances[obj.name]

	return obj1

def field_output_request(name='field output',variables=(),timepoints=(),step='step1',intervals=None, amplitudes=None,Xvars=(),later_remove=()):
	## VER: 2017-05-28, v2.3
	## 如果一个载荷步有timepoints，而下一个载荷步没做设置，则默认仍采用该timepoints，即所谓的propogate
	## 如果不提供timepoints，则每一个increment都将保存结果，对于static分析是好的，但对于explicit分析，increment很多，此时odb文件会很大。

##	field_output_request(timepoints=(timepoints2, timepoints1),variables=ALL)	;changing1
##	field_output_request(timepoints={'heating':timepoints1,'bonding':timepoints1, 'cooling':timepoints2, 'remove':timepoints1},variables=ALL)	;changing1

##	field_output_request(timepoints={'step2':timepoints1},variables=PRESELECT)
##	field_output_request(timepoints={'step3':timepoints2},variables=ALL)

##  field_output_request(amplitudes=(temp_table2,press_table2)
##	field_output_request(later_remove=('remove','P'))

	## Example:
##	times1 = myrange(0,1,0.05)
##	timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1
##
##	times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,50, 0.5)
##	timepoints2 = create_timepoints(times2,factor=1e-5)
##
##	create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
##	create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
##	field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

	step = check_step(step)

	if timepoints in empty and amplitudes not in empty:
		amplitudes = tolist(amplitudes)
		times = []
		for amp in amplitudes:
			if amp in _m.amplitudes.keys():
				data = _m.amplitudes[amp].data
			elif amp in _m.amplitudes.values():
				data = amp.data
			else:
				data = totable(amp)

			for item in data:
				time0 = item[0]
				if time0 not in times:
					times.append(time0)
		times = _sort(times)
		times = totuple(times)

		timepoints = create_timepoints(times, name='TimePoints-1')	;changing

	antype1 = _step(step).procedureType

	## 以下是GUI中的step模块下的选择结果。
	dict1 = {}   ## 注意,step中选择的variable与后处理的variable可能不同。即，后处理的variable在step中不一定能看到(invalid)。

	if antype1 == STATIC_GENERAL:
		dict1['preselect'] = ['CDISP','CF','CSTRESS','LE','PE','PEEQ','PEMAG','RF','S','U','COORD','EVOL','TEMP']
		dict1['stress'] = ['S']
		dict1['strain'] =  ['E','EE','IE','LE','NE','PE','PEEQ','PEEQT','PEMAG','PEQC','THE']
		dict1['dis_velo_accel'] = ['U', 'V']
		dict1['force'] = ['RF','CF','TF','GRAV','P','BF']		## P-Pressure load
		dict1['contact'] = ['CSTRESS','CDISP','CFORCE']
		## CFORCE-Contact force; CDISP-Contact displacements; CSTRESS-Contact stresses

		dict1['energy'] = 'ENER','ELEN','ELEDEN'
		## ENER-All energy magnitudes; ELEN-All energy magnitudes in the element;  ELEDEN-All energy density components

		dict1['thermal'] = ['TEMP']
		dict1['volume_coord'] = ['COORD','EVOL','IVOL','SVOL','STH','ESOL']
		## SVOL-integrated section volume; EVOL-element volume; IVOL-integration point volume; COORD-Nodal coordinates

		## 显示分析情况下才有DENSITY。在status部分

	##	dict1['dis_vel_acc'] = 'UT','UR','VT','VR'
	##	dict1['volume_coord1'] = 'CVOL'
	##	dict1['contact1'] = 'CNAREA','CSTATUS'
	##	dict1['force'] = 'RT','RM','NFORC','BF',

	elif antype1 == COUPLED_TEMP_DISPLACEMENT:  ## static analysis
		dict1['preselect'] = ['A','CSTRESS','EVF','LE','PE','PEEQ','PEEQVAVG','PEVAVG','RF','S','SVAVG','U','V','COORD']
		dict1['stress'] = ['S','TRIAX']
		## TRIAX-Stress triaxiality (即应力三轴度。一般拉伸试验时，若未出现颈缩现象也就是缩头现象就断裂，则stress triaxiality=0.33)
		## 应力三轴度: 是一个应力状态的标志，其定义为一点处的平均应力/等效应力。单向拉伸=0.33，单项压缩=-0.33，纯剪切=0。
		## 或者说：triaxiality = 静水压力/mises应力。
		## TRIAX只能在Explicit中使用。TRIAX is not availabel for element type C3D8R

		dict1['strain'] = ['E', 'PE', 'PEEQ', 'PEEQT', 'PEMAG', 'PEQC', 'NE', 'LE', 'ER']
		## ER-Mechanical strain rate component

		dict1['dis_velo_accel'] = ['U', 'UT', 'UR', 'V', 'VT', 'VR', 'A', 'AT', 'AR']
		dict1['force'] = ['RF', 'RT', 'RM', 'CF', 'BF', 'GRAV', 'P']
		dict1['contact'] = ['CSTRESS', 'CFORCE']
		## FSLIPR-Slip velocity magnitude; FSLIP-Accumulated slip displacement

		dict1['energy'] = 'ENER','ELEN','ELEDEN'
		## ENER-All energy magnitudes; ELEN-All energy magnitudes in the element;  ELEDEN-All energy density components

		dict1['thermal'] = ['TEMP']
		dict1['volume_coord'] = ['SVOL', 'EVOL', 'IVOL', 'COORD']   ## 显式：虽然可以有IVOL，但后处理看不到IVOL的结果，有EVOL的结果。
		## SVOL-integrated section volume; EVOL-element volume; IVOL-integration point volume; COORD-Nodal coordinates

		dict1['state_field_user'] = ['SDV', 'FV', 'UVARM', 'STATUS']
		## SDV-Solution dependent state variables; FV-Predefined field variables; UVARM-User defined output variables;
		## STATUS-Some failure and plasticity models; VUMAT

		## Others for backup:
##		dict1['contact'] = ['FSLIPR', 'FSLIP']

	elif antype1 == DYNAMIC_EXPLICIT:  ## dynamic analysis
		dict1['preselect'] = ['COORD','U','V','A','CSTRESS','LE','PE','PEEQ','PEEQVAVG','PEVAVG','RF','S','SVAVG','EVOL','PEQC','ENER']
		mats = get_all_mats()
		for mat in mats:
			if 'H10POW' in mat.upper():
				dict1['preselect'].append('DENSITY')   ## powder compaction
				dict1['preselect'].append('TRIAX')
				break

		dict1['stress'] = ['S','TRIAX']
		## TRIAX-Stress triaxiality (即应力三轴度。一般拉伸试验时，若未出现颈缩现象也就是缩头现象就断裂，则stress triaxiality=0.33)
		## 应力三轴度: 是一个应力状态的标志，其定义为一点处的平均应力/等效应力。单向拉伸=0.33，单项压缩=-0.33，纯剪切=0。
		## 或者说：triaxiality = 静水压力/mises应力。
		## TRIAX只能在Explicit中使用。TRIAX is not availabel for element type C3D8R

		dict1['strain'] = ['E', 'PE', 'PEEQ', 'PEEQT', 'PEMAG', 'PEQC', 'NE', 'LE', 'ER']
		## ER-Mechanical strain rate component

		dict1['dis_velo_accel'] = ['U', 'UT', 'UR', 'V', 'VT', 'VR', 'A', 'AT', 'AR']
		dict1['force'] = ['RF', 'RT', 'RM', 'CF', 'BF', 'GRAV', 'P']
		dict1['contact'] = ['CSTRESS', 'CFORCE']
		## FSLIPR-Slip velocity magnitude; FSLIP-Accumulated slip displacement

		dict1['energy'] = 'ENER','ELEN','ELEDEN'
		## ENER-All energy magnitudes; ELEN-All energy magnitudes in the element;  ELEDEN-All energy density components

		dict1['thermal'] = ['TEMP']
		dict1['volume_coord'] = ['SVOL', 'EVOL', 'IVOL', 'COORD']   ## 显式：虽然可以有IVOL，但后处理看不到IVOL的结果，有EVOL的结果。
		## SVOL-integrated section volume; EVOL-element volume; IVOL-integration point volume; COORD-Nodal coordinates

		dict1['state_field_user'] = ['SDV', 'FV', 'UVARM', 'DENSITY', 'STATUS']
		## SDV-Solution dependent state variables; FV-Predefined field variables; UVARM-User defined output variables;
		## STATUS-Some failure and plasticity models; VUMAT

		## Others for backup:
##		dict1['contact'] = ['FSLIPR', 'FSLIP']

	elif antype1 == DYNAMIC_TEMP_DISPLACEMENT:  ## dynamic analysis
		dict1['preselect'] = ['A','CSTRESS','EVF','LE','PE','PEEQ','PEEQVAVG','PEVAVG','RF','S','SVAVG','U','V','EVOL','TEMP']
		dict1['stress'] = ['S','TRIAX']
		## TRIAX-Stress triaxiality (即应力三轴度。一般拉伸试验时，若未出现颈缩现象也就是缩头现象就断裂，则stress triaxiality=0.33)
		## 应力三轴度: 是一个应力状态的标志，其定义为一点处的平均应力/等效应力。单向拉伸=0.33，单项压缩=-0.33，纯剪切=0。
		## 或者说：triaxiality = 静水压力/mises应力。
		## TRIAX只能在Explicit中使用。TRIAX is not availabel for element type C3D8R

		dict1['strain'] = ['E', 'PE', 'PEEQ', 'PEEQT', 'PEMAG', 'PEQC', 'NE', 'LE', 'ER']
		## ER-Mechanical strain rate component

		dict1['dis_velo_accel'] = ['U', 'UT', 'UR', 'V', 'VT', 'VR', 'A', 'AT', 'AR']
		dict1['force'] = ['RF', 'RT', 'RM', 'CF', 'BF', 'GRAV', 'P']
		dict1['contact'] = ['CSTRESS', 'CFORCE']
		## FSLIPR-Slip velocity magnitude; FSLIP-Accumulated slip displacement

		dict1['energy'] = 'ENER','ELEN','ELEDEN'
		## ENER-All energy magnitudes; ELEN-All energy magnitudes in the element;  ELEDEN-All energy density components

		dict1['thermal'] = ['TEMP']
		## 对于2D分析，SVOL,EVOL,IVOL将无效。
		dict1['volume_coord'] = ['SVOL', 'EVOL', 'IVOL', 'COORD']   ## 显式：虽然可以有IVOL，但后处理看不到IVOL的结果，有EVOL的结果。
		## SVOL-integrated section volume; EVOL-element volume; IVOL-integration point volume; COORD-Nodal coordinates

		dict1['state_field_user'] = ['SDV', 'FV', 'UVARM', 'DENSITY', 'STATUS']
		## SDV-Solution dependent state variables; FV-Predefined field variables; UVARM-User defined output variables;
		## STATUS-Some failure and plasticity models; VUMAT

		## Others for backup:
##		dict1['contact'] = ['FSLIPR', 'FSLIP']


	if 'temp' in totext(antype1).lower():
		dict1['thermal'].append('NT')

	variables0 = []  ## default
	for k,v in dict1.items():
		variables0 = variables0 + tolist(v)
	variables0 = remove_repeated_items(variables0)
	variables_default = sorted(dict1['preselect'])	;changing
	print fnln(),'variables_default=',variables_default
##	raise Exception

##	>>> list1 = ['c','a','b']
##	>>> sorted(list1)
##	['a', 'b', 'c']
##	>>>

	if type_of(variables) == 'STR':   ## user provided
		variables = variables.upper()

	print fnln(),'variables=',variables
##	raise Exception

	variables1 = []
	if variables in [PRESELECT,'PRESELECT']:
##		variables1 = PRESELECT
		variables1 = variables_default
	elif variables in [ALL,'ALL']:
		variables1 = ALL		## 自动选择所有可能输出的结果，但不是全部的结果。但是会导致odb文件非常大，且读写都很慢。
	else:
##		variables1 = tolist(variables0)
		variables = tolist(variables)
		for var in variables:
			if type_of(var) == 'STR':
				var1 = var.upper()
				if var1 not in variables1:
					variables1.append(var1)

		Xvars = tolist(Xvars)
		if Xvars not in empty:
			for var in Xvars:
				if type_of(var) == 'STR':
					var1 = var.upper()
					if var1 in variables1:
						variables1 = remove_item(variables1,var1)


	if variables1 in empty:
		variables1 = variables_default		## user not provide variables

	if type_of(variables1) == 'LIST':
		variables1 = totuple(variables1)

##	print fnln(),'variables1=',variables1
##	raise Exception
	variables = variables1

	print fnln(),'variables=',variables

	try:
		del _m.fieldOutputRequests['F-Output-1']
	except:
		pass

	print fnln(),'variables=',variables
##	raise Exception

	name = new_key(_m.fieldOutputRequests.keys(),name)
	if variables == ALL:
		_m.FieldOutputRequest(name=name, createStepName=step, variables=ALL)
	else:
##		_m.FieldOutputRequest(name=name, createStepName=step, variables=PRESELECT)
		_m.FieldOutputRequest(name=name, createStepName=step, variables=variables)

	if timepoints not in empty:
		times = [None]*8
		if type_of(timepoints) == 'DICT':
			for key,tp in timepoints.items():
				id = step_name_to_id(key)
				if is_INT(id):
					times[id] = tp
		else:
			times = tolist(timepoints)
			times = [None] + times

		timepoints = times
##		print fnln(),timepoints
##		raise Exception

		for i in range(len(timepoints)):
			name1 = timepoints[i]
			if name1 in _m.timePoints.keys() and i < len(_m.steps):
				_m.fieldOutputRequests[name].setValuesInStep(stepName=step, timePoint=name1, variables=variables)

##	raise Exception

	if later_remove not in empty and type_of(variables) == 'TUPLE':  ## 例如，model_change()之后，P的输出是无效的且不收敛。
		step1,vars = later_remove  ## only applicable for one modify at later
		vars = tolist(vars)

		variables = tolist(variables)

		for var in vars:
			if type_of(var) == 'STR':
				var1 = var.upper()
				if var1 in variables:
					variables = remove_item(variables,var1)

		id = get_sequence_index(_m.steps.keys(),step)
		if step1 in _m.steps.keys()[id+1:]:
			variables = totuple(variables)
			_m.fieldOutputRequests[name].setValuesInStep(stepName=step1, variables=variables)

	if is_integer(intervals):
		_m.fieldOutputRequests[name].setValues(numIntervals=intervals)

	return name

def file2lines(filename = 'E:/jobs.txt'):
	## VER: 2010-04-19

	f = open(filename)
	list1 = []
	list1 = f.readlines()
	if len(list1) > 1:
		for i in range(len(list1) - 1):
			list1[i] = list1[i][:-1]
	elif len(list1) == 1:
		list1[0] = list1[0][:-1]

	f.close

	return list1

function_labels['files_in_folder'] = 'path','name','extension','timesort','folder','dir'
def files_in_folder(namewith='',path='',subdir='',ext='',extension='',timesort='decrease',content=''):
	## VER: 2017-07-24, v1.3 默认按时间排序，时间最新的排在最前面。

	## files_in_folder(path='Z:\A0283-Assembly analysis-Oscar')

##	>>> files_in_folder('abaqus
    # ')
##  ['abaqus.rpy', 'abaqus.rpy.2', 'abaqus.rpy.1']

##	>>> get_work_dir()
##	'Z:/A0283-Assembly analysis-Oscar/new1/'
##	>>>
##	>>> real_dir(get_work_dir())
##	'Z:/A0283-Assembly analysis-Oscar/new1'
##	>>>

##	>>> files_in_folder(namewith='ker_',subdir='abaqus_plugins')
##	['ker_AI_A0282_compaction.py']

	timesort = timesort.lower()

	work_dir = get_work_dir()
	if path in empty:
		path = work_dir
	if subdir not in empty:
		path = path + '/' + subdir
##	print 'path=',path
	path = real_dir(path)

	files = os.listdir(path)
##	if subdir in empty:
##		files = os.listdir('.')
##	else:
##		files = os.listdir(subdir)
##		path = path + '/' + subdir

	path = real_dir(path) + '/'

##	print fnln(),'files=',files
	newlist = []
	for file1 in files:
		path1 = real_dir(path + file1)
##		print fnln(),'path1=',path1
		if os.path.isfile(path1):
			newlist.append(file1)
	files = newlist

##	print fnln(),'files=',files
	if extension not in empty:
		ext = extension

	if ext not in empty:
		ext = totext(ext)
		ext = ext.lower()
		if ext[0] != '.':
			ext = '.' + ext

		newlist = []
		for file1 in files:
			if file1.lower().endswith(ext):
				newlist.append(file1)
		files = newlist

##	print fnln(),'files=',files
	if namewith not in empty:
		newlist = []
		for file1 in files:
			if namewith in file1:
				newlist.append(file1)
		files = newlist

##	print fnln(),'files=',files
##	raise Exception
	if content not in empty:
		list1 = []
		for file1 in files:
			path1 = real_dir(path + file1)
			if content in open(path1).readlines()[-1]:
				list1.append(file1)
		files = list1

	else:
		if timesort in ['increase','decrease'] and files not in empty:
			list1 = []
			for file1 in files:
				path1 = real_dir(path + file1)
				list1.append((file1, file_time_second(path1)))

			list2 = sort_tuple_type_elements(list1, index=1)
			if timesort == 'decrease':
				list2.reverse()
			files = list2

			newlist = []
			for file1 in files:
				newlist.append(file1[0])
			files = newlist

	return files

def file_time_second(file1):
	## VER: 2014-08-25, v1.0

##>>> file_time_second('CS_A0206_esize002_fric001_ss304.inp')
##1408929374.04658
##>>> file_time_date('CS_A0206_esize002_fric001_ss304.inp')
##(2014, 8, 25, 9, 16, 14, 46578)
##>>> file_time_date('CS_A0206_esize002_fric001_ss304.inp',format='str')
##'2014-08-25 09:16:14.046578'
##>>>

	if os.path.isfile(file1):
		time1 = os.path.getmtime(file1)
	else:
		raise Exception('*** file ' + file1 + ' not exists.')

	return time1

def file_time_date(file1,format='tuple'):
	## VER: 2014-08-25, v1.0

##>>> file_time_second('CS_A0206_esize002_fric001_ss304.inp')
##1408929374.04658
##>>> file_time_date('CS_A0206_esize002_fric001_ss304.inp')
##(2014, 8, 25, 9, 16, 14, 46578)
##>>> file_time_date('CS_A0206_esize002_fric001_ss304.inp',format='str')
##'2014-08-25 09:16:14.046578'
##>>>

	if os.path.isfile(file1):
		time1 = os.path.getmtime(file1)
		time2 = datetime.datetime.fromtimestamp(time1)

		if format == 'tuple':
			time3 = repr(time2)
			loc = time3.find('(')
			time3 = time3[loc:]
			time3 = eval(time3)
		else:
			time3 = str(time2)

	else:
		raise Exception('*** file ' + file1 + ' not exists.')

	return time3

def find_circular_edges(p,radius=None,RP=None,axis=None):

	## VER: ('VER: 2012-08-15, v1.1')

	p = check_pias(p)

	edges = []
	for i in xrange(len(p.edges)):
		edge = p.edges[i]
##	for edge in p.edges:
		try:
			radius1 = edge.getRadius()
		except:
			continue
		if radius != None and equal(radius,radius1):
			edges.append(edge)
		else:
			edges.append(edge)

	if (RP == None and axis != None) or (RP != None and axis == None):
		raise Exception('Both RP and axis are required.')

	if RP != None and axis != None and len(edges) > 0:
		edges = edge_select(p,edges=edges,RP=RP,axis=axis)

	return edges


def find_closest_number(list1, data):
	## VER: 2015-04-30, v1.0
	## 用于将单元的体积密度值归一到某个密度档位。

##	>>> list1 = [6.4,6.5, 6.6, 6.7, 6.8, 6.9, 7.0]
##	>>> find_closest_number(list1, 6.663)
##	6.7
##	>>> find_closest_number(list1, 6.643)
##	6.6
##	>>>

	if is_number(list1):
		list1, data = data, list1

	list1 = tolist(list1)
	if is_number(data) == False:
		raise Exception('*** Numeric data is required.')

	data = smart_round(data)

	list2 = _sort(list1 + [data])

	if data == list2[0]:
		closest = list2[1]
	elif data == list2[-1]:
		closest = list2[-2]
	else:
		index = list2.index(data)

		d1 = abs(data - list2[index - 1])
		d2 = abs(data - list2[index + 1])

		if d1 <= d2:
			closest = list2[index - 1]
		else:
			closest = list2[index + 1]

	return closest

def find_coarse(value1,value2,err=2e-4,fail=None):
	## VER: 2014-08-11, v1.0
	## 间隙小于3um，且更加趋向整数者。

	result = fail
	if is_numbers(value1,value2):
		if PK(value1,value2) == 0:
			result = value1
		elif abs(value1 - value2) < err:
			if get_float_num(value1) - get_float_num(value2) >= 1:
				result = value2
			elif get_float_num(value2) - get_float_num(value1) >= 1:
				result = value1

	return result

function_labels['find_contacts'] = 'interact','tie','master','slave','friction'
def find_contacts(action='tie', master_insts=None, master_parts=None, master_set=None, mfaces=None, xEdges_m=None,
	slave_insts=None, slave_set=None, sfaces=None, slave_parts=None, xEdges_s=None,
	base_set=None, base_parts=None, base_insts=None, base_type = None,  ## 基于谁来限制接触区域, 或者base为已知的确定面
	mate_set=None, mate_insts=None, mate_parts=None,
	parts=None, insts=None, xEdges=None, collect_edges=None,
	find_inst_by='set', search_or_find=None, fix='_', refined_insts='_', force_create=False, gap=None,
	one_one='no',prop='Frictionless', step='step1', monitor_pair=[]):

	## VER: ('VER: 2016-10-25, v6.1')	## 可以在命令窗口执行以观察。
	## base vs mate, master vs slave

##	create_general_static_step()
##	find_contacts(action='tie',master_parts='lam',slave_parts='pad')
##	find_contacts(action='interact',master_parts='lam')
##	find_contacts(action='tie',slave_parts='pad')

## find_contacts思路
##find_contacts
##=> s2s_interact_std
##=> get_msface_and_msregion =>> side1_faces_to_pair(只有mfaces和sfaces其中之一未知时才执行)
##=> check_in_contact =>>  cross_of_faces_and_faces
##
##s2s_interact_std:
##1. 确定master_inst, slave_inst
##2. 确定contact_name
##3. 调用get_face_and_region_pair
##4. check_in_contact
##5. create set and create interact
##
##get_msface_and_msregion:
##1). 消化face_set（转化为mfaces or sfaces)
##2). 消化xEdges参数(转化为xEdges_m or xEdges_s)
##
##1. 获得face list形式的mfaces,sfaces。如有缺一，则通过get_face_pair补齐
##2. 获得face list形式的xEdges_s,xEdges_m
##3. 获得mfaces和sfaces对应的region。若xEdges_s和xEdges_m非空，则为mix_region
##4. 返回mfaces,sfaces,xEdges_m,xEdges_s,mregion,sregion
##
##check_in_contact:
##1. 确认是否有交集、是否有重复。如无重复，则登记
##2. 如果是tie,确认是否有共用slave edges。若有，提出警告并给出警告信息。
##2. 返回create

	global insts_space,find_contact_com, find_process, msfaces_trace

	msfaces_trace = []
	globals()['collect_edges'] = collect_edges

##	raise Exception
	step = check_step(step)
	antype = _step(step).procedureType

	if antype == FREQUENCY and action != 'tie':
		print fnln_fnln(),'action was changed from',action,'to tie for the modal analysis.'
		action = 'tie'

	if action == 'tie':
		cont_func = s2s_tie
	elif action == 'interact':
		cont_func = s2s_interact_std

	find_process = ['find_contacts']

	find_contact_com += 1
	step = check_step(step)

	print ' '
	print '**************************************'
	print 'find_contacts(), #' + str(find_contact_com),': Finding and creating interactions...'

	command = get_parameters(locals(),clear='empty')
	print ' '

	action = action.lower()
	one_one = one_one.lower()

	parts = real_parts(parts)
	insts = real_insts(insts)
	monitor_pair = real_insts(monitor_pair)

	master_parts = real_parts(master_parts)
	master_insts = real_insts(master_insts)
	slave_parts = real_parts(slave_parts)
	slave_insts = real_insts(slave_insts)

	base_insts = real_insts(base_insts)
	base_parts = real_parts(base_parts)
	mate_insts = real_insts(mate_insts)
	mate_parts = real_parts(mate_parts)

	## update
	masters = [master_set,mfaces,master_parts,master_insts]
	slaves = [slave_set,sfaces,slave_parts,slave_insts]
	bases = [base_set, base_parts, base_insts]
	mates = [mate_set, mate_parts, mate_insts]
	pois = [parts,insts]

	## 1.1. 解读masters，获得master_insts
	if not is_empties(masters):
		if master_insts in empty:
			if master_set not in empty:
				master_insts = insts_by_set(master_set)
			elif mfaces not in empty:
				master_insts = get_pois(mfaces)
			elif master_parts not in empty:
				master_insts = insts_of_parts(master_parts)

		if master_set not in empty:
			mfaces = master_set

		masters = [master_set,mfaces,master_parts,master_insts]  ## update
		if master_insts in empty:   ## ★
			raise Exception(fnln_fnln(), 'Fail to get the master_insts from masters.')
		else:
			print 'master_insts=',poi_names(master_insts)

##	print fnln(),'master_insts=',master_insts
##	raise Exception

	## 1.2. 解读slaves，获得slave_insts
	if not is_empties(slaves):
		if slave_insts in empty:
			if slave_set not in empty:
				slave_insts = insts_by_set(slave_set)
			elif sfaces not in empty:
				slave_insts = get_pois(sfaces)
			elif slave_parts not in empty:
				slave_insts = insts_of_parts(slave_parts)

		if slave_set not in empty:
			sfaces = slave_set

		slaves = [slave_set,sfaces,slave_parts,slave_insts]
		if slave_insts in empty:
			raise Exception('Fail to get the slave_insts from slaves.')
		else:
			print 'slave_insts=',poi_names(slave_insts)

	## 1.3. 解读bases, 获得base_insts
	if not is_empties(bases):
		print 'bases=',bases
		if base_insts in empty:
			if base_set not in empty:
				base_insts = insts_by_set(base_set)
			elif base_parts not in empty:
				base_insts = insts_of_parts(base_parts)

		bases = [base_set, base_parts, base_insts]
		print fnln_fnln(),'bases=',bases
		if base_insts in empty:  ## ★
			raise Exception(fnln_fnln(), 'Fail to get the base_insts from bases.')
		else:
			print 'base_insts=',poi_names(base_insts)

	## 1.4. 解读mates, 获得mate_insts
	if not is_empties(mates):
		if mate_insts in empty:
			if mate_set not in empty:
				mate_insts = insts_by_set(mate_set)
			elif mate_parts not in empty:
				mate_insts = insts_of_parts(mate_parts)

		mates = [mate_set, mate_parts, mate_insts]
		if mate_insts in empty:
			raise Exception(fnln_fnln(), 'Fail to get the mate_insts from mates.')
		else:
			print 'mate_insts=',poi_names(mate_insts)

	## 1.5 解读pois, 得到insts
	if not is_empties(pois):
		if parts not in empty:
			insts = insts_of_parts(parts)

		pois = [parts,insts]
		if insts in empty():
			raise Exception('Fail to get insts from pois.')
		else:
			print 'insts =',poi_names(insts)

	## update, 去除parts, master_set和slave_set
	masters = [mfaces,master_insts]
	slaves = [sfaces,slave_insts]
	bases = [base_set, base_insts]
	mates = [mate_set, mate_insts]
	pois = [insts, insts]   ## 不能是[insts]，否则tolist(pois)=insts，而不是[insts]

	if base_set in empty and base_insts not in empty and not is_empties(mfaces,sfaces,mate_set):
		raise Exception('请将base与mate调换，因为需要将已知面作为base.')

	if len(remove_empty(master_insts,slave_insts,base_insts,mate_insts)) >= 3:
		raise Exception('Confused input. 参数过多，有重复.')

	print ' '
	print '2. 开始确定全部的masters, slaves, bases, mates, base_type, base_set'
	print fnln(),masters
	print fnln(),slaves
	print fnln(),'bases=',bases
	print fnln(),'mates=',mates

	if not is_empties(masters) and is_empties(slaves,bases,mates):
		print fnln_fnln(),'**Entrance 2.1: 仅提供masters'
		print_caller_code()

		if base_type not in ['master','slave']:
			base_type = 'master'

		if base_type == 'master':
			base_insts = master_insts
			if mfaces not in empty:
				base_set = mfaces

			slave_insts = unselect(a.instances.values(),master_insts)
			mate_insts = slave_insts
##			slave_insts = a.instances.values()
##			mate_insts = a.instances.values()

		else:
			if mfaces not in empty:
				print 'mfaces=',mfaces
				print 'base_type',base_type

				raise Exception('Confused info. master_set or mfaces is not empty, but base_type = slave')

			mate_insts = master_insts
			base_insts = unselect(a.instances.values(),mate_insts)
			slave_insts = base_insts
##			slave_insts = a.instances.values()

	elif not is_empties(slaves) and is_empties(masters,bases,mates):
		print fnln_fnln(),'**Entrance 2.2: 仅提供slaves'
		print_caller_code()

		if base_type not in ['master','slave']:
			base_type = 'slave'

		if base_type == 'slave':
			base_insts = slave_insts
			if sfaces not in empty:
				base_set = sfaces

			master_insts = a.instances.values()
			mate_insts = a.instances.values()

		else:
			if sfaces not in empty:
				print 'sfaces=',sfaces
				print 'base_type',base_type
				raise Exception('Confused info. slave_set or sfaces is not empty, but base_type = master')

			base_insts = a.instances.values()
			mate_insts = slave_insts
			master_insts = a.instances.values()

	elif not is_empties(bases) and is_empties(masters,slaves,mates):
		print fnln_fnln(),'**Entrance 2.3: 仅提供bases'
		print_caller_code()

		if base_type not in ['master','slave']:
			raise Exception('base_type is required.')

		if base_type == 'master':
			master_insts = base_insts
			mate_insts = slave_insts = a.instances.values()

		elif base_type == 'slave':
			slave_insts = base_insts
			mate_insts = master_insts = a.instances.values()

	elif not is_empties(mates) and is_empties(masters,slaves,bases):
		print fnln_fnln(),'**Entrance 2.4: 仅提供mates'
		print_caller_code()

		if base_type not in ['master','slave']:
			raise Exception('base_type is required.')

		if base_type == 'master':  ## 已知mate, 但mate为slave
			slave_insts = mate_insts
			base_insts = master_insts = a.instances.values()

		elif base_type == 'slave':	## 已知mate, 但mate为master
			master_insts = mate_insts
			base_insts = slave_insts = a.instances.values()

	elif not is_empties(pois) and is_empties(masters,slaves,bases, mates):
		print fnln_fnln(),'**Entrance 2.5: 仅提供pois'
		print_caller_code()

		if base_type not in ['master','slave']:
			base_type = 'slave'
		base_insts = mate_insts = master_insts = slave_insts = insts

	elif is_empties(bases,mates,masters,slaves):
		print fnln_fnln(),'**Entrance 2.6: 什么都不提供'
		print_caller_code()

		if base_type not in ['master','slave']:
			base_type = 'slave'
		base_insts = mate_insts = master_insts = slave_insts = a.instances.values()

	elif all_lists_not_empty(masters,bases) and is_empties(slaves,mates):
		print fnln_fnln(),'**Entrance 2.7: 仅提供masters和bases'
		print_caller_code()

		base_type = 'slave'
		mate_insts = master_insts
		slave_insts = base_insts

		if mfaces not in empty:
			mate_set = mfaces

	elif all_lists_not_empty(masters,mates) and is_empties(slaves,bases):
		print fnln_fnln(),'**Entrance 2.8: 仅提供masters和mates'
		print_caller_code()

		base_type = 'master'
		base_insts = master_insts
		slave_insts = mate_insts

		if mfaces not in empty:
			base_set = mfaces

	elif all_lists_not_empty(slaves,bases) and is_empties(masters,mates):
		print fnln_fnln(),'**Entrance 2.9: 仅提供slaves和bases'
		print_caller_code()

		base_type = 'master'
		master_insts = base_insts
		mate_insts = slave_insts

		if sfaces not in empty:
			mate_set = sfaces

	elif all_lists_not_empty(slaves,mates) and is_empties(masters,bases):
		print fnln_fnln(),'**Entrance 2.10: 仅提供slaves和mates'
		print_caller_code()

		base_type = 'slave'
		master_insts = mate_insts
		base_insts = slave_insts

		if sfaces not in empty:
			base_set = sfaces

	elif all_lists_not_empty(masters,slaves) and is_empties(bases,mates):
		print fnln_fnln(),'**Entrance 2.11: 仅提供masters和slaves'
		print_caller_code()

		if base_type not in ['master','slave']:
			if mfaces not in empty and sfaces in empty:
				base_type = 'master'
			else:
				base_type = 'slave'

		if base_type == 'master':
			base_insts = master_insts
			mate_insts = slave_insts

			if mfaces not in empty:
				base_set = mfaces

			if sfaces not in empty:
				mate_set = sfaces

		else:
			base_insts = slave_insts
			mate_insts = master_insts

			if sfaces not in empty:
				base_set = sfaces

			if mfaces not in empty:
				mate_set = mfaces

	elif all_lists_not_empty(bases,mates) and is_empties(masters,slaves):
		print fnln_fnln(),'**Entrance 2.12: 仅提供bases和mates'
		print_caller_code()

		if base_type not in ['master','slave']:
			raise Exception('base_type is required, master or slave.')

		if base_type == 'master':
			master_insts = base_insts
			slave_insts = mate_insts
		else:
			master_insts = mate_insts
			slave_insts = base_insts
	else:
		raise Exception('Fail to get the base_insts,mate_insts,master_insts,slave_insts,base_type,base_set')

	masters = [mfaces,master_parts,master_insts]
	slaves = [sfaces,slave_parts,slave_insts]
	bases = [base_set, base_parts, base_insts]
	mates = [mate_set, mate_parts, mate_insts]

	base_inst_names = poi_names(base_insts)
	mate_inst_names = poi_names(mate_insts)

	msfaces_trace.append(get_traceback()[-4:] + ['base_set',objs_num(base_set), 'mate_set', objs_num(mate_set),'ext=',refined_insts,'fix=',fix])

	print ' '
	print '**Parameters checking summumary:'
	print 'master_insts=',poi_names(master_insts)
	print 'slave_insts=',poi_names(slave_insts)
	print 'base_type=',base_type
	print 'base_set=',base_set
	print 'base_insts=',poi_names(base_insts)
	print 'mate_insts=',poi_names(mate_insts)
	print 'find_inst_by=',find_inst_by,', search_or_find=',search_or_find
	print ' '

	if not solid_sequence(master_insts,slave_insts,base_type,base_insts,mate_insts):
		raise Exception('Fail to get the base_insts,mate_insts,master_insts,slave_insts,base_type')

	found_num = 0
	fc_tried = 'no'
	cross_tried = 'no'

	fix0 = fix
	refine_ext0 = refined_insts

	## Situation 1
	if base_set not in empty and mate_set in empty:    ## 已经知道base_faces
		if search_or_find != 'find':
			search_or_find = 'search'
			command['search_or_find'] = 'search'

		print fnln_fnln(),'**根据base_set来找接触对: base_set=',repr(base_set)
		print ' '
		for base_inst in base_insts:
			for mate_inst in mate_insts:
				if mate_inst.name == base_inst.name:
					continue

				print ' '
				print '■根据base_set来找接触对，现在枚举实例配对：base_inst=',base_inst.name,', mate_inst=',mate_inst.name

##				if base_type == 'master':
##					fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=base_inst,p2=mate_inst)
##				elif base_type == 'slave':
##					fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=mate_inst,p2=base_inst)

				if base_inst in monitor_pair and mate_inst in monitor_pair:
					globals()['debug'] = True

				if type_of(base_set) == 'STR':
					base_faces = set2objs(base_inst,base_set)
				elif type_of(base_set) == 'LIST':
					base_faces = base_set

				print 'search_or_find=',search_or_find

##				print 'mate_insts=',poi_names(mate_insts)
##				stop(debug)

				msfaces_trace = []
				msfaces_trace.append(get_traceback()[-4:] + ['base_faces',objs_num(base_faces),'mate_faces=0','search_or_find=' + search_or_find, 'ext=' + refined_insts,'fix=' + fix,'gap=' + repr(gap),'force_create=' + repr(force_create) ])

				## ★
				refined = refined_insts  ## 由于反复要利用，所以不能更新refined_insts为实际的. refined为具体的。refined_insts为匿名的。
				if refined_insts in ['ms','both','12',12]:
					refined = master_inst.name + ',' + slave_inst.name
				elif refined_insts == 'm':
					refined = master_inst.name
				elif refined_insts == 's':
					refined = slave_inst.name

				base_faces,mate_faces = side1_faces_to_pair(base_faces,side1_inst=base_inst,side2_inst=mate_inst,search_or_find=search_or_find,
					fix=fix,refined_insts=refined, force_create=force_create,gap=gap)
				msfaces_trace.append(get_traceback()[-2:] + ['base_faces',objs_num(base_faces),'mate_faces',objs_num(mate_faces), 'refined=',refined_insts,'fix=',fix])

				if len(mate_faces) > 0:
					if type_of(base_set) == 'STR':
						string1 = partial_setname(base_inst,base_set)
						name = mate_inst.name + '//' + base_inst.name + '_' + string1 +'(' + base_type[0] + ')'
					elif type_of(base_set) == 'LIST':
						name = mate_inst.name + '//' + base_inst.name + '(' + base_type[0] + ')'

					if base_type == 'master':
						cont_func(master_inst=base_inst,slave_inst=mate_inst,name=name,mfaces=base_faces,sfaces=mate_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=force_create, gap=gap, fix=fix, refined_insts=refined_insts)
					elif base_type == 'slave':
						cont_func(master_inst=mate_inst,slave_inst=base_inst,name=name,mfaces=mate_faces,sfaces=base_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=force_create, gap=gap, fix=fix, refined_insts=refined_insts)

					found_num = found_num + 1
					if type_of(base_set) == 'STR':
						print '	**num =',found_num, ", find by specified face set: ",base_set,'//',"''"
					else:
						print '	**num =',found_num, ", find by specified base faces"

					print '	Total interactions:',len(_m.interactions)
					print '	Total ties:',len(_m.constraints)
					print ' '

	## Situation 2
	elif base_set not in empty and mate_set not in empty:
		print '**Situation 2: base_set=',base_set,', mate_set=',mate_set
		print ' '
		for base_inst in base_insts:
			for mate_inst in mate_insts:
				if mate_inst.name == base_inst.name:
					continue

				print '■base_inst=',base_inst.name,', mate_inst=',mate_inst.name

##				if base_type == 'master':
##					fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=base_inst,p2=mate_inst)
##				elif base_type == 'slave':
##					fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=mate_inst,p2=base_inst)

				refined = refined_insts  ## 由于反复要利用，所以不能更新refined_insts为实际的. refined为具体的。refined_insts为匿名的。
				if refined_insts in ['ms','both','12',12]:
					refined = master_inst.name + ',' + slave_inst.name
				elif refined_insts == 'm':
					refined = master_inst.name
				elif refined_insts == 's':
					refined = slave_inst.name

				base_faces = set2objs(base_inst,base_set)
				mate_faces = set2objs(mate_inst,mate_set)
				cross = cross_of_faces_and_faces(base_faces,mate_faces,p1=base_inst,p2=mate_inst,fix=fix,refined_insts=refined,gap=gap,force_create=force_create)
				print fnln_fnln(),'cross_of_faces_and_faces=',cross,
				if cross['no_cross'] == True:
				 	if force_create == True:
						print ', but force_create=True'
					else:
						continue

				base_faces = cross[base_inst.name]
				mate_faces = cross[mate_inst.name]

				print fnln_fnln(),'Now to build the',action
				string1 = partial_setname(base_inst,base_set)
				name = mate_inst.name + '//' + base_inst.name + '_' + string1 +'(' + base_type[0] + ')'

				if base_type == 'master':
					created = cont_func(base_inst,mate_inst,name=name,mfaces=base_faces,sfaces=mate_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=force_create, gap=gap, fix=fix, refined_insts=refined_insts)
				elif base_type == 'slave':
					created = cont_func(mate_inst,base_inst,name=name,mfaces=mate_faces,sfaces=base_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=force_create, gap=gap, fix=fix, refined_insts=refined_insts)

				if created:
					found_num = found_num + 1

				print '	**num =',found_num, ', find by specified face set:', base_set,'//',mate_set
				print '	Total interactions:',len(_m.interactions)
				print '	Total ties:',len(_m.constraints)

				print ' '

	## Situation 3
	elif base_set in empty and mate_set in empty and find_inst_by == 'set':
		print "**Situation 3: base_set==mate_set==None. Will find by fc_,fs_,fm_ sets of base_insts."
		search_or_find = 'search'
		command['search_or_find'] = 'search'
		for base_inst in base_insts:
			part = _m.parts[base_inst.partName]
			partname = base_inst.partName

			print ' '
			print '** base_inst=',base_inst.name,', searching fc_ sets...'

			i = 0
			for setname in part.sets.keys():
				if setname[0:3] in ['fc_','fs_','fm_']:
					base_set = setname
					if master_insts not in empty:
						if base_inst in master_insts and base_set[:3] == 'fs_':
							continue

					if slave_insts not in empty:
						if base_inst in slave_insts and base_set[:3] == 'fm_':
							continue

					if master_insts not in empty and base_inst in master_insts:
						base_type = 'master'

					elif slave_insts not in empty and base_inst in slave_insts:
							base_type = 'slave'

					else:
						prefix = base_set[:3]
						if prefix == 'fs_':
							base_type = 'slave'
						elif prefix == 'fm_':
							base_type = 'master'
						elif prefix == 'fc_':
							base_type = 'slave'   ##???****

					found = False
					base_faces = set2objs(base_inst,base_set)

					i = i + 1
					print ' '
					print '----'
					print str(i) + ': Found base_set:',base_set
					print 'base_type=',base_type

					for mate_inst in mate_insts:
						if mate_inst.name == base_inst.name:
							continue

##						if base_type == 'master':
##							fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=base_inst,p2=mate_inst)
##						elif base_type == 'slave':
##							fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=mate_inst,p2=base_inst)

						refined = refined_insts  ## 由于反复要利用，所以不能更新refined_insts为实际的. refined为具体的。refined_insts为匿名的。
						if refined_insts in ['ms','both','12',12]:
							refined = master_inst.name + ',' + slave_inst.name
						elif refined_insts == 'm':
							refined = master_inst.name
						elif refined_insts == 's':
							refined = slave_inst.name

						base_faces = set2objs(base_set,base_inst)
						base_faces,mate_faces = side1_faces_to_pair(base_faces,side1_inst=base_inst,side2_inst=mate_inst,search_or_find=search_or_find, fix=fix, refined_insts=refined_insts, force_create=force_create, gap=gap)

						if len(mate_faces) > 0:
							found = True
							shape_b = face_shape(base_faces[0])
							shape_m = face_shape(mate_faces[0])
							if show_in_items([shape_b,shape_m],'plane') == False:
								force_create = True

							string1 = partial_setname(base_inst,base_set)
							name = mate_inst.name + '//' + base_inst.name + '_' + string1 + '(' + base_type[0] + ')'

							if base_type == 'master':
								created = cont_func(master_inst=base_inst,slave_inst=mate_inst,name=name,mfaces=base_faces,sfaces=mate_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=force_create, gap=gap, fix=fix, refined_insts=refined_insts)
							elif base_type == 'slave':
								created = cont_func(master_inst=mate_inst,slave_inst=base_inst,name=name,mfaces=mate_faces,sfaces=base_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=force_create, gap=gap, fix=fix, refined_insts=refined_insts)

							if created:
								found_num = found_num + 1
								print '**found_num =',found_num
								print ' '

							if one_one == 'yes':
								break

		if found_num == 0:
			fc_tried = 'failed'

	## Situation 4 (cross-space method)
	if fc_tried == 'failed' or find_inst_by == 'cross':
		find_inst_by == 'cross'
		print ' '
		if fc_tried == 'failed':
			print fnln_fnln(),'******Failed by fc_ face sets method. ',
		print 'Now, situation 4: Trying cross-space method...'
		print ' '

		for base_inst in base_insts:
##			base_space = insts_space[base_inst.name]
			base_space = poi_space(base_inst)
			for mate_inst in mate_insts:
				if mate_inst.name == base_inst.name:
					continue

##				mate_space = insts_space[mate_inst.name]
				mate_space = poi_space(mate_inst)
				cross = cross_of_spaces(base_space,mate_space)
				if len(cross['gap_dir']) >= 2:
					continue

				print 'Finding mate faces of', base_inst.name, 'in', mate_inst.name,'...'

##				if base_type == 'master':
##					fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=base_inst,p2=mate_inst)
##				elif base_type == 'slave':
##					fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=mate_inst,p2=base_inst)

				refined = refined_insts  ## 由于反复要利用，所以不能更新refined_insts为实际的. refined为具体的。refined_insts为匿名的。
				if refined_insts in ['ms','both','12',12]:
					refined = master_inst.name + ',' + slave_inst.name
				elif refined_insts == 'm':
					refined = master_inst.name
				elif refined_insts == 's':
					refined = slave_inst.name

				if cross['gap_dir'] in empty:
					base_faces = face_select(base_inst,x=cross[0]['range'],y=cross[1]['range'],z=cross[2]['range'])
					if search_or_find == 'find':
						base_faces,mate_faces = side1_faces_to_pair(base_faces,side1_inst=base_inst,side2_inst=mate_inst,search_or_find='find',fix=fix, refined_insts=refined_insts, force_create=force_create, gap=gap)
					elif search_or_find == 'search':
						mate_faces = face_select(mate_inst,x=cross[0]['range'],y=cross[1]['range'],z=cross[2]['range'])

					if len(base_faces) > 0 and len(mate_faces) > 0:
						name = mate_inst.name + '//' + base_inst.name + '(' + base_type[0] + ')'
						if base_type == 'master':
							created = cont_func(master_inst=base_inst,slave_inst=mate_inst,name=name,mfaces=base_faces,sfaces=mate_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, fix=fix, refined_insts=refined_insts, force_create=force_create, gap=gap)
						elif base_type == 'slave':
							created = cont_func(master_inst=mate_inst,slave_inst=base_inst,name=name,mfaces=mate_faces,sfaces=base_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, fix=fix, refined_insts=refined_insts, force_create=force_create, gap=gap)

						if created:
							found_num = found_num + 1

						print '**num =',found_num, ', find by plane_contact cross-range between two instances:',base_inst.name,'//',mate_inst.name
						print 'Total interactions:',len(_m.interactions)
						print 'Total ties:',len(_m.constraints)
						print ' '

				elif len(cross['gap_dir']) == 1 and force_create == True:
					print "cross['gap_dir']=",cross['gap_dir'],', but force_create = True.'
					if cross['gap_dir'] == [0]:
						base_faces = face_select(base_inst,x=cross[0]['range'][0],y=cross[1]['range'],z=cross[2]['range'])
						mate_faces = face_select(mate_inst,x=cross[0]['range'][1],y=cross[1]['range'],z=cross[2]['range'])
					elif cross['gap_dir'] == [1]:
						base_faces = face_select(base_inst,y=cross[1]['range'][0],x=cross[0]['range'],z=cross[2]['range'])
						mate_faces = face_select(mate_inst,y=cross[1]['range'][1],x=cross[0]['range'],z=cross[2]['range'])
					elif cross['gap_dir'] == [2]:
						base_faces = face_select(base_inst,z=cross[2]['range'][0],x=cross[0]['range'],y=cross[1]['range'])
						mate_faces = face_select(mate_inst,z=cross[2]['range'][1],x=cross[0]['range'],y=cross[1]['range'])

					if base_faces in empty or mate_faces in empty:
						print fnln_fnln(),'******base_faces or mate_faces is empty.'
						continue

					## search by base_faces
					print 'Finding mate faces by base_faces...'
					base_faces,mate_faces1 = side1_faces_to_pair(base_faces,side1_inst=base_inst,side2_inst=mate_inst,search_or_find='search',force_create=True, gap=gap, fix=fix, refined_insts=refined_insts)
					if len(base_faces) > 0 and len(mate_faces1) > 0:
						name = mate_inst.name + '//' + base_inst.name + '(' + base_type[0] + ')'
						if base_type == 'master':
							created = cont_func(master_inst=base_inst,slave_inst=mate_inst,name=name,mfaces=base_faces,sfaces=mate_faces1,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, force_create=True, gap=gap, prop=prop, refined_insts=refined_insts,fix=fix)
						elif base_type == 'slave':
							created = cont_func(master_inst=mate_inst,slave_inst=base_inst,name=name,mfaces=mate_faces1,sfaces=base_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, force_create=True, gap=gap, prop=prop, refined_insts=refined_insts,fix=fix)

						if created:
							found_num = found_num + 1

						print '**num =',found_num, ', find by plane_contact cross-range between two instances:',base_inst.name,'//',mate_inst.name
						print 'Total interactions:',len(_m.interactions)
						print 'Total ties:',len(_m.constraints)
						print ' '

					## search by mate_faces
					print 'Finding mate faces by mate_faces...'
					mate_faces,base_faces1 = side1_faces_to_pair(mate_faces,side1_inst=mate_inst,side2_inst=base_inst,search_or_find='search',force_create=True, gap=gap, fix=fix, refined_insts=refined_insts)
					if len(base_faces1) > 0 and len(mate_faces) > 0:
						name = mate_inst.name + '//' + base_inst.name + '(' + base_type[0] + ')'
						if base_type == 'master':
							created = cont_func(master_inst=base_inst,slave_inst=mate_inst,name=name,mfaces=base_faces1,sfaces=mate_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=True, gap=gap,  fix=fix, refined_insts=refined_insts)
						elif base_type == 'slave':
							created = cont_func(master_inst=mate_inst,slave_inst=base_inst,name=name,mfaces=mate_faces,sfaces=base_faces1,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, force_create=True, gap=gap, fix=fix, refined_insts=refined_insts)

						if created:
							found_num = found_num + 1

						print '**num =',found_num, ', find by plane_contact cross-range between two instances:',base_inst.name,'//',mate_inst.name
						print 'Total interactions:',len(_m.interactions)
						print 'Total ties:',len(_m.constraints)
						print ' '

		if found_num == 0:
			cross_tried = 'failed'

	## Finally, Situation 5
	if cross_tried == 'failed' and fc_tried == 'no':
		find_inst_by == 'set'
		print ' '
		print '**Situation 5: Failed by cross-space method, now force to find by every fc_,fs_,fm_ sets of base_insts... ******'
		print ' '

		for base_inst in base_insts:
			part = _m.parts[base_inst.partName]
			partname = base_inst.partName

			print ' '
			print '** base_inst=',base_inst.name,', searching fc_ sets...'

			i = 0
			for setname in part.sets.keys():
				if setname[0:3] in ['fc_','fs_','fm_']:
					base_set = setname
					if master_insts not in empty:
						if base_inst in master_insts and base_set[:3] == 'fs_':
							continue

					if slave_insts not in empty:
						if base_inst in slave_insts and base_set[:3] == 'fm_':
							continue

					if master_insts not in empty and base_inst in master_insts:
						base_type = 'master'

					elif slave_insts not in empty and base_inst in slave_insts:
							base_type = 'slave'

					else:
						prefix = base_set[:3]
						if prefix == 'fs_':
							base_type = 'slave'
						elif prefix == 'fm_':
							base_type = 'master'
						elif prefix == 'fc_':
							base_type = 'slave'   ##???****

					found = False
					base_faces = set2objs(base_inst,base_set)

					i = i + 1
					print '----'
					print str(i) + ': Found base_set:',base_set
					print 'base_type=',base_type

					for mate_inst in mate_insts:
						if mate_inst.name == base_inst.name:
							continue

##						if base_type == 'master':
##							fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=base_inst,p2=mate_inst)
##						elif base_type == 'slave':
##							fix,refined_insts = check_fix_extend(fix=fix0,refined_insts=refine_ext0,p1=mate_inst,p2=base_inst)

						refined = refined_insts  ## 由于反复要利用，所以不能更新refined_insts为实际的. refined为具体的。refined_insts为匿名的。
						if refined_insts in ['ms','both','12',12]:
							refined = master_inst.name + ',' + slave_inst.name
						elif refined_insts == 'm':
							refined = master_inst.name
						elif refined_insts == 's':
							refined = slave_inst.name

						base_faces = set2objs(base_set,base_inst)
						base_faces,mate_faces = side1_faces_to_pair(base_faces,side1_inst=base_inst, side2_inst=mate_inst,search_or_find=search_or_find,fix=fix,refined_insts=refined_insts, force_create=force_create, gap=gap)

						if len(mate_faces) > 0:
							found = True

							string1 = partial_setname(base_inst,base_set)
							name = mate_inst.name + '//' + base_inst.name + '_' + string1 + '(' + base_type[0] + ')'

							if base_type == 'master':
								created = cont_func(master_inst=base_inst,slave_inst=mate_inst,name=name,mfaces=base_faces,sfaces=mate_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, fix=fix, refined_insts=refined_insts, force_create=force_create, gap=gap)
							elif base_type == 'slave':
								created = cont_func(master_inst=mate_inst,slave_inst=base_inst,name=name,mfaces=mate_faces,sfaces=base_faces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, prop=prop, fix=fix, refined_insts=refined_insts, force_create=force_create, gap=gap)

							if created:
								found_num = found_num + 1
								print '**found_num =',found_num
								print ' '

							if one_one == 'yes':
								break

		if found_num == 0:
			fc_tried = 'failed'

	if found_num > 0:
		print ' '
		print '--->Totally',found_num,action+'s','are created for',base_inst_names
		command = repr(command)
		command = use_poi_var_name(command)
		print 'by find_contacts:',command
		print ' '
	else:
		print fnln_fnln(),'****No contacts was found.'

	print ' '
	print fnln_fnln(),'**find_process='
	print find_process
	print ' '

	try:
		del globals()['s2s_process']
	except:
		pass

	return found_num

function_labels['fix_nodes_of_insert'] = 'hole nodes','diameter','open','mouth','fix','insert'
def fix_nodes_of_insert(p1,axis_side=MIN,angle=10,return_label=False):
	## VER: 2016-10-12, v1.2
	## hole_axis = 'z'
	## applicable for full model
	## History: angle=40 is too big.

##	nodes = fix_nodes_of_insert(p1,axis_side=MAX,return_label=False)
##	light(nodes)

	p1 = check_pia(p1)
	print fnln(),'axis_side=',axis_side
	if axis_side == MIN:
		face_nodes = nodes_by_face(p1,z=MIN,nz=-1,angle=angle)
	else:
		face_nodes = nodes_by_face(p1,z=MAX,nz=1,angle=angle)

	edge_nodes = get_edge_nodes(face_nodes)

##	light(face_nodes)
##	raise Exception

	nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MAX),groupY=(MID,MIN))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MAX),groupY=(MID,MAX))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byx(nodes2,absolute=True)
	node_x01 = nodes3[0]

##	light(node_x01)
##	raise Exception

	nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MIN),groupY=(MID,MAX))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MIN),groupY=(MID,MIN))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byx(nodes2,absolute=True)
	node_x02 = nodes3[0]

	nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MAX),groupX=(MID,MIN))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MAX),groupX=(MID,MAX))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byy(nodes2,absolute=True)
	node_y01 = nodes3[0]

	nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MIN),groupX=(MID,MAX))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MIN),groupX=(MID,MIN))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byy(nodes2,absolute=True)
	node_y02 = nodes3[0]

	nodes = [node_x01,node_x02,node_y01,node_y02]   ## x=0: node_x01,node_x02;  y=0:node_y01,node_y02]
	light(nodes)

	if return_label == True:
		nodes = [node_x01.label, node_x02.label,node_y01.label,node_y02.label]

	return nodes

def find_edge_loop(edge,angle=10,edges=None,faces=None):
	## VER: 2016-07-28, v1.2
	## reference: find_edge_loops()

	if type_of(edge) != 'edges':
		raise Exception('*** An edge is required.')

	if is_edge_loop(edge):
		return [edge]

	if faces not in empty:
		edges = faces_to_edges(faces)

	poi = get_poi(edge)

	if len(poi.cells) == 0:
		angle = 100
		ext_edges = exterior_edges(poi)
		if edges in empty:
			edges = ext_edges
		else:
			edges = get_common(edges,ext_edges)

		if edge not in edges:
			print '*** Fail to find the edge loop'
			return []

##	print len(edges)

	if edges not in empty:
		edges = tolist(edges)
		angle = 100

	valids = [edge]
	invalids = []
	i = 0
	while True:
		i = i + 1
		edge1 = valids[-1]
		adjacents = tolist(edge1.getAdjacentEdges())

		adjacents = unselect(adjacents,invalids)
		adjacents = unselect(adjacents,valids)

		if edges not in empty:
			adjacents = get_common(adjacents,edges)

		if len(adjacents) == 1 and len(valids) == 1:  ## 第一条
			valids = valids + adjacents
			continue
		elif len(adjacents) == 0:  ## search finished
			break
		else:
			if len(poi.cells) == 0:
				valids = valids + adjacents

			else:
				find = []
				for e1 in adjacents:
					angle1 = connect_angle_of_edges(e1,edge1)
					if angle1 < angle:
						find.append(e1)
					if len(find) == 2:
						break

				if find in empty:  ## search finished
					invalids = invalids + adjacents
					break   ## break while
				else:
					valids = valids + find
					invalids = invalids + unselect(adjacents,find)

		if is_edge_loop(valids):
			break

	if not is_edge_loop(valids):
		print fnln(),'*** Fail to find the edge loop.'
		valids = []

	return valids

def same_radius(objs):
	## VER: 2016-06-29, v1.0

	objs = tolist(objs)
	same = True
	radius = get_radius(objs[0])

	if not is_number(radius):
		return False

	if len(objs) > 1:
		for i in range(len(objs))[1:]:
			obj = objs[i]
			rad = get_radius(obj)
			if not is_number(rad) or rad !=radius:
				same = False
				break

	return same

def find_edge_loops(edges,angle=10,sort='size',only_circle=False,faces=None,within=False):
	## VER: 2016-07-28, v1.5
	## sort = False, 'x', 'y', 'z','size'. if sort == True, means sort='size'
	## edges = find_edge_loops('tpunch',sort='z',only_circle=True)
	## reference: is_edge_loop()
	## reference: find_edge_loop()

	## edges = find_edge_loops('powder',faces=faces)
	# >>> edges = loop_edges('insert',sort=False)
	# >>> light(edges)

##	edges = find_edge_loops(p1,sort=False)
##	edges = find_edge_loops(p1,sort='y')

##	loops = find_edge_loops('tpunch',sort='z',only_circle=True)
##	edges = loops[0]

	if type_of(sort) == 'STR':
		sort = sort.lower()

	if sort == True:
		sort = 'size'

	poi = None
	if is_pia(edges):
		poi = check_pia(edges)
		edges = poi.edges
		if len(poi.cells) == 0:
			within = True

	edges0 = []
	edges = tolist(edges)
	if type_of(edges[0]) == 'faces':
		edges = faces_to_edges(edges)
		edges0 = edges
		within = True

	edges = exterior_edges(edges)

	if faces not in empty:
		edges0 = faces_to_edges(faces)
		edges = get_common(edges,edges0)
		within = True

##	light(edges)

##	raise Exception

	if within == False:
		newlist = []
		for edge in edges:
			if edge_shape(edge) in ['arc','circle','spline']:
				newlist.append(edge)

		if newlist not in empty:
			edges = newlist   ## refine to be non-lines if exists.

	if only_circle == True:
		newlist = []
		for edge in edges:
			if edge_shape(edge) in ['arc','circle','spline']:
				newlist.append(edge)
		edges = newlist

	i = -1
	alls = []
	valids = []

##	light(edges)
##	raise Exception

	for edge in edges:
		if len(edge.getVertices()) == 1:  ## 先把circle找出来
			valids.append([edge])
			alls.append(edge)

	edges = unselect(edges,alls)
##	if is_edge_loop(edges):  ## maybe the combination of two loops
##		alls = alls + edges
##		valids.append(edges)
##		edges = []

##	light(edges)
##	raise Exception

##	light(edges0)
##	raise Exception

	while len(edges) > 0:
		i = i + 1
		edge1 = edges[0]

		valids1 = find_edge_loop(edge1,angle=angle,edges=edges0)

		if valids1 not in empty and is_edge_loop(valids1):
			if only_circle == False:
				valids.append(valids1)
				alls = alls + valids1
			else:
				if same_radius(valids1):
					valids.append(valids1)
					alls = alls + valids1

		edges = unselect(edges,valids)
		edges = unselect(edges,valids1)
		edges = unselect(edges,edge1)

	if sort in ['x','y','z']:
		dict1 = {}
		for list0 in valids:
			space = objs_space(list0)
			if sort == 'x':
				loc = (space[0] + space[1])/2
			elif sort == 'y':
				loc = (space[2] + space[3])/2
			elif sort == 'z':
				loc = (space[4] + space[5])/2

			loc = round(loc,3)
			if loc not in dict1.keys():
				dict1[loc] = []
			dict1[loc].append(list0)

		edges = []
		for loc in _sort(dict1.keys()):  ## sort by loc first
			if len(dict1[loc]) == 1:
				edges.append(dict1[loc])
			else:
				dict2 = {}
				for list0 in dict1[loc]:
					length = edges_length(list0)
					length = round(length,3)
					if length not in dict2.keys():
						dict2[length] = []
					dict2[length].append(list0)

				for length in _sort(dict2.keys()):  ## Then sort by length
					edges = edges + dict2[length]

	elif sort == 'size':
		list1 = []
		for list0 in valids:
			length = edges_length(list0)
			length = smart_round(length)
			list1.append((length,list0))

		list2 = sort_tuple_type_elements(list1,index=0)

		edges = []
		for i in range(len(list2)):
			edges1 = list2[i][1]
			edges.append(edges1)

	if sort == False:
		result = alls
	else:
		result = edges

	print ' '
	print fnln(),len(edges),'edge loops are found.'

	return result

def find_func(*names):
	## VER: ('VER: 2016-10-11, v1.8')

	global user_functions

##>>> find_func('_set')
##---Find 52 functions by ['_SET', 'SET_'] , operator= OR
##['KP_set', '_set_float_num', 'change_part_setname', 'clear_empty_sets', 'clear_model_settings', 'contact_sets', 'create_odb_node_set', 'create_set', 'create_side_sets', 'cross_set_mat', 'current_variable_setting', 'edel_of_set',

	names = tolist(names)

	for i in range(len(names)):
		str1 = names[i]
		if type_of(str1) != 'STR':
			str1 = repr(str1)
		names[i] = str1.upper()

	if len(names) == 1:   ## search both _set and set_
		if names[0][0] == '_' and names[0][-1] != '_':
			name = names[0][1:] + '_'
			names.append(name)
			names.append('OR')

	if names[-1] not in ['AND','OR']:
		names.append('AND')

	names0 = names
	action = names[-1]
	names = names[:-1]

	if 'user_functions' not in globals().keys():
		get_user_functions()

	funcs = []

	if action == 'AND':
		for func in user_functions.values():	## 寻找真值
			func1 = func.upper()
			meet = True
			for name in names:
				if name not in func1:
					meet = False
					break
			if meet == True:
				funcs.append(func)
	elif action == 'OR':
		for func in user_functions.values():	## 寻找真值
			func1 = func.upper()
			meet = False
			for name in names:
				if name in func1:
					meet = True
					break
			if meet == True:
				funcs.append(func)

	funcs.sort()

	print '--By function name, find',len(funcs),'functions, operator=',names0[-1]
	print funcs
	print ' '

	funcs1 = []
	name1 = names[0]
	for func,labels in function_labels.items():
		labels0 = tolist(labels)  ## 防止仅仅有一个label的情形
		for label in labels0:
			if name1 in label.upper():
				funcs1.append(func)
				break

	if funcs1 not in empty:
		print '--By labels, find',len(funcs1),'functions:'
		print funcs1
		print ' '

##	print fnln(),caller_name()

	if caller_name() == 'cliCommand':
		funcs = None

	return funcs

find_function = find_func

def fn_cal_inertia(part,ndir='y',setname=None,mat=None):
	## VER: 2011-10-18, v1.3

	part = check_pias(part)
	if type_of(part) == 'PINSTANCE':
		part = part.part

	if type_of(mat) == 'STR':
		setname = mat

	cells = cell_select(part,setname=setname)
	if ndir == 'y':
		section_faces = face_select(part,y=MIN,cells=cells)
	elif ndir == 'x':
		section_faces = face_select(part,x=MIN,cells=cells)
	elif ndir == 'z':
		section_faces = face_select(part,z=MIN,cells=cells)
	section_area = get_area(section_faces)

	prop = part.getMassProperties(regions=list2sequence(section_faces))
	centroid = prop['areaCentroid']

	if centroid[0] in empty:
		raise Exception('Fail to get the area centroid.')
	else:
		x1,y1,z1 = centroid
		x1 = round(x1,3)
		y1 = round(y1,3)
		z1 = round(z1,3)

		if abs(x1) < 1e-6:
			x1 = 0
		if abs(y1) < 1e-6:
			y1=0
		if abs(z1) < 1e-6:
			z1 = 0

		centroid = [x1,y1,z1]

	unit_part = copy_part(part,'unit_part')
	move_part(unit_part,from_loc = centroid,to_loc=(0,0,0))
	unit_part = _m.parts[unit_part]

	if ndir == 'y':
		hex_cut(unit_part,y=(1,MAX))   ## must
	elif ndir == 'x':
		hex_cut(unit_part,x=(1,MAX))   ## must
	elif ndir == 'z':
		hex_cut(unit_part,z=(1,MAX))   ## must

	cells = cell_select(unit_part,setname=setname)
	prop2 = unit_part.getMassProperties(regions=list2sequence(cells))

	unit_mass = get_mass(unit_part,setname=setname)/1e6   ## ton
	density_area = unit_mass/section_area

	mass_inertia = prop2['momentOfInertia']
	mass_inertia = tolist(mass_inertia)

	print ' '
	print '**By mass inertia method:'
	print 'mass of unit_part=',unit_mass
	print 'density_area of unit_part=',density_area
	print ' '

	area_inertia = [0]*6
	for i in range(len(mass_inertia)):
		area_inertia[i] = round(mass_inertia[i]/density_area,3)

	print 'mass inertia(Jx,Jy,Jz,Jxy,Jyz,Jzx) =',mass_inertia
	print 'area inertia(Ix,Iy,Iz,Ixy,Iyz,Izx) =',area_inertia
	print 'ndir =',ndir

	print ' '
	print '**By fn_inertia_of_faces(faces):'
	inertia = fn_inertia_of_faces(section_faces)

	del_parts(unit_part)

	return

def fn_cell_temp(NOCT=45,Ta=30,irrad=800):
	## VER: 2011-06-24, v1.0
	## Ta: ampient temperature (degC), irrad: light irradiance (kw/m^2), Tc: cell temperature(estimated)

	Tc = Ta + (NOCT - 20)*irrad/800.

	return Tc

def fn_cost_down(delta_mass=None,power=300, mass0=None,mass1=None,price_ton=None,price_kg=None,price_g=None,sales=None):
	## VER: 2012-12-06, v1.3 price in RMB

	if price_ton == price_kg == None:
		price_ton = 17800

	if price_ton != None:
		price_g = price_ton/1e6
	elif price_kg != None:
		price_g = price_kg/1000

	if price_ton == None and price_g != None:
		price_tone = price_g*1e6

	if sales == None:
		sales = 1e7

	if mass0 != None and mass1 != None:
		delta_mass = mass0 - mass1

	total_mass = int(delta_mass*sales/1e6)

	if delta_mass != None:
		costDown_sales = delta_mass*sales*price_g
		costDown_sales = round(costDown_sales/1e7,2)   ## 单位：千万元

		costDown_module = delta_mass*price_g
		costDown_module = round(costDown_module,2)
	else:
		raise Exception('delta_mass or (mass0,mass1) is required for calculation.')

	us_costdown = round(costDown_module/power/6.3, 3)*100

	print ' '
	print '单个组件边框减重=',delta_mass,'g, 按照铝锭价格=',price_ton,'RMB/顿计算, 材料成本下降',costDown_module,'RMB'
	print '按组件功率power=300W算，每瓦铝材cost down=',us_costdown,'美分'
	print '按组件销量=',int(sales/10000),'万个计算，节省铝材=', total_mass,'顿, 铝材成本降低共',costDown_sales,'千万RMB'
	print ' '

	return costDown_sales

def formatted_name(list1,name):
	## VER: 2017-05-27, v1.2
	## name = formatted_name(_m.loads,name)
	## name = formatted_name(_m.constraints,name)
	## name = formatted_name(_m.predefinedFields.keys(),name)

	if type_of(list1) == 'STR':
		list1,name = name,list1

	trace = caller_trace()
	lineno = trace[-3]

	seq = get_SN(list1,2)
##	name = '_' + seq + '_' + name + '_' + str(lineno)
	name = '_' + seq + '_' + name
	name = new_key(list1,name)

	return name

def frame_weight_of_module():
	## VER: 2012-11-30, v1.1

	mass = 0
	for part in _m.parts.values():
		if 'Frame' in part.sets.keys():
			length = get_poi_length(part)
			dir1 = get_beam_dir(part)

			if dir1 == 'y':
				if 500 < length < 1000:
					mass = mass + get_mass(parts=part,setname='Frame')*2
				else:	## length > 1000 or length < 500
					mass = mass + get_mass(parts=part,setname='Frame')
			elif dir1 == 'x':
				if length < 500:
					mass = mass + get_mass(parts=part,setname='Frame')*2
				else:
					mass = mass + get_mass(parts=part,setname='Frame')

	mass = round(mass*1e3,2)	## unit: 克
	print '--->组件边框重量为',mass,'克'

	return mass

def from_to(from1=0,to=0):
	## VER: 2010-08-26,v1.0
	return to - from1

def ymin_faces(poi, x=None, z=None):

	## VER: ('VER: 2012-06-20, v1.1')	## 只要面的法线为y方向，即使该面是倾斜的，也是可以选中的。

	poi = check_pias(poi)
	faces = faces_of_cut(poi, y=MIN, x=x, z=z)   ## 可以是front的局部，用x和z参数来定义局部区域。

	return faces

##def func_dict(func=None,VER='',items=None):
##	## VER: .VER:  = {'date':'2012-11-15', 'VER':1.2}
##
##	global function_start
##
##	if type_of(func) == 'STR' and func.lower() not in user_functions:
##		VER = func
##		func = None
##
##	elif type_of(func) == 'DICT':
##		items = func
##		func = None
##
##	if func == None:
##		func = caller_name()
##
##	func = check_func(func)
##
##	date = ''
##	ver = 0
##
##	if type_of(VER) == 'STR':
##		VER = VER.upper()
##		if VER.startswith('VER:'):
##			VER = VER[4:]
##		VER = VER.strip()
##
##		loc = VER.find(',')
##		if loc != -1:
##			date = VER[:loc]
##
##			VER = VER[loc + 1:]
##
##		while True:
##			if VER[0].isdigit() == False:
##				VER = VER[1:]
##			else:
##				break
##
##		try:
##			ver = eval(VER)
##		except:
##			pass
##
##	if date != '':
##		func.VER: ['date'] = date
##
##	if type_of(ver) == 'FLOAT':
##		func.VER: ['VER'] = ver
##
##	if type_of(items) == 'DICT':
##		for key in items.keys():
##			func.VER: [key] = items[key]
##
##	time1 = time.time()
##	info1 = caller_fnln()
##	print ' '
##	print 'info1=',info1
####	lineno = caller_fnln()[1]
##	lineno = info1[1]
##	function_start[lineno] = time1
##
##	return lineno

def func_process(*lists):
	## VER: 2011-05-10, v1.0

	lists = tolist(lists)

	caller = caller_names()[-1]

	for list1 in lists:
		try:
			globals()[list1].append(caller)
		except:
			pass

	return

def function_name(variable):
	## VER: 2010-08-17, v1.0

	if type_of(variable) != 'FUNCTION':
		raise Exception('A function name variable is required. line=2562, function_name()')	## ********

	return str(variable)[10:-15] + '()'

def get_air_density(temperature=None, pressure=None):
	## VER: 2013-08-09, v1.0
	## pressure: absolut pressure of air. 单位: Pa
	## temperature: absolute temperature. 单位：degC，最后换算为K

	if pressure in empty:
		pressure = 101325

	if temperature in empty:
		temperature = 25    ## room temperature

	temperature = temperature + 273.15
	R_specific = 287.058   ## 单位：J/(kg*K)  SI单位制

	density = pressure/(R_specific*temperature)
	density = round(density,4)

	print 'density=',density
	print '--condition: pressure=',pressure, 'Pa, temperature=', temperature - 273.15, 'degC'

	return density

def get_air_conductivity(Ts=None, Tg=None):
	## VER: 2013-08-08, v1.0
	## 执行顺序，例如：

	## Tg: 气体的温度，也就是气体的环境温度，单位: degC
	## Ts: 气体与固体接触表面的温度。单位: degC

	if Ts in empty:
		Ts = 25   ## 室温

	if Tg in empty:
		Tg = Ts

	Ts = Ts + 273.15   ## 单位: K，绝对温度制
	Tg = Tg + 273.15

	Kf = 2.72e-4*pow((Tg+Ts)/2, 0.8)
	Kf = round(Kf,4)
	globals()['Kf'] = Kf

	print 'Solid temperature Ts=',Ts - 273.15,'degC'
	print 'Air thermal conductivity Kf=',Kf
	print '--'

	return Kf


def get_all_mats(poi=None):

	## VER: ('VER: 2012-07-04, v1.1')

	mats = get_mats(poi=poi)
	all_mats = []
	for inst,value in mats.items():
		for mat in value.keys():
			if mat not in all_mats:
				all_mats.append(mat)

	if len(_m.materials) < 20:
		print '--->All materials in the model:',all_mats
		print 'detail info:'
		print mats
		print ' '

	return all_mats

def get_all_treats_from_levels_list(DOE_method):
	## VER: 2013-05-08, v1.1
	## treats is local variable. treats may come from DOE_table or from levels_list

	global levels_list

	if levels_list in empty:
##		print fnln() 'DOE treats is empty.'
		return []

	treats = []  ## local variable
	if DOE_method == 'table':
		col_num = len(levels_list.values()[0])
		for i in range(col_num):
			treat = {}
			for par in levels_list.keys():
				treat[par] = levels_list[par][i]
			treats.append(treat)

	elif DOE_method == 'multiply':
		par_num = len(levels_list.keys())
		factors = levels_list.keys()

		par0 = factors[0]
		for value0 in levels_list[par0]:
			treat = {}
			treat[par0] = value0
##			print par0,'=',value0

			if par_num >=2:
				par1 = factors[1]
				for value1 in levels_list[par1]:
					treat[par1] = value1
##					print par1,'=',value1

					if par_num >=3:
						par2 = factors[2]
						for value2 in levels_list[par2]:
							treat[par2] = value2

							if par_num >=4:
								par3 = factors[3]
								for value3 in levels_list[par3]:
									treat[par3] = value3

									if par_num ==5:
										par4 = factors[4]
										for value4 in levels_list[par4]:
											treat[par4] = value4
											treats.append(eval(repr(treat)))
									elif par_num > 5:
										raise Exception('不能同时考虑6个以上的factors.')
									else:
										treats.append(eval(repr(treat)))

							else:
								treats.append(eval(repr(treat)))
					else:
##						treats.append(treat)   ## Error, 因为treat改变之后，treats的元素也跟着改变。
						treats.append(eval(repr(treat)))
##						print 'treat=',treat,',added'
##						print 'treats=',treats
##						print ' '
			else:
				treats.append(eval(repr(treat)))

	if len(treats) > 0:
		print 'DOE treats='
		myprint(treats)
##	else:
##		print fnln(),'DOE treats is empty.'

	return treats

def get_angle_of_cut_sides(cut_sides,angle_with_X=None,angle_with_Y=None,angle_with_Z=None):
	## VER: 2013-12-20, v1.0

	cut_sides = tolist(cut_sides)
	if len(cut_sides) != 2:
		raise Exception("*** cut_sides are required, such as: cut_sides=['+x','-y']")

	if cut_sides not in empty:
		for i in range(len(cut_sides)):
			side = cut_sides[i]
			side = side.lower()
			if len(side) == 1:
				cut_sides[i] = '+' + side

	cut_sides = cut_sides[0] + cut_sides[1]
	num = cut_sides.count('-')
	if num == 1:
		sign = -1
	else:
		sign = 1

	angle = get_real_input(angle_with_X,angle_with_Y,angle_with_Z)
	if angle in empty:
		raise Exception('*** rotation angle is required.')

	if 'z' in cut_sides and 'x' in cut_sides:    ## x is bigger than z, so zox
		if angle_with_X not in empty:
			angle = sign*abs(angle_with_X)
		elif angle_with_Z not in empty:
			angle = -sign*abs(angle_with_Z)
		else:
			raise Exception('*** angle from x or z is required.')

	elif 'x' in cut_sides and 'y' in cut_sides:		## y is bigger than x, so xoy
		if angle_with_Y not in empty:
			angle = sign*abs(angle_with_Y)
		elif angle_with_X not in empty:
			angle = -sign*abs(angle_with_X)
		else:
			raise Exception('*** angle from x or y is required.')

	elif 'y' in cut_sides and 'z' in cut_sides:		## y is bigger than x, so xoy
		if angle_with_Z not in empty:
			angle = sign*abs(angle_with_Z)
		elif angle_with_Y not in empty:
			angle = -sign*abs(angle_with_Y)
		else:
			raise Exception('*** angle from y or z is required.')

	return angle

def get_area(faces,x=None,y=None,z=None):
	## VER: ('2016-08-12, v1.6')

##	>>> get_area('p2top',z=MAX)
##	403.770495751793
##	>>>

	if is_poi(faces):
		poi = check_poi(faces)
		if (x,y,z) != (None,None,None):
			faces = face_select(poi,x=x,y=y,z=z)
		else:
			faces = poi.faces

	faces = tolist(faces)
	area = 0
	for face in faces:
		area = area + face.getSize(printResults=False)

	return area

def read_vars_from_model_description(refreshed=True):
	## VER: 2014-09-09, v1.3

	global _vars

	if refreshed == False:
		refresh()

	_vars={}

	info = _m.description
	info = info.strip()

	if info not in empty:
		filename = '_user_data_' + cae_file_title + '.txt'
		file1 = open(filename,'w')
		print >> file1, info
		file1.close()

		print ' '
		print 'read_vars_from_model_description() into dict _vars:'
		print info
		print ' '

		_vars = read_vars_from_file(file1=filename)

		## Don't delete
##		try:
##			execfile(filename, __main__.__dict__)
##		except:
##			print 'Failed. Please ensure the right python syntext, such as comment to begin with #'

##		_vars = read_vars_from_file(file1=filename)

##		if set_global == True:
##			for key,val in _vars.items():
##				globals()[key] = val

	else:
		print 'No user data.'

	return

def find_odb_variables():
	## VER: 2014-03-26, v1.0

	vars = odb_variables()

	stress = {}
	strain = {}
	pressure = {}
	force = {}
	displacement = {}
	temperature = {}
	flux = {}
	energy = {}

	for var in vars.keys():
		info = vars[var]
		var0 = var.lower()
		description = info['description'].lower()

		if 'stress' in description or 'stress' in 'var0':
			stress[var] = description
		if 'strain' in description:
			strain[var] = description
		if 'press' in description or 'press' in var0:
			pressure[var] = description
		if 'force' in description or 'force' in var0:
			force[var] = description
		if 'displace' in description:
			displacement[var] = description
		if 'temp' in description or 'temp' in var0:
			temperature[var] = description
		if 'flux' in description or 'flux' in var0:
			flux[var] = description
		if 'energy' in description:
			energy[var] = description

	print ' '
	print 'Stress variables:'
	myprint(stress)
	print 'Strain variables:'
	myprint(strain)
	print 'Force variables:'
	myprint(force)
	print 'Pressure variables:'
	myprint(pressure)
	print 'Energy variables:'
	myprint(energy)
	print 'Displacement variables:',displacement
	print 'Temperature variables:', temperature
	print 'Flux variables:', flux
	print ' '

	return

def find_similars(names1,names2):
	## VER: 2015-03-27, v1.0

	names1 = tolist(names1)
	names0 = []
	for name in names1:
		names0 = names0 + find_similar(name,names2)

	return names0

def find_similar(name,names):
	## VER: 2015-03-27, v1.0

	name = name.lower()
	names1 = []
	for name1 in names:
		names1.append(name1.lower())

	similar = []
	for i in range(len(names)):
		if name == names1[i]:
			similar = [names[i]]
			break

	if similar == []:
		for i in range(len(names)):
			if names1[i].startswith(name) == True:
				similar.append(names[i])

	return similar

def find_slope_edges(poi):

	## VER: ('VER: 2012-08-09, v1.0')

	poi = check_pias(poi)

	edges = []
	for i in xrange(len(poi.edges)):
		edge = poi.edges[i]
		try:
			radius = edge.getRadius()
			continue
		except:
			pass

		try:
			curvature = edge.getCurvature(edge.pointOn[0])
			continue
		except:
			pass

		xlocs = []
		ylocs = []
		zlocs = []

		for index in edge.getVertices():
			x0,y0,z0 = poi.vertices[index].pointOn[0]
			if x0 not in xlocs:
				xlocs.append(x0)
			if y0 not in ylocs:
				ylocs.append(y0)
			if z0 not in zlocs:
				zlocs.append(z0)

		if len(xlocs) + len(ylocs) + len(zlocs) >= 5:
			edges.append(edge)

	print '--->',len(edges),'slope edges are found'

	return edges

def find_slope_faces(poi,exterior=True,nx=None,ny=None,nz=None,mat=None,ndir='slope'):

	## VER: ('VER: 2012-08-09, v1.0')	## ndir纯粹属于兼容性参数，无用。

	poi = check_pias(poi)
	if ndir != 'slope':
		raise Exception('ndir should be slope')

##	if type_of(mat) == 'STR':
##		cells = set2objs(poi,mat)
##		faces0 = faces_of_cells(cells)
##	else:
##		faces0 = poi.faces

	faces = []
	for i in xrange(len(poi.faces)):
		face = poi.faces[i]
##	for face in poi.faces:
		try:
			radius = face.getRadius()
			continue
		except:
			pass

		try:
			curvature = face.getCurvature(face.pointOn[0])
			continue
		except:
			pass

		try:
			normal = face.getNormal()
		except:
			continue

		normal = list(normal)
		if normal.count(0) != 2:
			faces.append(face)

	faces = check_facing_dir(faces,exterior=exterior, nx=nx, ny=ny, nz=nz)

	if type_of(mat) == 'STR':
		mat_cells = set2objs(poi,mat)
		new_list = []
		for face in faces:
			indexs = face.getCells()
			for index in indexs:
				cell = poi.cells[index]
				if cell in mat_cells:
					new_list.append(face)
					continue

		faces = new_list

	print '--->',len(faces),'slope faces are found'

	return faces

def fine_display(quality=EXTRA_FINE):
	## VER: 2014-08-14, v1.3
	## it will be the same result in assembly view.

	refresh()
	vpnow = get_vpnow()
	dpo = vpnow.displayedObject

	quality = totext(quality)
	quality = quality.upper()
	if 'ULTRA' in quality or 'BEST' in quality:
		quality = 'EXTRA_FINE'

	if quality not in ['EXTRA_FINE','FINE']:
		quality = 'EXTRA_FINE'
	quality = eval(quality)

	if type_of(dpo) in ['PART','ASSEMBLY']:
		pois = objs_of_dg()
		insts = real_insts(pois)
		parts = parts_of_insts(insts)
		if parts in empty:
			parts = real_parts(pois)
		if parts in empty:
			parts = _m.parts.values()

		for part in parts:
			part.setValues(geometryRefinement=EXTRA_FINE)
	elif type_of(dpo) == 'ODB':
		vpnow.odbDisplay.basicOptions.setValues(curveRefinementLevel=FINE)

	plot(dpo)

	return quality

def fix_can_rotate(name,faces,ndir=None):
	## VER: 2013-04-06, v1.0

	global options, BCs, BC_status

	if type_of(name) != 'STR':
		raise Exception('**** BC name is required.')

	_lineno = lineno_and_codes()[-2]
	seq = get_SN(_m.boundaryConditions,2)
	name = '_' + seq + '_' + name + '_' + str(_lineno)
	name = new_key(_m.boundaryConditions,name)

	if BC_status.keys() in empty:
		BC_status_initiate()
##		for inst in a.instances.keys():
##			if inst not in BC_status.keys():
##				BC_status[inst] = {}

	if type_of(faces) == 'STR':
		faces = set2objs(faces)

	faces = tolist(faces)
	region = list2region(faces=faces,region_type='set')
##	names = poi_names(faces)
##	print 'poi_names=',names

	if type_of(ndir) == 'STR':
		ndir = ndir.lower()
		if ndir not in ['x','y','z']:
			raise Exception('**** ndir should be x,y,or z')

	else:
		ndir = face_ndir(faces[0])

	if ndir == 'x':
		_m.DisplacementBC(amplitude=UNSET, createStepName='Initial', distributionType=UNIFORM,
			fieldName='', localCsys=None, name=name, region=region,
		    u1=SET, u2=UNSET, u3=UNSET, ur1=UNSET, ur2=SET, ur3=SET)   ## no rotate. if want to modify the value, further to do that in other step.
	elif ndir == 'y':
		_m.DisplacementBC(amplitude=UNSET, createStepName='Initial', distributionType=UNIFORM,
			fieldName='', localCsys=None, name=name, region=region,
		    u1=UNSET, u2=SET, u3=UNSET, ur1=SET, ur2=UNSET, ur3=SET)   ## no rotate. if want to modify the value, further to do that in other step.
	elif ndir == 'z':
		_m.DisplacementBC(amplitude=UNSET, createStepName='Initial', distributionType=UNIFORM,
			fieldName='', localCsys=None, name=name, region=region,
		    u1=UNSET, u2=UNSET, u3=SET,ur1=SET, ur2=SET, ur3=UNSET)   ## no rotate. if want to modify the value, further to do that in other step.

	return name

def fix_no_rotate(name,faces,ndir=None):
	## VER: 2013-04-06, v1.0

	global options, BCs, BC_status

	if type_of(name) != 'STR':
		raise Exception('**** BC name is required.')

	_lineno = lineno_and_codes()[-2]
	seq = get_SN(_m.boundaryConditions,2)
	name = '_' + seq + '_' + name + '_' + str(_lineno)
	name = new_key(_m.boundaryConditions,name)

##	if BC_status.keys() in empty:
##		for inst in a.instances.keys():
##			if inst not in BC_status.keys():
##				BC_status[inst] = {}

	if type_of(faces) == 'STR':
		faces = set2objs(faces)

	faces = tolist(faces)
	region = list2region(faces=faces,region_type='set')

	if type_of(ndir) == 'STR':
		ndir = ndir.lower()
		if ndir not in ['x','y','z']:
			raise Exception('**** ndir should be x,y,or z')

	else:
		ndir = face_ndir(faces[0])

	if ndir == 'x':
		_m.DisplacementBC(amplitude=UNSET, createStepName='step1', distributionType=UNIFORM,
			fieldName='', localCsys=None, name=name, region=region, u1=SET, u2=UNSET, u3=UNSET, ur1=SET, ur2=SET, ur3=SET)   ## no rotate. if want to modify the value, further to do that in other step.

	elif ndir == 'y':
		_m.DisplacementBC(amplitude=UNSET, createStepName='step1', distributionType=UNIFORM,
			fieldName='', localCsys=None, name=name, region=region,
		    u1=UNSET, u2=SET, u3=UNSET, ur1=SET, ur2=SET, ur3=SET)   ## no rotate. if want to modify the value, further to do that in other step.

	elif ndir == 'z':
		_m.DisplacementBC(amplitude=UNSET, createStepName='step1', distributionType=UNIFORM,
			fieldName='', localCsys=None, name=name, region=region,
		    u1=UNSET, u2=UNSET, u3=SET,ur1=SET, ur2=SET, ur3=SET)   ## no rotate. if want to modify the value, further to do that in other step.

	add_BC_status(faces,name,DOFs=ndir)

	return name

def fn_bolt_load(Mt,D=12,kt=0.2):
	## VER: 2011-05-11, v1.0. Mt: 拧紧力矩(N.m)(tighten torque)  D: 罗纹公称直径(即罗纹的外径，mm)  kt: 拧紧力矩因子

	D = D/1000.
	F = Mt/(kt*D)
##	F = Mt/(1.1*kt*D)
	F = int(round(F/1000.))   ## kN

	stress = F*1000/(3.14159265*D*D/4)
	stress = int(stress/1e6)

	print 'boltload F =',F,'kN'
	print 'stress=',stress,'MPa, stress/0.6=',int(round(stress/0.6)),'MPa'
	print 'Note: 4.8 yield strength = 320MPa, 8.8 yield strength = 640MPa'
	print ' '

	return F,stress

def get_bulk_modulus(elastic_modulus,poisson=0.3):
	## VER: 2015-04-08, v1.0
	## bulk modulus decrease with decreased poisson's ratio

##	>>> get_bulk_modulus(583, 0.25)
##	388.67
##	>>> get_bulk_modulus(583, 0.24)
##	373.72
##	>>> get_bulk_modulus(583, 0.23)
##	359.88
##	>>> get_bulk_modulus(583, 0.22)
##	347.02
##	>>>

	bulk = elastic_modulus / (3*(1-2*poisson))
	bulk = smart_round(bulk)

	return bulk

def get_cae_file_title():
	## VER: ('VER: 2013-06-10, v1.2')  No .cae

	global cae_file_title

	path = mdb.pathName
	loc1 = path.rfind('\\')

	title = path[loc1 + 1:]
	if title == '<unnamed>':
		title = 'unnamed'
	else:
		title = title[:-4]

	cae_file_title = title
##	print fnln_fnln(),'--->title=',title, ", so cae_file = title + '.cae'"

	return title

def get_caller_code():
	## VER: 2017-08-15, v1.4

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

	trace = get_traceback(instance_list=True)
##	print 'trace=',trace
	trace0 = trace[2]	;please_check	;changing ## ## save_user_data(jobnum)  ## correct
##	trace0 = trace[1]	## 	blank_cae(analysis1_title)
##	trace0 = trace[0]  	## eval(funcs[0])()
	caller_file = trace0.filename
##	print 'lineno=',trace0.command_lineno - 1

##	print 'caller_file=',caller_file
	if 'abaqusCliCommand.py' in caller_file:
		code = trace0.locals['text']
##		print '***code1=',code1
	else:
		code = get_line_code(trace0.command_lineno - 1,py_file=caller_file)

##	print 'caller code=',code

##	print ' '
##	prettyPrint(trace,3)
##
##	frame = ''
##	for i in range(len(trace)):
##		if trace[i].final_command == 'get_caller_code':
##			frame = trace[i-1]
##
##	if frame in empty:
##		raise Exception('**** Fail to get the frame file.')
##
##	caller_file = frame.filename
##	print fnln(),'caller_file=',caller_file
##	caller_file = search_file(caller_file)
####	print fnln(),'caller_file=',file1
####	raise Exception
##
##	if '.py' in caller_file:
##		code = get_line_code(frame.command_lineno - 1,py_file=caller_file)
##	else:
##		code = frame.co_names

	code = modify_string(code,' ')

	return code

def caller_name():
	## VER: 2014-03-31, v1.4
	## 如果是在命令窗口中执行命令，则caller_name='cliCommand'

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

##	try:
##		raise Exception
##	except:
##		frame = sys.exc_info()[2].tb_frame.f_back.f_back
##		func = frame.f_code.co_name
##		if func == '?':
##			func = '<module>'

	## common structure, copy to such as: fnln(),caller_fnln(),caller_name(),
	info = get_traceback()
	info = info[:-2]
	if len(info) >= 4:
		info = info[-4:]

	if info[0] == '<module>' and info[1] == 1:
		info[0] = 'cliCommand'

	## End of common structure

	func = info[0]

	return func

def caller_lineno():
	## VER: 2014-03-31, v1.1

	## common structure, copy to such as: fnln(),caller_fnln(),caller_name(),
	info = get_traceback()
	info = info[:-2]
	if len(info) >= 4:
		info = info[-4:]

	if info[0] == '<module>' and info[1] == 1:
		info[0] = 'cliCommand'

	## End of common structure

	lineno = info[1]

	return lineno


def caller_names():
	## VER: 2011-05-07, v1.0
	## 例如：['__main__', 'main', 'create_contacts', 'create_module_contacts', 'find_contacts', 's2s_interact_std']

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

	history = get_traceback()
	history = history[:-4]

	functions = []
	for item in history:
		if type_of(item) == 'STR' and item in globals().keys():
			functions.append(item)

	return functions

def get_traceback(instance_list=False,collect_code=False,overwrite=True,warn=None,level=10):
	##  Note: this command will raise one error if overwrite=True (default); the previous error trace will be overwritten.
	## VER: {'date':'2013-04-01', 'VER':2.6}		## 该函数只能在某个函数中被调用，并将获得该函数的函数名和调用时的行号。
	## Note: collect_code = True will lead to slower time to build the model.

	## 结果最后一个行号为get_called_trace的调用语句的所在行号。
	## 结果形式：['<module>', 18283, 'main', 18038, 's2s_tie', 14882, 's2s_contact_std', 14782]
	## 在代码中打印traceback: print get_traceback()
	## print_traceback()用于出错之后在命令框中输出错误的调用记录。

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

	## 注意当前行所在的行号和所在的函数名就保存在get_traceback[-2:]中

	## 如果是GUI菜单按钮调用，则结果仅仅为 [被调用函数名,get_traceback()所在的行号]

	global _trace_path, _trace_objs

	if overwrite == False:
		if '_trace_path' in globals().keys() and '_trace_objs' in globals().keys():
			if instance_list == True:
				return _trace_objs
			else:
				return _trace_path

	if warn not in empty:
		instance_list = False
		print ' '
		print '★★★Warning: ' + warn

	try:
		raise Exception		## 故意制造一个错误
	except:
##		print ' '
##		print '=====================collecting history...'
		info = []
##		frame = sys.exc_info()[2].tb_frame.f_back	## 不包含本函数信息，仅包含到get_traceback()命令语句所在行的信息。
		frame = sys.exc_info()[2].tb_frame   			## 包含到本函数信息，即command_lineno = frame.f_lineno所在行信息。

		file_name = frame.f_code.co_filename
		frame_name = frame.f_code.co_name

		firstlineno = frame.f_code.co_firstlineno

		command_lineno = frame.f_lineno
		if frame_name == '?':
			frame_name = '<module>'

		line_info = Codeline()   ## 生成类的实例
		line_info.filename = file_name     ##e.g., 'C:/Temp/utest.py'
		line_info.frame_name = frame_name
		line_info.command_lineno = command_lineno
		line_info.firstlineno = firstlineno
		line_info.frame = frame

		changing
##		print 'frame_name=',frame_name  ## 始终等于frame_name=get_traceback ?
		if frame_name != '<module>':
			line_info.locals = frame.f_locals
			line_info.frame_type = 'FUNCTION'
		else:
			line_info.locals = {}
			line_info.frame_type = 'MODULE'

		conames = list(frame.f_code.co_names)
		if len(conames) > 10:
			conames = conames[:10] + ['......']
		line_info.co_names = repr(conames)

		if collect_code == True:
			command_code = get_line_code(command_lineno,py_file=file_name)
		else:
			command_code = 'line code not collected due to collect_code = False'
		line_info.command_code = command_code

		info.append(line_info)
##		print 'file_name=',file_name

		while True:
			frame = frame.f_back

			if frame.f_back == None:
				break

			file_name = frame.f_code.co_filename
			frame_name = frame.f_code.co_name
			firstlineno = frame.f_code.co_firstlineno
			command_lineno = frame.f_lineno

			infunc0 = frame_name
			if frame_name == '?':
				frame_name = '<module>'

			line_info = Codeline()  ## 每一个新的实例都要先实例化。类似于line_func = {}
			line_info.filename = file_name
			line_info.frame_name = frame_name
			line_info.command_lineno = command_lineno
			line_info.firstlineno = firstlineno
			line_info.frame = frame

			if frame_name != '<module>':
				line_info.locals = frame.f_locals
				line_info.frame_type = 'FUNCTION'
			else:
				line_info.locals = {}
				line_info.frame_type = 'MODULE'

			conames = list(frame.f_code.co_names)
			if len(conames) > 10:
				conames = conames[:10] + ['......']
			line_info.co_names = repr(conames)

			if collect_code == True:
				command_code = get_line_code(command_lineno,py_file=file_name)
			else:
				command_code = 'line code not collected due to collect_code = False'

			line_info.command_code = command_code
			info.append(line_info)

	info.reverse()   ## 倒数：奇数为行号，偶数为函数名。

	for i in range(len(info) - 1):
		info[i].final_command = info[i+1].frame_name

	info.pop()  ##  Remove the last one (without the property 'final_command'

##	prettyPrint(info,3)
	_trace_objs = info
	_trace_path = call_line_history(info)

	info1 = _trace_objs
	if instance_list == False:
		info1 = _trace_path

	return  info1

def get_cell_edge_in_dir(cell,dir='x'):
	## VER: 2013-07-25, v1.0

	if type_of(face) != 'cells':
		raise Exception('*** one cell is required.')

	edges = edges_of_cells(cell)

	edge0 = None
	edges0 = []
	for edge in edges:
		angle = get_intersect_angle(edge,axis=dir)
		if angle == 0:
			edge0 = edge
			break
		elif angle < 45:
			edges0.append([angle,edge])

	if edge0 == None:
		if edges0 in empty:
			raise Exception('*** Fail to get the edge in ' + repr(dir) + ' for the cell.')

		edges0 = sort_tuple_type_elements(edges0,index=0)
		edge0 = edges0[0][1]

	return edge0

def get_cells_insts():
	## VER: 2014-11-19, v1.0

	insts = []
	for inst in a.instances.values():
		if len(inst.cells) > 0:
			insts.append(inst)

	return insts

def get_circle_center(circle):
	## VER: 2014-09-10, v1.1

##>>> get_circle_center(_sketch('sk_ejector').geometry.values()[-1])
##(0.0, 5.0)
##>>>

	if 'circle' not in type_of(circle) and 'arc' not in type_of(circle):
		raise Exception('*** circle geometry is required.')

	vertices = circle.getVertices()
	loc = vertices[-1].coords   ## 圆心是最后一个点。

	return loc

get_arc_center = get_circle_center

def get_common(*lists):
	## VER: 2011-05-05, v1.2

	lists = tolist(lists)

	if len(lists) == 1:
		raise Exception('******At least two lists/strings are required.')

	for i in range(len(lists)):
		if type_of(lists[i]) == 'STR':
			lists[i] = lists[i].split()

	elements = []
	for list1 in lists:
		for item in list1:
			if item not in elements:
				elements.append(item)

	common = []
	for item in elements:
		Found = 0
		for list1 in lists:
			if item in list1:
				Found += 1

		if Found == len(lists):
			common.append(item)

	## for minitab
##	print ' '
##	print 'Input factors=',elements
##	print 'Common factors=',common
##	print ' '

	return common

def get_constraint_type(name):
	## VER: 2013-06-14, v1.0

	type1 = 'NA'
	if name in _m.constraints.keys():
		doc = _m.constraints[name].__doc__
		loc = doc.find(' ->')
		if loc > 0:
			type1 = doc[:loc].lower()

	return type1

def get_vpnow():
	## VER: 2014-02-28, v1.1
	## 10.23: get_vpnow()不会使密度结果消失。

##	global _m, a
##
##	if len(mdb.models) == 1:
##		_m = mdb.models.values()[0]
##		a = _m.rootAssembly

	return session.viewports[session.currentViewportName]

def get_current_leaf():
	## VER: 2014-03-28, v1.1
	## display all: leaf = dgo.Leaf(leafType=DEFAULT_MODEL)

	dg = dg_now()
	leaf = dg['leaf']

	return leaf

def get_current_model(vpnow=None,global_var=False):
	## VER: 2014-09-13, v1.6
	## 如果增加或减少了模型的part,instance, sketches之前及之后不及时运行get_current_model()，可能会非正常退出。
	## 在这种情况下，如果不运行get_current_model()，则较省事的办法是声明 global _m, a

	## 一个cae可以有很多个model, current model是指active model。但active model不一定显示在viewport中。
	## 如果current viewport属于mdb viewport: 则可知current model
	## 如果有多个mdb viewport在打开且对应不同的model，但都不是current viewport，那么current model是什么？

	global current_model_name, _m, a, odb, oa, scratchOdb

	if vpnow in empty:
		vpnow = get_vpnow()
	else:
		viewport_type, vpnow = check_viewport(vpnow)

	dpo = vpnow.displayedObject
##	print fnln(),'dpo=',dpo

	name = None
	if len(session.sessionState.keys()) == 1:   ## session.sessionState.keys() is the viewport names
		name = session.sessionState.values()[0]['modelName']

	else:
##		vpnow = get_vpnow()
##		dpo = vpnow.displayedObject
		if type_of(dpo) in ['PART','ASSEMBLY','sketch']:  ## current viewport is a mdb viewport
			name = get_parent(dpo).name

		else:
			for vp in session.sessionState.keys():
				if vp == vpnow.name:
					name = session.sessionState[vp]['modelName']
					break
					## 虽然current viewport不是mdb viewport，但current model为：
					## 在该viewport中，切换到assembly或part模块时所处的model

	if name in empty:
		raise Exception('*** Fail to get current_model_name for current viewport.')

##	setting_display()

	current_model_name = name
	_m = mdb.models[name]
	a = _m.rootAssembly
	a.unlock()
	a.regenerate()

##	dpo = get_dpo()
	if type_of(dpo) == 'ODB':
		odb = dpo
		oa = odb.rootAssembly
		scratchOdb = session.ScratchOdb(odb)

##	if dpo == None:
##		vpnow.setValues(displayedObject=a)

##	if type_of(dpo) in ['PART','ASSEMBLY','sketch']:  ## current viewport is a mdb viewport
	for part in _m.parts.values():
		try:
			part.unlock()
		except:
			pass
		part.regenerate()

##	a.unlock()
##	a.regenerate()

##		if type_of(dpo) in ['ASSEMBLY','PART']:
##			create_csys(a,loc=(0,0,0))


	get_cae_file_title()

	callers = caller_names()
	if callers[:2] == ['cliCommand', 'refresh']:
		print fnln12(), 'Current model name=',name
		print fnln12(),'cae file=',cae_file_title + '.cae'

	return name

def get_curvature(obj,pointOn=None,par=None):
	## VER: ('VER: 2013-12-11,v1.5')   ## parameter应该在0~1之间。
	## get_radius(3 points) -> RC_shape(one point)

## 也可以用part.getCurvature(list2sequence(obj))来获得curvature，此时，结果如下：
##	For an arc, the curvature is constant over the entire edge(arc是一个圆的一部分，即圆弧）, and equal to the inverse of the radius. 是半径的倒数，如：radius=2.5，则curvature=0.4
##	For a straight line, the curvature is constant and equal to 0.
## For a spline edge, the curvature varies over a range, and this methods computes the maximum.（该maximum可能为0)

##>>> edge.getCurvature(edge.pointOn[0])	## 有半径，但是只是代表改点处的半径，不代表该曲线就一定是圆形的。
##{'tangent': (-0.70710678118654, -0.707106781186555, -0.0), 'evaluationPoint': (469.582233047034, 1.76776695296634, -27.8), 'radius': 2.5, 'curvature': (0.282842712474622, -0.282842712474616, 0.0)}

##>>> get_curvature(e1,pointOn=(63.567694, 426.612388, 44.105148))
##{'tangent': (0.072827184316877, -0.727074880892728, 0.682684640811042), 'evaluationPoint': (63.5676946551372, 426.612388261358, 44.1051482084637), 'radius': 60.5816926820255, 'curvature': (0.00146376919200282, -0.0111761586668492, -0.0120590180709216)}
##>>>

	if type_of(obj) not in ['edges','faces']:
		raise Exception('******An edge or face is required.')

	if type_of(pointOn) == 'vertices':
		point = pointOn
		pointOn = point.pointOn[0]

	if type_of(par) in numerics and type_of(obj) != 'edges':
		raise Exception('edge object is required.')

	if par in empty and pointOn in empty:
		pointOn = obj.pointOn[0]

	please_check
	curvature = None  ##平面的curvature=None，也就是完全度=0
	## 对于edge, 只要在任意一点求曲率失败，就说明该edge是直线。(??)
	if pointOn not in empty:
		try:
			curvature = obj.getCurvature(point=pointOn)	## radius = curvature['radius']
		except:
			pass
	else:
		try:
			curvature = obj.getCurvature(parameter=par)	## not applicable for a straight line ## radius = curvature['radius']
		except:
			pass

	return curvature

def get_cutting_section(pass_point1=(),cut_sides=['+y','+x'], angle_with_X=None,angle_with_Y=None,angle_with_Z=None,x=None,y=None,z=None):
	## VER: 2013-05-25, v1.0. 角度可正可负，含义不同。正表示为逆时针方向，负表示顺时针方向。
	## 获得一个倾斜的巨大的平行四边形。

##	if pass_point1 in empty:
##		if type_of(x) not in numerics:
##			x = 0
##		if type_of(y) not in numerics:
##			y = 0
##		if type_of(z) not in numerics:
##			z = 0
##		pass_point1 = x,y,z

##	x0,y0,z0 = pass_point1

	if type_of(x) in numerics and y in empty and z in empty:
		x0 = x
	elif type_of(y) in numerics and z in empty and x in empty:
		y0 = y
	elif type_of(z) in numerics and x in empty and y in empty:
		z0 = z

	span = _scale - 100

	Min = -span
	Max = span

	cut_sides = tolist(cut_sides)
	for i in range(len(cut_sides)):
		side = cut_sides[i]
		side = side.lower()
		if len(side) == 1:
			side = '+' + side
		cut_sides[i ] =side

	angle_with_X, angle_with_Y, angle_with_Z = get_real_angle(angle_with_X,angle_with_Y,angle_with_Z)

	## 由列表改为字符串。
	if len(cut_sides) == 2:
		## 排序
		if cut_sides[0][1] > cut_sides[1][1]:
			cut_sides = [cut_sides[1], cut_sides[0]]
		sides =  cut_sides[0] + cut_sides[1]

	else:
		sides = cut_sides[0]

	if len(cut_sides) == 2:
		sketch_plane = sides[1] + sides[3]

		if sides in ['+x-y','-x+y','+y-z','-y+z','+x+z','-x-z']:
			quarter = 13
		else:
			quarter = 24

		if sketch_plane == 'xy':
			if angle_with_X in empty and angle_with_Y in empty:
				raise Exception('**** angle angle_with_X or angle_with_Y is required.')

			if type_of(angle_with_Y) in numerics:
				angle_with_X = 90 - angle_with_Y

			x1,x2 = x0 - span, x0 + span
			y1 = y0 - span*tan(angle_with_X*pi/180)
			y2 = y0 + span*tan(angle_with_X*pi/180)

			## quarter to determine point1 and point2
			if quarter == 13:            ## 1,3象限
				point1 = x1, y1, -span
				point2 = x2, y2, -span
			else:   				      ## 2,4象限, point1, point2安装x来排序。
				point1 = x1, y2, -span
				point2 = x2, y1, -span

			## sides to determin point3 and point4
			if sides == '+x-y':
				point3 = point2[0] + span, point2[1], point2[2]
				point4 = point1[0] + span, point1[1], point1[2]
			else:
				point3 = point2[0] - span, point2[1], point2[2]
				point4 = point1[0] - span, point1[1], point1[2]

		elif sketch_plane == 'yz':
			if angle_with_Y in empty and angle_with_Z in empty:
				raise Exception('**** angle angle_with_Y or angle_with_Z is required.')

			if type_of(angle_with_Z) in numerics:
				angle_with_Y = 90 - angle_with_Z

			y1,y2 = y0 - span, y0 + span
			z1 = z0 - span*tan(angle_with_Y*pi/180)
			z2 = z0 + span*tan(angle_with_Y*pi/180)

			## quarter to determine point1 and point2
			if quarter == 13:             ## 1,3象限
				point1 = -span, y1, z1
				point2 = -span, y2, z2

			else:  				      ## 2,4象限, point1, point2安装y来排序。
				point1 = -span, y1, z2
				point2 = -span, y2, z1

			## sides to determin point3 and point4
			if sides == '+y-z':
				point3 = point2[0], point2[1] + span, point2[2]
				point4 = point1[0], point1[1] + span, point1[2]
			else:
				point3 = point2[0], point2[1] - span, point2[2]
				point4 = point1[0], point1[1] - span, point1[2]

		elif sketch_plane == 'xz':
			if angle_with_X in empty and angle_with_Z in empty:
				raise Exception('**** angle angle_with_X or angle_with_Z is required.')

			if type_of(angle_with_Z) in numerics:
				angle_with_X = 90 - angle_with_Z

			x1,x2 = x0 - span, x0 + span
			z1 = z0 + span*tan(angle_with_X*pi/180)   ## 方向相反，所以加减相反。
			z2 = z0 - span*tan(angle_with_X*pi/180)

			## quarter to determine point1 and point2
			if quarter == 13:           ## 1,3象限
				point1 = x1, -span, z1
				point2 = x2, -span, z2

			else:   				      ## 2,4象限, point1, point2安装x来排序。
				point1 = x1, -span, z2
				point2 = x2, -span, z1

			## sides to determin point3 and point4
			if sides == '+x+z':
				point3 = point2[0] + span, point2[1], point2[2]
				point4 = point1[0] + span, point1[1], point1[2]
			else:
				point3 = point2[0] - span, point2[1], point2[2]
				point4 = point1[0] - span, point1[1], point1[2]

		if 'x' not in sketch_plane:
			ndir = 'x'
		elif 'y' not in sketch_plane:
			ndir = 'y'
		elif 'z' not in sketch_plane:
			ndir = 'z'

	elif len(cut_sides) == 1:
		print fnln_fnln(),'cut_sides=',cut_sides
		print fnln_fnln(),'sides=',sides
##		raise Exception
		if sides[1] == 'x':
##			sketch_plane = 'xy'   ## ndir = z, z的值都为-span, 变化y
			point1 = x0, Min, Min
			point2 = x0, Max, Min
			ndir = 'z'

		elif sides[1] == 'y':
##			sketch_plane = 'yz'  ## ndir = x, x的值都为-span
			point1 = Min,y0,Min
			point2 = Min,y0,Max
			ndir = 'x'

		elif sides[1] == 'z':
			## __|__x   |=z
			ndir = 'y'
			y1 = y2 = y3 = y4 = Min
			z1 = z2 = z0
			if sides == '+z':
				z3 = z4 = Max
			else:
				z3 = z4 = Min
			x1 = x4 = Min
			x2 = x3 = Max

			point1 = x1,y1,z1
			point2 = x2,y2,z2
			point3 = x3,y3,z3
			point4 = x4,y4,z4

##			sketch_plane = 'yz'		## ndir = x, x的值都为-span
##			point1 = Min, Min, z0
##			point2 = Min, Max, z0
##			ndir = 'x'

#			if sides == '+z':


##		point1 = tolist(point1)
##		point2 = tolist(point2)
##		point3 = copy.deepcopy(point2)   ## 一定要用deepcopy，否则错误。
##		point4 = copy.deepcopy(point1)
##
##		if '+x' in sides:
##			point3[0] = point3[0] + span
##			point4[0] = point4[0] + span
##
##		elif '-x' in sides:
##			point3[0] = -span
##			point4[0] = -span
##
##		elif '+y' in sides:
##			point3[1] = point3[1] + span
##			point4[1] = point4[1] + span
##
##		elif '-y' in sides:
##			point3[1] = point3[1] - span
##			point4[1] = point4[1] - span
##
##		elif '+z' in sides:
##			point3[2] = Max
##			point4[2] = Max
##
##		elif '-z' in sides:
##			point3[2] = Min
##			point4[2] = Min
##
##	point1 = totuple(point1)
##	point2 = totuple(point2)
##	point3 = totuple(point3)
##	point4 = totuple(point4)

	points = (point1, point2, point3, point4)
##	print fnln_fnln(),points
##	stop1()


	offset = Min

	return points, ndir, offset

function_labels['get_cylindrical_mate_face'] = 'pair','interact','side2','circular','mate'
def get_cylindrical_mate_face(face1,inst2):
	## VER: 2017-08-04, v1.0  获得共轴的圆柱面（凹凸匹配)

	## case_A1被pin_A1和pin_A2挖了两个孔。
##	sfaces = face_select(pin_A1,shape='cylindrical')
##	mfaces = get_cylindrical_mate_face(sfaces,inst2=mid_A1)
##	s2s_tie('pin1_mid',mfaces=mfaces,sfaces=sfaces)
##
##	sfaces = face_select(pin_A1,shape='cylindrical')
##	mfaces = get_cylindrical_mate_face(sfaces,inst2=case_A1)
##	s2s_tie('pin1_case',mfaces=mfaces,sfaces=sfaces)

	face1 = tolist(face1)[0]
	shape1 = face_shape(face1)
	if shape1 not in ['cylindrical','conical']:
		raise Exception('*** Fail to get the axis of the face1.')

	center,vector,datum = center_axis_of_cylind_face(face1)
	center_vector1 = (center,vector)

##	print fnln(),center_vector1
##	raise Exception

	inst2 = check_inst(inst2)
	av1 = AV_shape(face1)
	if av1 == 'n':
		av2 = 'u'
	elif av1 == 'u':
		av2 = 'n'
	else:
		raise Exception('*** Error AV_shape')

##	print fnln(),'vector=',vector
##	raise Exception

	faces2 = face_select(inst2,ndir='cylindrical',ao_tu=av2,center_vector=center_vector1)

	return faces2

def get_datum_pointOn(poa,name):
	## 2011-05-15, v1.0

	if type_of(name) in ['PART','PINSTANCE','ASSEMBLY']:
		poa,name = name,poa

	poa = check_pias(poa)
	if type_of(poa) == 'PINSTANCE':
		poa = a

	id = get_feature_id(poa,name)

	if id not in poa.datums.keys():
		raise Exception('******name= ' + name + ' is not valid datum type(point,axis,plane,csys), but other type of feature.')
	else:
		loc = poa.datums[id].pointOn
		return loc

	return

def fn_delta_T(thick,K,Q1='',A1=1,J='',q='',Tw1='',Tw2='',Tair='',h='',A2=1):
	## 2010-09-16, v1.2, heat flow from wall1 to wall2 to air2
	## del_T = Tw1 - Tw2

	thick0 = thick
	Tw10 = Tw1
	Tw20 = Tw2

	if thick > 1:
		thick = thick/1000.  ## unit: m
	r1 = thick/K
	try:
		r2 = 1.0/h
	except:
		pass

	r_total = ''
	try:
		r_total = r1 + r2
	except:
		pass

	try:
		del_T = (Tw1 - Tair)*r1/r_total
	except:
		if q != '':
			J = q

		if J == '':
			try:
				J = Q1/A1
			except:
				raise Exception('Q1 and A1 is required, if J is unknown.')	## **********
		try:
			del_T = J*r1
		except:
			del_T = ''

	if del_T != '':
		del_T = round(del_T,1)

		try:
			Tw2 = Tw1 - del_T
		except:
			try:
				J2 = J*A1/A2
				Tw2 = Tair + J2/h
			except:
				pass

	print 'Conditions:'
	print 'Resistor1(conductor): A1=',A1,'m^2, thick=',thick0,'mm, K=',K, 'W/(m.K)'
	print '     Q1=',Q1,'W, J=',J,'W/m^2, Tw1=',Tw10,'degC, Tw2=',Tw20,'degC'
	print 'Resistor2(air): A2=',A2,'m^2, h=',h,'W/(m^2.K)'
	print '     Tw2=',Tw20,'degC, Tair=',Tair,'degC'
	print '--->Results: △T=',del_T,'degC, Tw2=',Tw2,'degC'
	print ' '

	return

def get_decimal_num(value, width=4):
	## VER: 2017-10-26, v1.8   To know which location for round
	## reference: get_amplitude().

##	>>> get_magnitude(0.0575204268097878)
##	-2
##	>>>

#>>> get_magnitude(0.2) ##小数点1位
#-1
#>>>

##>>> get_magnitude(5)  ## 各位
##1
##>>>

##>>> get_magnitude(0)
##0
##>>>
	if 'NUMPY' in type_of(value):
		value = eval(str(value))

##	if type_of(value) == 'NUMPY.FLOAT32':
##		value = eval(repr(value))

	if type_of(value) not in numerics:
		print 'value=',repr(value)
		print 'type=',type_of(value)
		raise Exception('*** A float number is required.')

	mag = get_magnitude(value)   ##
##	print fnln_fnln(),'value=',value
##	print fnln_fnln(),'mag=',mag

	if mag == 1:   ##个位数
		num = 4
	elif mag == 2: ## 十位数
		num = 3
	elif mag == 3:
		num = 2
	elif mag == 4:
		num = 1
	elif mag >= 5:
		num = 0
	elif mag == 0:   ## 说明该数为0
		num = 4
	elif mag < 0:   ## mag=-2表示在0.01位上有非零数字
		num = abs(mag) + width - 1
		num = int(num)

	return num

def get_diameters(poi):
	## VER: 2014-12-10, v1.0

	poi = check_poi(poi)

	diameters = []
	for face in poi.faces:
		if len(face.getCells()) == 1:
			try:
				radius = face.getRadius()
				if 2*radius not in diameters:
					diameters.append(2*radius)
			except:
				pass

	diameters = sort(diameters)

	return diameters

function_labels['get_diamond_dims'] = 'PV','suntech','glass','dimension','size','type','module'
def get_diamond_dims(module_type):
	## VER: 2012-02-24, v1.0

	global glass_length, glass_width, glass_thick1, glass_thick2, EVA_thick

	if module_type == 'D48' or module_type == 'DF':	## 4*8
		glass_length = 1330		## 1330*2/9 = 300
		glass_width = 670
		glass_thick1 = 2.5		;please_check
		glass_thick2 = 2.5		;please_check
		EVA_thick = 1.1

	elif module_type == 'DV':	## 6*12
		glass_length = 1950		## 比有框时小6mm, 有框时为1956,  1950*2/9 = 440
		glass_width = 986			## 比有框时小6mm，有框时为992
		glass_thick1 = 2.5			;please_check
		glass_thick2 = 2.5			;please_check
		EVA_thick = 1.1

	elif module_type == 'DW':	## 6*10
		glass_length = 1634		## 比有框时小6mm, 有框时为1640,  1634*2/9 = 370
		glass_width = 986			## 比有框时小6mm，有框时为992
		glass_thick1 = 2.5		;please_check
		glass_thick2 = 2.5		;please_check
		EVA_thick = 1.1

	elif module_type == 'DU':	## 6*9
		glass_length = 1476		## 比有框时小6mm, 有框时为1482,  1476*2/9 = 330
		glass_width = 986			## 比有框时小6mm，有框时为992
		glass_thick1 = 2.5		;please_check
		glass_thick2 = 2.5		;please_check
		EVA_thick = 1.1

	elif module_type == 'DX':	## 6*9
		glass_length = 1318		## 比有框时小6mm, 有框时为1324,  1318*2/9 = 300
		glass_width = 986			## 比有框时小6mm，有框时为992
		glass_thick1 = 2.5		;please_check
		glass_thick2 = 2.5		;please_check
		EVA_thick = 1.1

	elif module_type == 'D1st':		## First solar, clamp2corner = 275 +/- 25, clamp_length = 80, 伏法玻璃
		glass_length = 1200			## 1200*2/9. = 270
		glass_width = 600
		glass_thick1 = 3.2
		glass_thick2 = 3.2
		EVA_thick = 0.5		## 总厚度为6.8mm, EVA厚度不是1.1mm

	print 'module_type=',module_type
	please_check
	if module_type[0] == 'D':
		write_global_variables(var_file_full,glass_length, glass_width, glass_thick1, glass_thick2, EVA_thick)
	else:
		raise Exception('Unknow diamond module type: '+ module_type)

	return

def get_display_module():
	## VER: 2015-04-03, v1.0

	vp = get_vpnow()
	dpo = get_dpo()

	module = None
	if type_of(dpo) == 'ASSEMBLY':
		display = vp.assemblyDisplay
		if display.loads == ON:
			module = 'loads'
		elif display.interactions == ON:
			module = 'interactions'
		elif display.mesh == ON:
			module = 'mesh'
		else:
			module = 'assembly'  ## assembly, step, or job
	elif type_of(dpo) == 'PART':
		module = 'part'			## part or property
	elif type_of(dpo) == 'sketch':
		module = 'sketch'
	else:
		if dpo == None:
			module = None

	mode = vp.colorMode

	return (module,mode)

def get_display_now():
	## VER: 2014-04-21, v1.0

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	if type_of(dpo) == 'PART':
		display = vpnow.partDisplay
	elif type_of(dpo) == 'ASSEMBLY':
		display = vpnow.assemblyDisplay
	elif type_of(dpo) == 'ODB':
		display = vpnow.odbDisplay
	else:
		display = None

	return display

function_labels['arc_diameter_by_3points'] = 'distance','radius','loc','circle','arc'
def arc_diameter_by_3points(loc1,mid,loc2):
	## VER: 2015-11-19, v1.0
	## To get the arc height between loc1 and loc2. mid is the top of the arc.
	## reference: point_to_line_distance()

	a = get_distance(loc1,mid)
	b = get_distance(loc2,mid)
	c = get_distance(loc1,loc2)

	x = (a*a + c*c - b*b)/(2*c)   ## x is part of length of c in a side
	h = sqrt(a*a - x*x)

	R = (c*c + 4*h*h)/(8*h)
	diameter = 2*R
	diameter = smart_round(diameter)

	return diameter

function_labels['point_to_line_distance'] = 'gap','perpendicular','line','distance','edge','loc','line equation','angle'
def point_to_line_distance(point,end1,end2,ignore=None):
	## VER: 2017-02-21, v1.2, end1, end2可组成一条直线。求的是点point到这条直线的距离
	## To get the arc height between end1 and end2. point is the top of the arc.

##	>>> point_to_line_distance(point=(1,1),end1=(0,0),end2=(5,0))
##	1.0
##	>>> point_to_line_distance(point=(0,1),end1=(0,0),end2=(5,0))
##	1.0
##	>>>

	a = get_distance(end1,point,ignore=ignore)
	b = get_distance(end2,point,ignore=ignore)
	c = get_distance(end1,end2,ignore=ignore)

	x = (a*a + c*c - b*b)/(2*c)   ## x is part of length of c in a side
	h2 = abs(a*a - x*x)
	h = sqrt(h2)
	h = smart_round(h)

	return h

def get_distance(loc1,loc2,ignore=None):
	## VER: 2017-02-21,v1.6

	if type_of(ignore) == 'STR':
		ignore = ignore.lower()
		if ignore not in ['x','y','z']:
			raise Exception('*** ignore axis should be x,y,or z')

	if type_of(loc1) == 'vertices':
		loc1 = loc1.pointOn[0]
	elif type_of(loc1) == 'DATUMPOINT':
		loc1 = loc1.pointOn
	elif type_of(loc1) == 'nodes':
		loc1 = loc1.coordinates

	if type_of(loc2) == 'vertices':
		loc2 = loc2.pointOn[0]
	elif type_of(loc2) == 'DATUMPOINT':
		loc2 = loc2.pointOn
	elif type_of(loc2) == 'nodes':
		loc2 = loc2.coordinates

	if len(loc1) == 3 and len(loc2) == 3:
		x1,y1,z1 = loc1
		x2,y2,z2 = loc2

		if ignore == 'x':
			x1=x2=0
		elif ignore == 'y':
			y1=y2=0
		elif ignore == 'z':
			z1=z2=0

		dist = sqrt((x1 - x2)**2 + (y1 - y2)**2 + (z1 - z2)**2)

	elif len(loc1) == 2 and len(loc2) == 2:
		x1,y1 = loc1
		x2,y2 = loc2

		dist = sqrt((x1 - x2)**2 + (y1 - y2)**2)

	else:
		raise Exception('*** Error loc1 and loc2')

##	dist = round6(dist)  ##??**** 不能简化

	return dist

get_dist = get_distance

function_labels['get_edge_nodes'] = 'open','radius','diameter','sintering','fix','hole','insert','mouth'
def get_edge_nodes(nodes):
	## VER: 2015-06-29, v1.0
	## 获取外围边缘线的节点。但是有时edge nodes所在的单元会变形，导致不在一个平面内。有时，mesh edge会被挤压到某个沉头孔表面中。

	## Insert, hole axis = 'z'
##	face_nodes = nodes_by_face(p1,z=MIN,nz=-1)
##	edge_nodes = get_edge_nodes(face_nodes)   ## to get the circular nodes

	nodes = tolist(nodes)

	newlist = []
	for node in nodes:
		if len(node.getElements())<=2:   ## 这里相当于获得变形前的edge. 有时getElements() > 2，但属于变形后的edge
			newlist.append(node)

	return newlist

def get_edge_seeds(edge):
	## VER: 2011-03-10, v1.0
	## Reference: get_edge_esize(), get_edge_enum()

	if type_of(edge) != 'edges':
		raise Exception('******An edge is required.')

	poi = get_poi(edge)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	method = poi.getEdgeSeeds(edge,EDGE_SEEDING_METHOD)   ## 结果：UNIFORM_BY_NUMBER表示按number来seed；UNIFORM_BY_SIZE表示按size来seed。
	esize = 0
	enum = 0
	if method != NONE:  ## 有seed
		esize = poi.getEdgeSeeds(edge,AVERAGE_SIZE)
		esize = round(esize,6)
		enum = poi.getEdgeSeeds(edge,NUMBER)

	return method,esize,enum   ## 不管是按number来seed, 还是按size来seed, esize和enum都会有一个数值。

def get_edge_esize(edge,poi=None):
	## VER: 2012-09-11, v1.0

	## Reference: get_edge_enum(), get_edge_seeds()

	if type_of(edge) != 'edges':
		raise Exception('******An edge is required.')

	if poi in empty:
		poi = get_poi(edge)

	if type_of(poi) == 'PINSTANCE':
		poi = a

	esize = poi.getEdgeSeeds(edge,AVERAGE_SIZE)		## 如果还没有人为seed，返回0
	if esize != 0:
		esize = round(esize,6)

	return esize

def get_dpo(viewport=None):
	## VER: 2013-10-12, v1.0

	if viewport in empty:
		viewport = get_vpnow()
	elif type_of(viewport) == 'STR' and viewport in session.viewports.keys():
		viewport = session.viewports[viewport]

	if type_of(viewport) != 'VIEWPORT':
		raise Exception('*** a viewport is required.')

	return viewport.displayedObject

def get_edge_enum(edge,poi=None):
	## VER: 2012-09-11, v1.0

	if type_of(edge) != 'edges':
		raise Exception('******An edge is required.')

	if poi in empty:
		poi = get_poi(edge)

	if type_of(poi) == 'PINSTANCE':
		poi = a

	enum = poi.getEdgeSeeds(edge,NUMBER)		## 如果还没有seed，返回0

	return enum

def get_element_facing_nodes(elems,nx=None,ny=None,nz=None):
	## VER: 2016-01-12, v1.1

	## create nodal surface
##	elems = element_select('powder_A1',x=MAX,err=0.05)
##	nodes = get_element_facing_nodes(elems,nx=1)
##	create_nodal_surface('powder_A1', nodes=nodes)

##	elems = element_select('powder_A1',ny=-1)
##	nodes = get_element_facing_nodes(elems,ny=-1)
##	create_nodal_surface('powder_A1',nodes=nodes,name='sur_bot')


	faces = get_an_element_face(elems,nx=nx,ny=ny,nz=nz)
	nodes = element_faces_to_nodes(faces)

	return nodes

def problem_powder_compaction():
	## VER: 2016-01-12, v1.0

	## 1. 下移过快(跳跃性迁移): powder上表面的节点一下子下移到die很深的位置，实际上die只是向下移动一点点而已
	## condition: STRUCTURE, frequency=1,sweep=1(能算完，但上表面的land弧度没了), sweep=5(不能算完，有超出单元)
	## 网格情况:左上角合并,网格一般，不属于边缘密集型。

	## 2. 左上角合并+SWEEP:网格质量不好(粉体上表面网格密集，远处疏松)，结果：单元变形过大，一开始就出错。
	## 3. 左上角不合并，用STRUCTURE网格，frequency=1,sweep=1，仍存在一开始网格迁移的事情。怀疑是powder的上部分网格不够理想(有弯曲现象)
	## 4. powder中间剖分，使上面的网格很好很方正，仍然存在初始网格大跃迁的情况。怀疑是ALE需要分布进行（开始填充时不用ALE)

	## 无法模拟powder filling
	## 倒着压（沉头孔上小下大）时，pin不能往下移动，因为powder不能自动跟着落下来(filling issue)
	## 中模或下冲有弧度且往下走时会存在transfer问题
	## 无法模拟green part ejection
	## 无法模拟crack prediction
	## 无法测量压坯的密度分布
	## 无法模拟模具移动速度的影响
	## 无法获得很高的变形预测精度
	## 1/4模型的对称模拟有问题?
	## ALE mesh: 设置复杂。

	## pin的摩擦系数可以考虑降低一些，帮助减小流动阻力
	## sweep mesh: 从上往下的sweep mesh比较好。
	## 1/4模型与全模型的区别:前者由于对称约束可能会影响网格的自适应，导致不收敛。同时，1/4模型对后处理收集结果不利。
	## 接触冒出：pin的转角处加一个倒角利于粉体的流动。
	## 为了便于粉体的流动，如果tool的surface很复杂，尽量避免surface的法线突然改变90度甚至更高的改变的情形。
	## 增加倒角利于surface的顺利过渡。
	## crack predict

	## scale factor: 质量缩放系数，可能800-2000是合适的。太小运算速度太慢。

	pass

	return

def get_an_element_face(elems,nx=None,ny=None,nz=None,angle_err=10):
	## VER: 2016-01-11, v1.2
	## only find one face

##	>>> faces = get_an_element_face(e1,nx=1)
##	>>> faces
##	[mdb.models['Model-2'].rootAssembly.instances['odb_pocket_A1'].elemFaces[3845]]
##	>>> light(faces)   ## 把相应的节点highlight出来
##	>>> type_of(faces[0])
##	'elemFaces'
##	>>>

	## Example:
##	elems = element_select('powder_A1',y=MAX)
##	faces = get_an_element_face(elems,ny=1)
##
##	nodes = nodes_by_face('powder_A1',y=MAX,ny=1)
##	create_nodal_surface('powder_A1', nodes=nodes)

##	elems = element_select('powder_A1',ny=-1)
##	nodes = get_element_facing_nodes(elems,ny=-1)
##	create_nodal_surface('powder_A1',nodes=nodes,name='sur_bot')

	elems = tolist(elems)

	if elems in empty:
		raise Exception('*** elements are required.')

	if type_of(elems[0]) != 'elements':
		raise Exception('*** elements are required.')

	shape = get_element_shape(elems[0])

	if (nx,ny,nz) == (None,None,None):
		raise Exception('*** nx,ny,or nz is required.')

	faces = []
	if shape == '3D':
		for elem in elems:
			faces1 = elem.getElemFaces()
			for face in faces1:
				if len(face.getElements()) == 1:
					center = element_center(elem)
					nodes1 = face.getNodes()
					normal = normal_vector_of_three_points_plane(nodes1[0],nodes1[1],nodes1[2],center)

					vector = vector_in_01(normal)

					xmeet = ymeet = zmeet = True
					if nx not in empty and nx != vector[0]:
						xmeet = False
					if ny not in empty and ny != vector[1]:
						ymeet = False
					if nz not in empty and nz != vector[2]:
						zmeet = False

					if xmeet and ymeet and zmeet and face not in faces:
						faces.append(face)
						break

			if faces != []:   ## 3D model, need only one face, then get other faces with element angle
				break

	elif shape == '2D':
		for elem in elems:
			faces1 = elem.getElemEdges()
			for face in faces1:
				if len(face.getElements()) == 1:
					center = element_center(elem)
					nodes1 = face.getNodes()
					node1,node2 = nodes1
					x1,y1,z1 = node1.coordinates
					x2,y2,z2 = node2.coordinates
					if center[0] == 0:
						loc3 = 10,(y1+y2)/2,(z1+z2)/2
						center = 5,center[1],center[2]
					elif center[1] == 0:
						loc3 = (x1+x2)/2, 10, (z1+z2)/2
						center = center[0],5,center[2]
					elif center[2] == 0:
						loc3 = (x1+x2)/2, (y1+y2)/2, 10
						center = center[0],center[1],5

					normal = normal_vector_of_three_points_plane(node1,node2,loc3,center)
					vector = vector_in_01(normal)
					## such as: normal=(-0.2171557, 0.976137, 0) and then vector= [-1,1,0]

					xmeet = ymeet = zmeet = True
					if is_number(nx) and nx != vector[0]:
						angle = vector_angle(start=node1,end=node2,axis='y')
						if angle > angle_err:
							xmeet = False
						if abs(nx) + abs(vector[0])>1:  ## 避免0.955与-0.955的情况，夹角很小，但方向相反
							ymeet = False

					if is_number(ny) and ny != vector[1]:
						angle = vector_angle(start=node1,end=node2,axis='x')
						if angle > angle_err:
							ymeet = False
						if abs(ny) + abs(vector[1])>1:
							ymeet = False

					if is_number(nz) and nz != vector[2]:
						meet = False

					if xmeet and ymeet and zmeet and face not in faces:
						faces.append(face)
						break

	return faces

def exterior_faces_of_elements(elems):
	## VER: 2016-12-07, v1.1

	elems = tolist(elems)
	elems = exterior_elements(elems)
	poi = get_poi(elems)

	ext_faces = []
##	seeds = []
##	i = 0
##	expand_elems = []
	for elem in elems:
		faces1 = elem.getElemFaces()
##		if elem in expand_elems:
##			continue

##		i = i + 1
##		print i
		for face in faces1:
			if len(face.getElements()) == 1 and face not in ext_faces:
				ext_faces.append(face)

##			if len(face.getElements()) == 1:
##				if face not in ext_faces:
##					seeds.append(face)
##					faces2 = face.getElemFacesByFaceAngle(angle)
##
##					faces2 = tolist(faces2)
##					ext_faces = ext_faces + faces2
##
##					surf1 = element_faces_to_surface(faces=faces2)
##					elems2 = tolist(surf1.elements)
##					expand_elems = expand_elems + elems2
##
##				break

	return ext_faces

def get_element_index_in_field(label=None,inst=None, element=None):

	## VER: ('VER: 2012-04-04, v1.0')	## Example: field_var[inst_index][element_index]

	if element not in empty:
		if type_of(element) != 'ODBMESHELEMENT':
			raise Exception('odb element is required.')

		inst = get_poi(element)
		label = element.label

	else:
		if label in empty or inst in empty:
			raise Exception('Both element label and instance are required.')

		inst = check_odb_inst(inst)
		if type_of(label) != 'INT':
			raise Exception('Element label is required.')

	inst_index = get_inst_index_in_field(inst)
	inst_elements = all_odb_elements[inst_index]

	elem_index = 'NA'
	for i in xrange(len(inst_elements)):
		if inst_elements[i].label == label:
			elem_index = i
			break

	elem_num = 0
	for i in range(len(all_odb_elements))[:inst_index]:
		elem_num = elem_num + len(all_odb_elements[i])

	field_index = elem_num + elem_index

	print 'inst_index =',inst_index
	print 'elem_index =',elem_index
	print 'field_index = ',field_index
	if elem_index == field_index:
		print 'elem_index = field_index'
	else:
		print 'elem_index < field_index'

	print 'Usage: field_var[inst_index][elem_index]], such as: all_odb_elements[inst_index][elem_index]'
	print 'Usage: field_var[field_index],such as: LE13.values[field_index]'
##	print 'Usage: field_var[' + str(inst_index) + '][' + str(elem_index) + ']'
	print ' '

	return elem_index, field_index

def get_element_shape(elem0):
	## VER: 2015-06-05, v1.1

	if type_of(elem0) != 'elements':
		raise Exception('*** An element is required.')

	if len(elem0.getNodes()) >= 6:
		shape = '3D'
	else:
		poi = get_parent(elem0)
		shape1 = part_shape(poi)[1]
		if shape1[:2] == '2D':
			shape = '2D'
		else:
			shape = '3D'

##		nodes0 = elements_to_nodes(elem0)
##		if len(nodes0) <=3:
##			shape = '2D'
##		else:
##			v1 = normal_vector_of_three_points_plane(nodes0[0],nodes0[1],nodes0[2])
##			v2 = normal_vector_of_three_points_plane(nodes0[1],nodes0[2],nodes0[3])
##			v3 = normal_vector_of_three_points_plane(nodes0[-3],nodes0[-2],nodes0[-1])
##			if v1 == v2 == v3:
##				shape = '2D'
##			else:
##				shape = '3D'

	return shape

def get_element_type(poi):
	## VER: 2015-03-19, v1.0

##  'elemCode': 'CAX3T',
##  'elemDeletion': UNKNOWN_ELEM_DELETION,
##  'elemLibrary': EXPLICIT,

	poi = check_poi(poi)

	types = []
	type1 = None
	type2 = None
	type3 = None

	if type_of(poi) == 'PINSTANCE':
		poi = poi.part

	if len(poi.elements) == 0:
		return types

	if len(poi.cells) > 0:
		seq = poi.cells[:10] + poi.cells[-10:]
		for obj in seq:
			try:
				type0 = poi.getElementType(obj,elemShape=HEX)
				type1 = type0.elemCode
			except:
				pass

			if type1 not in empty:
				break

		for obj in seq:
			try:
				type0 = poi.getElementType(obj,elemShape=WEDGE)
				type2 = type0.elemCode
			except:
				pass

			if type2 not in empty:
				break

		for obj in seq:
			try:
				type0 = poi.getElementType(obj,elemShape=TET)
				type3 = type0.elemCode
			except:
				pass

			if type3 not in empty:
				break

		if type1 in empty:
			type1 = 'UNKNOWN_HEX'
		if type2 in empty:
			type2 = 'UNKNOWN_WEDGE'
		if type3 in empty:
			type3 = 'UNKNOWN_TET'

		types = [type1,type2,type3]

	elif len(poi.faces) > 0:
		seq = poi.faces[:10] + poi.faces[-10:]
		for obj in seq:
			try:
				type0 = poi.getElementType(obj,elemShape=QUAD)
				type1 = type0.elemCode
			except:
				pass

			if type1 not in empty:
				break

		for obj in seq:
			try:
				type0 = poi.getElementType(obj,elemShape=TRI)
				type2 = type0.elemCode
			except:
				pass

			if type2 not in empty:
				break

		if type1 in empty:
			type1 = 'UNKNOWN_QUAD'
		if type2 in empty:
			type2 = 'UNKNOWN_TRI'

		types = [type1,type2]

	elif len(poi.edges) > 0:
		seq = poi.edges[:10] + poi.edges[-10:]
		for obj in seq:
			try:
				type0 = poi.getElementType(obj,elemShape=LINE)
				type1 = type0.elemCode
			except:
				pass

			if type1 not in empty:
				break

		if type1 in empty:
			raise Exception('*** Fail to get the element type.')
		else:
			types = [type1]

	elif len(poi.elements) > 0:
		seq = poi.elements[:50] + poi.elements[-50:]
		for obj in seq:
			elem = repr(obj.type)
			if elem not in types:
				types.append(elem)

	return types

function_labels['get_eset'] = 'get_leaf_of_odb_sets','element'
def get_eset(setname,instance=None):
	## VER: ('VER: 2012-10-09, v1.2')

	inst_eset = []
	insts = []

	if type_of(setname) != 'STR':
		raise Exception('Please provide setname')

	setname = setname.upper()
	if instance in empty:
		pos = setname.find('.')
		if pos == -1:
			inst_eset = inst_dot_esets(setname)
		else:
			inst_eset = (setname,)
		if len(inst_eset) == 0:
			print fnln_fnln(),'******No instance was found by setname=',setname
	else:
		instance = real_odb_insts(instance)
		for inst in instance:
			inst_eset.append(inst.name + '.' + setname)

	inst_eset = totuple(inst_eset)
	print 'inst.eset=',inst_eset,'by setname=',setname

	return inst_eset

def get_parent(obj,repository=None):
	## VER: 2014-07-15, v2.2
	## reference: get_repository_key(), get_poi()
	## get_parent()获得小数点之前的内容，get_repository_key()获得[]中的内容。


##>>> edge
##mdb.models['Model-1'].parts['cutEdge'].edges.findAt((99.81019, -59.43963, -11.277429),)
##>>> get_parent(edge)
##mdb.models['Model-1'].parts['cutEdge']
##>>>

##	>>> set1
##	mdb.models['Model-1'].parts['PDC'].sets['H11N']
##	>>> get_repository_key(set1,'sets')
##	'H11N'
##	>>> get_parent(set1)
##	mdb.models['Model-1'].parts['PDC']
## >>> set1.name
## AttributeError: 'Set' object has no attribute 'name'
## >>>

	## A.B , 则A是B的parent

	##>>> g1
	##mdb.models['Model-1'].sketches['s_ejector'].geometry[4]
	##>>> get_parent(g1)
	##>>>
	##>>> get_parent(g1,'geometry')
	##mdb.models['Model-1'].sketches['s_ejector']

	## example:
##	r1[35] = mdb.models['Model-1'].rootAssembly.referencePoints[35]
##	type_of(r1[35] = type_of(r1[35])
##	get_repository_key(get_repository_key(r1[35],'referencePoints')) = 35

##>>> faces = shaft_A1.faces[0]
##>>> get_parent(faces)
##mdb.models['Model-1'].rootAssembly.instances['shaft_A1']
##>>>

	objs = tolist(obj)

	parent = None
	if len(objs) == 1:
		obj = objs[0]
		text1 = repr(obj)
		text2 = text1.lower()

		if type_of(repository) != 'STR':
			type1 = original_type(obj).lower()
			if type1 == 'vertex':
				type1 = 'vertices'
			type2 = type_of(obj).lower()

			if type2 in ['cells','faces','edges','vertices']:
				type1,type2 = type2,type1
		else:
			type1 = repository.lower()

##		print fnln(),type1
##		print fnln(),text2
##		raise Exception


		if type1 in text2:
			loc1 = text2.find('.' + type1)
			text3 = text2[:loc1]   ## text3 are all in lower case
##			print 'type1=',type1
##			print 'text2=',text2
##			print 'text3=',text3
##			raise Exception

			try:
				parent = eval(text1[:len(text3)])   ## keeep original case
			except:
				loc1 = text2.find('.' + type2)
				text3 = text2[:loc1]
				try:
					parent = eval(text1[:len(text3)])
				except:
					pass


##		print 'parent=',parent   ## if there is '.findAt' in the string, then now, parent=None
		if parent in empty:
			if '.findAt' in text1:
				loc = text1.find('.findAt')
				text1 = text1[:loc]		;please_check

			locs = locs_of_substring(text1,'.')
			locs.reverse()
			if locs not in empty:
				for loc in locs:
					text1 = text1[:loc]
##					print fnln(),'text1=',text1
					try:
						parent = eval(text1)
					except:
						pass

					if parent not in empty:
						break

		if parent in empty:
			print '*** Fail to find the parent, obj type=',type_of(obj)

		if 'ARRAY' in type_of(parent) or type_of(parent) in ['LIST','TUPLE','DICT']:
			print fnln(),'Warning: type_of(parent)=',type_of(parent)
			## 例如: mdb.models['model-1'].parts['stamp'].vertices

	elif len(objs) > 1:
		pois = []
		newlist = [objs[0],objs[-1]]
##		print fnln(),newlist
		if len(objs) > 4:
			list1 = randomize(range(len(objs)))

			index1 = list1[0]
			if objs[index1] not in newlist:
				newlist.append(objs[index1])

			index2 = list1[1]
			if objs[index2] not in newlist:
				newlist.append(objs[index1])

		for obj in newlist:
			poi = get_parent(obj)
			if poi not in pois:
				pois.append(poi)

		if len(pois) == 1:
			parent = pois[0]
		else:
			raise Exception('****Multiple pois found, use get_pois() instead.')

	return parent

get_parent_of_repository = get_parent

def get_part_esize(part,size=None):
	## VER: 2012-09-21, v1.1
	## Refer: get_part_seed()

	part = check_part(part)
	glob1 = part.getPartSeeds(DEFAULT_SIZE)
	assigned = part.getPartSeeds(SIZE)
	if assigned == 0:
		print 'Global esize for',part.name,'has not been defined yet.'
		assigned = glob1
	elif assigned > glob1:    ##???****
		assigned = glob1

	if size not in empty and size < glob1:
		assigned = size

	print 'esize of',part.name, ': CAE default=',glob1,', user defined=',assigned

	return glob1,assigned

function_labels['get_script_file'] = 'dir','path','py'
def get_script_file(func=None):
	## VER: 2016-09-02, v1.0
	## 即使脚本文件不在工作目录及其子目录，也能判断出来。

##	>>> get_script_file()
##	'E:/FEM/USM/py/AG_A0271_H10F_B109.py'
##	>>> get_file_path()
##	'E:/FEM/USM/py/AG_A0271_H10F_B109.py'
##	>>>

##	>>> text1 = repr(face_select.func_code)
##	>>> len(text1)
##	93
##	>>> text1
##	'<code object face_select at 7F9ADAD0, file "E:/FEM/USM/py/AG_A0271_H10F_B109.py", line 25426>'

	if type_of(func) == 'FUNCTION':
		functions = [func]
	else:
		functions = [face_select, new_key, create_job]

	files = []
	for func in functions:
		text1 = repr(func.func_code)
		loc1 = text1.find('"')
		text1 = text1[loc1+1:]

		loc2 = text1.rfind('"')
		text1 = text1[:loc2]

		name = text1
		if name not in files:
			files.append(name)

	file_path = files[0]

	return file_path

function_labels['script_path'] = 'dir','py'
def script_path(func=None):
	## VER: 2016-10-31, v1.0

	path = get_script_file(func)
	loc = path.rfind('/')
	path = path[:loc + 1]

	return path

function_labels['get_file_name'] = 'script','python','code','source'
def get_file_name():
	## VER: 2017-07-28, v1.6

	path = get_file_path()
	loc = path.rfind('/')
	name = path[loc+1:]

	return name

def get_file_name0(func=None):
	## VER: 2017-03-08, v1.5 可能有误

##	>>> str1 = 'abaqus_plugins\BF_A0219_button_compaction_divide.py'
##	>>> str1
##	'abaqus_plugins\\BF_A0219_button_compaction_divide.py'
##	>>> loc = str1.rfind('\\')
##	>>> loc
##	14
##	>>> str1[loc+1:]
##	'BF_A0219_button_compaction_divide.py'
##	>>>

	trace1 = get_traceback(instance_list=True)
##	print 'trace1=',trace1
##	raise Exception

	if type_of(func) == 'FUNCTION':
		func = func.func_name

	if type_of(func) == 'STR':
		path = ''
		for item in trace1:
			if item.final_command == func:
				path = item.filename
				break
		if path == '':
			raise Exception('Fail to get the file name of func: ' + func)
	else:
		path = trace1[0].filename

	loc = path.rfind('/')
	name = path[loc+1:]
	loc = name.rfind('\\')
	if loc>0:
		name = name[loc+1:]

	return name

def get_files_in_dir(path=None,extension=None,ext=None):
	## VER: 2014-07-17, v1.1
	## reference: files_in_folder()

##	caenames = get_files_in_dir(extension='cae')
##	caename = new_key(caenames,caename)


## >>> get_files_in_dir(extension='cae')
##	['A0212_imported2', 'A0212_imported22', 'A6_A0212_rotary_cutter_model', 'A8_A0212_rotary_cutter_model', 'A9_A0212_rotary_cutter_model', 'AA_A0212_rotary_cutter_model', 'AB_A0212_rotary_cutter_model', 'AC_A0212_rotary_cutter_model', 'AD_A0212_rotary_cutter_model', 'AE_A0212_rotary_cutter_model', 'AF_A0212_rotary_cutter_model', 'AG_A0212_rotary_cutter_model', 'AH_A0212_rotary_cutter_model', 'AI_A0212_rotary_cutter_model', 'AJ_A0212_rotary_cutter_model', 'AK_A0212_rotary_cutter_model', 'AL_A0212_rotary_cutter_model', 'AM_A0212_rotary_cutter_model', 'AxisymmConeCrack', 'BG_A0212_rotary_gravity_force_mass_V200', 'BH_A0212_rotary_G_F_mass_constV200', 'BO_A0212_rotary_body_F_mass_Initial200', 'BP_A0212_rotary_body_F_mass_Initial200', 'BQ_A0212_rotary_body_F_mass_Initial200', 'BR_A0212_rotary_body_F_mass_const200', 'BS_A0212_rotary_body_F_mass_initialV100', 'CA_A0212_rotary_initialV150_4_loc30', 'CB_A0212_rotary_initialV150_4_loc30', 'CE_A0212_rotary_initialV150_4_loc30', 'CG_A0212_rotary_initialV150_4_loc30', 'CH_A0212_rotary_initialV150_4_45deg', 'CH_A0212_rotary_initialV150_4_90deg', 'CI_A0212_rotary_initialV150_4_90deg', 'CK_A0212_rotary_initialV150_4_90deg', 'imported', 'imported2', 'import_test_full', 'p3', 'p342-1', 'p342', 'part-342', '_temp']
##	>>>
	if ext not in empty:
		extension = ext

##	if extension in empty and path not in empty:
##		path, extension = extension, path

	if path in empty:
		path = get_work_dir()

	path = real_dir(path)
##	files_num, dict1 = my_walk(path)
	dict1 = my_walk(path)

##	print 'extension=',extension

	if extension not in empty:
		extension = totext(extension)
		extension = extension.lower()
		if extension[0] != '.':
			extension = '.' + extension
##	else:
##		raise Exception('**** Error file extension')

	files = dict1[path]['files']  ## file names have extension

	files1 = []
	if extension not in empty:   ## files list will be without extension
		for file in files:
			name1 = file.lower()  ;please_check
			if name1.endswith(extension):
##				name1 = name1[:-len(extension)]
				name1 = file[:-len(extension)]
				files1.append(name1)
		files = files1

##	print '--->',len(files),'files are found, extension=',repr(extension)

	return files

function_labels['get_file_path'] = 'dir','full path'
def get_file_path():
	## VER: 2016-09-02, v1.5
	## 结果形式为绝对路径，如D:/JYQ/pro/49AC/AF_49AC_W35_plate.py，对于clipCommand, 结果为'<input>'

##	>>> get_script_file()
##	'E:/FEM/USM/py/AG_A0271_H10F_B109.py'
##	>>> get_file_path()
##	'E:/FEM/USM/py/AG_A0271_H10F_B109.py'
##	>>>

##	try:
##		trace1 = get_traceback(instance_list=True)
##	except:
##		raise Exception('*** Fail to get the file path.')
##	path = trace1[0].filename

	return get_script_file()


def elements_dict_by_face(elements,fine_angle=30,axis='x',rough_angle=70,by_fine=True):
	## VER: 2016-04-14, v1.5. Results is sequence
	## by_fine = False means that this surface is very rough in angles, not an ideal surface.

##	Compare below two methods, method1 is better than method2
##	1)
##	nodes = nodes_by_face('green_A1',nz=-1,z=MIN)
##	elems = nodes_to_elements(nodes)
##	elements_to_surface(elems,name='surf-a',axis='z')
##	2)
##	elems = element_select('green_A1',z=MIN,nz=-1)
##	elements_to_surface(elems,name='surf-a',axis='z')

##	>>> elements_dict_by_face(e1,axis='z')
##	angle2= 0.1063
##	angle4= 89.7
##	{'face2': mdb.models['Model-1'].parts['p1'].elements[84105:84106]}
##	>>> face_numbers_of_element(e1,axis='z')
##	angle2= 0.1063
##	angle4= 89.7
##	[2]
##	>>> elements_dict_by_face(e1,axis='x')
##	angle2= 89.894
##	angle4= 5.2604
##	{'face4': mdb.models['Model-1'].parts['p1'].elements[84105:84106]}
##	>>> face_numbers_of_element(e1,axis='x')
##	angle2= 89.894
##	angle4= 5.2604
##	[4]
##	>>>

##	>>> elems,nodes = elems_nodes_by_face('green',nx=1,x=MAX)
##	>>> elems1 = elements_dict_by_face(elems,axis='x')
##	>>> elems1[-1]
##	4 ## most face num, corresponding sequence is elems1[3]
##	Then manually pick an element(e1) in GUI to create a surface, check the rpy file to confirm the most face side.
##  off course, face num can also be double confirmed by face_numbers_of_element(e1,axis=axis)
##	>>> face_numbers_of_element(e1)
##	4
##	>>>

	elements = tolist(elements)
	face1elements = []
	face2elements = []
	face3elements = []
	face4elements = []
	face5elements = []
	face6elements = []
	face7elements = []
	face8elements = []

	if by_fine == True:
		angle = fine_angle
	else:
		angle = rough_angle

	for element in elements:
		sides = face_numbers_of_element(element,angle=angle,axis=axis)  ## sides=[]时，单元将被忽略
		if 1 in sides:
			face1elements.append(element)
		if 2 in sides:
			face2elements.append(element)
		if 3 in sides:
			face3elements.append(element)
		if 4 in sides:
			face4elements.append(element)
		if 5 in sides:
			face5elements.append(element)
		if 6 in sides:
			face6elements.append(element)
		if 7 in sides:
			face7elements.append(element)
		if 8 in sides:
			face8elements.append(element)

	total = face1elements + face2elements + face3elements + face4elements + face5elements + face6elements + face7elements + face8elements
	if len(total) > 0:
		total = list2sequence(total)
	else:
		total = None

	if face1elements not in empty:
		face1elements = list2sequence(face1elements)

	if face2elements not in empty:
		face2elements = list2sequence(face2elements)

	if face3elements not in empty:
		face3elements = list2sequence(face3elements)

	if face4elements not in empty:
		face4elements = list2sequence(face4elements)

	if face5elements not in empty:
		face5elements = list2sequence(face5elements)

	if face6elements not in empty:
		face6elements = list2sequence(face6elements)

	if face7elements not in empty:
		face7elements = list2sequence(face7elements)

	if face8elements not in empty:
		face8elements = list2sequence(face8elements)


	num1 = len(face1elements)
	num2 = len(face2elements)
	num3 = len(face3elements)
	num4 = len(face4elements)
	num5 = len(face5elements)
	num6 = len(face6elements)
	num7 = len(face7elements)
	num8 = len(face8elements)

	dict1 = {}
	if num1 > 0:
		dict1['face1'] = face1elements
	if num2 > 0:
		dict1['face2'] = face2elements
	if num3 > 0:
		dict1['face3'] = face3elements
	if num4 > 0:
		dict1['face4'] = face4elements
	if num5 > 0:
		dict1['face5'] = face5elements
	if num6 > 0:
		dict1['face6'] = face6elements
	if num7 > 0:
		dict1['face7'] = face7elements
	if num8 > 0:
		dict1['face8'] = face8elements
	dict1['total'] = total

	return dict1

def get_face_edge_in_dir(face,dir='x'):
	## VER: 2013-07-25, v1.0
	## 选择一个面中与dir夹角最小的一条边。

	if type_of(face) != 'faces':
		raise Exception('*** one face is required.')

	edges = faces_to_edges(face)

	edges0 = []
	for edge in edges:
		print 'dir=',dir
		angle,dir1 = get_intersect_angle(edge,axis=dir)
		if angle == 0:
			edges0 = ([0,edge,dir1],)
			break
		elif angle < 45:
			edges0.append([angle,edge,dir1])

	if edges0 in empty:
		raise Exception('*** Fail to get the edge in ' + repr(dir) + ' for the face.')

	edges0 = sort_tuple_type_elements(edges0,index=0)  ## 升序  （排在最前面的是与dir夹角最小的edge

##	print edges0
	angle, edge,dir1 = edges0[0]  ## 按角度来选择，而不是按长度来选择

	return edge

def get_faces_insts():
	## VER: 2014-11-19, v1.0, 这样的inst有可能是3D in space

	insts = []
	for inst in a.instances.values():
		if len(inst.cells) == 0 and len(inst.faces) > 0:
			insts.append(inst)

	return insts

def face_and_nodes_of_element(elem):
	## VER: 2014-10-13, v1.0
	##

	if type_of(elem) != 'elements':
		raise Exception('*** an element is required.')

##	On two-dimensional or axisymmetric shell elements, you can use the following arguments:
##	face1Elements
##
##	face2Elements
##
##	face3Elements
##
##	face14Elements
##
##	On solid elements, you can use the following arguments:
##	face1Elements
##
##	face2Elements
##
##	face3Elements
##
##	face4Elements
##
##	face5Elements
##
##	face6Elements
##
##	On three-dimensional shell elements, you can use the following arguments:
##	side1Elements
##
##	side2Elements
##
##	side12Elements
##
##	On three-dimensional wire elements, you can use the following arguments:
##	end1Elements
##
##	end2Elements
##
##	circumElements
##
##	On two-dimensional or axisymmetric wire elements, you can use the following arguments:
##	side1Elements
##
##	side2Elements

	dict1 = {}
	edges = elem.getElemEdges()
	for i in range(len(edges)):
		index = i + 1
		face = 'face' + str(index)

		node1, node2 = edges[i].getNodes()
		if node1.label > node2.label:
			node1, node2 = node2, node1   ## 排序

		dict1[face] = [node1,node2]

	return dict1


def get_feature_id(poa,name):
	## VER: 2011-05-15, v1.0

	if type_of(name) in ['PART','PINSTANCE','ASSEMBLY']:
		poa,name = name,poa

	poa = check_pias(poa)
	if type_of(poa) == 'PINSTANCE':
		poa = a

	id = poa.features[name].id

	return id

def get_script_work_and_result_files():
	## VER: 2016-09-02, v1.3

	global script_file_full, print_morning,print_afternoon, my_globals, work_dir

	add2my_globals('script_file_full')

##	keys0 = locals().keys()   ## create global vars

	## file
	## double cofirm the file name and project name.

	print ' '
	file_path = get_script_file()   ## 例如：'E:/FEM/USM/py/AG_A0271_H10F_B109.py'
	print fnln(),'script file =',file_path

	loc1 = file_path.rfind('/')
	script_file_dir = file_path[:loc1 + 1]  ## 最后一个字符为/
	main_file_full = get_file_name()

##	script_file_dir = file_path[:-len(main_file_full)]
##	main_script_file = script_file_dir + main_file_full
##	print 'script_file_dir=',script_file_dir

	loc = locs_of_substring(file_path,'/')
	root_path = file_path[:loc[-2]+1]

##	plugin_path = root_path + '/abaqus_plugins/'
	##print 'plugin_path=',plugin_path
##	if os.path.isdir(plugin_path) == False:
##		os.mkdir(plugin_path)

	computer_name = os.environ['COMPUTERNAME']
	work_system = platform.architecture()    ## such as: ('64bit', 'WindowsPE')
	work_dir = os.path.abspath('.')
	work_dir = modify_string(work_dir,'\\', '/') + '/'		## Phython用"\\"来表示一个反斜杠字符'\'，而'\'并不是\本身(转义)。

	if imported:
		locals2globals(keys0,locals())
		hide_datum()

		raise Exception

	print ' '
	print 'computer name =',computer_name
	print "work directory =",work_dir

	if imported == False and jobnum.lower() not in main_file_full.lower():
		raise Exception('project number is not shown in the file name')

##	file1 = open(script_file_dir + main_file_full)
	file1 = open(file_path)
	main_file_code = file1.readlines()
	file1.close()
	del file1

##	result_file = script_file_dir + '_' + jobnum + '_results' + '_' + computer_name[:3] + '.txt'
	result_file = '_' + jobnum + '_results' + '_' + computer_name[:3] + '.txt'

	time_now = time.asctime()[:16]
	loc = time_now.rfind(' ')
	hour = time_now[loc+1:]
	loc = hour.find(':')
	hour = hour[:loc]
	if hour[0] == '0':
		hour = hour[1:]
	hour = eval(hour)

	if hour < 12 and 'print_morning' not in globals().keys():
		line_print(result_file,' ')
		line_print(result_file,'## ' + time_now)  ## print date
		print_morning = False

	elif hour > 12 and 'print_afternoon' not in globals().keys():
		line_print(result_file,' ')
		line_print(result_file,'## ' + time_now)  ## print date
		print_afternoon = False

##	locals2globals(keys0,locals())

##	os.system('attrib +R ' + file_path)  ## file_path必须是绝对路径。不能仅仅是文件名。

	## put to files
	if len(run_indexs) >= 5:   ## backup_curve_file
		loc = script_file_dir[:-1].rfind('/')
		new_file_name = 'DOE_' + main_file_full[:-3] + '.py'
		new_dir = script_file_dir + script_file_dir[loc+1:]

		if os.path.isdir(new_dir) == False:
			os.mkdir(new_dir)

		if not os.path.isfile(new_dir + new_file_name):
			shutil.copy(script_file_dir + main_file_full,new_dir + new_file_name)
		os.system('attrib +R ' + new_dir + new_file_name)

	return

def radius_of_fit_nodes(cae_nodes=None, odb_nodes='dim_arc_ymax',path=None,part=None,labels=(),axis='xy',axis1='x',axis2='y',sort='x',step=-1,frame=-1,err=0.1,expand=False,
	negative_axis1=False,negative_axis2=False,sym=False,save_wire=False):
	## VER: 2016-09-30, v1.8
	## path in odb, setname in cae.
	## negative_axis1 = True表示最后曲线方程开口朝右，但不影响半径值。（一般不用)
	## negative_axis2 = True表示最后曲线方程开口朝下，但不影响半径值。
	## 对于shell类型的part（例如die)，可以直接框选节点建立相应的set，然后通过set2objs()获得nodes，然后求其半径。

##	nodes = nodes_by_face(p1,y=MAX,ny=1,angle=10)
##	nodes1 = node_select(p1,z=_zmid(p1),x=(-6.5,6.5),err=0.1,nodes=nodes)
##	radius_of_fit_nodes(nodes1,axis='xy')	## R=61.234(BL,sym model，数据不对称处理), R=63.125((BK,full model)
##	radius_of_fit_nodes(nodes1,axis='xy',sym=True)  ## R=62.797(BL,sym model,数据对称处理),可见，数据需对称处理

##	>>> radius_of_fit_nodes(nodes1,axis='xz',negative_axis2=True)
##	Fit equation as below:
##	Y = 0.0186708*X*X - 0.000252042*X - 2.1858
##	28.196
##	>>> radius_of_fit_nodes(nodes1,axis='xz')
##	Fit equation as below:
##	Y = -0.0186708*X*X + 0.000252042*X + 2.1858
##	28.196

##	nodes1 = node_select(p1,z=MID,x=(-6.5,6.5),err=0.1,poiRefY=(MAX,-2))
##	radius_of_fit_nodes(nodes1,axis='xy')
##	nodes1 = node_select(p1,z=MID,y=(-6.5,6.5),err=0.1,poiRefX=(MAX,-2))
##	radius_of_fit_nodes(nodes1,axis='xy')

##	>>> radius_of_fit_nodes(nodes1,axis='yx')  ## 63.022  correct
##	>>> radius_of_fit_nodes(nodes1,axis='xy')  ## 236.43, wrong, these nodes are along y axis, not x axis

	## Example:
	## radius_of_fit_nodes(odb_nodes='dim_arc_ymax',axis1='x',axis2='y',sort='x')  ## results: R = 35.213
	## radius_of_fit_nodes(odb_nodes=labels,axis1='x',axis2='y',sort='x')
	## radius_of_fit_nodes(part='p1',cae_nodes='mid',axis1='x',axis2='y')
	## radius_of_fit_nodes(part='p1',cae_nodes='set5',axis1='x',axis2='y',err=0.1,expand=False)  ## 手工在GUI建立node set之后，然后获取其radius

##	>>> nodes = nodes_of_odb_path('nodes_ymax')
##	>>> nodes[0]
##	session.openOdb(r'D:/JYQ/A0256-USM insert/D1_A0256_USM_insert_rough1_4hr.odb').rootAssembly.instances['GREEN_A1'].nodes[932]
##	>>> type_of(nodes[0])
##	'ODBMESHNODE'
##	>>> radius_of_fit_nodes(nodes)  ## nodes are picked by creating path in odb
##	35.376

##	>>> radius_of_fit_nodes(path='nodes_ymax')
##	35.376

	if axis not in empty and type_of(axis) == 'STR':
		axis1 = axis[0]
		axis2 = axis[1]
		sort = axis1

	if type_of(odb_nodes) in ['TUPLE','LIST']:
		if type_of(get_parent(odb_nodes[0])) in ['PART','PINSTANCE']:
			cae_nodes = odb_nodes
			odb_nodes = None

	if path not in empty:
		if path in session.paths.keys() or path in session.paths.values():
			odb_nodes = nodes_of_odb_path(path)
		else:
			print fnln(),'path=',repr(path)
			raise Exception('*** path not existed in session.')

	if labels not in empty or cae_nodes not in empty:
		locs = locs_of_arc_nodes(labels=labels,part=part,cae_nodes=cae_nodes, axis1=axis1,axis2=axis2,err=err,expand=expand)
		if cae_nodes not in empty:
			set1 = create_set(nodes=cae_nodes,name='_Fit_nodes',check_name=True)
			print ' '
			print fnln(),'-->Created node set',name_of_set(set1),'for these cae nodes.'
			light(cae_nodes)
	else:
		locs = odb_coords_by_xydata(nodes=odb_nodes,axis1=axis1,axis2=axis2,sort=sort,step=step,frame=frame)

	if negative_axis1 == True or negative_axis2 == True:
		newlist = []
		for i in range(len(locs)):
			x,y = locs[i]
			if negative_axis1 == True:
				x = -x
			if negative_axis2 == True:
				y = -y
			newlist.append((x,y))
		locs = newlist

	if sym == True:
		sym1 = True

	if sym == True:   	## 仅适用于补足对称面另外一侧的点。
		newlist = []
		for loc in locs:
			x1,y1 = loc
			newlist.append((x1,y1))
			newlist.append((-x1,y1))
		locs = sort_locs(newlist,index=0)

	fit_curve = polyfit(points=locs,degree=2)
	equation = fit_curve['equation']

	vx = []
	for item in locs:
		vx.append(item[0])

	min0 = min(vx)
	max0 = max(vx)

	xvalues = myrange(start=min0,end=max0,inc=0.01*(max0-min0))  ## 100 points
	points = []
	for X in xvalues:
		Y = eval(equation)
		points.append((X,Y,0))
	points = totuple(points)

##	save_mdb()
	partname = blank_part('wire_part')
	p = _part(partname)

	try:  ## 高版本
		p.WireSpline(points=points, mergeType=IMPRINT, meshable=OFF, smoothClosedSpline=OFF)   ## IMPRINT, MERGE
	except: ## 6.12
		p.WireSpline(points=points, mergeWire=ON, meshable=OFF, smoothClosedSpline=OFF)

	e1 = p.edges[0]

##	plot(p)

	prange = myrange(start=0.1,end=0.9,inc=0.02)
	radius = []
	for par in prange:
		info = RC_shape(e1,par=par)
		radius.append(info[0])

	radius = _sort(radius)[2:-2]
	R = smart_round(sum(radius)/len(radius))
	print ' '
	print fnln(),'Radius =',R, ', diameter=',2*R
	print fnln(),'The nodes are fitted into wire part',p.name
	print ' '

	if save_wire == False:
		del_parts(p)

	return R

def get_fix_status(dict1):
	## VER: 2013-06-16, v1.1

	DOFs = []
	fix_status = {'U1':UNSET, 'U2':UNSET, 'U3':UNSET, 'UR1':UNSET, 'UR2':UNSET, 'UR3':UNSET}

	results = []
	print2('dict1=',dict1)
	for k,v in dict1.items():
		dof = k.upper()
		if dof == 'UX':
			dof = 'U1'
		elif dof == 'UY':
			dof = 'U2'
		elif dof == 'UZ':
			dof = 'U3'
		elif dof == 'URx':
			dof = 'UR1'
		elif dof == 'URy':
			dof = 'UR2'
		elif dof == 'URZ':
			dof = 'UR3'

		value = v
		if type_of(value) not in numerics and value not in _m.amplitudes.keys():
			value = UNSET
		if value != UNSET:
			fix_status[dof] = value

	print2('fix_status=',fix_status)
##	raise Exception

	for dof,value in fix_status.items():
		if value not in empty:
			if dof == 'U1':
				DOFs.append('x')
			elif dof == 'U2':
				DOFs.append('y')
			elif dof == 'U3':
				DOFs.append('z')
			elif dof == 'UR1':
				DOFs.append('UR1')
			elif dof == 'UR2':
				DOFs.append('UR2')
			elif dof == 'UR3':
				DOFs.append('UR3')

	print2('DOFs=',DOFs)

##	raise Exception

	if DOFs in empty:
		raise Exception('**** No dof was specified for BC.')

	return fix_status, DOFs

def get_fontsize():
	## VER: 2016-05-16, v1.2

	global fontsize

	computer = get_computer_name()
	viewport_num = len(session.viewports.keys())

	vpnow = get_vpnow()
	fontsize = int(round(0.13*min(vpnow.currentHeight,vpnow.currentWidth)))
	if fontsize <12:
		fontsize = 12
	else:
		if viewport_num == 1:
			if fontsize > 22:
				fontsize = 22
		elif viewport_num >= 2:
			if fontsize > 20:
				fontsize = 20

	size = fontsize

	return size

function_labels['get_frameless_module_dims'] = 'glass','PV','suntech','dimension','type'
def get_frameless_module_dims(module_type):
	## VER: ('VER: 2012-02-24, v1.0')

	global glass_length, glass_width, glass_thick, EVA_thick

	if module_type == 'FL48':	## 4*8
		glass_length = 1330		## 1330*2/9 = 300
		glass_width = 670
		glass_thick = 2.5		;please_check
		EVA_thick = 0.8
		TPT_thick = 0.4

	elif module_type == 'FLV':	## 6*12
		glass_length = 1950		## 比有框时小6mm, 有框时为1956,  1950*2/9 = 440
		glass_width = 986			## 比有框时小6mm，有框时为992
		glass_thick = 4			;please_check
		EVA_thick = 0.8
		TPT_thick = 0.4

	elif module_type == 'FLW':	## 6*10
		glass_length = 1634		## 比有框时小6mm, 有框时为1640,  1634*2/9 = 370
		glass_width = 986			## 比有框时小6mm，有框时为992

##		glass_length = 2360		;please_check('由于搭在横梁上，缩短了100mm')
##		glass_width = 1230
		glass_thick = 3.2		;please_check
		EVA_thick = 0.8
		TPT_thick = 0.4

	elif module_type == 'FLU':	## 6*9
		glass_length = 1476		## 比有框时小6mm, 有框时为1482,  1476*2/9 = 330
		glass_width = 986			## 比有框时小6mm，有框时为992
		glass_thick = 3.2		;please_check
		EVA_thick = 0.8
		TPT_thick = 0.4

	elif module_type == 'FLX':	## 6*9
		glass_length = 1318		## 比有框时小6mm, 有框时为1324,  1318*2/9 = 300
		glass_width = 986			## 比有框时小6mm，有框时为992
		glass_thick = 3.2		;please_check
		EVA_thick = 0.8
		TPT_thick = 0.4

	elif module_type == 'FL1st':		## First solar, clamp2corner = 275 +/- 25, clamp_length = 80, 伏法玻璃
		glass_length = 1200			## 1200*2/9. = 270
		glass_width = 600
		glass_thick = 3.2
		EVA_thick = 0.8
		TPT_thick = 0.4

	print 'module_type=',module_type
	please_check
	if module_type.startswith('FL'):
		write_global_variables(var_file_full,glass_length, glass_width, glass_thick, TPT_thick, EVA_thick)
	else:
		raise Exception('Unknow diamond module type: '+ module_type)

	return

def get_func_defaults(func):
	## VER: 2012-12-10, v1.0, 获取函数的缺省变量的名称及缺省值。

	func = check_func(func)

	vars_num = func.func_code.co_argcount
	if func.func_defaults not in empty:
		defaults_num = len(func.func_defaults)
	else:
		defaults_num = 0

	vars = func.func_code.co_varnames[:vars_num]
	defaults = {}
	start = vars_num - defaults_num
	if defaults_num > 0:
		for i in range(defaults_num):
			value = func.func_defaults[i]
			var = vars[start + i]
			defaults[var] = value

##	print 'defaults=',defaults

	return defaults

function_labels['get_func_loc'] = 'function','loc'
def get_func_loc(func):
	## VER: 2016-11-22, v1.3 获得func在user_functions中应该排的位置。然后查找该位置函数，其前面就是该函数应保存的位置。

	global user_functions

	if type_of(func) == 'FUNCTION':
		func = func.func_name

	if type_of(func) != 'STR':
		raise Exception('******Function name is required.')

	func = func.lower()

	if 'user_functions' not in globals().keys():
		get_user_functions()

	functions = user_functions.keys()
	functions.sort()

	for func1 in functions:
		if func1 > func:
			return user_functions[func1]

	return

get_function_loc = get_func_loc

def get_function_handler(func):
	## VER: 2011-04-28, v1.0

	func = check_func(func)

	handler_line_no = func.func_code.co_firstlineno
	py_file = func.func_code.co_filename

	file1 = open(py_file)
	lines = file1.readlines()
	file1.close()

	handler_code = ''

	line1 = lines[handler_line_no - 1][:-1]
	line1 = line1.rstrip()
	line0 = line1.lstrip()
	handler_code = handler_code + line0

	if line1[-2:] != '):':
		line2 = lines[handler_line_no][:-1]
		line2 = line2.rstrip()
		line0 = line2.lstrip()
		handler_code = handler_code + line0

		if line2[-2:] != '):':
			line3 = lines[handler_line_no + 1][:-1]
			line3 = line3.rstrip()
			line0 = line3.lstrip()
			handler_code = handler_code + line0

			if line3[-2:] != '):':
				line4 = lines[handler_line_no + 2][:-1]
				line4 = line4.rstrip()
				line0 = line4.lstrip()
				handler_code = handler_code + line0

	return handler_code

def get_function_info(func):
	## VER: 2011-04-18, v1.0

	func = check_func(func)

	handler_line = func.func_code.co_firstlineno
	py_file = func.func_code.co_filename

	file1 = open(py_file)
	lines = file1.readlines()
	file1.close()

	return py_file,handler_line,lines

def get_function_pars(func):
	## VER: 2011-04-28, v1.0

	func = check_func(func)
	handler = get_function_handler(func)

	breaks = ['(', ')', ' ', ',', '=', '*']
	loc = handler.find('(')
	handler = handler[loc:-1]

	local_vars = func.func_code.co_varnames

	parameters = []
	for var in local_vars:
		if var in handler:
			loc = handler.find(var)
			if handler[loc-1] in breaks and handler[loc + len(var)] in breaks:
				parameters.append(var)
				handler = handler[loc + len(var):]
		else:
			break

	return parameters

def get_Gr(Ts=None,Troom=None,feature_L=None,v_movement=None,fluid='air', beta=None):
	## VER: 2013-08-09, v1.0

	if Ts in empty:
		Ts = 25

	if Troom in empty:
		Troom = 20

	if feature_L in empty and 'feature_L' in globals().keys():
		feature_L = globals()['feature_L']

	if v_movement in empty:
		if fluid=='air':
			v_movement = 14.8e-6
		elif fluid == 'water':
			v_movement = 1.01e-6
		elif fluid == 'oil':
			v_movement = 1.19e-3

	Ts = Ts + 273.15
	Troom = Troom + 273.15

	if beta in empty:
		beta = 1/Ts

	g = 9.81   ## m/s2

	print 'v_movement=',v_movement
	Gr = beta*g*feature_L**3*abs(Ts-Troom)/(v_movement*v_movement)
	Gr = int(Gr)
	globals()['Gr'] = Gr

	print 'Gr=',Gr
	if Gr < 1e8:
		print 'Gr < 1e8, laminar flow'
	elif Gr > 1e9:
		print 'Gr > 1e9, turbulant flow'
	else:
		print '1e8 < Gr < 1e9'

	print 'Ts=',Ts-273.15,'degC,  Troom=', Troom-273.15, 'degC'
	print '--'

	return

def get_hc(Ts, Tg=None, Nu=None, fluid='air', flow_shape='shaft_external', Kf=None, feature_L=None, radius=None):
	## VER: 2013-08-27, v1.1
	## 与温度有关。

	## Nu: 努赛尔数
	## Kf: 流体的热导率, 单位：W/(m.K)
##	空气的热导率(W/m.K):
##	-100C: 0.0158,
##	0C: 0.0241,
##	100C: 0.0317,
##	1000C: 0.0760

	## Example:
##	>>> get_Re(rpm=150, rotate_D=0.2)
##	Re= 42453
##	feature_L= 0.2 m
##	>>> get_Nu()
##	Use global Re = 42453
##	Pr= 0.701
##	Nu= 143.7794
## >>> get_hc()
## Use global Nu = 143.7794
## Use global feature_L = 0.2 m
## Tg= 21.0 degC
## According to hc = Nu*Kf/feature_L, hc= 18.5 W/(m2*K)
## >>>

	if Nu in empty and 'Nu' in globals().keys():
		Nu = globals()['Nu']
		print "Use global Nu =",Nu

	if feature_L in empty:
##		if flow_shape == 'shaft_external':
##			if radius in empty:
##				raise Exception('*** radius of the shaft is required.')
##			feature_L = 2*radius
		if 'feature_L' in globals().keys():
			feature_L = globals()['feature_L']
			print "Use global feature_L =",feature_L,'m'
		else:
			raise Exception('*** feature_L is required.')

	if Kf in empty and fluid == 'air':
		Kf = get_air_conductivity(Tg=Tg, Ts=Ts)

	hc = Nu*Kf/feature_L
	hc = round(hc,1)
	print 'According to hc = Nu*Kf/feature_L,',
	print 'hc=',hc,'W/(m2*K)'
##	print 'Local variable feature_L=',feature_L

	avg = hc
	if 'Nus' in globals().keys():
		hcs = {}
		sum = 0
		for key in Nus.keys():
			hcs[key] = Nus[key]*Kf/feature_L
			hcs[key] = round(hcs[key],1)
			sum = sum + hcs[key]
		print 'hcs =',hcs
		avg = round(sum/len(hcs),1)
		print 'average_hc=',avg

	return avg

def get_hiden_insts():
	## VER: 2014-04-24, v1.0

	display = get_display_now()
	if type_of(display) != 'ASSEMBLYDISPLAYOPTIONS':
		raise Exception('*** Assembly display is required.')

	visibles = display.visibleInstances
	hides = unselect(a.instances.keys(), visibles)

	return hides

def get_repository(obj):
	## VER: 2014-07-15, v1.0

	## Reference: get_parent(), get_repository(), get_repository_key(), type_of_repository()

##>>> p1 = a.instances['carbide_A1']
##>>> get_repository(p1)
##mdb.models['Model-1'].rootAssembly.features
##>>>

	parent = get_parent(obj)
	text1 = repr(parent)
	type1 = type_of(obj)

##	print fnln(),'type1=',type1
	house = None
	if type1 == 'PART':
		house = _m.parts
	elif type1 == 'PINSTANCE':
		house = a.features
	elif type1 in ['cells','faces','edges','vertices']:
		house = eval(text1 + '.' + type1)
	elif type1 == 'FEATURE':
		if type_of(parent) == 'PART':
			house = eval(text1 + '.features')
		elif type_of(parent) in ['PINSTANCE','ASSEMBLY']:
			house = a.features
	elif type1 == 'SET':
		if type_of(parent) == 'PART':
			house = eval(text1 + '.sets')
		elif type_of(parent) in ['PINSTANCE','ASSEMBLY']:
			house = a.sets
	elif type1 == 'SURFACE':
		if type_of(parent) == 'PART':
			house = eval(text1 + '.surfaces')
		elif type_of(parent) in ['PINSTANCE','ASSEMBLY']:
			house = a.surfaces

	return house

function_labels['get_sequence_index'] = 'list','tuple','index','sequence'
def get_sequence_index(sequence, value=None, partial=None, first_one=True, last_one=False):
	## VER: ('VER: 2016-12-19, v1.2')
	## 在一个列表中出现的位置
	## reference: get_repository_key()

	## index = get_sequence_index(_m.steps,step)   ## index=0代表Initial step

##	>>> get_sequence_index(_m.steps.keys(),'step2')
##	2
##	>>>

##	>>> get_sequence_index(_m.boundaryConditions,BC)
##	0
##	>>>

	if type_of(sequence) == 'REPOSITORY':
		if value in sequence.values():
			sequence = sequence.values()
		elif value in sequence.keys():
			sequence = sequence.keys()

	if last_one == True:
		first_one = False

	sequence = tolist(sequence)

	indexs = []
	if partial in empty:
		if value not in sequence:
			indexs = [-1]
		else:
			for i in range(len(sequence)):
				if sequence[i] == value:
					indexs.append(i)

	elif type_of(partial) == 'STR':
		for i in range(len(sequence)):
			if type_of(sequence[i]) == 'STR' and partial in sequence[i]:
				indexs.append(i)

	if first_one == True:
		index = indexs[0]
	elif last_one == True:
		index = indexs[-1]

	return index

function_labels['get_inputs'] = 'function parameters','user input','local'
def get_inputs(locals1,default_pars=None,xKeys=(),xValues=()):
	## VER: 2012-12-11, v1.3

	if type_of(locals1) != 'DICT':
		raise Exception('****** locals() is required for input.')

	if default_pars == None:
		default_pars = get_func_defaults(caller_name())

	xKeys = tolist(xKeys)
	xValues = tolist(xValues)
	if default_pars in empty:
		default_pars = {}

	if type_of(default_pars) == 'DICT':
		defaults = default_pars.items()
	elif type_of(default_pars) in ['TUPLE','LIST']:
		if len(default_pars) > 0 and type_of(default_pars[0]) in ['TUPLE','LIST']:
			if len(default_pars[0]) == 2:
				defaults = default_pars
			else:
				print fnln_fnln(),'default_pars=',default_pars
				defaults = []
		else:
			print fnln_fnln(),'default_pars=',default_pars
			defaults = []
	else:
		print fnln_fnln(), 'default_pars=',default_pars
		defaults = []

	if defaults in empty:
		raise Exception('Fail to get the inputs of default vars, caller=' + totext(caller_fnln()))

	pars = {}
	for k,v in defaults:
		if k not in xKeys:
			v1 = locals1[k]
			if v != v1 and v1 not in xValues:  ## 只记录非缺省的参数。
				pars[k] = v1

	for key in pars.keys():
		v = pars[key]
		if type_of(v) not in basic_types:
			try:
				pars[key] = v.name
			except:
				pars[key] = type_of(v)

		elif type_of(v) in ['TUPLE','LIST'] and len(v) > 0:
			if type_of(v[0]) not in basic_types:
				list1 = []
				for item in v:
					try:
						v1 = item.name
					except:
						v1 = type_of(item)

					list1.append(v1)
				pars[key] = list1

	return pars

function_labels['get_insert_dome'] = 'concave','convex'
def get_insert_dome(p1):
	## VER: 2016-09-08, v1.0

	p1 = check_poi(p1)

	nodes_top = node_select(p1,PRz=(MAX,-1))
	nodes_bot = node_select(p1,PRz=(MIN,1))

	if len(nodes_top) > 1.5*len(nodes_bot):
		dome = 'zmin'
	elif len(nodes_bot) > 1.5*len(nodes_top):
		dome = 'zmax'
	else:
		dome = 'unknow'

	return dome

def get_inst_index_in_field(inst):

	## VER: ('VER: 2012-04-04, v1.0')

	inst = check_odb_inst(inst)
	index = get_sequence_index(oa.instances.keys(),inst.name)

	return index

def objs_of_internal_set(setname,poi=None):
	## VER: 2016-12-16, v1.3
	## open the cae file of multi-cavity jobs: A0210 for double check

##>>> surf2 = a.allInternalSurfaces.values()[0]
##>>> type_of(surf2)
##'SURFACE'
##>>>

	if type_of(setname) in ['PART','PINSTANCE','ASSEMBLY'] and type_of(poi) == 'STR':
		setname,poi = poi,setname

	if type_of(setname) != 'STR':
		raise Exception('******internal setname or internal surface name is required.')

	if poi in empty:
		poi = a

	poi = check_pias(poi,force_list=True)
	if poi not in empty:
		poi = poi[0]
	else:
		poi = a

	internal_sets = poi.allInternalSets.keys()
	internal_surfs = poi.allInternalSurfaces.keys()

	objs = []
	set1 = None
	surface = False
	if setname in internal_surfs:   ## region type
		set1 = poi.allInternalSurfaces[setname]
		surface = True

		if set1 not in empty:
			if len(set1.faces) > 0:
				objs = tolist(set1.faces)
			elif len(set1.edges) > 0:
				objs = tolist(set1.edges)
			elif len(set1.elements) > 0:
				objs = tolist(set1.elements)
			elif len(set1.nodes) > 0:
				objs = tolist(set1.nodes)

	elif setname in internal_sets:  ##????? 结果形式为array, setname的形式如：_G159, _PickedSet107, cell_A1._G36_#5
		set1 = poi.allInternalSets[setname]

		if set1 not in empty:
			if len(set1.cells) > 0:
				objs = tolist(set1.cells)
			elif len(set1.faces) > 0:
				objs = tolist(set1.faces)
			elif len(set1.edges) > 0:
				objs = tolist(set1.edges)
			elif len(set1.vertices) > 0:
				objs = tolist(set1.vertices)
			elif len(set1.elements) > 0:
				objs = tolist(set1.elements)
			elif len(set1.nodes) > 0:
				objs = tolist(set1.nodes)
			elif len(set1.referencePoints) > 0:
				objs = tolist(set1.referencePoints)

			if len(objs) == 0:
				objs = leaf_ids_to_insts(set1.instances)

	else:
		print fnln_fnln(),'******',setname,'not the internal sets/surface of',poi.name,', Please check.'

	return objs

def get_common_space(space1,space2,space3):
	## VER: 2014-05-23, v1.0

	s1,s2,s3,s4,s5,s6 = space1
	m1,m2,m3,m4,m5,m6 = space2
	n1,n2,n3,n4,n5,n6 = space3

	v1 = get_repeated(s1,m1,n1)
	v2 = get_repeated(s2,m2,n2)
	v3 = get_repeated(s3,m3,n3)
	v4 = get_repeated(s4,m4,n4)
	v5 = get_repeated(s5,m5,n5)
	v6 = get_repeated(s6,m6,n6)

	return v1,v2, v3,v4,v5, v6

def get_connected_edges(p,loc=(),edges=None):
	## VER: 2015-11-16, v1.1
	## To find a loop of edges

	## Example:
	## edges = get_connected_edges('base',loc=(0,175.5,0))

	p = check_poi(p)

	if edges not in empty:
		locs0 = locs_of_edges(edges)
		loc = locs0[0]

	if type_of(loc) == 'vertices':
		loc = loc.pointOn[0]

	if is_location(loc) == False:
		raise Exception('*** A vertice or a point location is requried.')

	pshape = part_shape(p)[1]

	curves = edges_at(p,loc=loc)
	curves = [curves[0]]
	if curves not in empty:
		found = True
		while found:
			newlist = []
			edges1 = curves[-1].getAdjacentEdges()
			for edge in edges1:
				if 'shell' in pshape and len(edge.getFaces()) > 1:
					continue
				elif 'solid' in pshape and len(edge.getFaces()) > 2:
					continue
				newlist.append(edge)

			if len(curves) > 1:
				edges1 = curves[-2].getAdjacentEdges()
				for edge in edges1:
					if 'shell' in pshape and len(edge.getFaces()) > 1:
						continue
					elif 'solid' in pshape and len(edge.getFaces()) > 2:
						continue
					newlist.append(edge)

			edges1 = newlist
			edges2 = unselect(edges1,curves)

			if edges2 in empty:
				break
			else:
				curves = curves + edges2

	print fnln(),'--->',len(curves),'edges are found in connected.'

	return curves

def get_connected_geometry(sketch,loc):
	## VER: 2015-04-20, v1.0

	sketch = check_sketch(sketch)
	if type_of(loc) == 'vertices':
		loc = loc.coords
	if is_location(loc) == False:
		raise Exception('*** A vertice or a point location is requried.')

	locs = [loc]
	curves = geometry_at(sketch,loc=loc)
##	print fnln(),'curves=',curves
##	raise Exception

	if curves not in empty:
		for i in range(len(sketch.geometry)):
			for curve1 in sketch.geometry.values():
				if curve1.getSize() < 0:	## construction
					continue

				if curve1 in curves:
					continue

				locs1 = vertice_locs_of_geometry(sketch, curve1)
				locs2 = loc_unselect(locs1,	locs)	## remove possible common locs
				if len(locs2) < len(locs1):
					curves.append(curve1)

				locs = vertice_locs_of_geometry(sketch, curves)	## expand locs

	print fnln(),'--->',len(curves),'geometry are found in connected.'

	return curves

def get_constraint_info(contact):
	## VER: 2014-06-11, v1.2

	if contact in _m.constraints.keys():
		contact = _m.constraints[contact]

	if contact not in _m.constraints.values():
		raise Exception('*** constraint is required.')

	info = {}
	if 'master' in contact.__members__:
		master_region = contact.master
		info1 = get_region_info(master_region,region_type='surface')

		info['mfaces'] = info1['objs']
		info['master'] = info1['pois']
		try:
			info['msize'] = size_of_objs(info1['objs'])
		except:
			info['msize'] = 'NA'

		info['mnum'] = len(info1['objs'])
		info['mtype'] = info1['obj_type']
		info['msurface'] = info1['region_name']

	if 'slave' in contact.__members__:
		slave_region = contact.slave
		info1 = get_region_info(slave_region,region_type='surface')
##		myprint(info1)

		info['sfaces'] = info1['objs']
		info['slave'] = info1['pois']
		try:
			info['ssize'] = size_of_objs(info1['objs'])
		except:
			info['ssize'] = 'NA'

		info['snum'] = len(info1['objs'])
		info['stype'] = info1['obj_type']
		info['ssurface'] = info1['region_name']

	if 'surface' in contact.__members__:
		region = contact.surface
		info1 = get_region_info(region)

		info['faces'] = info1['objs']
		info['insts'] = info1['pois']
		try:
			info['surface_size'] = size_of_objs(info1['objs'])
		except:
			info['surface_size'] = 'NA'

		info['obj_num'] = len(info1['objs'])
		info['obj_type'] = info1['obj_type']
		info['surface'] = info1['region_name']

	if 'controlPoint' in contact.__members__:
		info['couplingType'] = contact.couplingType
		info1 = get_region_info(contact.controlPoint)
		info['controlPoint'] = info1['region_name']
		info['point_type'] = info1['obj_type']

	return info


def get_interact_surface(contact):
	## VER: 2014-06-11, v1.2

	if contact in _m.interactions.keys():
		contact = _m.interactions[contact]

	if contact not in _m.interactions.values():
		raise Exception('*** interaction is required.')

	info = {}
	if 'master' in contact.__members__:
		master_region = contact.master
		info1 = get_region_info(master_region,region_type='surface')

		info['mfaces'] = info1['objs']
		info['master'] = info1['pois']
		try:
			info['msize'] = size_of_objs(info1['objs'])
		except:
			info['msize'] = 'NA'

		info['mnum'] = len(info1['objs'])
		info['mtype'] = info1['obj_type']
		info['msurface'] = info1['region_name']

	if 'slave' in contact.__members__:
		slave_region = contact.slave
		info1 = get_region_info(slave_region,region_type='surface')
##		myprint(info1)

		info['sfaces'] = info1['objs']
		info['slave'] = info1['pois']
		try:
			info['ssize'] = size_of_objs(info1['objs'])
		except:
			info['ssize'] = 'NA'

		info['snum'] = len(info1['objs'])
		info['stype'] = info1['obj_type']
		info['ssurface'] = info1['region_name']

	if 'surface' in contact.__members__:
		region = contact.surface
		info1 = get_region_info(region)

		info['faces'] = info1['objs']
		info['insts'] = info1['pois']
		try:
			info['size'] = size_of_objs(info1['objs'])
		except:
			info['size'] = 'NA'

		info['obj_num'] = len(info1['objs'])
		info['obj_type'] = info1['obj_type']
		info['surface'] = info1['region_name']

	return info

def get_inner_faces(poi,faces=None, nx=None, ny=None, nz=None, ndir=None, angle=25, bypick=True):
	## VER: 2014-01-17, v1.3
	## Example: faces2 = get_inner_faces(stamp_A1,bypick=True)

	## faces = get_inner_faces('carbide_A1') ## 3D model, get the inner faces of carbide linner in the press tool, these face will contact powder.

	poi = check_pias(poi)

	if type_of(faces) == 'STR':
		faces = set2objs(poi,faces)

	if faces in empty:
		faces = tolist(poi.faces)

##	if (ref_nx, ref_ny, ref_nz) != (None, None, None):
##		if ref_nx in [-1, 1]:
##			faces = face_select(poi, faces=faces, ndir='x',nx=ref_nx)
##			if faces in empty:
##				raise Exception('*** Fail to find the internal faces with ndir = x')
##
##		elif ref_ny in [-1, 1]:
##			faces = face_select(poi, faces=faces, ndir='y',ny=ref_ny)
##			if faces in empty:
##				raise Exception('*** Fail to find the internal faces with ndir = y')
##
##		elif ref_nz in [-1, 1]:
##			faces = face_select(poi, faces=faces, ndir='z',nz=ref_nz)
##			if faces in empty:
##				raise Exception('*** Fail to find the internal faces with ndir = z')

	newlist = []
	for face1 in faces:
		if len(face1.getCells()) != 1:
			continue

		if is_inner_plane(face1):
			if bypick == True:
				if face1 not in newlist:
					newlist.append(face1)
			else:
				newlist = connect_all_faces(face1, angle=angle)
				break
		else:
			shape = AV_shape(face1)
			if shape == 'U':
				if bypick == True:
					if face1 not in newlist:
						newlist.append(face1)
				else:
					newlist = connect_all_faces(face1, angle=angle)
					break

	faces = newlist

	faces = face_select(poi,faces=faces, nx=nx, ny=ny, nz=nz, ndir=ndir)

	print fnln(), len(faces),'inner faces are found.'

	return faces

def get_intersect_angle(obj1,obj2=None,axis=None,plane=None):
	## VER: 2013-12-20, v1.2. axis =x, y, or z
	## If you provide a plane as an argument, Abaqus/CAE computes the angle using the normal to the plane

##>>> axis1 = create_datum_axis(anvil,'x')
##>>> axis2 = create_datum_axis(anvil,'y')
##>>> get_intersect_angle(obj1 = axis1, obj2 = axis2)
##The angle between the arrows is 90.000000 degrees
##(90.0, 1)
##>>>

	plane1 = None
	plane2 = None
	line1 = None
	line2 = None

	type1 = type_of(obj1)
	if type1 in ['edges', 'DATUMAXIS']:
		line1 = obj1
	elif type1 in ['faces', 'DATUMPLANE']:
		plane1 = obj1
	else:
		raise Exception('*** one edge or plane face is required.')

	poi = get_poi(obj1)
	if type_of(poi) == 'PINSTANCE':
		poi = a

##	print type_of(obj2)
	if obj2 not in empty:
		if type_of(obj2) not in ['edges','faces','DATUMAXIS','DATUMPLANE']:
			print 'Usage: get_interset_angle(obj1,obj2=None,axis=None,plane=None)'
			raise Exception('*** one edge, plane face, datum axis, or datum plane is required.')

	else:  ## obj2 in empty
		if axis in empty and plane in empty:
			raise Exception('*** axis or datum plane is required.')

		if axis not in empty:
			axis = totext(axis)
			axis = axis.lower()

			if axis not in ['x','y','z']:
				raise Exception('*** axis should be x, y, or z')

			if axis == 'x':
				obj2 = create_axis_x(poi)
			elif axis == 'y':
				obj2 = create_axis_y(poi)
			elif axis == 'z':
				obj2 = create_axis_z(poi)

		elif plane not in empty:
			plane = totext(plane)
			plane = plane.lower()

			if plane not in ['xoy','yoz','xoz','zox']:
				raise Exception("*** plane should be 'xoy','yoz','xoz' or 'zox'")

			if plane == 'xoy':
				obj2 = create_datum_plane_by_offset(poi,ndir='z')
			elif plane == 'yoz':
				obj2 = create_datum_plane_by_offset(poi,ndir='x')
			elif plane in ['xoz','zox']:
				obj2 = create_datum_plane_by_offset(poi,ndir='y')

	type2 = type_of(obj2)
	if type2 in ['edges','DATUMAXIS']:
		line2 = obj2
	elif type2 in ['faces','DATUMPLANE']:
		plane2 = obj2

	if line1 in empty and plane1 in empty:
		raise Exception('*** fail to get line1 or plane1')

	if line2 in empty and plane2 in empty:
		raise Exception('*** fail to get line2 or plane2')

	if plane1 not in empty:   ##必须是一个平面，不能是一个圆柱面。
		if line2 not in empty:
			angle = poi.getAngle(plane1=plane1,line2=line2)
			to_correct = True
		elif plane2 not in empty:
			angle = poi.getAngle(plane1=plane1,plane2=plane2)
			to_correct = False

	elif line1 not in empty:
		if line2 not in empty:
			angle = poi.getAngle(line1=line1,line2=line2)
			to_correct = False
		elif plane2 not in empty:
			angle = poi.getAngle(line1=line1,plane2=plane2)
			to_correct = True

	dir = 1
	if 90 < angle <= 180:
		dir = -1
##		print 'angle corrected. Originally =',angle
		angle = 180 - angle   ## 线的方向为：起点在右，终点在左

	if to_correct == True:
		angle = 90 - angle

	return angle,dir

def get_jobnum_and_runtime(stepname=None):
	## VER: 2013-08-20, v1.2

	Title0 = []
	Time0 = []

	if stepname not in odb.steps.keys():
		stepname = odb.steps.keys()[-1]

	Title0 = [odb_file_title,'step=' + stepname]

##	try:
##		run_time = get_runtime(odb) + cae_time   ## cae_tme not defined
##	except:

	try:
		run_time = get_runtime(odb)
	except:
		run_time = 999

	run_time = round(run_time, 1)
	last_frame = odb.steps[stepname].frames[-1]   ## example: odb.steps.keys() = ['step1', 'step2', 'step3']
	step_time = last_frame.frameValue
	if step_time > 0:
		time1 = str(run_time) + 'min'
		Time0 = ['run_time', time1]

##	print fnln_fnln(),Title0 + Time0

	return Title0 + Time0

def get_K1c(D1D2=(), cracks=(), kg=30):
	## VER: 2014-07-11, v1.0

##>>> get_K1c((124.3, 120, 126.2, 124.7), (169.5, 171.2))
##(1917, 9.36)
##>>> get_K1c(169.7, (134.2, 135.9, 129.6, 128.5))
##(1932, 9.1)
##>>> (1917+1932)/2.0
##1924.5
##>>> (9.1+9.36)/2
##9.23
##>>>

	D1D2 = tolist(D1D2)
	cracks = tolist(cracks)

	if len(D1D2) == 4 and len(cracks) in [1,2]:
		D1D2, cracks = cracks, D1D2

	if len(D1D2) == 1:
		D1D2 = [D1D2[0], D1D2[0]]
	D = sum(D1D2)/2.0
	Dm = D/1000   ## unit: m

	length = sum(cracks) / 4.0
	total_length = sum(cracks)/1000  ## unit: m

	C = D + length
	Hv = 1.8544*kg/(Dm*Dm)
	K1c = 0.0028*9.81*sqrt(Hv*kg/total_length)

	Hv = int(round(Hv))
	K1c = round(K1c, 2)

	return Hv, K1c

def get_repository_key(obj,substring=None):
	## VER: 2016-03-01, v1.4, 又名: get_index()。
	## 注意有时单元的label不等于index+1，此时需要用get_index(element)来获得index，则对生成sequence很重要。
	## 数字类型的index和字典key类型的index统称index。

	## Reference: get_parent(), get_poi(), get_sequence_index(),
	## get_parent()获得小数点之前的内容，get_repository_key()获得[]中的内容。
	## get_repository_key(): 获得某个元素在某个repository或dict中的key
	## get_sequence_index(): 获得某个元素在某个tuple或者list中的出现的位置。
	## type_of_repository(): 获得repository本身的名字，例如：sets, parts, etc.
	##      'Repository' object is not iterable

	##>>> e1
	##mdb.models['Model-1'].parts['p1'].elements[127478]
	##>>> get_index(e1)
	##127478
	##>>> e1.label
	##1041
	##>>>

	## Odb label is stored with index = label - 1, such as:
##	>>> nodes = oa.instances.values()[0].nodes
##	>>> nodes[720].label
##	721

##	>>> frame
##	session.openOdb(r'E:/FEM/A0212/E8_A0212_rotary_initialV700_test.odb').steps['step1'].frames[1]
##	>>> get_repository_key(frame)
##	1
##	>>>

	## example:
##	r1[35] = mdb.models['Model-1'].rootAssembly.referencePoints[35]
##	type_of(r1[35] = type_of(r1[35])
##	get_repository_key(get_repository_key(r1[35],'referencePoints')) = 35

	## Example:
	## csys1 = mdb.models['Model-1'].parts['carbide1']
	## get_repository_key(csys1,'model') = 'Model-1'
	## get_repository_key(csys1,'part') = 'carbide1'

	## Text1 = "mdb.models['Model-1'].parts['carbide1']"
	## get_repository_key(Text1,'model') = 'Model-1'

##	>>> faces = shaft_A1.faces[0]
##	>>> get_parent(faces)
##	mdb.models['Model-1'].rootAssembly.instances['shaft_A1']

##>>> v1
##mdb.models['Model-1'].sketches['sk_nib'].vertices.findAt((5.31956002404528, 1.48),)
##>>> prettyPrint(v1)
##({'coords': 'tuple object'})
##>>> v1.id  ## 草图的几何点没有id这个特性
##AttributeError: 'ConstrainedSketchVertex' object has no attribute 'id'
##>>> type_of(v1)
##'vertices'
##>>>
##>>> id_of_sketch_vertice
##<function id_of_sketch_vertice at 0x7B2F4CB0>
##>>>
##>>> id_of_sketch_vertice(v1)
##6
##>>> v1.coords
##(5.31956002404528, 1.48)
##>>> s1.vertices[6]
##mdb.models['Model-1'].sketches['sk_nib'].vertices.findAt((5.31956002404528, 1.48),)
##>>>

	if type_of(obj) == 'vertices' and 'sketches' in repr(obj):
		id = id_of_sketch_vertice(obj)
		return id

	if type_of(obj) in ['cells','faces','edges','vertices']:
		return obj.index   ##也就是诸如part.edges[index]

##		>>> get_index(edges[0])
##		1
##		>>> edges[0]
##		mdb.models['Model-1'].parts['powder'].edges.findAt((8.023, 41.944776, 0.0),)
##		>>> _part('powder').edges[2]
##		mdb.models['Model-1'].parts['powder'].edges.findAt((2.00575, 55.92637, 0.0),)
##		>>> _part('powder').edges[1]
##		mdb.models['Model-1'].parts['powder'].edges.findAt((8.023, 41.944776, 0.0),)
##		>>>

##	>>> dg
##	session.displayGroups['arc_ymax']
##	>>>
##	>>> get_index(dg)
##	'arc_ymax'
##	>>>

	object = False
	if type_of(obj) not in basic_types:
		string1 = repr(obj)
		if substring in empty:
			if string1[-1] == ']':
				string1 = string1[:-1]
				loc = string1.rfind('[')
				index = string1[loc+1:]
				if index.isdigit():
					return eval(index)

		string1 = repr(obj)
		object = True
		if substring in empty:
			substring = type_of(obj)

	else:  ## basic types
		if type_of(obj) == 'STR':
			string1 = obj
			if string1.startswith('mdb.') or string1.startswith('odb.') or string1.startswith('session.'):
				object = True

		else:
			string1 = totext(string1)

	if type_of(substring) != 'STR':
		raise Exception('**** substring is required.')

	if substring[0] != '.':
		substring = '.' + substring     ## begin with '.'

	if object == True:
		if substring[-1] not in ['s','[']:
			substring = substring + 's'

	if substring[-1] != '[':
		substring = substring + '['     ## end with '['

	loc = string1.upper().find(substring.upper())
	if loc == -1:
		print('**** Fail to get the key name. string1 = '+ string1 + ', substring = ' + substring)
		return None

	string2 = string1[loc + len(substring):]

	if ']' not in string2:
		print('**** Fail to get the key name.')
		return None

	loc1 = string2.find(']')
	key = string2[0:loc1]

	key = totext(key)
	if key.isdigit():
		key = eval(key)

	return key

function_labels['get_hole_diameter'] = 'nodes','results','radius','postprocessing','insert'
def get_hole_diameter(nodes,ndir=None,axis=None):
	## VER: 2016-11-17, v1.0

	## create a node set for the hole, name='hole1'
##	>>> get_hole_diameter('hole',ndir='z')
##	['get_p1', 38865] Created global var p1. You can use in GUI command.
##	['get_p1', 38866] p1.name= OB50
##
##	7.896
##	>>>

	if type_of(nodes) == 'STR':
		nodes = set2objs(get_p1(),nodes)

	nodes = tolist(nodes)

	if axis not in empty:
		ndir = axis

	if type_of(ndir) == 'STR':
		ndir = ndir.lower()
		if ndir not in ['x','y','z']:
			raise Exception('*** ndir should be x,y or z')

	locs = []
	for node in nodes:
		x,y,z = node.coordinates
		if ndir in empty:  ## slope
			loc = (x,y,z)
		elif ndir == 'x':
			loc = (0,y,z)
		elif ndir == 'y':
			loc = (x,0,z)
		elif ndir == 'z':
			loc = (x,y,0)

		locs.append(loc)

	locs = randomize(locs)

	dists = []
	for i in range(int(len(locs)/2)):
		gaps = []
		for loc in locs:
			gap = get_dist(locs[i],loc)
			gaps.append(gap)
		dists.append(max(gaps))

	dist = max(dists)
	dist = round(dist,3)

	return dist

function_labels['get_hole_nodes'] = 'hole nodes','diameter','open','mouth','fix','insert','sintering','feature'
def get_hole_nodes(p1,set_nodes=None,zend=None):
	## VER: 2016-11-15, v1.0
	## you can create the set for hole nodes in GUI, for sure.

	## get_hole_nodes(get_p1(),'hole1')

	p1 = check_poi(p1)

	if set_nodes in empty:
		if zend not in [MIN,MAX]:
			zend = MIN

		face_nodes = nodes_by_face(p1,zend=zend,angle=5)   ## select of face_nodes may be error for complex shape
		nodes1 = node_select(p1,nodes=face_nodes,Gx=MID,err=2)  ## 0.5
		nodes1 = nodes_sort_byy(nodes1)

		gaps = []
		dict1 = {}
		for i in range(len(nodes1)-1):
			dist = get_distance(nodes1[i],nodes1[i+1])
			dict = round(dist,6)
			gaps.append(dist)
			dict1[dist] = [nodes1[i],nodes1[i+1]]
		gap = max(gaps)

		nodes0 = dict1[gap]
		nodes = nodes0[0].getNodesByFeatureEdge(20) ## angle=20

	else:
		if type_of(set_nodes) == 'STR':
			if type_of(p1) == 'PINSTANCE':
				p1 = a
			set_nodes = set2objs(p1,setname=set_nodes)
		nodes = tolist(set_nodes)

	nodesy = nodes_sort_byy(nodes)
	nodesx = nodes_sort_byx(nodes)

	x0,y0,z0 = nodesx[0].coordinates
	x1,y1,z1 = nodesx[-1].coordinates
	dx = x1 - x0

	x0,y0,z0 = nodesy[0].coordinates
	x1,y1,z1 = nodesy[-1].coordinates
	dy = y1 - y0

	dx = smart_round(dx)
	dy = smart_round(dy)

	dict2 = {}
	dict2['dy'] = dy
	dict2['dx'] = dx
	dict2['ynodes'] = [nodesy[0],nodesy[-1]]
	dict2['xnodes'] = [nodesx[0],nodesx[-1]]
	dict2['nodes'] = nodes
	dict2['D'] = (dx+dy)/2

	return dict2

def get_index(obj,substring=None):
	## reference: get_sequence_index()

	## Reference: get_parent(), get_poi(), get_sequence_index(),
	## get_parent()获得小数点之前的内容，get_repository_key()获得[]中的内容。
	## get_repository_key(): 获得某个元素在某个repository或dict中的key
	## get_sequence_index(): 获得某个元素在某个tuple或者list中的出现的位置。
	## type_of_repository(): 获得repository本身的名字，例如：sets, parts, etc.
	##      'Repository' object is not iterable

	return get_repository_key(obj=obj,substring=substring)

function_labels['get_last_step_frame_index'] = 'number','step index','increment','frame'
def get_last_step_frame_number():
	## VER: 2016-11-13, v1.0

	last_step_number = odb.steps.values()[-1].number  ## number=1时，step index = 0，即第一个分析步
	last_frame_number = odb.steps.values()[-1].frames[-1].frameId  ## 若最好一个frame的index=17，则framenumber=18(framenumber=1时为初始状态，没有结果)
	## increment number也就是frameId

	return last_step_number, last_frame_number

def get_leaf_of_assembly_sets(setnames,insts=None):
	## VER: 2012-12-11, v1.1

	setnames = tolist(setnames)
	insts = real_insts(insts)
	if insts in empty:
		insts = a.instances.values()

	sets = []
	for inst in insts:
		for set1 in setnames:
			for set2 in inst.sets.keys():
				if set1.upper() == set2.upper():
					sets.append(inst.sets[set2])
					break

	sets = totuple(sets)
	leaf = dgm.LeafFromSets(sets=sets)

	return leaf

function_labels['get_leaf_of_odb_sets'] = 'element','eset'
def get_leaf_of_odb_sets(setname,inst=None):
	## VER: 2012-08-30, v1.6 用于后处理.

	global _ndel, odb,a1

	vpnow = get_vpnow()
	odb = vpnow.displayedObject
	a1 = odb.rootAssembly     ## 后处理：a1，与前处理的a不同。

	_ndel = 0
##	ttl()

	setname = tolist(setname)
	if type_of(setname[0]) != 'STR':
		raise Exception('******setname required.')

	if len(setname) == 1:
		setname = setname[0].upper()
		dot = setname.find('.')
		name = setname[dot + 1:]
		esets = inst_dot_esets(name,inst=inst)

		if dot == -1:   ## 不存在点
			if len(esets) > 0:
				leaf = dgo.LeafFromElementSets(elementSets=esets)
			else:
				insts = []
				for inst in a1.instances.keys():
					if setname in inst:
						insts.append(inst)
				insts = tuple(insts)

				if len(insts) > 0:
					leaf = dgo.LeafFromPartInstance(partInstanceName=insts)
				else:
					raise Exception('******No eset or instance found by name= ' + repr(setname))

		else:
			if setname in esets:
				leaf = dgo.LeafFromElementSets(elementSets=(setname,))
			else:
				raise Exception('****** No such eset= ' + repr(setname))

	elif len(setname) > 1:
		dot = setname[0].find('.')
		if dot == -1:
			esets = []
			for name in setname:
				name1 = name.upper()
				esets1 = inst_dot_esets(name1)
				esets = esets + tolist(esets1)

			if len(esets) > 0:
				print 'Found esets=',esets
				print 'tips: aquire esets by their materials.'
				esets = totuple(esets)
				leaf = dgo.LeafFromElementSets(elementSets=esets)

			else:
				insts = []
				for name in setname:
					name1 = name.upper()
					for inst in a1.instances.keys():
						if name1 in inst:
							insts.append(inst)

				if len(insts) > 0:
					insts = tuple(insts)
					print 'Found insts=',insts
					leaf = dgo.LeafFromPartInstance(partInstanceName=insts)
				else:
					raise Exception('******Fail to find esets or insts by ' + repr(setname))

		elif dot >=0:
			esets = []
			for name in setname:
				name1 = name.upper()
				esets0 = inst_dot_esets(name1)
				if name1 in esets0:
					esets.append(name1)

			if len(esets) > 0:
				esets = totuple(esets)
				leaf = dgo.LeafFromElementSets(elementSets=esets)
			else:
				raise Exception('****** No such esets= ' + repr(setname))

	return leaf

def get_aspect_ratio(powder):
	## VER: 2013-11-14, v1.0

	powder = check_pias(powder)
	PFH = _ymax(powder) - _ymin(powder)
	area = get_area(powder)

	ratio = PFH*PFH/area
	ratio = round(ratio, 4)

	return ratio

def get_attrib(obj,name):
	## VER: 2013-07-16, v1.0

	if type_of(name) != 'STR':
		raise Exception('*** attribute name is required.')

	exist = False
	if mems_num(obj) > 0 and name in obj.__members__:
		try:
			result = eval('obj.' + name)
		except:
			result = 'unknow'

	elif keys_num(obj) > 0 and name in obj.keys():
		try:
			result = obj[name]
		except:
			result = 'unknow'

	else:
		result = 'unknow'
##		raise Exception('*** ' + name + ' is not an .member or [key] of ' + repr(obj))

	return result

def get_BC_info(BC1):
	## VER: 2014-06-11, v1.1

	if BC1 in _m.boundaryConditions.keys():
		BC1 = _m.boundaryConditions[BC1]

	if BC1 not in _m.boundaryConditions.values():
		raise Exception('*** BC name is incorrect.')

	region_type = None
	BC_type = type_of(BC1)
	info1 = get_region_info(BC1,region_type=region_type)
	info1['action_name'] = BC1.name
	info1['action_type'] = BC_type
	info1['description'] = BC1.__doc__

	objs = info1['objs']

	if objs not in empty:
		try:
			size = size_of_objs(objs)
			if type_of(size) not in numerics:
				size = 'NA'
			info1['region_size'] = size
		except:
			info1['region_size'] = 'NA'
		info1['obj_num'] = len(objs)
	else:
		info1['region_size'] = 'NA'
		info1['obj_num'] = 'NA'

	return info1

def get_beam_dir(poi):
	## VER: ('VER: 2012-10-12, v1.2')  ##获取poi的长度方向，poi的长度通过get_poi_length(poi)函数来获得。

	x1,x2,y1,y2,z1,z2 = poi_space(poi)
	dims = [x2 - x1, y2 - y1, z2 - z1]
	dims.sort()
	L = max(dims)
	ratio = round(L/dims[1],2)

	if ratio >= 5:
		if PK(x2 - x1, L) == 0:
			dir1 = 'x'
		elif PK(y2 - y1, L) == 0:
			dir1 = 'y'
		elif PK(z2 - z1, L) == 0:
			dir1 = 'z'
	else:
		dir1 = 'NA'

	return dir1

def fn_get_levels(low=None,high=None,vmin=None,vmax=None,factors=4):
	## 2011-06-26, v1.2

	if factors == 2:
		alpha = 1.414
	elif factors == 3:
		alpha = 1.682
	elif factors == 4:
		alpha = 2.0
	elif factors == 5:
		alpha = 2.378
	elif factors == 6:
		alpha = 2.828

	if low != None and vmin != None:
		high = low*(1+alpha) - alpha*vmin
		print fnln_fnln(),'high=',high

	elif high != None and vmax != None:
		low = high*(1+alpha) - alpha*vmax
		print fnln_fnln(),'low=',low

	elif high != None and vmin != None:
		low = (high + vmin*alpha)/(1+alpha)
		print fnln_fnln(),'low=',low

	elif low != None and vmax != None:
		high = (low + vmax*alpha)/(1+alpha)
		print fnln_fnln(),'high=',high

	elif vmin != None and vmax != None:
		high = vmax - (vmax - vmin)/(2+alpha)
		low = vmin + (vmax - vmin)/(2+alpha)
		print fnln_fnln(),'high=',high,', low=',low

	if vmax == None:
		vmax = high + (high - low)/alpha
		print fnln_fnln(),'vmax=',vmax

	if vmin == None:
		vmin = low - (high - low)/alpha
		print fnln_fnln(),'vmin=',vmin

	ext = (high-low)/alpha
	print 'extend=(high-low)/alpha=',ext

	vmin = round(vmin,2)
	vmax = round(vmax,2)
	low = round(low,2)
	high = round(high,2)
	mid = (high + low)/2

	print '--->vmin=',vmin,', low=',low,', center=',mid,', high=',high,', vmax=',vmax, ', alpha=',alpha
	print ' '

	return vmin,low,high,vmax

def get_line_code(line_no,py_file=None,func=None):
	## VER: 2017-03-08, v1.6, called by get_caller_code()
	## 注意，line_no从0开始，不是从1开始。

	if type_of(func) == 'INT':
		func,line_no = line_no,func

##	print 'caller_lineno=',caller_lineno()
##	print 'caller_name=',caller_name()

	if caller_name() == 'cliCommand':
		line_no = line_no - 1

	if func in empty and py_file in empty:
		py_file = get_file_name()

	if func not in empty:
		if type_of(func) == 'FUNCTION':
			py_file = func.func_code.co_filename
		elif type_of(func) == 'STR':
			if func in dir(__main__):
				func = eval(func)
				py_file = func.func_code.co_filename
			else:
				raise Exception(repr(ln()) + '******No such function name= ' + repr(func))
		else:
			raise Exception(repr(ln()) + '****** Unknow function	=' + repr(func))

	line1 = read_lines(py_file,line_nums=line_no)

##	if type_of(py_file) == 'FILE':
##		name = py_file.name
##		py_file.close()
##		py_file = name
##
##	if type_of(py_file) != 'STR':
##		raise Exception('****** py_file is needed')
##
##	try:
##		file1 = open(py_file)
##		lines = file1.readlines()
##		file1.close()
##
##		line1 = lines[line_no - 1][:-1]
##		line1 = line1.strip()
####		line1 = line1.rstrip()
####		line1 = line1.lstrip()
##	except:
##		line1 = '**** Fail to get_line_code() for file ' + py_file
##
##	line1 = modify_string(line1,'\t','    ')

	return line1

def coords_of_objs(objs,dir=None):
	## VER: 2013-12-05, v1.0

	## Example: coords_of_objs(zmax_faces(stamp),dir='y') ## [-5.34, -4.17433, -1.591352, 1.591352, 4.17433, 5.34]

	vertices = vertices_of_objs(objs)

	locs = []
	for vertice in vertices:
		loc = vertice.pointOn[0]
		if loc not in locs:
			locs.append(loc)

	if type_of(dir) == 'STR':
		dir = dir.lower()
		if dir not in ['x','y','z']:
			raise Exception('*** dir should be in x,y,or z')

		newlist = []
		if dir == 'x':
			for loc in locs:
				x = loc[0]
				if x not in newlist:
					newlist.append(x)
			locs = newlist
		elif dir == 'y':
			for loc in locs:
				y = loc[1]
				if y not in newlist:
					newlist.append(y)
			locs = newlist
		elif dir == 'z':
			for loc in locs:
				z = loc[2]
				if z not in newlist:
					newlist.append(z)
			locs = newlist

		locs.sort()

	return locs


def locs_of_sketch(sketch,x=None,y=None,H=None,V=None,pointOn=True,dir=None, search_in='part',	nearby=5e-3,at_geometry=True,sort=None):
	## VER: 2015-10-29, v1.5
	## reference: locs_of_poi(), find_loc(), ylocs(),xlocs(),zlocs()
	## dir不要改变pointOn的值
	## find_loc()有groupX,groupY， locs_of_sketch()没有。且locs_of_sketch()运行比较慢。
	## reference: locs_of_sketch_vertices()

##	>>> locs_of_sketch('sk_ejector_volume',x=0,pointOn=False)
##	['locs_of_sketch', 26694] search_in= part
##	['locs_of_sketch', 26695] pointOn= False
##	['locs_of_sketch', 26696] dir= None
##	[-10.19, 0]
##	>>>

##	locs0 = locs_of_sketch_vertices('sk_ejector')
##  各种操作
##	new_locs = new_points_of_sketch(sketch,locs0)
##	curves = new_geometry_of_sketch(sketch,curves0)


	if type_of(dir) == 'STR':
		dir = dir.lower()
		dir = dir2num(dir)

	if dir not in empty and dir not in [0,1,2]:
		raise Exception('*** error dir')

	sketch = check_sketch(sketch)

	print fnln(),'search_in=',search_in
	print fnln(),'pointOn=',pointOn
	print fnln(),'dir=',dir

	if search_in == 'part':  ## 一条直线被点剖分后，search_in='sketch'时能找出来，但search_in='part'时忽略了。
		temp_part = sketch_to_wire(sketch)
		locs = locs_of_poi(poi=temp_part, x=x,y=y,pointOn=pointOn,dir=dir, nearby=nearby)
		del _m.parts[temp_part]

		if pointOn == True:
			for i in range(len(locs)):
				locs[i] = locs[i][0],locs[i][1]   ## 2D point

	else:
		sketch2 = copy_sketch(sketch)

		if x not in empty:
			H = x

		if y not in empty:
			V = y

		H0,V0 = H,V
		H,V = real_xy_sketch(sketch2,H=H,V=V)

		if type_of(H) in numerics and type_of(V) not in numerics:   ## V may be None or a range
			dir = 1
			if H0 not in [MIN,MAX]:
				divide_geometry(sketch2, H=H)
		elif type_of(H) not in numerics and type_of(V) in numerics:  ## V may be None or a range.
			dir = 0
			if V0 not in [MIN,MAX]:
				divide_geometry(sketch2, V=V)

		vertices = sketch_vertice_select(sketch2,H=H0,V=V0, at_geometry=at_geometry)  ;please_check
		## compare with sketch_vertice_select(sketch1...)

		pointOns = []
		for point in vertices:
			pointOns.append(point.coords)

		if pointOns not in empty:
			locs1 = []
			for loc in pointOns:
##				loc1 = round_loc(loc)   ## 注意不能round_loc, 否则会影响connect_points()的精度和locs_of_sketch()的结果
				locs1.append(loc)
			pointOns = locs1

		locs = []
		if pointOn == False and pointOns not in empty:
			for loc in pointOns:
				if loc[dir] not in locs:
					locs.append(loc[dir])

			locs.sort()    ## 某个方向的刻度值
		else:
			locs = pointOns   ##点在x,y,z方向的坐标。
			if dir in [0,1] and len(locs) > 1:
				locs = sort_tuple_type_elements(locs,index=dir)

		del _m.sketches[sketch2]

	show_sketch(sketch)

	if sort not in empty:
		locs = sort_locs(locs,index=sort)

	return locs

def locs_of_sketch_vertices(sketch,at_geometry=True,sort=None):
	## VER: 2015-04-20, v1.1

	sketch = check_sketch(sketch)

	locs0 = []
	for vertice in sketch.vertices.values():
		loc = vertice.coords

		if at_geometry == True:
			geom = sketch.geometry.findAt(loc,printWarning=False)
			if geom == None:
				continue

		if loc not in locs0:
			locs0.append(loc)

	if sort not in empty:
		locs0 = sort_locs(locs0,index=sort)

	return locs0

function_labels['locs_of_substring'] = 'index','string','loc'
def locs_of_substring(str1,sub):
	## VER: 2019-09-13, v1.2 获得某个子字符串在整个字符串中出现的位置列表。例如，目录名D:/JYQ/pro/49AC/AF_49AC_W35_plate.py中反斜杠/出现的倒数第二个位置。

	num = len(str1)
##	num = num - 1
	locs = []

	now = 0
	if str1.count(sub) > 0:
		while True:
			num1 = str1.find(sub,now)
			if num1 >= 0 and num1 < num:
				if num1 not in locs:
					locs.append(num1)
					now = num1 + 1
			else:
				break

	return locs

def low_limit(value1=None):
	## VER: 2014-08-25, v1.0

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) == 'ODB':
		if is_number(value1):
			vpnow.odbDisplay.contourOptions.setValues(minAutoCompute=OFF, minValue=value1)
		else:
			vpnow.odbDisplay.contourOptions.setValues(minAutoCompute=ON)

	return

def up_limit(value1=None):
	## VER: 2014-08-25, v1.0

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) == 'ODB':
		if is_number(value1):
			vpnow.odbDisplay.contourOptions.setValues(maxAutoCompute=OFF, maxValue=value1)
		else:
			vpnow.odbDisplay.contourOptions.setValues(maxAutoCompute=ON)

	return

def set_limits(*value1):
	## VER: 2014-08-25, v1.0
	## example: set_limits(0,6294)

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) == 'ODB':
		value1 = tolist(value1)
		if is_number(value1) and len(value1) == 2:
			value1 = _sort(value1)
			vpnow.odbDisplay.contourOptions.setValues(minAutoCompute=OFF, minValue=value1[0], maxAutoCompute=OFF, maxValue=value1[1])
		else:
			vpnow.odbDisplay.contourOptions.setValues(minAutoCompute=ON, maxAutoCompute=ON)

	return

def true_main_var(main_var):
	## VER: 2014-03-24, v1.0
	## Example: 'CNORMF   ASSEMBLY_SURF-2/ASSEMBLY__PICKEDSET39_CNS_'的结果为: CNORMF

	main_var0 = main_var
	if '  ' in main_var and len(main_var) > 20:
		loc = main_var.find('  ')
		main_var0 = main_var[:loc]

	return main_var0

def get_main_sub_var():
	## VER: 2014-11-28, v1.4
	## current main_var and sub_var

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) != 'ODB':
		raise Exception('*** an odb viewport is required.')

	main_var = sub_var = ''		;please_check
	variable = vpnow.odbDisplay.primaryVariableLabel
	if '(' in variable:
		loc = variable.find('(')
		variable = variable[:loc]
		variable = variable.strip()

	main_var = variable
	if ',' in variable:
		loc = variable.find(',')
		main_var = variable[:loc]
		sub_var = variable[loc+1:]
		sub_var = sub_var.strip()

##		if main_var == 'COORD':
##			vars = odb_variables()
##			if sub_var.startswith('COOR') and sub_var[-1] in ['1','2','3']:
##				num = eval(sub_var[-1])
##				sub_var = vars['COORD']['components'][num - 1]

	main_var = main_var.upper()
	main_var = true_main_var(main_var)

	if main_var in empty:
		raise Exception('*** Fail to get the main_var.')

	return main_var,sub_var

def get_dpo_type(viewport=None):
	## VER: 2013-10-12, v1.0

	## reference: get_dpo()

	if viewport in empty:
		viewport = get_vpnow()
	elif type_of(viewport) == 'STR' and viewport in session.viewports.keys():
		viewport = session.viewports[viewport]

	if type_of(viewport) != 'VIEWPORT':
		raise Exception('*** a viewport is required.')

	return type_of(viewport.displayedObject)

def combine_two_faces(faces):
	## VER: 2014-08-28, v1.0

	faces = tolist(faces)
	part = get_poi(poi)
	if is_part(part) == False:
		raise Exception('*** faces should be from part.')

	if len(faces) != 2:
		raise Exception('*** Two faces are required.')

	edges1 = faces_to_edges(faces[0])
	edges2 = faces_to_edges(faces[1])

	edges = get_common(edges1, edges2)
	vertices = edges_to_vertices(edges)

	seq_e = list2sequence(edges)
	seq_v = list2sequence(vertices)

	try:
		part.ignoreEntity(entities=(seq_e, seq_v))
		print '--->Two faces combine sucessfully.'
	except:
		print '*** Fail to combine these two faces.'

	return

def locs_of_objs(objs,index=0):
	## VER: 2015-03-30, v1.0
	## reference: xlocs(),ylocs(),zlocs()

	vertices = vertices_of_objs(objs)

	locs = []
	for vertice in vertices:
		loc = vertice.pointOn[0][index]
		if loc not in locs:
			locs.append(loc)

	locs.sort()

	return locs

def locs_of_poi(poi,vertices=None, x=None,y=None,z=None,nx=None,ny=None,nz=None,dir=None,axis=None,index=None,pointOn=True,nearby=5e-3,groupX=None,groupY=None,groupZ=None):
	## VER: ('VER: 2015-09-29, v2.0')	## 注意，对于dir='z', x和y都可以是一个范围，也可以是确定的值。
	## 获取一些点在某个坐标轴的坐标值。
	## 可能会进行辅助的batch_divide操作来产生需要的点，从而得到该点的位置。
	## 对于sketch，可以先通过wire_to_sketch()来变成temp part，然后获得相应的点。
	## reference: find_loc(), vertice_select(),xlocs(),ylocs(),zlocs()
	## 可以用vertice_select()先选出vertice，然后代入locs_of_poi()获得进一步信息。

	## Example:
##	locs_of_poi('powder',y=MID,groupX=MAX)  ## 结果:[(11.201, 26.78, 0.0)]

	## Example:
	## locs = coords_of_poi(powder_s,x=(_xmax(powder_s,y=MAX),MAX),dir='x')
	## coords_of_poi(cutter,y=MIN,dir='x')   ## 结果为[105.248, 105.288]

##>>> coords_of_poi(anvil,dir='x')
##[0.0, 104.749, 105.149, 105.249, 105.269, 105.289, 105.389, 105.789, 118.0, 122.0, 140.0]
##>>>

##>>> locs_of_poi('powder',x=MIN)
##
##['locs_of_poi', 40, 'batch_divide', 3633] Performing batch divide for ['powder_temp4'] in x , offsets= [0.0]
##[(0.0, 0.0, 0.0), (0.0, 7.653474, 0.0), (0.0, 13.477964, 0.0)]
##>>> locs_of_poi('powder',x=MIN,dir='y')
##
##['locs_of_poi', 40, 'batch_divide', 3633] Performing batch divide for ['powder_temp5'] in x , offsets= [0.0]
##[0.0, 7.653474, 13.477964]
##>>> locs_of_poi('powder',y=MIN)
##
##['locs_of_poi', 42, 'batch_divide', 3633] Performing batch divide for ['powder_temp6'] in y , offsets= [0.0]
##[(0.0, 0.0, 0.0)]
##>>> locs_of_poi('powder',y=MAX1)
##
##['locs_of_poi', 42, 'batch_divide', 3633] Performing batch divide for ['powder_temp7'] in y , offsets= [20.7295]
##--->Performed partition for powder_temp7 , divide#= 1 , y = 20.7295
##[(0.0, 20.7295, 0.0), (4.375, 20.7295, 0.0)]
##>>>

	## Example:
##	>>> locs_of_poi(powder,x=(MIN1,MAX1))
##	[(11.2005, 0, 0), (11.2005, 63.75, 0), (0.0005, 63.75, 0), (0.0005, -10.19, 0), (10.347359, -2.533, 0), (11.110957, -0.035381, 0), (11.158772, 0, 0)]
##	>>> locs_of_poi(powder,x=(MIN1,MAX1),dir='x')
##	[(0.0005, 63.75, 0), (0.0005, -10.19, 0), (10.347359, -2.533, 0), (11.110957, -0.035381, 0), (11.158772, 0, 0), (11.2005, 63.75, 0), (11.2005, 0, 0)]
##	>>> locs_of_poi(powder,x=(MIN1,MAX1),dir='x',ny=-1)
##	[(10.347359, -2.533, 0), (11.110957, -0.035381, 0), (11.158772, 0, 0)]

	dir = get_real_input(dir,axis)

	if type_of(dir) == 'STR':
		dir = dir.lower()
		dir = dir2num(dir)

	x,y,z = real_xyz(poi,x=x,y=y, z=z)
	if is_number(x) and type_of(y) not in numerics and type_of(z) not in numerics:
		dir = 1
	elif is_number(y) and type_of(x) not in numerics and type_of(z) not in numerics:	## 对草图来说比较实用
		dir = 0
	elif is_number(z) and type_of(x) not in numerics and type_of(y) not in numerics:
		dir = 0

##	print fnln(),'dir=',dir
	if dir not in empty and dir not in [0,1,2]:
		raise Exception('*** error dir')

##	print fnln(),'pointOn=',pointOn
##	print fnln(),'dir=',dir

	poi = check_pias(poi)

	temp_part = ''
	if vertices in empty:
		x10,x20,y10,y20,z10,z20 = poi_space(poi)

		if (x,y,z) != (None,None,None) and (nx,ny,nz) == (None,None,None):
			temp_part = temp_part_of_poi(poi)
	##		print fnln(),'x,y,z=',x,y,z
			if x not in empty:
				div = True
				if type_of(x) in numerics:
					if abs(x - x10) < 1e-3 or abs(x - x20) < 1e-3:
						div = False

				if div == True:
					batch_divide(temp_part,x=x)

			if y not in empty:
				div = True
				if type_of(y) in numerics:
					if abs(y - y10) < 1e-3 or abs(y - y20) < 1e-3:
						div = False

				if div == True:
					batch_divide(temp_part,y=y)

			if z not in empty:
				div = True
				if type_of(z) in numerics:
					if abs(z - z10) < 1e-3 or abs(z - z20) < 1e-3:
						div = False

				if div == True:
					batch_divide(temp_part,z=z)

			vertices = vertice_select(temp_part,x=x,y=y,z=z)

		elif (nx,ny,nz) != (None,None,None):
			vertices = vertice_select(poi,nx=nx,ny=ny,nz=nz,x=x,y=y,z=z)

		else:
			vertices = poi.vertices

	if vertices not in empty and (groupX not in empty or groupY not in empty or groupZ not in empty):
##		print fnln(),vertices
		space = objs_space(vertices)
		if groupX not in empty:
			groupX = real_xyz_in_space(space,x=groupX)
			vertices = vertice_select(p=poi, vertices=vertices, x=groupX)
		elif groupY not in empty:
			groupY = real_xyz_in_space(space,y=groupY)
			vertices = vertice_select(p=poi, vertices=vertices, y=groupY)
		elif groupZ not in empty:
			groupZ = real_xyz_in_space(space, z=groupZ)
			vertices = vertice_select(p=poi, vertices=vertices, z=groupZ)

	pointOns = []
	for point in vertices:
		pointOns.append(point.pointOn[0])

##	print fnln(),'temp_part=',temp_part
##
##	raise Exception
	if temp_part not in empty:
##		del _m.parts[temp_part]
		del_parts(temp_part)

	if pointOns not in empty:
		locs1 = []
		for loc in pointOns:
##			loc1 = round_loc(loc)   ## 注意不能round_loc，否则会影响connect_points()精度和locs_of_sketch()的结果
			locs1.append(loc)
		pointOns = locs1

##	print fnln(),'pointOns=',pointOns
##	print fnln(),'pointOn=',pointOn

	locs = []
	if pointOn == False and pointOns not in empty:
		for loc in pointOns:
			if loc[dir] not in locs:
				locs.append(loc[dir])

		locs.sort()    ## 某个方向的刻度值

	else:
		locs = pointOns   ##点在x,y,z方向的坐标。
		if dir in [0,1,2] and len(locs) > 1:
			locs = sort_tuple_type_elements(locs,index=dir)

	return locs

def get_region_info(region,region_type=None):
	## VER: 2014-06-11, v1.0

## Example:
##>>> get_region_info(load9)
##{'objs': [], 'region': 'whole_model'}
##>>> get_load_info(load9)
##{'objs': [], 'description': 'Gravity -> The Gravity object stores the data of a gravity load.', 'region': 'whole_model', 'region_size': 'NA', 'action_name': 'Load-9', 'action_type': 'GRAVITY', 'obj_num': 'NA'}
##>>>

	if type_of(region) != 'TUPLE':
		try:
			region = region.region   ## sucha as region = load1.region
		except:
			raise Exception("*** load or BC region is required, format=('Set-10', 'Assembly', 1, 1, 0)")

	region0 = None
	region_name = region[0]
##	print fnln(),'region=',region
##	print fnln(),'region_name=',region_name

	if len(region) == 4:
		if region_name == '':
			region0 = 'whole_model'
	elif len(region) in [5,6]:
		pia = None
		if len(region) == 5:   ## then region[1] == 'Assembly'
			pia = a
		elif len(region) == 6:  ## region[1] is the part, and region[2] is the instance
			pia = a.instances[region[2]]

##		print fnln(),'type_of(pia)=',type_of(pia)
		if pia not in empty:
			if region_type == 'surface':
				if region_name in pia.surfaces.keys():
					region0 = pia.surfaces[region_name]
				elif region_name in a.allInternalSurfaces.keys():
					region0 = a.allInternalSurfaces[region_name]
				elif region_name in a.allInternalSets.keys():   ## ?????
					region0 = a.allInternalSets[region_name]
			elif region_type == 'set':
				if region_name in pia.sets.keys():
					region0 = pia.sets[region_name]
				elif region_name in a.allInternalSets.keys():
					region0 = a.allInternalSets[region_name]
				elif region_name in a.allInternalSurfaces.keys():
					region0 = a.allInternalSurfaces[region_name]
			else:
				if region_name in pia.surfaces.keys():
					region0 = pia.surfaces[region_name]
				elif region_name in pia.sets.keys():
					region0 = pia.sets[region_name]
				elif region_name in a.allInternalSurfaces.keys():
					region0 = a.allInternalSurfaces[region_name]
				elif region_name in a.allInternalSets.keys():
					region0 = a.allInternalSets[region_name]

	info1 = {}
	if type_of(region0) == 'SURFACE':
		info1 = get_surface_info(region0)
	elif type_of(region0) == 'SET':
		info1 = get_set_info(region0)
	else:
		info1['objs'] = []
	info1['region'] = region0

	if region0 == 'whole_model':
		info1['region_name'] = 'NA'
		info1['pois'] = 'whole_model'
		info1['parent'] = a
		info1['region_type'] = 'whole_model'
		info1['obj_type'] = 'NA'

	return info1

function_labels['get_line_nodes'] = 'profile','adjacent','flatness','extend','select'
def get_line_nodes(node,dir1='x',angle=20):
	## VER: 2017-06-08, v1.0

##	>>> nodes = set2objs(p1,name='side1')
##	>>> nodes1 = node_select(p1,nodes=nodes,z=MID)  ## 此时的节点可能不是连续地在一条线上，由于变形的原因。
##	>>> nodes2 = get_line_nodes(nodes1,dir1='y') ## 此时的节点可能不是连续地在一条线上，便于获得这条线的profile and flatness

	## nodes = get_line_nodes(nodes[1],dir1='x')

	if type_of(node) in ['LIST','TUPLE'] and type_of(node[0]) == 'nodes':
		nodes = node
		num = len(nodes)
		index = int(round(num/2.0))
		node = nodes[index]


	if type_of(node) != 'nodes':
		raise Exception('*** a node is required.')

	dir1 = dir1.lower()
	if dir1 not in ['x','y','z']:
		raise Exception('*** dir1 should be x, y, or z')

	node1 = adjacent_nodes(node,dir1='+'+dir1)
	if len(node1) == 0:
		node1 = adjacent_nodes(node,dir1='-'+dir1)

	nodes = []
	if len(node1) > 0:
		nodes = [node,node1[0]]
	else:
		raise Exception('*** Fail to get the adjacent node')

	if len(nodes) == 2:
		nodes = extend_two_nodes(nodes,angle=angle)

	return nodes

def get_load_info(load1):
	## VER: 2014-06-11, v1.1

	if load1 in _m.loads.keys():
		load1 = _m.loads[load1]

	if load1 not in _m.loads.values():
		raise Exception('*** Load name is incorrect.')

	region_type = None
	action_type = type_of(load1)
	if 'FORCE' in action_type:
		region_type = 'set'
	elif 'PRESSURE' in action_type:
		region_type = 'surface'

	info1 = get_region_info(load1,region_type=region_type)
##	myprint(info1)
##	raise Exception

	info1['action_name'] = load1.name
	info1['action_type'] = action_type
	info1['description'] = load1.__doc__

	objs = info1['objs']

	if objs not in empty:
		try:
			size = size_of_objs(objs)
			if type_of(size) not in numerics:
				size = 'NA'
			info1['region_size'] = size
		except:
			info1['region_size'] = 'NA'
		info1['obj_num'] = len(objs)
	else:
		info1['region_size'] = 'NA'
		info1['obj_num'] = 'NA'

	return info1

def get_load_set(load1):
	## VER: 2014-06-11, v1.0

	if type_of(load1) == 'STR' and load1 in _m.loads.keys():
		load1 = _m.loads[load1]

	set_name = load1.region[0]
	set1 = None
	if load1.region[1] == 'Assembly':
		if set_name in a.sets.keys():
			set1 = a.sets[set_name]
		elif set_name in a.allInternalSets.keys():
			set1 = a.allInternalSets[set_name]
	elif len(load1.region) == 6:
		inst = load1.region[2]
		if inst in a.instances.keys():
			inst = a.instances[inst]
			set1 = inst.sets[set_name]

	if type_of(set1) != 'SET':
		raise Exception('*** fail to get the set of load. load1.region = ' + repr(load1.region))

	return set1


def get_load_surface(load1):
	## VER: 2014-06-11, v1.0

	if type_of(load1) == 'STR' and load1 in _m.loads.keys():
		load1 = _m.loads[load1]

	surface_name = load1.region[0]
	surface = None
	if load1.region[1] == 'Assembly':
		if surface_name in a.surfaces.keys():
			surface = a.surfaces[surface_name]
		elif surface_name in a.allInternalSurfaces.keys():
			surface = a.allInternalSurfaces[surface_name]
	elif len(load1.region) == 6:
		inst = load1.region[2]
		if inst in a.instances.keys():
			inst = a.instances[inst]
			surface = inst.surfaces[surface_name]

	if type_of(load1) == 'PRESSURE' and type_of(surface) != 'SURFACE':
		raise Exception('*** fail to get the surface of load. load1.region = ' + repr(load1.region))

	return surface

def get_locs(sketch,points):
	## VER: 2016-09-26, v1.0

	global poly_points, last_point

	sketch = check_sketch(sketch)

	## 把一个list装入到括号中
##	if len(points) == 1: ## 如果是tuple，可能是位置
##		points = points[0]

	print fnln(),'points=',points
	print ' '
##	poly_points = []
	k = 0
	for i in range(len(points)):
		k += 1
		point = points[i]
##		num0 = len(poly_points)

		if len(poly_points) > 2 and poly_points[-1] == poly_points[-2]:
			poly_points.pop()	## remove repeated item (dx,dy) = (0,0)

##		if k == 3:
##			print fnln(),point
##			print fnln(),'ndir=',ndir
##			raise Exception

		type1 = type_of(point)
##		print fnln(),'type1=',type1
##		print fnln(),'point=',point

		if is_location(point) == True:
##			if len(point) == 3:   ## 草图中的坐标只有两个
##				x0,y0,z0 = point
##				if ndir == 'x':
##					point = (y0,z0)
##				elif ndir == 'y':
##					point = (x0,z0)
##				elif ndir == 'z':
##					point = (x0,y0)

			poly_points.append(point)   		## provide the coords, assume to be absolute.

		elif type1 == 'vertices':
			poly_points.append(point.coords)  ## 草图中的点
		elif type1 == 'STR':
			point1 = point.lower()
			loc = ()
			if point1 == 'xmax':
				loc = find_loc(sketch,x=MAX)
			elif point1 == 'xmin':
				loc = find_loc(sketch,x=MIN)
			elif point1 == 'ymax':
				loc = find_loc(sketch,y=MAX)
			elif point1 == 'ymin':
				loc = find_loc(sketch,y=MIN)

			if is_location(loc):
				poly_points.append(loc)
			else:
				raise Exception('*** fail to get the location for ' + point1)

		else:
			if type1 == 'TUPLE' and len(point) == 2:
				if type_of(point[0]) == 'STR':
					point = {point[0]:point[1]}
					type1 = 'DICT'

			if type1 != 'DICT':
				raise Exception('*** a dict is required, indicating target (x,y) or (dx,dy)')

##			print fnln(),'poly_points=',poly_points
			x0,y0 = poly_points[-1]		## last_point
			if len(point) == 1:
				var = point.keys()[0]
				data = point[var]
				var = var.upper()

				## finally format to: 2H, 2V, DH, DV, DT
				please_check
				if var in ['H','X']:  ## 相当于提供了标准尺寸
					var = '2H'
				elif var in ['V','Y']:
					var = '2V'
				elif var == 'DX':
					var = 'DH'
				elif var == 'DY':
					var = 'DV'
				elif var == 'T':
					var = 'DT'

				if var[-1] == '=':
					var = var[:-1]

				if var == 'DH':
					x1 = x0 + data
					y1 = y0
					poly_points.append((x1,y1))

				elif var == '2H':
					data = real_xy_sketch(sketch,x=data,Xonly=True)
					x1 = data
					y1 = y0
##					print fnln(),(x1,y1)
					poly_points.append((x1,y1))

				elif var == 'DV':
					x1 = x0
					y1 = y0 + data
					poly_points.append((x1,y1))

				elif var == '2V':
					data = real_xy_sketch(sketch,y=data,Yonly=True)
					x1 = x0
					y1 = data
					poly_points.append((x1,y1))

				elif var == 'DT':
					x1 = x0 + data[0]
					y1 = y0 + data[1]
					poly_points.append((x1,y1))

				elif var == '2T':
					data = real_xy_sketch(sketch,loc=data)
					x1 = data[0]
					y1 = data[1]
					poly_points.append((x1,y1))

			elif len(point) == 2:
				x1 = None	;	y1 = None
				if 'x' in point.keys():
					x1 = real_xy_sketch(sketch,x=point['x'],Xonly=True)
				elif 'dx' in point.keys():
					x1 = x0 + point['dx']

				if 'y' in point.keys():
					y1 = real_xy_sketch(sketch,y=point['y'],Yonly=True)
				elif 'dy' in point.keys():
					y1 = y0 + point['dy']

				if 'angle' in point.keys():
					angle = point['angle']   ## angle的正负就决定了增量的正负。
					if x1 not in empty and y1 in empty:
						y1 = y0 + abs((x1 - x0))*tanD(angle)
					elif y1 not in empty and x1 in empty:
						x1 = x0 + abs((y1 - y0))*tanD(angle)

				if x1 in empty or y1 in empty:
					raise Exception('*** x1 and y1 are all required for slope line.')

				poly_points.append((x1,y1))

	print fnln(),'poly_points=',poly_points
	print fnln(),'last_point =',poly_points[-1]

##		num1 = len(points1)
##		if num1 > num0:
##			last_point = points1[-1]   ;please_check
##			print fnln_fnln(),'last_point=',last_point

	return

def get_magnitude(num):
	## VER: 2015-11-17, v1.2
	## 获取一个数的数量级。

##	>>> get_magnitude(1.5)
##	1   ## 1 means 0 < num < 10
##	>>> get_magnitude(15)
##	2
##	>>> ## 2 means 10 < num < 100

	num0 = tolist(num)
	for i in range(len(num0)):
		num0[i] = abs(num0[i])
	num = max(num0)

	if type_of(num) not in numerics:
		raise Exception('*** a float number is required.')

##	num = abs(num)
	value0 = str(num)
	value0 = value0.lower()

	if '.' not in value0:
		value0 = value0 + '.0'

##	print fnln(),"value0=",value0
	loc = value0.find('.')

	if num == 0:
		magnitude = 0
	elif 'e' in value0:
		loc = value0.find('e')
		magnitude = value0[loc+1:]
		magnitude = magnitude.strip()
		sign = 1
		if magnitude[0] == '-':
			sign = -1
		for i in range(len(magnitude)):
			if magnitude[i] in ['1','2','3','4','5','6','7','8','9']:
				magnitude = eval(magnitude[i:])
				break
		magnitude = sign*magnitude

	elif num >= 1:
		magnitude = loc
	else:   ## string
		value0 = value0[loc+1:]  ## no . now
##		print fnln(),'value0=',value0
##		print fnln(),'type_of(value0)=',type_of(value0)
		if value0 == '0':
			magnitude = 0
		else:
			for i in range(len(value0)):
				if value0[i] != '0':
					magnitude = -(i+1)
					break

	return magnitude


def get_mass(poa=None, parts=None,insts=None,cells=None,setname=None,mat=None,print_result=True):
	## VER: 2013-11-14, v2.3.  Al边框的setname=Frame
	## 允许输入不存在的part的名字。单位：kg
	## reference: volume_to_mass(): change the volume of insts to mass

	mass = 0
	if type_of(mat) == 'STR':
		setname = mat

	assembly = None
	parts = real_parts(parts)
	insts = real_insts(insts)
	if mat not in empty:
		setname = mat

	input = ''
	if is_empties(poa,parts,insts,cells,setname):
		assembly = a
	else:
		if poa not in empty:
			if type_of(poa) == 'ASSEMBLY':
				assembly = a
			else:
				parts = real_parts(poa)
				insts = real_insts(poa)

	if assembly == a:
		mass = a.getMassProperties()['mass']
		input = 'Assembly'
	else:
		if setname not in empty:
			if insts in empty and parts in empty:
				insts = insts_by_set(setname)
				if insts in empty:
					parts = parts_by_set(setname)

			if insts not in empty:
				seq = set2sequence(setname,insts)
				mass = mass + a.getMassProperties(regions=seq)['mass']
				input = setname + ' of ' + repr(poi_names(insts))
			elif parts not in empty:
				for part in parts:
					cells = set2objs(setname,part)
					seq = list2sequence(cells,part)
					mass = mass + part.getMassProperties(regions=seq)['mass']
				input = setname + ' of ' + repr(poi_names(parts))

		elif cells not in empty:
			pois = get_pois(cells)
			input = 'cells of ' + repr(poi_names(pois))

			seq = list2sequence(cells)
			if type_of(pois[0]) == 'PART':
				if len(pois) > 1:
					raise Exception('******Cells from multiple parts.')
				else:
					part = pois[0]
					mass = part.getMassProperties(regions=seq)['mass']

			else:
				mass = a.getMassProperties(regions=seq)['mass']

		elif insts not in empty:
			input = repr(poi_names(insts))
			for inst in insts:
				mass = mass + inst.part.getMassProperties()['mass']

		elif parts not in empty:
			input = repr(poi_names(parts))
			for part in parts:
				try:
					mass0 = part.getMassProperties()['mass']
				except:
					mass0 = 0

				if type_of(mass0) not in numerics:   ## 2D model
					mass0 = 0

				if print_result == True:
					print 'part: ',part.name,
					print ', mass0=',repr(mass0),'ton for mm-N units'

				mass = mass + mass0

	mass = mass*1e6 ## now, unit = g   (产品的称重大多都是以克为单位的）
	mass = round(mass,2)

	if print_result == True:
		print 'Weight of ' + input,':',mass,'g'
		print 'Totally=',mass*4,'g for quarter symmetric model, and',mass*2,'g for half sym model'
		print ' '

	return mass		## unit: g

def get_mass_vol_compaction():
	## VER: 2015-11-24, v1.0

	insts = []
	deforms = []
	for inst in oa.instances.values():
		if inst.type == DEFORMABLE_BODY:
			deforms.append(inst)
			if 'powder' in inst.name.lower():
				insts.append(inst)
			elif 'H10POW' in inst.elements[0].sectionCategory.name:
				insts.append(inst)

	if insts in empty and len(deforms) == 1:
		insts = deforms

	step_name,frame,time1 = current_step_frame_time()
	density0 = odb.steps[step_name].frames[frame].fieldOutputs['DENSITY'].values
	IVOLs = odb.steps[step_name].frames[frame].fieldOutputs['EVOL'].values

	mass = 0
	vol_all = 0
	for value in density0:
		if value.instance in insts:  	## value.instance is object,not instance name
			density_e = value.data
			if density_e >= 14e-9:
				density_e = 14e-9	;please_check
			elif density_e <= 3e-9:
				density_e = 3e-9

			label = value.elementLabel
			vol_e = IVOLs[label-1].data
			mass = mass + vol_e*density_e
			vol_all = vol_all + vol_e

##	mass = round(mass*1e6,4)	## 单位：g

	return mass, vol_all

def get_mat_ids(poi):
	## VER: 2014-12-04, v1.0
	## Before scale part, collect the ids of materials.

	poi = check_poi(poi)
	mats = get_mats(poi)

	if mats in empty:
		raise Exception('*** No material in the poi.')

	dict1 = mats.values()[0]

	dict2 = {}
	for mat in dict1.keys():
		dict2[mat] = []
		sets = dict1[mat]   ## a set name list
		for set1 in sets:
			objs = set2objs(poi,set1)
			for obj in objs:
				index = obj.index
				if index not in dict2[mat]:
					dict2[mat].append(index)

	return dict2

function_labels['get_mats'] = 'material','part','instance','poi','model'
def get_mats(poi=None):
	## VER: ('VER: 2014-05-09, v1.6')	## poi = part, instance,assembly, or _m

##	>>> get_mats()
##	{'tpunch_A1': {}, 'powder_A1': {'H10pow': ['set_H10pow']}, 'bpunch_A1': {}, 'die_A1': {}}
##	>>>

	vpnow = get_vpnow()
	if type_of(poi) not in ['PART','PINSTANCE','ODBINSTANCE']:
		if type_of(poi) == 'STR':
			if poi in _m.parts.keys():
				poi = _m.parts[poi]
			elif poi in a.instances.keys():
				poi = a.instances[poi]
			elif type_of(vpnow.displayedObject) == 'ODB' and poi in oa.instances.keys():
				poi = oa.instances[poi]

		elif poi in empty:
			if type_of(vpnow.displayedObject) in ['PART','ASSEMBLY','ODB']:
				poi = vpnow.displayedObject

	if type_of(poi) not in ['PART','PINSTANCE','ASSEMBLY','MODEL','ODB','ODBINSTANCE']:
		raise Exception('Please specify the poi to get materials.')

	mats = {}
	type1 = type_of(poi)
	if type1 == 'PART':
		part = poi
		sections = part.SectionAssignment.caller.sectionAssignments
		for section in sections:
			matname = _m.sections[section.sectionName].material
			if matname not in _m.materials.keys():
				continue

			if matname not in mats.keys():
				mats[matname] = []
			mats[matname].append(section.region[0])	## 该section的内部setname

		mats1 = {}
		mats1[part.name] = mats
		mats = mats1

	elif type1 == 'MODEL':	## 即_m
		for part in _m.parts.values():
			mats[part.name] = get_mats(part)[part.name]

	elif type1 in ['ASSEMBLY','PINSTANCE']:
		for inst in a.instances.values():
			if type_of(poi) == 'PINSTANCE' and inst != poi:
				continue
			part = inst.part
			mats[inst.name] = get_mats(part)[part.name]

	elif type1 in ['ODB','ODBINSTANCE']:  ##后处理
		sections = odb.sections
		for section in sections.values():
			name = section.name[17:]   ## 去除Section-ASSEMBLY_前缀
			loc = name.find('__')
			inst = name[:loc]
			setname = name[loc + 1:]
			material = section.material
			if type_of(poi) == 'ODBINSTANCE' and poi.name != inst:
				continue
			if material not in mats.keys():
				mats[material] = []
			mats[material].append(inst + '.' + setname)

	return mats

def get_maxElem(inst1):
	## 2010-06-13
	global _inst,_ndel,_top_elems

	_inst = inst1.upper()
	_ndel = 0

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	odb = vpnow.displayedObject
	assembly = odb.rootAssembly
	stress = odb.steps['step1'].frames[-1].fieldOutputs['S']
	stressSet= odb.steps['step1'].frames[-1].fieldOutputs['S'].values

	inst1 = assembly.instances[_inst]
	inst_set = stress.getSubset(region=inst1)

	edict = {}
	for elem in inst_set.values:
		edict[elem.elementLabel] = elem.mises

	_top_elems = sort_by_value(edict)

	print 'Create global variable: _top_elems'
	print _top_elems[0:10]
	print '  '

	return

def get_mdb_viewports():
	## VER: 2014-04-17, v1.1. To find all opend viewports which is mdb viewport instead of odb viewport.

	viewports = {}
	for viewport in session.viewports.values():
		dpo = viewport.displayedObject
		if type_of(dpo) in ['PART','ASSEMBLY','sketch']:
			model_name = get_parent(dpo).name
			viewports[viewport.name] = model_name

	return viewports

def opened_models():
	## VER: 2014-05-19, v1.0

	viewports = get_mdb_viewports()
	models = viewports.values()
	models = remove_repeated_items(models)

	return models

def get_mesh_control(part,cells=None,faces=None,edges=None):
	## VER: 2013-07-24, v1.0

	part = check_part(part)
	objs = get_real_input(cells,faces,edges)

	if type_of(objs) == 'STR':
		objs = set2objs(part,objs)

	objs = tolist(objs)
	if objs in empty:
		if len(part.cells) > 0:
			objs = part.cells
		elif len(part.faces) > 0:
			objs = part.faces
		elif len(part.edges) > 0:
			objs = part.edges
		else:
##			print '** Fail to get the mesh control for', part.name
			return {}

	techniques = []
	elem_shapes = []
	algorithms = []

	for obj in objs:
		technique = part.getMeshControl(region=obj, attribute=TECHNIQUE)
		if technique not in techniques:
			techniques.append(technique)

		elem_shape = part.getMeshControl(region=obj, attribute=ELEM_SHAPE)
		if elem_shape not in elem_shapes:
			elem_shapes.append(elem_shape)

		algorithm = part.getMeshControl(region=obj, attribute=ALGORITHM)
		if algorithm not in algorithms:
			algorithms.append(algorithm)


	result = {'technique':techniques, 'elem_shape':elem_shapes, 'algorithm':algorithms}

	return result

function_labels['get_mid_profile'] = 'flatness','straightness','insert','sintering','coordinates','axis','xyplot'
def get_mid_profile(p1,nodes,axis='xy',filename='_coords_nodes.txt',sort=True,left=None,right=None,factor=1,relative=True):
	## VER: 2017-06-08, v1.0

	## side2 = get_mid_profile(p1,'side2',axis='xy',filename='_AE1_PFH1314_OB06_side2.txt')
	## side3 = get_mid_profile(p1,'side3',axis='xy',factor=-1,filename='_AE1_PFH1314_OB06_side3.txt')
##	>>> nodes1 = get_mid_profile(p1,'side1',axis='yx',filename='_AC_PHF125_OB06_side1.txt')
##	['get_mid_profile', 16, 'node_select', 57544] 44 nodes are selected by node_select().
##	['list_to_txt_lines', 51444] TUPLE has been printed to file Z:/A0282 new triangle verify/compact606/results/_AC_PHF125_OB06_side1.txt
##	values: min= 6.346101 , max= 6.364316 , gap= 0.018215
##	>>>

	p1 = check_poi(p1)
	if type_of(nodes) == 'STR':
		nodes = set2objs(p1,name=nodes)
	nodes = tolist(nodes)
	if len(nodes) < 3:
		raise Exception('*** surface nodes or set is required.')

	axis = axis.lower()
	nodes1 = []
	if 'z' not in axis:
		nodes1 = node_select(p1,nodes=nodes,z=MID)
	elif 'y' not in axis:
		nodes1 = node_select(p1,nodes=nodes,y=MID)
	elif 'x' not in axis:
		nodes1 = node_select(p1,nodes=nodes,x=MID)

	if len(nodes1) == 0:
		raise Exception('*** Fail to get the mide nodes.')

	nodes1 = get_line_nodes(nodes1,dir1=axis[0])

	coords = node_coords_to_profile(nodes=nodes1,axis=axis,filename=filename,sort=sort,left=left,right=right,factor=factor,relative=relative)

	refresh(filename,ask=False)

	return coords

function_labels['get_mode_frequency'] = 'modal'
def get_mode_frequency(mode_num=None,stepnum=None):

	## VER: ('VER: 2012-05-16, v1.3')

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) not in ['ODB','XYPLOT']:
		raise Exception('No odb was displayed.')

	refresh()

	steps = []
	for i in range(len(odb.steps)):
		step = odb.steps.values()[i]
		if step.domain == MODAL:
			steps.append(i)

	if steps in empty:
		raise Exception('没有模态分析步来获得各阶频率。')

	if type_of(stepnum) == 'INT':
		if stepnum > len(odb.steps):
			raise Exception('Error step num')

		if odb.steps.values()[stepnum - 1].domain != MODAL:
			raise Exception('第' + str(stepnum) + '载荷步并不是一个模态分析步.')

	else:
		stepnum = steps[-1] + 1

	freqs = []
	for frame in odb.steps.values()[stepnum - 1].frames:
		freqs.append(frame.frequency)

	if type_of(mode_num) == 'INT':
		result = freqs[mode_num]
	else:
		result = freqs[1:]

	print 'Freqs=',result,'for stepnum=',stepnum,', stepname=',odb.steps.keys()[stepnum-1]

	return result

def get_model_antypes0(step=None):
	## VER: 2014-11-20, v1.0
	## 大写即为原有符号形式。

	if step not in empty:
		step = check_step(step)
		if step != 'Initial':
			type0 = _m.steps[step].procedureType
			type1 = totext(type0).lower()
			return type1
		else:
			raise Exception('*** A step name is required.')

	else:
		antypes = []
		for step in _m.steps.keys():
			if step != 'Initial':
				type0 = _m.steps[step].procedureType
				type1 = totext(type0).lower()
				antypes.append(type1)

		if antypes not in empty:
			antypes1 = remove_repeated_items(antypes)
			if len(antypes1) == 1:
				antypes = antypes1

		return antypes

	return

function_labels['real_antype'] = 'step','procedure','analysis type','antype','dof','problem'
def real_antype(antype):
	## VER: 2016-10-28, v1.0

	info = step_type_detail(antype)
	type1 = info['antype']

	return type1

function_labels['step_type_detail'] = 'procedure','type','step','analysis','antype','problem','DOF','solver','info','model'
def step_type_detail(procedure_type):
	## VER: 2016-10-28, v1.1, procedure_type is the step type selected in GUI.

##	>>> step_type_detail('Frequency')
##	stepnames are sorted by creating sequence.
##	['step_type_detail', 35861] small_type= frequency
##	['step_type_detail', 35862] big_type  =
##	['step_type_detail', 35863] command   = FrequencyStep
##	['step_type_detail', 35864] solver    = implicit
##	{'category': 'linear pertubation', 'user function': 'frequency_and_mode_shapes_step', 'results': 'displacement/velocity', 'tags': '', 'solution technique': '', 'variables': 'U', 'solver': 'implicit', 'equation solver': 'matrix storage=symmetric', 'first step': True, 'antype': 'stress', 'command': 'FrequencyStep', 'input': 'eigensolver=lanczos or subspace or AMS; number of eignvalues requested; minimum/maximum eignvalues of interest; normalize eigen vector by displacement or mass; acoustic coupling', 'procedure_type': FREQUENCY}
##	>>>

	big_type = ''
	small_type = ''
##	if procedure_type in _m.steps.keys() or procedure_type in _m.steps.values():
	if is_step(procedure_type):
		step = check_step(procedure_type)
##		print fnln(),'step=',step
		if step == 'Initial':
			raise Exception('*** Initial step has no procedure type.')

		big_type = _m.steps[step].procedureType   ## big type

	else:  ## small type
		procedure_type = procedure_type.lower()
		procedure_type = modify_string(procedure_type,'  ',' ')
		procedure_type = modify_string(procedure_type,'  ',' ')
		small_type = modify_string(procedure_type,' ,',',')  ## 逗号面前无空格

	small_type0 = modify_string(small_type,',',' ')
	small_type0 = modify_string(small_type0,'-',' ')
	small_type0 = modify_string(small_type0,'_',' ')
	small_type0 = modify_string(small_type0,'+',' ')
	small_type0 = modify_string(small_type0,'/',' ')

	## Abaqus analysis user's guide:
##	6.2 static stress/displacement analysis
##		“Static stress analysis procedures: overview,” Section 6.2.1
##		“Static stress analysis,” Section 6.2.2
##		“Eigenvalue buckling prediction,” Section 6.2.3
##		“Unstable collapse and postbuckling analysis,” Section 6.2.4
##		“Quasi-static analysis,” Section 6.2.5
##		“Direct cyclic analysis,” Section 6.2.6
##		“Low-cycle fatigue analysis using the direct cyclic approach,” Section 6.2.7
##	6.3 dynamic stress/displacement analysis
##		“Dynamic analysis procedures: overview,” Section 6.3.1
##		“Implicit dynamic analysis using direct integration,” Section 6.3.2
##		“Explicit dynamic analysis,” Section 6.3.3
##		“Direct-solution steady-state dynamic analysis,” Section 6.3.4
##		“Natural frequency extraction,” Section 6.3.5
##		“Complex eigenvalue extraction,” Section 6.3.6
##		“Transient modal dynamic analysis,” Section 6.3.7
##		“Mode-based steady-state dynamic analysis,” Section 6.3.8
##		“Subspace-based steady-state dynamic analysis,” Section 6.3.9
##		“Response spectrum analysis,” Section 6.3.10
##		“Random response analysis,” Section 6.3.11
##	6.4 steady-state transport analysis
##	6.5 Heat transfer and thermal stress analysis
##		“Heat transfer analysis procedures: overview,” Section 6.5.1
##		“Uncoupled heat transfer analysis,” Section 6.5.2
##		“Fully coupled thermal-stress analysis,” Section 6.5.3
##		“Adiabatic analysis,” Section 6.5.4
##	6.6 Fluid dynamic analysis
##	6.8 Coupled pore fluid flow and stress analysis
##		“Coupled pore fluid diffusion and stress analysis,” Section 6.8.1
##		“Geostatic stress state,” Section 6.8.2
##	6.9 Mass diffusion analysis


	## if explicit shown in small_type, then solver = explicit, otherwise implicit
	big2small = {}  ## small is my name, and big is the formal name

	## 应力相关
	big2small[STATIC_GENERAL] = 'static,general'
	big2small[DIRECT_CYCLIC ] = 'direct cyclic'			## 低周疲劳分析，准稳态
	big2small[DYNAMIC_IMPLICIT ] = 'dynamic,implicit'	## 隐式分析
	big2small[DYNAMIC_SUBSPACE] = 'dynamic,subspace'	## 隐式分析，前面分析步为dynamic implicit
	big2small[DYNAMIC_EXPLICIT ] = 'dynamic,explicit'	## 显式分析★

	## 热相关
	big2small[HEAT_TRANSFER ] = 'heat transfer' 							## 纯热分析，隐式
	big2small[COUPLED_TEMP_DISPLACEMENT] = 'coupled temp-displacement'		## 隐式分析
	big2small[DYNAMIC_TEMP_DISPLACEMENT ] = 'dynamic,temp-disp,explicit'	## 显式分析★
	big2small[ANNEAL ] = 'anneal'											## 显式分析★ (前面一步为dynamic explicit或 dynamic temp-disp explcit

	## 岩土相关
	big2small[GEOSTATIC ] = 'geostatic'
	big2small[SOILS ] = 'soils'
	big2small[MASS_DIFFUSION ] = 'mass diffusion'

	## 频率相关
	big2small[FREQUENCY ] = 'frequency'   ## 计算很快
	big2small[COMPLEX_FREQUENCY] = 'complex frequency'
	big2small[STATIC_LINEAR_PERTURBATION ] = 'static,linear pertubation'
	## 载荷频率变化的响应分析
	big2small[RANDOM_RESPONSE] = 'random response'
	big2small[RESPONSE_SPECTRUM] = 'response spectrum'
	big2small[STEADY_STATE_MODAL] = 'steady-state dynamics,modal'   ## 计算很快, steady state modal dynamics
	big2small[STEADY_STATE_DIRECT ] = 'steady-state dynamics,direct' ## 计算很慢 steady state direct dynamics
	## 撤销载荷后的余震分析
	big2small[MODAL_DYNAMICS] = 'modal dynamics'	## transient modal dynamics
	##
	big2small[STEADY_STATE_SUBSPACE] = 'steady-state dynamics,subspace' ## steady state subspace dynamics
	big2small[SUBSTRUCTURE_GENERATE ] = 'substructure generation'

	## 屈曲相关
	big2small[BUCKLE ] = 'buckle'  ## 屈曲, collapse
	big2small[STATIC_RIKS ] = 'static,riks'		## 简化的屈曲分析？？

	small2big = {}
	for k,v in big2small.items():
		small2big[v] = k

	small2info = {}

	## antype: 仅stress中，从单元形状角度，又区分3D stress, shell和cohesive
	## 3D stress中，单元类型C3D8R在standard和explicit中都适用
	## thermal_stress中，单元类型C3D8T在standard和explicit中都适用
	## thermal中，单元类型DC3D8仅适用于standard。在explicit没有纯热分析

	## ================================================
	if small_type0 in ['static general','general static', 'static','disp','stress strain','stress']:
		small_type = 'static,general'

	dict1 = {}
	dict1['category'] = 'general'
	type1 = 'static,general'   ## shown in GUI
	dict1['procedure_type'] = STATIC_GENERAL
	dict1['command'] = 'StaticStep'
	dict1['keyword'] = '*Static'
	dict1['user function'] = 'create_general_static_step'	## vvv
	dict1['solver'] = 'implicit'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'Nlgeom; automatic stabilization'
	dict1['equation solver'] = 'method=direct or iterative; matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = 'Full Newton or quasi-Newton'
##	*Step, name=Step-1
##	*Static
##	1., 1., 1e-05, 1.

	##
	##
	dict1['variables'] = 'CDISP,CF,CSTRESS,LE,PE,PEEQ,PEMAG,RF,S,U'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	if small_type0 in ['temp disp','disp temp','thermal stress']:
		small_type = 'coupled temp-displacement'

	dict1 = {}
	type1 = 'coupled temp-displacement'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'automatic stabilization; nlgeom; max. temperature change per increment, steady/transient response'
	dict1['equation solver'] = 'unsymmetric'
	dict1['solution technique'] = 'full Newton or seperated'
	##
	dict1['command'] = 'CoupledTempDisplacementStep'
	dict1['procedure_type'] = COUPLED_TEMP_DISPLACEMENT
	dict1['user function'] = 'create_coupled_temp_displacement_step'    ##vvv
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CDISP,CF,CSTRESS,HFL,LE,NT,PE,PEEQ,PEMAG,RF,RFL,S,U'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact, thermal'
	dict1['antype'] = 'thermal_stress'
	small2info[type1] = dict1

	## ================================================
	if small_type0 in ['cyclic','cyclic direct','direct cyclic']:
		small_type = 'direct cyclic'

	dict1 = {}
	type1 = 'direct cyclic'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = 'fatigue'
	dict1['input'] = 'max. temperature change per increment; include low-cycle fatigue analysis: Forward damage extrapolation'
	dict1['equation solver'] = 'Matrix storage = use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'DirectCyclicStep'
	dict1['procedure_type'] = DIRECT_CYCLIC
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CF,LE,RF,S,U,'
	dict1['results'] = 'stress/strain, displacement/velocity, force'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	if small_type0 in ['dynamic implicit','implicit dynamic']:
		small_type = 'dynamic,implicit'

	dict1 = {}
	type1 = 'dynamic,implicit'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'Nlgeom; application=analysis product default/transient fidelity/moderate dissipation/Quasi-static; '
	dict1['equation solver'] = 'Matrix storage = use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = 'Full Newton or quasi-Newton'
	##
	dict1['command'] = 'ImplicitDynamicsStep'
	dict1['procedure_type'] = DYNAMIC_IMPLICIT
	dict1['user function'] = 'create_dynamic_implicit_step'		## vvv
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'A,CDISP,CF,CSTRESS,LE,PE,PEEQ,PEMAG,RF,S,U,V'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	if small_type0 in ['explicit dynamic','dynamic explicit','explicit']:
		small_type = 'dynamic,explicit'

	dict1 = {}
	type1 = 'dynamic,explicit'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = 'mass scaling'
	dict1['input'] = 'Nlgeom; linear bulk viscosity; quadratic bulk viscosity'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'ExplicitDynamicsStep'
	dict1['procedure_type'] = DYNAMIC_EXPLICIT
	dict1['user function'] = 'create_dynamic_explicit_step'		## vvv
	dict1['solver'] = 'explicit'   ## ★step.explicit = True
	##
	dict1['variables'] = 'A,CSTRESS,EVF,LE,PE,PEEQ,PEEQVAVG,PEVAVG,RF,S,SVAVG,U,V'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact, volume'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'aneal'	## 通过升高温度消除应力或使多孔材料致密化
	dict1['category'] = 'general'
	dict1['first step'] = False			## 第一个分析部需是dynamic explicit
	dict1['tags'] = ''	## 仅仅有一个tag:basic
	dict1['input'] = 'Nlgeom=ON; post-anneal reference temperature=maintain current/value'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'AnnealStep'
	dict1['procedure_type'] = ANNEAL
	dict1['user function'] = ''
	dict1['solver'] = 'explicit'   ## ★step.explicit = True
	##
	dict1['variables'] = 'A,CSTRESS,EVF,LE,PE,PEEQ,PEEQVAVG,PEVAVG,RF,S,SVAVG,U,V'  ## 与dynamic explicit一模一样
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact, volume'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1


	## ================================================
	if 'disp' in small_type or 'stress' in small_type:
		if 'temp' in small_type or 'thermal' in small_type:
			if 'dynamic' in small_type or 'explicit' in small_type:  ## such as: dynamic temp-disp explicit
				small_type = 'dynamic,temp-disp,explicit'

	dict1 = {}
	type1 = 'dynamic,temp-disp,explicit'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = 'mass scaling'
	dict1['input'] = 'Nlgeom; linear bulk viscosity; quadratic bulk viscosity'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'TempDisplacementDynamicsStep'
	dict1['procedure_type'] = DYNAMIC_TEMP_DISPLACEMENT
	dict1['solver'] = 'explicit'   ## ★step.explicit = True
	##
	dict1['variables'] = 'A,CSTRESS,EVF,HFL,LE,NT,PE,PEEQ,PEEQVAVG,PEVAVG,RF,RFL,S,SVAVG,U,V'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact, thermal, volume'
	dict1['antype'] = 'thermal_stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'geostatic'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'Nlgeom'
	dict1['equation solver'] = 'method=direct or iterative; matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = 'Full Newton or quasi-Newton'
	##
	dict1['command'] = 'GeostaticStep'
	dict1['procedure_type'] = GEOSTATIC
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CDISP,CF,CSTRESS,LE,POR,RF,S,SAT,U,VOIDR'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact, porous media/fluids'
	dict1['antype'] = 'stress_void'
	small2info[type1] = dict1

	## ================================================
	if small_type0 in ['thermal','heat','temp']:
		small_type = 'heat transfer'

	dict1 = {}
	type1 = 'heat transfer'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'max. temperature change per increment, steady/transient response'
	dict1['equation solver'] = 'method=direct or iterative; matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = 'Full Newton or quasi-Newton'
	##
	dict1['command'] = 'HeatTransferStep'
	dict1['procedure_type'] = HEAT_TRANSFER
	dict1['user function'] = 'create_heat_transfer_step'	## vvv
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'HFL,NT,RFL'
	dict1['results'] = 'thermal'
	dict1['antype'] = 'thermal'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'mass diffusion'
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'end step when normalized concentration change rate is less than; max. allowable normalized concentration change; steady/transient response'
	dict1['equation solver'] = 'matrix storage=unsymmetric'  ## 无法更改
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'MassDiffusionStep'
	dict1['procedure_type'] = MASS_DIFFUSION
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CONC,MFL,NNC,RFL'
	dict1['results'] = 'thermal, porous media/fluids, mass diffusion'
	dict1['antype'] = 'thermal_conc'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'soils'  ## 土壤
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'Nlgeom; automatic stabilization; steady/transient consolidation; max pore pressure change rate per increment; creep/swelling/viscoelastic strain error tolerance; end step when normalized concentration change rate is less than'
	dict1['equation solver'] = 'method=direct or iterative; matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = 'Full Newton or quasi-Newton'
	##
	dict1['command'] = 'SoilsStep'
	dict1['procedure_type'] = SOILS
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CF,LE,PFL,PFLA,POR,PTL,PTLA,RF,S,SAT,U,VOIDR'
	dict1['results'] = 'stress/strain, displacement/velocity, force, porous media/fluids'
	dict1['antype'] = 'stress_void'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'static,riks'   ## 稳态算法
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'stoping criteria'
	dict1['equation solver'] = 'matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'StaticRiksStep'
	dict1['procedure_type'] = STATIC_RIKS
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CDISP,CF,CSTRESS,LE,PE,PEEQ,PEMAG,RF,S,U'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'visco'    ## 粘性
	dict1['category'] = 'general'
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'Nlgeom; automatic stabilization; creep/swelling/viscoelastic strain error tolerance and its integration method(implicit_explicit or explicit_only)'
	dict1['equation solver'] = 'method=direct or iterative; matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = 'Full Newton or quasi-Newton'
	##
	dict1['command'] = 'ViscoStep'
	dict1['procedure_type'] = VISCO
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CDISP,CE,CEEQ,CEMAG,CF,CSTRESS,LE,PE,PEEQ,PEMAG,RF,S,U'
	dict1['results'] = 'stress/strain, displacement/velocity, force, contact'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'buckle'     ## 屈曲
	dict1['category'] = 'linear pertubation'  ## ★★
	dict1['first step'] = True
	dict1['tags'] = ''
	dict1['input'] = 'Nlgeom=off; eigensolver=lanczos or subspace; number of eignvalues requested; maximum eignvalues of interest'
	dict1['equation solver'] = 'matrix storage=symmetric'  ## 无法更改
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'BuckleStep'
	dict1['procedure_type'] = BUCKLE
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'U'
	dict1['results'] = 'displacement/velocity'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	dict1['category'] = 'linear pertubation'
	type1 = 'static,linear pertubation'     ## 基本没有什么设置
	dict1['procedure_type'] = STATIC_LINEAR_PERTURBATION
	dict1['command'] = 'StaticLinearPerturbationStep'
	dict1['keyword'] = '*Static'
	dict1['solver'] = 'implicit'
	dict1['first step'] = True	## ★
	dict1['tags'] = ''
	dict1['input'] = 'Nlgeom=off'
	dict1['equation solver'] = 'method=direct or iterative; matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = ''
	##
	dict1['variables'] = 'CF,LE,RF,S,U'
	dict1['results'] = 'stress/strain, displacement/velocity, force'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1
##	*Step, name=Step-1, perturbation
##	*Static  ## No parameters or data lines are used in a linear perturbation analysis.
##	**

	## ================================================
	if small_type0 in ['substructure','submodel']:
		small_type = 'substructure generation'

	dict1 = {}
	type1 = 'substructure generation'
	dict1['category'] = 'linear pertubation'
	dict1['first step'] = True	## ★
	dict1['tags'] = 'generation options, damping'
	dict1['input'] = 'substructure identifier Z; recovery region; specify retained eigenmodes by start mode and end mode; global damping ratios; structural damping controls; viscous damping; structural damping'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'SubstructureGenerateStep'
	dict1['procedure_type'] = SUBSTRUCTURE_GENERATE
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = ''
	dict1['results'] = '' ## 没有field output
	dict1['antype'] = ''
	small2info[type1] = dict1

	## ★★★★★★★★★★★★★★★★★★★★以下是模态分析

	## ================================================
##	if small_type0 in ['frequency response','response analysis','response']:
##		small_type = 'steady-state dynamics,direct'

	dict1 = {}  ## static direct response
	type1 = 'steady-state dynamics,direct'    ## 频率范围
	dict1['category'] = 'linear pertubation'
	dict1['procedure_type'] = STEADY_STATE_DIRECT
	dict1['keyword'] = '*Steady State Dynamics, direct'  ## direct-solution steady-state dynamic analysis
	dict1['command'] = 'SteadyStateDirectStep'
	dict1['user function'] = 'frequency_response_direct_modal_dynamics_step'
	dict1['solver'] = 'implicit'
	dict1['first step'] = True	## ★ 前面一个分析步不必是Frequency step。直接同时提取频率并进行响应分析。
	dict1['tags'] = ''
	dict1['input'] = 'compute real response only/complex response; Nlgeom=OFF only; linear/logarithmic; damping; lower frequency; higher frequency'
	dict1['equation solver'] = 'matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = ''
	##
	dict1['variables'] = 'A,CF,LE,RF,S,U,V'   ## 不考虑非线性变形行为
	dict1['results'] = 'stress/strain, displacement/velocity, force'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1
##	*Step, name=Step-1, perturbation
##	*Steady State Dynamics, direct, friction damping=NO
##	0.1, 40., 20, 1.   ## 0.1-40是频率范围
##	**

	## ================================================
	if small_type0 in ['freq','mode shape','frequence']:
		small_type = 'frequency'
	## 本分析步是进行模态分析的第一个分析步，在此基础上才会有响应分析
	dict1 = {}
	type1 = 'frequency'     ## 模态   ## 提取各阶模态频率
	dict1['category'] = 'linear pertubation'
	dict1['procedure_type'] = FREQUENCY
	dict1['command'] = 'FrequencyStep'
	dict1['keyword'] = '*Frequency'
	dict1['user function'] = 'frequency_and_mode_shapes_step'	## vvv
	dict1['solver'] = 'implicit'
	dict1['first step'] = True	## ★
	dict1['tags'] = ''
	dict1['input'] = 'eigensolver=lanczos or subspace or AMS; number of eignvalues requested; minimum/maximum eignvalues of interest; normalize eigen vector by displacement or mass; acoustic coupling'
	dict1['equation solver'] = 'matrix storage=symmetric'  ## 无法更改
	dict1['solution technique'] = ''
	##
	dict1['variables'] = 'U'
	dict1['results'] = 'displacement/velocity'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1
##	*Step, name=Step-1, perturbation
##	*Frequency, eigensolver=Lanczos, acoustic coupling=on, normalization=displacement
##	, , 30., , ,  ## maximum interest frequency=30Hz

	## ================================================
	dict1 = {}
	type1 = 'complex frequency'		## 在Frequency分析步的基础上
	dict1['category'] = 'linear pertubation'
	dict1['first step'] = False
	dict1['tags'] = ''
	dict1['input'] = 'number of eignvalues requested; minimum/maximum eignvalues of interest; frequency shift; friction-included damping effect'
	dict1['equation solver'] = 'matrix storage=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'ComplexFrequencyStep'
	dict1['procedure_type'] = COMPLEX_FREQUENCY
	dict1['user function'] = ''
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'U'
	dict1['results'] = 'displacement/velocity'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	dict1['category'] = 'linear pertubation'
	type1 = 'modal dynamics'		## 在Frequency分析步的基础上
	dict1['procedure_type'] = MODAL_DYNAMICS
	dict1['command'] = 'ModalDynamicsStep'
	dict1['keyword'] = '*Modal Dynamic'
	dict1['user function'] = 'time_response_modal_dynamics_step'	## vvv
	dict1['solver'] = 'implicit'
	dict1['first step'] = False
	dict1['tags'] = 'damping'
	dict1['input'] = 'Nlgeom=off; Time increment; Use initial condition/zero initial condition; default load variation with time; direct modal(start/end mode); composite modal(start/end mode); Rayleigh(start/end mode, alpha, beta)'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['variables'] = 'A,CF,LE,RF,S,U,V'  ## 结果比第一步频率分析丰富，有加速度，所以，时间是真实的时间，例如跌落之后的响应。★
	dict1['results'] = 'stress/strain,displacement/velocity,force'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1
##	*Step, name=Step-2, perturbation
##	*Modal Dynamic, continue=NO
##	0.1, 1.   ## 计算时间长度=1sec, time increment=0.1sec

	## ================================================
	dict1 = {}
	dict1['category'] = 'linear pertubation'
	type1 = 'steady-state dynamics,modal'    ## 频率范围
	dict1['procedure_type'] = STEADY_STATE_MODAL
	dict1['command'] = 'SteadyStateModalStep'  ## 运算非常快
	dict1['keyword'] = '*Steady State Dynamics'     ## 注意不是：'*Steady State Dynamics, modal'
	dict1['user function'] = 'frequency_response_modal_dynamics_step'	## 注意与time_response_modal_dynamics_step()不同
	dict1['solver'] = 'implicit'
	dict1['first step'] = False
	dict1['tags'] = 'damping'
	dict1['input'] = 'scale=linear/logarithmic; lower frequency; higher frequency; use eigenfrequencies to subdivide each frequency range; damping: direct modal/composite modal/Rayleigh/structural'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	##
	dict1['variables'] = 'A,CF,LE,RF,S,U,V'
	dict1['results'] = 'stress/strain, displacement/velocity, force'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1
##	*Step, name=Step-2, perturbation
##	*Steady State Dynamics
##	0.1, 40., 20, 3.

	## ================================================
	dict1 = {}
	type1 = 'random response'		## 在Frequency分析步的基础上
	dict1['category'] = 'linear pertubation'  ## ★★
	dict1['first step'] = False
	dict1['tags'] = 'damping'
	dict1['input'] = 'Nlgeom=off; scale=logarithmic/linear; lower frequency/upper frequency; direct modal(start/end mode); composite modal(start/end mode); Rayleigh(start/end mode, alpha, beta)'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'RandomResponseStep'
	dict1['procedure_type'] = RANDOM_RESPONSE
	dict1['user function'] = ''
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'A,LE,S,U,V'  ## 结果比第一步频率分析丰富
	dict1['results'] = 'stress/strain,displacement/velocity'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	type1 = 'response spectrum'		## 在Frequency分析步的基础上
	dict1['category'] = 'linear pertubation'
	dict1['first step'] = False
	dict1['tags'] = 'damping'
	dict1['input'] = 'Nlgeom=off; excitation=single direction/multi-direction; summation; use response spectrum amplitude component(tabular,periodic,etc); direct modal(start/end mode); composite modal(start/end mode); Rayleigh(start/end mode, alpha, beta)'
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'ResponseSpectrumStep'
	dict1['procedure_type'] = RESPONSE_SPECTRUM
	dict1['user function'] = ''
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'CF,LE,RF,S,U'  ## 结果比第一步频率分析丰富
	dict1['results'] = 'stress/strain,displacement/velocity,force'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	## ================================================
	dict1 = {}
	dict1['category'] = 'linear pertubation'
	type1 = 'steady-state dynamics,subspace'    ## 频率范围
	dict1['procedure_type'] = STEADY_STATE_SUBSPACE	## steady state subspace dynamics
	dict1['command'] = 'SteadyStateSubspaceStep'
	dict1['keyword'] = '*Steady State Dynamics, subspace projection'
	dict1['solver'] = 'implicit'
	dict1['first step'] = False
	dict1['tags'] = ''
	dict1['input'] = 'Nlgom=off;compute real/complex response;scale=linear/logarithmic; lower frequency; higher frequency; use eigenfrequencies to subdivide each frequency range; '
	dict1['equation solver'] = 'matrix solver=use solver default/unsymmetric/symmetric'
	dict1['solution technique'] = ''
	##
	##
	dict1['variables'] = 'A,CF,LE,RF,S,U,V'
	dict1['results'] = 'stress/strain, displacement/velocity, force'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1
##	*Step, name=Step-2, perturbation
##	*Steady State Dynamics, subspace projection, friction damping=NO
##	0.1, 40., 20, 1.   ## 0.1-40是频率范围


	## ================================================
	## 例如: step1=steady-state dynamics,direct; step2=dynamic implicit; step3=dynamic subspace
	## 例如: step1=dynamic implicit; step2=dynamic subspace
	## 在Frequency step之后无法做dynamic,subspace
	## 在static,linear pertubation step之后无法做dynamic,subspace
	## 在dynamic explicit step之后无法做dynamic,subspace
	## 在steady-state dynamics,direct之后无法进行dynamic,subspace
	## 在direct cyclic step之后无法进行synamic,subspace

	if small_type0 in ['dynamic subspace','subspace dynamic']:
		small_type = 'dynamic,subspace'

	dict1 = {}
	type1 = 'dynamic,subspace'
	dict1['category'] = 'general'  ## 注意与稳态的子域分析不一样
	dict1['first step'] = False    ## 前一个分析步为dynamic implicit
	dict1['tags'] = ''
	dict1['input'] = 'Nlgom=off/on;number of modes to use; default load variation with time '
	dict1['equation solver'] = ''
	dict1['solution technique'] = ''
	##
	dict1['command'] = 'SubspaceDynamicsStep'
	dict1['procedure_type'] = DYNAMIC_SUBSPACE
	dict1['solver'] = 'implicit'
	##
	dict1['variables'] = 'A,CDISP,CF,CSTRESS,LE,PE,PEEQ,PEMAG,RF,S,U,V'
	dict1['results'] = 'stress/strain, displacement/velocity, force,contact'
	dict1['antype'] = 'stress'
	small2info[type1] = dict1

	if big_type not in empty:
		small_type = big2small[big_type]
	info = small2info[small_type]

##	print fnln(),'small_type=',small_type
##	print fnln(),'big_type  =',big_type
##	print fnln(),'command   =',info['command']
##	print fnln(),'solver    =',info['solver']

	return info

step_type_info = step_type_detail

function_labels['step_procedure_type'] = 'procedure type','antype'
def step_procedure_type(step=None):
	## VER: 2016-08-31, v1.0
	## DYNAMIC_EXPLICIT, STATIC_GENERAL
	## reference: get_antype()

##	>>> step_procedure_type()
##	'dynamic_explicit'
##	>>>

	if step in empty:
		if len(_m.steps) == 1:
			raise Exception('*** There is only initial step')
		else:
			step = _m.steps.keys()[1]

	step = check_step(step)  ## if step is initial step, type1 = 'none'
	step = _m.steps[step]
	type1 = step.procedureType
	type1 = totext(type1).lower()

	return type1

function_labels['get_antype'] = 'step','procedure type','dof','model'
def get_antype(step=None,index=0):
	## VER: 2016-10-28, v1.3
	## reference: step_procedure_type()

	if step not in empty:
		step = check_step(step)
		steps = [_m.steps[step]]
	else:
		if len(_m.steps) == 1:
			raise Exception('*** No step created yet.')

		steps = _m.steps.values()[1:]  ## Initial step not included

	list1 = []
	for step1 in steps:
		info = step_type_detail(step1)
		type1 = info['antype']
		if type1 not in list1:
			list1.append(type1)

	if len(list1) == 0:
		raise Exception('*** Faile to get the analysis type.')

	antype = list1[0]

	return antype

function_labels['get_solver'] = 'solver','standard','implicit','explicit','antype','analysis'
def get_solver():
	## VER: 2016-10-28, v1.1

##	>>> get_solver()
##	'explicit'
##	>>>

	if len(_m.steps) == 1:
		raise Exception('*** No step created yet.')

	solvers = []
	for step in _m.steps.keys()[1:]:   ## 不包含Initial step
		solver1 = step_type_detail(step)['solver']
##		print fnln(),'solver1=',solver1
		if solver1 not in solvers:
			solvers.append(solver1)

	if len(solvers) == 1:
		solvers = solvers[0]

	return solvers

function_labels['get_module_dims'] = 'PV','suntech','dimension','size','type'
def get_module_dims(module_type):
	## VER: ('2012-11-30, v4.3')

	global glass_length, glass_width, glass_thick, glass_thick1, glass_thick2, EVA_thick, TPT_thick, cell_thick, cell_gap

	cell_thick = 0.18
	cell_gap = 2.5   ;please_check

	EVA_thick = 0.8
	TPT_thick = 0.4

	## ====================
	special = False
	if module_type[0] == 'D':				## 双玻组件
		special = True
		get_diamond_dims(module_type)

	elif module_type.startswith('FL'):	## 无框组件（标准组件去掉边框）
		special = True
		get_frameless_module_dims(module_type)

	elif module_type == 'lumeta':
		special = True

		FRP_length = 2360
		FRP_width = 1230
		FRP_thick = 3.2

		EVA_thick = 0.7
		cell_gap = 3

		cell_length = 125
		cell_array = [9,18]

		write_global_variables(var_file_full,FRP_length,FRP_width,FRP_thick,cell_length)

	elif has_frame == False:
		raise Exception('Fail to get the module dimensions, module_type=' + module_type)

##	print 'special=',special
##	raise Exception

	if special == True:
		## DOE factors (注意：在此之前不要出现secondary variables!!)
		if level_of_this_run not in empty:
			for factor in level_of_this_run.keys():
				globals()[factor] = level_of_this_run[factor]

		return

	## 组件功率：	A:180-195W, W: 225W,   V: 280W,   U: 210W
	## clamp2corner:	A:103-403,  W:108-408, V:127-427, U:96-396
	## 我建议：    A:100-400,  W:100-400, V:130-430
	## 5/9位置：   A: 351,  W:    , V: 435
	## 包装箱：A,U: 装26个组件，V和W:21个组件。

	keys0 = locals().keys()

	if pack_mat == 'Tape':
		top_adhesive_thick = 1	;please_check('0.5mm')
		bot_adhesive_thick = 1	;please_check('0.5mm')
	else:
		top_adhesive_thick = 0.5	;please_check('0.5mm')
		bot_adhesive_thick = 0.5	;please_check('0.5mm')

	silic_side = 1.0	;please_check(1.0, 1.5)  ## 以前一直用1.0

	kahuang_L = 40   ## 30,36,40(Cao: kahuang=40, 以前FEA:kahuang=50)
	options.append('kahuang_L=' + str(kahuang_L))		##**************

	## 看来用lip=1.5比lip=1.8结果更好，应力差不多，收敛却更好。

	if module_type == 'W50':
		frame_mass_ref = 3655
		glass_thick = 3.2
		glass_cover = 8

		top_lip_thick = 2			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 2			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 50			;please_check
		outer_wall_thick = 2			;please_check
		base_thick = 2			;please_check
		inner_wall_thick = 1.5	;please_check
		leg_gap = 4					;please_check('4(std), 5')
		wide_leg_gap = False
		flange_thick = base_thick

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1640   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 156		## 多晶
		cell_array = [6,10]	## 60 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = top_lip_width

##		if wide_leg_gap == True:
##			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
##		else:
##			bot_lip_width = top_lip_width

	elif module_type == 'W35':		## 新35mm边框, since 2012
		frame_mass_ref = 3655
		glass_thick = 3.2
		glass_cover = 8

		top_lip_thick = 1.7			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.7			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 35			;please_check
		outer_wall_thick = 1.5			;please_check
		base_thick = 1.5			;please_check
		inner_wall_thick = 1.3	;please_check
		leg_gap = 11.5					;please_check('4(std), 5')
		wide_leg_gap = True
		flange_thick = base_thick

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1640   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 156		## 多晶
		cell_array = [6,10]	## 60 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick

	elif module_type == 'Id':		## 边框截面与W35一样，电池数量4*10
		frame_mass_ref = 3655
		glass_thick = 3.2
		glass_cover = 8

		top_lip_thick = 1.7			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.7			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 35			;please_check
		outer_wall_thick = 1.5			;please_check
		base_thick = 1.5			;please_check
		flange_thick = base_thick
		inner_wall_thick = 1.3	;please_check
		leg_gap = 11.5					;please_check('4(std), 5')
		wide_leg_gap = True

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1640   ## 1665, 2012年1月份调整为1640
		module_top_width = 676

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 156		## 156单晶
		cell_array = [4,10]	## 40 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick

	elif module_type == 'SPK':
		frame_mass_ref = 0
		glass_thick = 3.2
		glass_cover = 11			;please_check('注意不是8')

		top_lip_thick = 1.7		;please_check
		bot_lip_thick = 1.3			;please_check

		frame_height = 34			;please_check
		outer_wall_thick = 1.3			;please_check
		base_thick = 1.3			;please_check
		inner_wall_thick = 1.3	;please_check
		leg_gap = 5.2					;please_check('4(std), 5')
		wide_leg_gap = False
		flange_thick = base_thick

		frame_bot_width = 29
		flange_dir = 'inside'

		module_top_length = 1675   ## 1665, 2012年1月份调整为1640
		module_top_width = 1001

		hole2corner1 = 290

		cell_length = 156		## 多晶
		cell_array = [6,10]	## 60 cells

		top_lip_width = 15.3
		bot_lip_width = 13.3

	elif module_type == 'V50':
		frame_mass_ref = 4041
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 2			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 2			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 50			;please_check
		outer_wall_thick = 2			;please_check
		base_thick = 2			;please_check
		inner_wall_thick = 1.5	;please_check
		leg_gap = 4					;please_check('4(std), 5')
		wide_leg_gap = False
		flange_thick = base_thick

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1956   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 156		## 多晶, 280W, 275W
		cell_array = [6,12]	## 72 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = top_lip_width

	elif module_type == 'V40':
		frame_mass_ref = 2845
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 1.5		;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.5		;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 40			;please_check
		outer_wall_thick = 1.5			;please_check
		base_thick = 1.5			;please_check
		inner_wall_thick = 1.3	;please_check
		leg_gap = 11.5					;please_check('4(std), 5')
		wide_leg_gap = True
		flange_thick = base_thick

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1956   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 156		## 多晶, 280W, 275W
		cell_array = [6,12]	## 72 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick

	elif module_type == 'A':
		frame_mass_ref = 2168
		glass_thick = 3.2
		glass_cover = 8

		top_lip_thick = 1.7			;please_check
		bot_lip_thick = 1.7			;please_check

		frame_height = 35				;please_check
		outer_wall_thick = 1.5			;please_check
		base_thick = 1.5			;please_check
		inner_wall_thick = 1.5	;please_check
		leg_gap = 4					;please_check('4(std), 5')

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1580   ## 190W, 195W
		module_top_width = 808

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 125		## 单晶
		cell_array = [6,12]	## 72 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
		else:
			bot_lip_width = top_lip_width

	elif module_type == 'U':
		frame_mass_ref = 2247
		glass_thick = 3.2
		glass_cover = 8

		top_lip_thick = 1.7			;please_check
		bot_lip_thick = 1.7			;please_check

		frame_height = 35				;please_check
		outer_wall_thick = 1.5			;please_check
		base_thick = 1.5			;please_check
		inner_wall_thick = 1.5	;please_check
		leg_gap = 4					;please_check('4(std), 5')

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1482
		module_top_width = 992

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 156		## 多晶, 210W, 205W
		cell_array = [6,9]	## 54 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
		else:
			bot_lip_width = top_lip_width

	elif module_type == 'H':		##超大组件
		frame_mass_ref = 4041
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 1.7		;please_check
		bot_lip_thick = 2			;please_check

		frame_height = 50			;please_check
		outer_wall_thick = 1.9		;please_check
		base_thick = 2			;please_check
		inner_wall_thick = 1.5	;please_check
		leg_gap = 11.6				;please_check('4(std), 5')

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1930
		module_top_width = 1319

		hole2corner1 = 140
		hole2corner2 = 390

		cell_length = 156
		cell_array = [8,12]	## 96 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick

	elif module_type == 'R1':		##Reliathon组件
		frame_mass_ref = 4146
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 2		;please_check
		bot_lip_thick = 2			;please_check

		frame_height = 65			;please_check
		outer_wall_thick = 3.0		;please_check
		inner_wall_thick = 1.5	;please_check
		base_thick = 2				;please_check
		flange_thick = base_thick

		leg_gap = 5				;please_check('4(std), 5')
		legs_span = inner_wall_thick + leg_gap + outer_wall_thick

		frame_bot_width = 'NA'
		flange_dir = 'outside'

		flange_S = 0
		turn_H = 8
		turn_thick = base_thick

##		frame_bot_width_big = 40.5
##		frame_bot_width_small = frame_bot_width_big - (inner_wall_thick + leg_gap + outer_wall_thick) - base_thick

		frame_bot_width_big0 = 51.5   ## OK
		frame_bot_width_small = 40.5	## control (OK)
		U_gap_small = frame_bot_width_small - turn_thick - legs_span
		U_gap_big = frame_bot_width_small + 0.5
		frame_bot_width_big = legs_span + U_gap_big + turn_thick	## right frame

		module_top_length = 1958
		module_top_width = 994

		cell_length = 156
		cell_array = [6,12]	## 72 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = top_lip_width

##	elif module_type == 'R15':		##Reliathon组件
##		frame_mass_ref = 4146
##		glass_thick = 4
##		glass_cover = 8
##
##		top_lip_thick = 2		;please_check
##		bot_lip_thick = 2			;please_check
##
##		frame_height = 50			;please_check('由65边50mm')
##		outer_wall_thick = 2.0		;please_check('由3mm变2mm')
##		inner_wall_thick = 1.5	;please_check
##		base_thick = 2				;please_check
##		flange_thick = base_thick
##
##		leg_gap = 4				;please_check('4(std), 5')
##		legs_span = inner_wall_thick + leg_gap + outer_wall_thick
##
##		frame_bot_width = 'NA'
##		flange_dir = 'outside'
##
##		flange_S = 0
##		turn_H = 8
##		turn_thick = base_thick
##
####		frame_bot_width_big = 40.5
####		frame_bot_width_small = frame_bot_width_big - (inner_wall_thick + leg_gap + outer_wall_thick) - base_thick
##
##		frame_bot_width_big0 = 51.5   ## OK
##		frame_bot_width_small = 40.5	## control (OK)
##		U_gap_small = frame_bot_width_small - turn_thick - legs_span
##		U_gap_big = frame_bot_width_small + 0.5
##		frame_bot_width_big = legs_span + U_gap_big + turn_thick	## right frame
##
##		module_top_length = 1958
##		module_top_width = 994
##
##		cell_length = 156
##		cell_array = [6,12]	## 72 cells
##
##		top_lip_width = glass_cover + silic_side + outer_wall_thick
##		bot_lip_width = top_lip_width

	elif module_type == 'R15':		## Reliathon 2.0  (注意：G1.5是失败的设计，高度为50mm，窄型腔)
		frame_mass_ref = 4041
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 2				;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.5			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 50				;please_check('由65边50mm')
		outer_wall_thick = 2			;please_check('由3mm变2mm')
		inner_wall_thick = 1.5		;please_check
		base_thick = 2			;please_check
		flange_thick = base_thick

		wide_leg_gap = False		;please_check('R1b是wid_leg_gap?')
		if wide_leg_gap == True:
			leg_gap = 11.5		## control
			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick
		else:
			legs_span = 8.5	## control
			leg_gap = legs_span - outer_wall_thick - inner_wall_thick
##			leg_gap = 4			## control
##			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick

		frame_bot_width = 'NA'
		flange_dir = 'outside'

		flange_S = 0
		turn_H = 8		## 含base_thick
		turn_thick = base_thick

		frame_bot_width_big0 = 51.5
		frame_bot_width_small = 40.5	## control
		U_gap_small = frame_bot_width_small - turn_thick - legs_span
		U_gap_big = frame_bot_width_small + 0.5
		frame_bot_width_big = legs_span + U_gap_big + turn_thick	## right frame

		## try, 不采用
##		step_H = 12
##		step_width = frame_bot_width_big - frame_bot_width_big0

		module_top_length = 1956   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		cell_length = 156		## 多晶, 280W, 275W
		cell_array = [6,12]	## 72 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
		else:
			bot_lip_width = top_lip_width

	elif module_type == 'R1b':		## Reliathon 2.0  (注意：G1.5是失败的设计，高度为50mm，窄型腔)
		frame_mass_ref = 4041
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 2				;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.5			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 65				;please_check
		outer_wall_thick = 1.5		;please_check
		inner_wall_thick = 1.3		;please_check
		base_thick = 1.5			;please_check
		flange_thick = base_thick

		wide_leg_gap = False		;please_check('R1b是wid_leg_gap?')
		if wide_leg_gap == True:
			leg_gap = 11.5		## control
			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick
		else:
			legs_span = 8.5	## control
			leg_gap = legs_span - outer_wall_thick - inner_wall_thick
##			leg_gap = 4			## control
##			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick

		frame_bot_width = 'NA'
		flange_dir = 'outside'

		flange_S = 0
		turn_H = 8		## 含base_thick
		turn_thick = base_thick

		frame_bot_width_big0 = 51.5
		frame_bot_width_small = 40.5	## control
		U_gap_small = frame_bot_width_small - turn_thick - legs_span
		U_gap_big = frame_bot_width_small + 0.5
		frame_bot_width_big = legs_span + U_gap_big + turn_thick	## right frame

		## try, 不采用
##		step_H = 12
##		step_width = frame_bot_width_big - frame_bot_width_big0

		module_top_length = 1956   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		cell_length = 156		## 多晶, 280W, 275W
		cell_array = [6,12]	## 72 cells

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
		else:
			bot_lip_width = top_lip_width

	elif module_type == 'R3':		## Reliathon 3.0  非对称边框
		frame_mass_ref = 4041
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 2				;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.5			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 40				;please_check('**')
		outer_wall_thick = 1.5		;please_check
		inner_wall_thick = 1.3		;please_check

		base_thick = 1.5			;please_check	## leg gap的底边厚
		flange_thick = 2   	## C边的厚度

		wide_leg_gap = True		;please_check('**R1b是wid_leg_gap')
		if wide_leg_gap == True:
			leg_gap = 11.5		## control
			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick
		else:
			##控制legs_span
##			legs_span = 8.5	## control
##			leg_gap = legs_span - outer_wall_thick - inner_wall_thick

			##控制leg_gap
			leg_gap = 5.7			## control, 以前是4
			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick

		frame_bot_width = 'NA'
		flange_dir = 'outside'

		flange_S = 0
		turn_H = 8		## 含flange_thick
		turn_thick = 2.0

		frame_bot_width_big0 = 51.5
		frame_bot_width_small = 35		## control**
		U_gap_small = frame_bot_width_small - turn_thick - legs_span
		U_gap_big = frame_bot_width_small + 0.7
		frame_bot_width_big = legs_span + U_gap_big + turn_thick	## right frame

		## try, 不采用
##		step_H = 12
##		step_width = frame_bot_width_big - frame_bot_width_big0

		module_top_length = 1956   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		cell_length = 156		## 多晶, 280W, 275W
		cell_array = [6,12]	## 72 cells

		spacer_bot_thick = 2.5		;please_check
		spacer_wall_thick = 2

		spacer_width = 30  ## 30(std),35
		spacer_offset = 2.5
		spacer_H = 65 - frame_height

		spacer_length = 400
		spacer_length = spacer_length/2
		spacer_top_thick = spacer_wall_thick
		spacer_open = 18

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
		else:
			bot_lip_width = top_lip_width

	elif module_type == 'R4':		## Reliathon 3.0 铆接钢管方案
		frame_mass_ref = 4041
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 2				;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.5			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 40				;please_check('**')
		outer_wall_thick = 1.8		;please_check
		inner_wall_thick = 1.3		;please_check

		base_thick = 1.8			;please_check	## leg gap的底边厚
		flange_thick = 2.5   	## C边的厚度

		wide_leg_gap = True		;please_check('**R1b是wid_leg_gap')
		if wide_leg_gap == True:
			leg_gap = 11.5		## control
			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick
		else:
			##控制legs_span
##			legs_span = 8.5	## control
##			leg_gap = legs_span - outer_wall_thick - inner_wall_thick

			##控制leg_gap
			leg_gap = 5.7			## control, 以前是4
			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick

		frame_bot_width = 'NA'
		flange_dir = 'outside'

		flange_S = 0
		turn_H = 8		## 含flange_thick
		turn_thick = 2.0

		frame_bot_width_big0 = 51.5
		frame_bot_width_small = 35		## control**
		U_gap_small = frame_bot_width_small - turn_thick - legs_span
		U_gap_big = frame_bot_width_small + 0.7
		frame_bot_width_big = legs_span + U_gap_big + turn_thick	## right frame

		## try, 不采用
##		step_H = 12
##		step_width = frame_bot_width_big - frame_bot_width_big0

		module_top_length = 1956   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		cell_length = 156		## 多晶, 280W, 275W
		cell_array = [6,12]	## 72 cells

		spacer_bot_thick = 3		;please_check
		spacer_wall_thick = 3

		spacer_width = 35  ## 30(std),35
		spacer_offset = 2
		spacer_H = 65 - frame_height

		spacer_length = 600
		spacer_length = spacer_length/2
		spacer_top_thick = spacer_wall_thick
		spacer_open = 18

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
		else:
			bot_lip_width = top_lip_width

	elif module_type == 'R5':		## Reliathon 3.0 铆接钢管方案
		module_top_length = 1956   ## 1665, 2012年1月份调整为1640
		module_top_width = 992

		cell_length = 156		## 多晶, 280W, 275W
		cell_array = [6,12]	## 72 cells

		frame_mass_ref = 4041
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 2				;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')
		bot_lip_thick = 1.5			;please_check('若小于2，会使实际的leg_gap_H偏高，同时lam2rail偏大')

		frame_height = 40				;please_check('**')
		outer_wall_thick = 1.5		;please_check
		inner_wall_thick = 1.3		;please_check

		base_thick = 2.0			;please_check	## leg gap的底边厚
		flange_thick = 2.5   	## C边的厚度

		wide_leg_gap = False		;please_check('**R1b是wid_leg_gap')
		if wide_leg_gap == True:
			leg_gap = 11.5		## control
			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick
		else:
			##控制legs_span
			legs_span = 8.5	## control(左右边框都是)
			leg_gap = legs_span - outer_wall_thick - inner_wall_thick

			##控制leg_gap
##			leg_gap = 5.7			## control, 以前是4(R1)
##			legs_span = inner_wall_thick + leg_gap + outer_wall_thick		## R1: legs_span=8.5mm, so leg_gap=8.5 - outer_wall_thick - inner_wall_thick

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick
		else:
			bot_lip_width = top_lip_width

		frame_bot_width = 'NA'
		flange_dir = 'outside'

		flange_S = 0
		turn_H = 8		## 含flange_thick
		turn_thick = 2.0
		gasket_thick = 2

		frame_bot_width_big0 = 51.5   ## 仅供参考

		frame_bot_width_small = 38		## control**(R1为40.5)
		assemble_tolerance = 0.5

		frame_bot_width_big = legs_span + frame_bot_width_small + turn_thick + assemble_tolerance   ## 例如: 8.5+40.5+2 + 0.5 = 51.5
##		print 'frame_bot_width_small=',frame_bot_width_small
##		print 'frame_bot_width_big=',frame_bot_width_big

		U_gap_small = frame_bot_width_small - turn_thick - legs_span
		U_gap_big = frame_bot_width_big - turn_thick - legs_span  ## 含有装配容差
		U_gap_gasket = U_gap_small - 2*gasket_thick

		## hole在U_gap_small的中间。
		hole2wall_big = turn_thick + U_gap_small/2  ## U-bolt的孔的中心到左边框的侧壁的距离
		hole2wall_small = U_gap_small/2
		if hole2wall_small - gasket_thick < 7:
			print 'hole2wall_small - gasket_thick=',hole2wall_small - gasket_thick
			raise Exception('hole2wall_small - gasket_thick < 7')

		spacer_H = 65 - frame_height
		spacer_offset = 2.5

		left_leg_wall = 2
		left_leg_bot = 2
		left_leg_width = 6

		## right_leg平齐U_turn
		right_leg_wall = 1.5
		right_leg_bot = 2
		right_leg_width = 13

		hole2left_leg = hole2wall_big - spacer_offset - left_leg_width
		if hole2left_leg < 7:
			print 'hole2left_leg=',hole2left_leg
			raise Exception('hole2left_leg < 7')

		spacer_open = frame_bot_width_big - legs_span - spacer_offset - left_leg_width - right_leg_width
		spacer_width = left_leg_width + spacer_open + right_leg_width

##		spacer_open = 13	;please_check
##		spacer_width = 30  ## 30(std),35
##		spacer_width = frame_bot_width_big - legs_span - spacer_offset


##		left_leg_width = hole2wall_big - spacer_open/2 - spacer_offset   ## 矩形框的底部开有open, 左边是L(矩形)，右边是rect
		if left_leg_width < 6:
			print 'left_leg_width=',left_leg_width
			raise Exception('Error left_leg_width')

##		right_leg_width = spacer_width - left_leg_width - spacer_open

	elif module_type == 'JR':		##Reliathon组件
		frame_mass_ref = 4146
		glass_thick = 4
		glass_cover = 8

		top_lip_thick = 1.7		;please_check
		bot_lip_thick = 2			;please_check

		frame_height = 50			;please_check
		outer_wall_thick = 2.5		;please_check
		base_thick = 2			;please_check
		inner_wall_thick = 2		;please_check
		leg_gap = 6					;please_check('4(std), 5')

		frame_bot_width = 35
		flange_dir = 'inside'

		module_top_length = 1958   ;please_check('等待确认...')
		module_top_width = 994		;please_check('等待确认...')

		cell_length = 156				;please_check('等待确认...')
		cell_array = [6,12]			;please_check('等待确认...')

		bolt_D_JR = 5   ## M8 的螺丝，取一半

		top_lip_width = glass_cover + silic_side + outer_wall_thick
		bot_lip_width = top_lip_width + 6

	please_check('外部提供')
	## DOE factors (注意：在此之前不要出现secondary variables!!)
	if level_of_this_run not in empty:
		for factor in level_of_this_run.keys():
			locals()[factor] = level_of_this_run[factor]
			value1 = level_of_this_run[factor]
			exec(factor + '=value1')

		del value1,factor

	##无外部提供,前面的内部也不提供top_lip_width和bot_lip_width
	if have_common(level_of_this_run.keys(),['glass_cover','silic_side','outer_wall_thick']):
		top_lip_width = glass_cover + silic_side + outer_wall_thick			;please_check

	if have_common(level_of_this_run.keys(),['outer_wall_thick','inner_wall_thick','leg_gap','glass_cover','silic_side']):
		bot_lip_width = top_lip_width
		if wide_leg_gap == True:
			bot_lip_width = outer_wall_thick + leg_gap + inner_wall_thick

	## secondary Variables:
	legs_span = inner_wall_thick + leg_gap + outer_wall_thick

	if _module_type[0] != 'R':
		bot_flange_hange = frame_bot_width - legs_span	##注意：其实frame_bot_width在长边和短边是不同的。

	lam_thick = glass_thick + EVA_thick + TPT_thick
	frame_mouth_gap = lam_thick + top_adhesive_thick + bot_adhesive_thick
	leg_gap_H = frame_height - (top_lip_thick + frame_mouth_gap + bot_lip_thick + base_thick)

	frame_length_L = module_top_length
	frame_length_S = module_top_width

	options.append('glass_thick='+str(glass_thick))		## **********

	glass_length = module_top_length - (outer_wall_thick + silic_side)*2
	glass_width = module_top_width - (outer_wall_thick + silic_side)*2

	print ' '
	print '****module_top_length, module_top_width, frame_height, glass_thick=',module_top_length, '×',module_top_width, '×',frame_height, '×', glass_thick,'mm'
	print ' '

	module_dims = locals2globals(keys0,locals())
	globals()['module_dims'] = module_dims
	add2my_globals('module_dims')

	globals()['cross_section_dims'] = ['frame_height','outer_wall_thick','inner_wall_thick','leg_gap', 'legs_span','base_thick','flange_thick', 'bot_flange_hange', 'frame_bot_width','glass_thick','top_lip_thick','bot_lip_thick','top_lip_width','bot_lip_width']

	write_global_variables(var_file_full,module_top_length,module_top_width,frame_mass_ref)

	line_print(var_file_full,' ')
	line_print(var_file_full,'## cross_section_dims:')
	write_global_variables(var_file_full,cross_section_dims)
	line_print(var_file_full,' ')

##	raise Exception

	return

def get_msface_and_msregion(master_inst,slave_inst,mfaces=None,sfaces=None, mregion=None, sregion=None, info='',
	xEdges_m=None, xEdges_s=None, xEdges=None, search_or_find='search', fix='_',refined_insts='_', gap=None,force_create=False):
	## VER: ('VER: 2014-11-13, v5.0')		## if sregion or mregion is provided, then they are readonly, and will not created again.
	## 本函数中，master_inst和slave_inst是不可省的。mfaces和sfaces不能都不提供。

	global contact_pairs, msfaces_trace, msfaces_determined

	add_to_process()

##	get_current_model()

	start_func(this_and_caller(to_print=False)[-2])

##	print fnln(),'force_create=',force_create
##	raise Exception

	master_inst = check_inst(master_inst)
	slave_inst = check_inst(slave_inst)

	if force_create == False:
		if '2D' in part_shape(master_inst)[1] or '2D' in part_shape(slave_inst)[1]:
			force_create = True

	if mfaces in empty and mregion in empty:
		raise Exception('*** mfaces or mregion is required.')

	if sfaces in empty and sregion in empty:
		raise Exception('*** sfaces or sregion is required.')
##	if [mfaces,sfaces] == [None, None]:
##		raise Exception('either mfaces or sfaces should be provided.')

	if xEdges not in empty:
		if type_of(xEdges) == 'STR':
			if xEdges in master_inst.sets.keys():
				xEdges_m = set2objs(xEdges,master_inst)

			if xEdges in slave_inst.sets.keys():
				xEdges_s = set2objs(xEdges,slave_inst)

		elif type_of(xEdges) == 'LIST':
			poi = get_poi(xEdges[0])
			if master_inst.name == poi.name:
				xEdges_m = xEdges
			elif slave_inst.name == poi.name:
				xEdges_s = xEdges

	if type_of(xEdges_m) == 'STR':
		xEdges_m = set2objs(xEdges_m,master_inst)

	if type_of(xEdges_s) == 'STR':
		xEdges_s = set2objs(xEdges_s,slave_inst)

	if type_of(mfaces) == 'STR':
		mfaces = set2objs(master_inst,mfaces)
	elif mregion not in empty:
##		mfaces = region2objs(master_inst,mregion)
		mfaces = region2objs(mregion)

	if type_of(sfaces) == 'STR':
		sfaces = set2objs(slave_inst,sfaces)
	elif sregion not in empty:
##		sfaces = region2objs(slave_inst,sregion)
		sfaces = region2objs(sregion)

##	print fnln(),'force_create=',force_create
##	raise Exception

##	stop1()

	please_check
##	if force_create == False:
##		fix,refined_insts = check_fix_extend(fix,refined_insts,master_inst,slave_inst,force_create=force_create)
##	else:
##		fix = master_inst.name + ',' + slave_inst.name

	trace0 = get_traceback()[-2:];		trace0[0] = '  ' + trace0[0]
	msfaces_trace.append(trace0 + [master_inst.name + '_mface',objs_num(mfaces),slave_inst.name + '_sface',objs_num(sfaces), 'ext=' + refined_insts,'fix=' + fix,'force=' + repr(force_create)])

	print fnln(),'mast=',master_inst.name
	print fnln(),'slave=',slave_inst.name
##	raise Exception

	if sfaces not in empty and mfaces in empty:
		sfaces1,mfaces = side1_faces_to_pair(sfaces,side1_inst=slave_inst,side2_inst=master_inst,search_or_find=search_or_find, fix=fix, refined_insts=refined_insts, force_create=force_create,gap=gap)
		if sfaces1 not in empty and mfaces not in empty:
			sfaces = sfaces1

	elif sfaces in empty and mfaces not in empty:
		mfaces1, sfaces = side1_faces_to_pair(mfaces,side1_inst=master_inst,side2_inst=slave_inst, search_or_find=search_or_find, fix=fix,refined_insts=refined_insts, force_create=force_create,gap=gap)
		if mfaces1 not in empty and sfaces not in empty:
			mfaces = mfaces1

	elif mfaces not in empty and sfaces not in empty:
		globals()['sfaces'] = sfaces
		globals()['mfaces'] = mfaces
		## use for highlight and check

##		stop1()

##		if master_inst.name in fix and slave_inst.name in fix:
##			msfaces_determined = True
##			force_create = True

		if force_create == False:
			shape1 = face_shape(mfaces)
			shape2 = face_shape(sfaces)

			if not (shape1 == shape2 == 'plane'):
				force_create = True	;please_check

		## 注意，下面很容易导致程序异常出错退出。
		if force_create == False:
##			fix,refined_insts = check_fix_extend(fix=fix,refined_insts=refined_insts,p1=master_inst,p2=slave_inst,force_create=False)
			cross = cross_of_faces_and_faces(mfaces,sfaces,fix=fix,refined_insts=refined_insts,force_create=force_create,gap=gap)

			if cross['no_cross'] == True:
				if force_create == False:
					print "**cross=",cross
##				raise Exception('在get_msface_and_msregion()中无法找到接触对，换成find_contacts()方式试试。')  ## ********
			else:
				mfaces1 = cross[master_inst.name]
				sfaces1 = cross[slave_inst.name]

				if mfaces1 not in empty:
					mfaces = mfaces1
				if sfaces1 not in empty:
					sfaces = sfaces1
##				if mfaces in empty or sfaces in empty:
##					raise Exception('mfaces or sfaces is turn to empty due to no_cross = True')

	if mfaces in empty or sfaces in empty:
		raise Exception('在get_msface_and_msregion()中无法找到接触对，换成find_contacts()方式试试。')  ## ********

	trace0 = get_traceback()[-2:];		trace0[0] = '  ' + trace0[0]
	msfaces_trace.append(trace0 + [master_inst.name + '_mface',objs_num(mfaces),slave_inst.name + '_sface',objs_num(sfaces), 'ext=' + refined_insts,'fix=' + fix,'force=' + repr(force_create), '**determined=' + repr(msfaces_determined)])

	if mregion in empty:
		if xEdges_m in empty:
##			mregion = list2region(mfaces,master_inst,region_type='surface')
			mregion = create_surface(objs=mfaces,info=info)
		else:
			name = '_xEdge_in_' + master_inst.name + '(m)//' + slave_inst.name
			name = new_key(a.sets.keys(),name)
			mregion = create_mix_region(master_inst,faces=mfaces,xEdges=xEdges_m,xEdges_name=name)

##	stop1()
	if sregion in empty:
		if xEdges_s in empty:
##			sregion = list2region(sfaces,slave_inst,region_type='surface')
			sregion = create_surface(objs=sfaces, info=info)
		else:
			name = '_xEdge_in_' + slave_inst.name + '(s)//' + master_inst.name
			name = new_key(a.sets.keys(),name)
			sregion = create_mix_region(slave_inst,faces=sfaces,xEdges=xEdges_s,xEdges_name=name)

	if xEdges_m in empty:
		xEdges_m = []

	if xEdges_s in empty:
		xEdges_s = []

##	raise Exception
##	stop1()

	return mfaces,sfaces,xEdges_m,xEdges_s,mregion,sregion

def create_C_steel(partname,height=None,broad=None,C=None,thick=None,C_sec=(),length=None,ndir='z',bone_dir=None):
	## VER: 2014-09-08, v1.0
	## create_C_steel('C1',C_sec=(120, 50, 20, 2.5),length=200, ndir='y', bone_dir='z')

	name = new_key('sk_H',_m.sketches)
	partname = new_key(partname,_m.parts)

	dx = 'dx'
	dy = 'dy'

	if is_numbers(C_sec):
		C_sec = _rsort(C_sec)
		if len(C_sec) == 2:
			height, broad = C_sec
		elif len(C_sec) == 3:
			height, broad, C = C_sec
		elif len(C_sec) == 4:
			height, broad, C, thick = C_sec

	if is_numbers(height, broad, C, thick) == False:
		raise Exception('*** dimensions are required.')

	height, broad, C, thick = _rsort(height, broad, C, thick)

	if is_number(length) == False:
		raise Exception('*** lengh is required.')

	if type_of(bone_dir) == 'STR':
		bone_dir = bone_dir.lower()

	ndir = ndir.lower()
	s = _m.ConstrainedSketch(name=name, sheetSize=200.0)
	s.setPrimaryObject(option=STANDALONE)
	s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	connect_points(s,(0,0),(dy,height),(dx,broad),(dy,-C),(dx,-thick), (dy,C - thick), (dx, -broad + 2*thick), (dy,-height + 2*thick), (dx, broad - 2*thick), (dy, C - thick), (dx, thick), (dy, -C), (dx,-broad))

	_m.Part(name=partname, dimensionality=THREE_D, type=DEFORMABLE_BODY)
	p = _m.parts[partname]

	p.BaseSolidExtrude(sketch=s, depth=length)
	s.unsetPrimaryObject()
	p.regenerate()

	if ndir == 'y':
		rotate_part(partname,angle_x=90)
		p = _m.parts[partname]
	elif ndir == 'x':
		rotate_part(partname,angle_y=90)
		p = _m.parts[partname]

	if bone_dir in ['x','y','z']:
		if bone_dir == ndir:
			raise Exception('*** bone_dir should be the bone_dir direction in cross-section.')

		bone_dir = dir2num(bone_dir)
		spans = spans_of_poi(partname)

		real_dim = spans[bone_dir]
		target_dim = height

		if real_dim != target_dim:
			if ndir == 'x':
				rotate_part(partname,angle_x = 90)
			elif ndir == 'y':
				rotate_part(partname,angle_y = 90)
			elif ndir == 'z':
				rotate_part(partname,angle_z = 90)

			p = _m.parts[partname]

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=p)

	return partname

def create_H_steel(partname,height=None,broad=None,t1=None,t2=None,H_sec=(),length=None,ndir='z',bone_dir=None):
	## VER: 2014-09-15, v1.1, t2:H竖直边的壁厚，t2H边缘边的壁厚。height:H中间竖直边的高度。尺寸上，像是一个旋转90度的H，或像工字。
	## create_H_steel('H1',H_sec=(100,50,5,7),length=200,ndir='y',bone_dir='x')

	name = new_key('sk_H',_m.sketches)
	partname = new_key(partname,_m.parts)

	dx = 'dx'
	dy = 'dy'

	if is_numbers(H_sec):
		H_sec = _rsort(H_sec)
		if len(H_sec) == 2:
			height,broad = H_sec
		elif len(H_sec) == 4:
			height, broad, t2,t1 = H_sec

	if is_numbers(height,broad,t1,t2) == False:
		raise Exception('*** dimensions are required.')

	height,broad,t2,t1 = _rsort(height,broad,t2,t1)
	overhang = (broad - t2)/2.0

	if is_number(length) == False:
		raise Exception('*** length is requred.')

	if type_of(bone_dir) == 'STR':
		bone_dir = bone_dir.lower()

	ndir = ndir.lower()
	s = _m.ConstrainedSketch(name=name, sheetSize=200.0)
	s.setPrimaryObject(option=STANDALONE)
	s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	connect_points(s,(0,0),(dx,broad),(dy,t1),(dx,-overhang),(dy,height - 2*t1),(dx,overhang),(dy,t1),(dx,-broad),(dy,-t1),(dx,overhang),(dy,-height + 2*t1),(dx,-overhang),(dy,-t1))

	_m.Part(name=partname, dimensionality=THREE_D, type=DEFORMABLE_BODY)
	p = _m.parts[partname]

	p.BaseSolidExtrude(sketch=s, depth=length)
	s.unsetPrimaryObject()
	p.regenerate()

	batch_divide_in_x(p)
	batch_divide_in_y(p)

##	print 'ndir=',ndir
##	raise Exception

	if ndir == 'y':
		rotate_part(partname,angle_x=90)
		p = _m.parts[partname]
	elif ndir == 'x':
		rotate_part(partname,angle_y=90)
		p = _m.parts[partname]

	if bone_dir in ['x','y','z']:
		if bone_dir == ndir:
			raise Exception('*** bone_dir should be the bone_dir direction in cross-section.')

		bone_dir = dir2num(bone_dir)
		spans = spans_of_poi(partname)

		real_dim = spans[bone_dir]
		target_dim = height

		if real_dim != target_dim:
			if ndir == 'x':
				rotate_part(partname,angle_x = 90)
			elif ndir == 'y':
				rotate_part(partname,angle_y = 90)
			elif ndir == 'z':
				rotate_part(partname,angle_z = 90)

			p = _m.parts[partname]

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=p)

	return partname

def create_pipe_steel(partname,x1=None,y1=None,thick=None,x2=None,y2=None,D1=None,R1=None,D2=None,R2=None,
	rec_sec=(),length=None,ndir='z',bone_dir=None,ptype='deformable'):
	## VER: 2014-09-17, v1.4
	## bone_dir是指截面中相对长的那条边的方向。
	## (计算钢材用量时，按密度钢材7.85计算。)
	## 对于实心型材，用create_block()

	## Example:
	## create_pipe_steel('p1',x1=8,D2=3)
	## create_pipe_steel('p1',x1=6,x2=4)  ## 外边长6，内边长4
	## create_pipe_steel(rail,x1=rail_width,y1=rail_height,thick=rail_thick,length=rail_length)
	## create_pipe_steel(rail,x1=4,y1=6)   ## 实心的

	name = new_key('sk_pipe',_m.sketches)
	partname = new_key(partname,_m.parts)

	if is_numbers(rec_sec) == True:
		rec_sec = tolist(rec_sec)
		rec_sec = _sort(rec_sec)
		rec_sec.reverse()
		if len(rec_sec) == 2:   ## 方钢，而不是solid block
			x1 = y1 = rec_sec[0]
			thick = rec_sec[1]
		elif len(rec_sec) == 3:	## 长，宽，厚
			x1,y1,thick = rec_sec

	if is_number(D1):
		R1 = D1/2.0

	if is_number(D2):
		R2 = D2/2.0

	if is_numbers(R1,thick):
		R2 = R1 - thick

	if is_number(x1) and y1 in empty:
		y1 = x1

	if is_number(x2) and y2 in empty:
		y2 = x2

	if is_number(length) == False:
		raise Exception('*** length is required.')

	if type_of(bone_dir) == 'STR':
		bone_dir = bone_dir.lower()

	ndir = ndir.lower()
	s = _m.ConstrainedSketch(name=name, sheetSize=200.0)
	s.setPrimaryObject(option=STANDALONE)
	s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	if is_numbers(x1,y1):
		s.rectangle(point1=(-x1/2.0, -y1/2.0), point2=(x1/2.0, y1/2.0))

		if is_number(thick):
			x2 = x1 - 2.0*thick
			y2 = y1 - 2.0*thick

	if is_numbers(x2,y2):
		s.rectangle(point1=(-x2/2.0, -y2/2.0), point2=(x2/2.0, y2/2.0))

	if is_number(R1):
		s.CircleByCenterPerimeter(center=(0.0, 0.0), point1=(R1, 0.0))

	if is_number(R2):
		s.CircleByCenterPerimeter(center=(0.0, 0.0), point1=(R2, 0.0))

	pshape,ptype = real_pshape_and_ptype(pshape=THREE_D, ptype=ptype)
	_m.Part(name=partname, dimensionality=pshape, type=ptype)
	p = _m.parts[partname]

	p.BaseSolidExtrude(sketch=s, depth=length)
	s.unsetPrimaryObject()
	p.regenerate()

	if R1 in empty and R2 in empty:
		batch_divide_in_x(p)
		batch_divide_in_y(p)

	if ndir == 'y':
		rotate_part(partname,angle_x=90)
		p = _m.parts[partname]
	elif ndir == 'x':
		rotate_part(partname,angle_y=90)
		p = _m.parts[partname]

	if bone_dir in ['x','y','z']:
		if bone_dir == ndir:
			raise Exception('*** bone_dir should be the bone_dir direction in cross-section.')

		bone_dir = dir2num(bone_dir)
		spans = spans_of_poi(partname)

		real_dim = spans[bone_dir]
		target_dim = max(x1,y1)

		if real_dim != target_dim:
			if ndir == 'x':
				rotate_part(partname,angle_x = 90)
			elif ndir == 'y':
				rotate_part(partname,angle_y = 90)
			elif ndir == 'z':
				rotate_part(partname,angle_z = 90)

			p = _m.parts[partname]

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=p)

	return partname

def refine_side2_faces_ndir(base_faces,mate_faces,force_create=False,gap=None):

	## VER: ('VER: 2012-07-13, v1.5')	## 本函数不需要fix,refined_insts参数
	## 本函数需要同时提供base_faces,mate_faces
	## caller = side1_faces_to_pair()
	## 本函数不修改base_faces

	global contact_pairs

	add_to_process()

	normal1 = face_ndir(base_faces[0])
	normal2 = face_ndir(mate_faces[0])

	if normal1 == normal2 and normal1 in ['x','y','z']: ## 否则无法refine
		nx0,ny0,nz0 = facing_dir(base_faces[0],ndir=normal1)
		nx0 = -nx0;	ny0 = -ny0;	nz0 = -nz0

		ndir = normal1
		if ndir == 'x':
			indx = 0
			vector = nx0
		elif ndir == 'y':
			indx = 2
			vector = ny0
		elif ndir == 'z':
			indx = 4
			vector = nz0

		base_inst = get_poi(base_faces[0])
		mate_inst = get_poi(mate_faces[0])

		space_base = objs_space(base_faces,base_inst)	## base_faces在法线方向上是一个点范围
		space_m2 = objs_space(mate_faces,mate_inst)

		cross = cross_of_ranges(space_base[indx : indx + 2],space_m2[indx : indx + 2])  ## 法向求cross
		print fnln_fnln(),'cross=',cross

		if cross['touch'] == True: 	## 相切，选距离最近的，当然也在相切面。
			mate_faces = face_select(mate_inst,faces=mate_faces,var_dict={ndir:cross['range']})

		else:
			if force_create == False and gap in empty:
				print fnln_fnln(),'******In',mate_inst.name,": cross['length'] < 0 in",ndir, ", no mate faces."
				mate_faces = []
			else:
				##先选一侧的面
				if vector > 0:
					mate_faces = face_select(mate_inst,faces=mate_faces,var_dict={ndir:(_min,space_base[indx])})
				elif vector < 0:
					mate_faces = face_select(mate_inst,faces=mate_faces,var_dict={ndir:(space_base[indx],_max)})

				if len(mate_faces) == 0:
					print fnln_fnln(),'******In',mate_inst.name,": no mate faces in",ndir

				else:
					space_m3 = objs_space(mate_faces,mate_inst)

					if vector > 0:
						mate_faces = face_select(mate_inst,faces=mate_faces, var_dict={ndir:space_m3[indx+1]})
						gap1 = abs(space_base[indx+1] - space_m3[indx+1])
					elif vector < 0:
						mate_faces = face_select(mate_inst,faces=mate_faces, var_dict={ndir:space_m3[indx]})
						gap1 = abs(space_base[indx] - space_m3[indx])

					if gap not in empty and gap1 > gap:
						print fnln_fnln(),'******In',mate_inst.name,": no mate faces within gap=",gap
						mate_faces = []

					elif len(mate_faces) > 0:
						space_m4 = objs_space(mate_faces,mate_inst)
						cross = cross_of_spaces(space_base,space_m4)
						print fnln_fnln(),'cross=',cross

	return mate_faces

def get_next_step(this_step,inc=1):
	## VER: 2016-04-01, v1.1

	this_step = check_step(this_step)
	this_id = step_name_to_id(this_step)
	if this_id == 0 and len(_m.steps) > 1:
		this_id = 1

	next_name = None
	if this_id == max(range(len(_m.steps))):
		print fnln(),'*** Exceed the maximum steps defined.'
		next_name = None
	else:
		next_id = this_id + inc
		if next_id > max(range(len(_m.steps))):
			print fnln(),'*** Exceed the maximum steps defined.'
			next_name = None
		else:
			next_name = _m.steps.keys()[next_id]

	return next_name

def get_nib_bearing(angles, joint_D=None, bearing_D=None,K=0.35):
	## VER: 2014-10-28, v1.0

##>>> get_nib_bearing(0.1, 11, 90)
##--->relief_angle is default to be 27deg
##(0.112, 0.039)
##>>> get_nib_bearing(0.3, 11, 60)
##--->relief_angle is default to be 27deg
##(0.33, 0.115)
##>>>

## bearing_D,bearing_length, joint_D,relief_dy = get_nib_bearing(joint_D=joint_D, angles=(reduction_angle, exit_angle))

		## Example:
##		joint_D = 0.3 		## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
##		bearing_D = None
##		reduction = 0.2
##
##		## 1. bearing and relief (首先要确定的参数)
##		nib_info = get_nib_bearing(joint_D=joint_D, bearing_D=bearing_D, angles=(reduction_angle, exit_angle))
##		bearing_D = nib_info['BD']
##		bearing_length = nib_info['BH']
##		relief_dy = nib_info['RH']
##		joint_D = nib_info['JD']


	angles = tolist(angles)
	if len(angles) == 2:
		reduction_angle,exit_angle = angles
		relief_angle = 27
		print '--->relief_angle is default to be 27deg'
	elif len(angles) == 3:
		reduction_angle, relief_angle, exit_angle = angles
	else:
		raise Exception('*** reduction_angle, relief_angle and exit_angle are required.')

	reduction_angle, relief_angle, exit_angle = _sort(reduction_angle, relief_angle, exit_angle)

	a1 = reduction_angle/2.0
	a2 = relief_angle/2.0
	a3 = exit_angle/2.0

	if joint_D not in empty:
		bearing_D = joint_D/(1 - 2*K*tanD(a1)*(2*tanD(a3) - tanD(a2))/(tanD(a1) + tanD(a3)))
	elif bearing_D not in empty:
		joint_D = bearing_D*(1 - 2*K*tanD(a1)*(2*tanD(a3) - tanD(a2))/(tanD(a1) + tanD(a3)))
	else:
		raise Exception('*** either joint_D or bearing_D is required.')

	bearing_D = round(bearing_D,3)
	bearing_length = round(bearing_D*K,3)
	joint_D = round(joint_D,3)
	relief_dy = bearing_length

	y1 = bearing_length*(tanD(a3) - tanD(a1) - tanD(a2))/(tanD(a1) + tanD(a3))
	y1 = round(y1,3)
	y2 = bearing_length - y1

	dict1 = {}
	dict1['y1'] = y1
	dict1['y2'] = y2
	dict1['BD'] = bearing_D
	dict1['BH'] = bearing_length
	dict1['JD'] = joint_D
	dict1['RH'] = relief_dy

	return dict1


def get_nodal_result(label=None,inst=None,node=None,variable='',sub_var='', scale=1,float_num = 3,x=(),y=(),z=(), loc=None):

	## VER: ('VER: 2012-04-06, v1.0')

##>>> get_nodal_result(1,'NIB_A1', variable='COORD', sub_var='COORD2')
##COORD,COORD2 result= 6.58 at node 1 of NIB_A1
##result_type= extracted integration_point result at node, avg=75%
##**You can plot the xyData table in XY Data manager, 得到该节点的值随时间变化曲线
##6.58
##>>>

	variable = variable.upper()
	vpnow = get_vpnow()

	if variable == 'PEEQ':
		scale = 100

	if not is_empties(x,y,z,loc):
		nodes = odb_node_select(p=inst,x=x,y=y,z=z,loc=loc)
		if nodes not in empty:
			node = nodes[0]
		else:
			raise Exception('No odb node was found to get_nodal_result()')

	if node not in empty:
		if type_of(node) == 'ODBMESHNODE':
			label = node.label
			inst = get_poi(node)
		elif type_of(node) == 'STR':
			nodes = odb_node_set_to_nodes(node)
			if len(nodes) > 1:
				raise Exception('There are more than one nodes in the node set ' + node)

			label = nodes[0].label
			inst = get_poi(nodes[0])

	if label in empty or inst in empty:
		raise Exception('node label and odb instance is required.')

	if type_of(label) != 'INT':
		raise Exception('node label is required.')

	if is_odb_inst(inst):
		inst = check_odb_inst(inst)

	if variable == 'MISES':
		variable = 'S'
		sub_var = 'Mises'
	elif variable == 'S1':
		variable = 'S'
		sub_var = 'Max. Principal'

	if sub_var in empty:
		if variable == 'LE':
			sub_var = 'Max. Principal'
		elif variable == 'CF':
			sub_var = 'Magnitude'
		elif variable == 'PEEQ':
			sub_var = ''
		elif variable == 'RF':
			sub_var = 'Magnitude'
		elif variable == 'S':
			sub_var = 'Mises'
		elif variable == 'U':
			sub_var = 'Magnitude'

	for key in session.xyDataObjects.keys():
		del session.xyDataObjects[key]

	if sub_var in empty or variable in empty:
		setting = current_variable_setting()
		refinement = setting['refinement']
		sub_var = setting['sub']
		main_var = setting['main']
		variable = main_var

	if sub_var not in empty:
		if '1' in sub_var or '2' in sub_var or '3' in sub_var:
			sub_type = COMPONENT
		else:
			sub_type = INVARIANT

	try:  ##积分点结果
		if sub_var not in empty:
			session.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((variable,
			    INTEGRATION_POINT, ((sub_type, sub_var), )), ), nodeLabels=((inst.name, (str(label), )), ))
		else:
			session.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((variable,
			    INTEGRATION_POINT), ), nodeLabels=((inst.name, (str(label), )), ))

		result_type = 'extracted integration_point result at node, avg=75%'

	except:
		if sub_var not in empty:
			session.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((variable,
			    NODAL, ((sub_type, sub_var), )), ), nodeLabels=((inst.name, (str(label), )), ))
		else:
			session.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((variable,
			    NODAL), ), nodeLabels=((inst.name, (str(label), )), ))

		result_type = 'true nodal result'

	table = session.xyDataObjects.values()[0].data

	frame = 0
	step_ID,frame_ID = vpnow.odbDisplay.fieldFrame
	for i in range(len(odb.steps)):
		if i < step_ID:
			frame = frame + len(odb.steps.values()[i].frames)
		else:
			break
	frame = frame + frame_ID
	result = table[frame]   ## format: step,value
	result = result[1]
	result = smart_round(result)

##	print fnln(),'step_ID=',step_ID
##	print fnln(),'result=',result

##	print len(table)
##	results = []
##	for item in table:
##		results.append(item[1])
##	result = max(results)

##	result = session.xyDataObjects.values()[0].data[-1][-1]
##	result = round(result*scale,float_num)
##	print variable + ',' + sub_var,'result=',result,'at node',label,'of',inst.name
##	print 'result_type=',result_type

	return result

def get_real_input(*vars):
	## VER: 2013-06-03, v1.0

	## 不需要poi，与real_xyz()不同。

	obj = None
	for var in vars:
		if var not in empty:
			obj = var
			break

	return obj

def get_normal(obj,point=()):

	## VER: ('VER: 2012-07-25,v1.1')

	if type_of(obj) not in ['edges','faces']:
		raise Exception('******An edge or face is required.')

	if point in empty:
		point = obj.pointOn[0]

	point = totuple(point)
	if type_of(point) != 'TUPLE':
		raise Exception('Error point loc, format=(x,y,z)')

	if len(point) != 3:
		raise Exception('Error point loc, format=(x,y,z)')

	n = None
	try:
		n = obj.getNormal(point=point)
	except:
		pass

	return n

def get_Nu(Re=None,Pr=None,Gr=None, alpha=None,equation=7, Ts=None):
	## VER: 2013-08-12, v1.2
	## 与温度无关

	## alpha: 修正系数
	## Pr: 普朗特数
	## Re: 雷诺数
	## Nu: 努赛尔数

	if Re in empty and 'Re' in globals().keys():
		Re = globals()['Re']
		print "Use global Re =",Re

	if Pr in empty:
		Pr = 0.701
	print 'Pr=',Pr

	if Gr in empty:
		if 'Gr' not in globals().keys():
			Gr = get_Gr(Ts=Ts)
		Gr = globals()['Gr']
		print 'Use global Gr =',Gr

	GrPr = int(Gr*Pr)
	print 'GrPr=',GrPr,
	if 1e-3 < GrPr < 5e2:
		print ', 1e-3 < GrPr < 5e2   (1)'
	elif 5e2 < GrPr < 2e7:
		print ', 5e2 < GrPr < 2e7    (2)'
	elif 2e7 < GrPr < 1e13:
		print ', 2e7 < GrPr < 1e13   (3)'

	RePr = int(Re*Pr)
	print 'RePr=',RePr


	## 根据alpha(修正系数）的大小排序。基本规律：alpha越大，Re的指数就越小。
	Nu1 = 0.022*pow(Re,0.821)   ## 计算结果适中。

	Nu2 = 0.023*pow(Re,0.8)*pow(Pr,0.4)  ## Pr的指数：流体被加热时用0.4，冷却时取0.3或者0.33. 管的长度/管径应该大于60

	Nu3 = 0.037*pow(Re,0.8)*pow(Pr,1/3.)  ## Turbulant flow for Re > 1e5 (rotating)

	if Re > 15000:
		Nu4 = 0.073*pow(Re,0.7)   					## 结果适中，如10.3   ## D. Dropkin et al, 1957
	else:
		Nu4 = 0.095*pow((0.5*Re*Re + Gr), 0.35)	## for horizontal cylinder

	Nu5 = 0.086*pow(Re, 0.69)*pow(Pr, 0.35)   ## 徐建宁等，<<轴承>>, 2006, No.5, pp.1-3

	Nu6 = 0.1*pow(Re,2/3.)     ## 计算结果适中，如9.9  ## Anderson I T et al, 1953

	if 1 < Re < 4.3e5:   ## alpha = 0.133
		Nu7 = 0.133*pow(Re,2/3.)*pow(Pr,1/3.)  ## 计算结果适中。如11

	Nu8 = 0.318*pow(Re,0.571)   ## 结果略大，如12.2   ## Baris Ozerdem et al, 2000 (forced convective heat transfer from a cylinder in the static air)

##	if 1 < Re < 5e5:  ## 层流
##		Nu9 = 0.399*pow(Re, 0.5)*pow(Pr, 0.43)  ## 结果偏小，如6.6
##	else:  ## 紊流
##		Nu9 = 0.0238*pow(Re, 0.8)*pow(Pr, 0.6)

	Nu10 = 0.664*pow(Re*Pr,0.5)   ## Kendous, etc. laminar flow for Re < 1e5 (Rotating)

	## Nu11明显比其他小。
##	if 1e-3 < GrPr < 5e2:
##		Nu11 = 1.18*pow(GrPr, 1/8.)
##	elif 5e2 < GrPr < 2e7:
##		Nu11 = 0.54*pow(GrPr, 1/4.)
##	elif 2e7 < GrPr < 1e13:
##		Nu11 = 0.135*pow(GrPr, 1/3.)

	Nus = {1:Nu1, 2:Nu2, 3:Nu3, 4:Nu4, 5:Nu5, 6:Nu6, 7:Nu7, 8:Nu8, 10:Nu10}

	sum = 0
	for key in Nus.keys():
		Nus[key] = round(Nus[key],2)
		sum += Nus[key]
	average = round(sum/len(Nus),1)


	Nu = Nus[equation]

	## Stanton number:
	St = round(Nu/RePr,4)
	print 'St = Nu/RePr =',St

	## Richardson number:
	## When Re^2 is much larger than Gr, buoyancy forces are negligible and forced convection is dominant while the inverse condition results in free convection.
	Ri = round(float(Gr)/(Re*Re),4)
	print 'Ri = Gr/(Re*Re) =',Ri,     ## Gr越大，boyancy(自然浮力作用)就越明显；Re*Re越大，强制对流就越明显。
	if Ri > 16:
		print ', Ri > 16: free convection',
		if Gr < 1e8:
			print ', Gr < 1e8: laminar flow'
		else:
			print ', Gr > 1e8: tubulant flow'

	elif Ri < 0.1:
		print ', Ri < 0.1: forced convection',
		if Re < 5e5:
			print ', Re < 5e5: laminar flow'
		else:
			print ', Re > 5e5: turbulant flow'
	else:
		print 'mixed laminar and turbulant flow'

	print ' '
	print 'Nus=',Nus,', equation=',equation
	print 'Nu=',Nu
	print 'average_Nu =',average

	print '--'

	globals()['Nu'] = Nu
	globals()['Nus'] = Nus

	globals()['Pr'] = Pr
	globals()['St'] = St
	globals()['Ri'] = Ri

	return

function_labels['get_objs_plane'] = 'csys','span','space'
def get_objs_plane(objs):
	## VER: 2016-10-13, v1.0

	Lx,Ly,Lz = objs_span(objs)
	dict1 = {'x':Lx,'y':Ly,'z':Lz}
	tuples = sort_by_value(dict1,reverse=True)
	plane = tuples[0][0] + tuples[1][0] + tuples[2][0]

	return plane

function_labels['get_odb_antype'] = 'step','analysis type','antype','procedure','problem'
def get_odb_antype(step=None):
	## VER: 2016-10-30, v1.0
	## reference: get_antype()

	if step in empty:
		stepname,frame,time = current_step_frame_time()
		step = odb.steps[stepname]
	else:
		step = check_odb_step(step=step)

	domain = step.domain
	if domain == MODAL:
		antype = 'modal'
	else:
		variables = main_vars()
		if 'NT11' in variables and 'S' in variables:
			antype = 'thermal_stress'
		elif 'S' in variables:
			antype = 'stress'
		elif 'NT11' in variables:
			antype = 'thermal'
		else:
			antype = ''

	return antype

def get_odb_elements(insts=None):
	## VER: 2015-05-11, v1.0

##	>>> dict1 = get_odb_elements('POWDER2-1')
##	>>> len(dict1.values()[0])
##	150690
##	>>>

	if insts not in empty:
		insts = tolist(insts)
		newlist = []
		for inst in insts:
			inst1 = check_odb_inst(inst)
			inst1 = inst1.name
			if inst1 not in newlist:
				newlist.append(inst1)
		insts = newlist

	if insts in empty:
		insts = oa.instances.keys()

	dict1 = {}
	for inst in insts:
		inst1 = oa.instances[inst]
		if inst1.type == DEFORMABLE_BODY:
			dict1[inst] = inst1.elements

	return dict1

def get_odb_elements_num():

	## VER: ('VER: 2012-04-04, v1.0')

	num = 0
	for i in range(len(all_odb_elements)):
		num = num + len(all_odb_elements[i])

	return num

def get_odb_file_title():
	## VER: 2014-03-30, v1.0

##	global odb_file_title

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) == 'ODB':
		odb = vpnow.displayedObject
		odb_file_path = odb.path

		loc = odb_file_path.rfind('/')
		odb_file_title = odb_file_path[loc+1:-4]

	else:
		raise Exception('*** odb viewport is required.')

	return odb_file_title


def get_odb_mesh_data(*insts):

	## VER: ('VER: 2011-12-27, v1.0')	## 获取实例的单元数和节点数，参数缺省时为整个模型的单元数和节点数。

	insts = tolist(insts)

	insts = real_odb_insts(insts)
	if insts in empty:
		insts = oa.instances.values()

	names = []
	if len(insts) < len(oa.instances):
		names = odb_insts_names(insts)
	elif len(insts) == len(oa.instances):
		names = 'the model'

	if type_of(insts[0]) != 'ODBINSTANCE':
		raise Exception('ODB instance is required.')

	elem_num = 0
	node_num = 0

	for inst in insts:
		elem_num = elem_num + len(inst.elements)
		node_num = node_num + len(inst.nodes)

##	print 'Elements qty=',elem_num,', nodes qty=',node_num,'for',names

	return elem_num, node_num

def get_odb_nodes_by_labels(inst,node_labels):
	## VER: ('VER: 2012-03-30, v1.1')

	if type_of(inst) == 'INT':
		inst, node_labels = node_labels, inst

	if type_of(node_labels) == 'ODBINSTANCE':
		inst, node_labels = node_labels, inst

	node_labels = tolist(node_labels)

	inst = check_odb_inst(inst)
	node_qty = get_odb_mesh_data(inst)[1]

	index = get_sequence_index(oa.instances.keys(), inst.name)
	all_nodes = oa.nodeSets[' ALL NODES'].nodes[index]

	nodes = []
	for label in node_labels:
		if label not in range(1,node_qty + 1):
			print '**Invalid node label=',label
			raise Exception('Invalid node label for' + repr(inst.name))

		node = all_nodes[label - 1]
		if node not in nodes:
			nodes.append(node)

	return nodes

def check_obj(obj,repository):
	## VER: 2014-08-13, v1.0

	##>>> dpo = get_dpo()
	##>>> type_of(dpo)
	##'XYPLOT'
	##>>> session.xyPlots
	##session.xyPlots
	##>>> check_obj(dpo,session.xyPlots)
	##session.xyPlots['XYPlot-1']
	##>>>

	if type_of(obj) == 'REPOSITORY':
		obj,repository = repository,obj

	if obj in repository.keys():
		obj = repository[obj]

	if obj not in repository.values():
		raise Exception('*** Incorrect obj type, or not existed obj.')

	return obj

def check_odb_step(step=None,step_num=None,step_id=None,step_name=None):
	## VER: 2015-05-13, v1.3, result is the step object
	## Reference: check_step(), return the step name in the cae module.
	## in mdb, step number start from 0(Initial), but in odb, step number start from 1
	## reference: check_step() for mdb

##>>> check_odb_step(1)
##session.openOdb(r'C:/FEM/A0270/CF_A0270_can_tooling_20000N.odb').steps['step1']
##>>> check_odb_step(2)
##session.openOdb(r'C:/FEM/A0270/CF_A0270_can_tooling_20000N.odb').steps['step2']
##>>>

##	>>> odb.steps.keys()
##	['underfilling', 'lowpressing', 'uppressing', 'ejection']   ## 没有Initial
##	>>>

##>>> step1 = check_odb_step(1)
##>>> step1.number
##1
##>>>

##>>> len(odb.steps)
##1
##>>> step = odb.steps.values()[-1]
##>>> step.number   ## step number start from 1
##1
##>>> odb.steps[1]
##TypeError: String Expected as dictionary Key
##>>> odb.steps.keys()[1]
##IndexError: list index out of range
##>>>
##>>> vpnow = get_vpnow()
##>>> vpnow.odbDisplay.setFrame(step=1)
##Invalid step index: 1
##
##Available step indices: 0 - 0
##>>>

	if is_number(step):
		step_num = step
		step = None

	## num从1开始，id从0开始。
	id_range = range(len(odb.steps))
	if is_number(step_num):
		if 0 < step_num <= len(odb.steps):
			step_id = step_num - 1
		elif step_num == 0:
			step_id = 0
		else:
			if abs(step_num) > len(odb.steps):
				raise Exception('*** Error step_num, out of range')
			step_id = id_range[step_num]

	elif is_number(step_id):
		step_id = id_range[step_id]
		if step_id not in id_range:
			raise Exception('*** Error step_id, out of range.')

	elif step_name in odb.steps.keys():
		step = odb.steps[step_name]
		step_id = step.number - 1

	if is_number(step_id):
		step = odb.steps.values()[step_id]

	if step in odb.steps.keys():
		step = odb.steps[step]
	elif step not in odb.steps.values():
		raise Exception('*** Error odb step.')

##	print fnln(), 'step_num=',step.number, ', step_name=',step.name,', step_id=',step.number - 1

	return step  ## the step object, step_num=step.number, step_id=step.number - 1

def get_outer_faces(poi,faces=None, ref_nx=None, ref_ny=None, ref_nz=None, angle=25, bypick=False,Xdir=None):
	## VER: 2013-11-12, v1.1, Xdir means exclude dir
	## Example: faces = get_outer_faces(stamp, bypick=True, Xdir='z')

	poi = check_pias(poi)

	if type_of(faces) == 'STR':
		faces = set2objs(poi,faces)

	if faces in empty:
		faces = tolist(poi.faces)

	if (ref_nx, ref_ny, ref_nz) != (None, None, None):
		if ref_nx in [-1, 1]:
			faces = face_select(poi, faces=faces, ndir='x',nx=ref_nx)
			if faces in empty:
				raise Exception('*** Fail to find the internal faces with ndir = x')

		elif ref_ny in [-1, 1]:
			faces = face_select(poi, faces=faces, ndir='y',ny=ref_ny)
			if faces in empty:
				raise Exception('*** Fail to find the internal faces with ndir = y')

		elif ref_nz in [-1, 1]:
			faces = face_select(poi, faces=faces, ndir='z',nz=ref_nz)
			if faces in empty:
				raise Exception('*** Fail to find the internal faces with ndir = z')

##	print fnln(),'bypick=',bypick
##	print fnln(),'len(faces)=',len(faces)

	newlist = []
	for face1 in faces:
		if is_outer_plane(face1):
			if bypick == True:
				if face1 not in newlist:
					newlist.append(face1)
			else:
				newlist = connect_all_faces(face1, angle=angle)
				break
		else:
			shape = AV_shape(face1)
			if shape == 'A':
				if bypick == True:
					if face1 not in newlist:
						newlist.append(face1)
				else:
					newlist = connect_all_faces(face1, angle=angle)
					break

	faces = newlist

	if Xdir in ['x','y','z']:
		newlist = []
		for face in faces:
			ndir1 = face_ndir(face)
			if ndir1 != Xdir:
				newlist.append(face)
		faces = newlist

	print fnln(), len(faces),'outer faces are found.'

	return faces


def get_output_list(step_num=-1,frame_num=-1,absolute=False,stepname=None):
	## VER: ('VER: 2013-05-09, v8.4')

	prefix = get_jobnum_and_runtime(stepname=stepname)
	suffix = get_output_list_others()

	## Below can be editted accordingly
	results = collect_results(stepname, ['model','U'],['carbide','Mises','S1'],['steel','Mises','S1','PEEQ'])
	output_list = prefix + results + suffix

	return output_list

def get_output_list_others():
	## VER: 2013-04-19, v1.0

	Others = []

	vpnow = get_vpnow()
	display = vpnow.odbDisplay

	elem_num, node_num = get_odb_mesh_data()
	Others = Others + ['elem_num',elem_num]
	for inst in oa.instances.values():
		Others = Others + [inst.name, len(inst.elements)]

	Others = Others + ['mats_num', len(display.materialAssignments.keys())]
	Others = Others + ['insts_num',len(oa.instances)]
	Others = Others + ['comp',get_computer_name()[:3]]

	try:
		Others = Others + ['contacts_num',contacts_num]
	except:
		pass

	try:
		Others = Others + ['module_mass',module_mass]
	except:
		pass

	return Others

function_labels['get_output_list_PV'] = 'PV','suntech','results','file','stress','write'
def get_output_list_PV(step_num=-1,frame_num=-1,absolute=False,stepname=None):
	## VER: ('VER: 2016-10-30, v8.4')

	global output_list

	Title0 = []
	Frame0 = []
	Glass0 = []
	Cell0 = []
	Adhesive0 = [];	Silic0 = [];	Tape0 = [];		Rubber0 = []
	Clamp0 = []
	Treats0 = [];		VIP_vars0 = []
	Others = []

	try:
		read_vars_from_file(var_file_full)
		Title0 = [odb_file_title,str(job_index).ljust(2),brief.ljust(10)]
	except:
		Title0 = [odb_file_title]

	try:
		frame_mass = frame_weight_of_module()
##		Others = Others + ['module_mass',module_mass, '**frame_mass', frame_mass]
	except:
		frame_mass = 'NA'

	step = odb.steps.values()[step_num]
	antype = check_odb_antype(step)
	if antype == 'modal':		## 如果是时域如应力分析，step.domain=TIME
		Frequencies = get_mode_frequency()
		Frequencies = ['Freq'] + Frequencies

	else:
		set_step_and_frame(step_num=step_num,frame_num=frame_num,absolute=absolute,stepname=stepname)

		if find_odb_insts('Frame') not in empty:
			frmS = get_result(setname='Frame',variable='Mises')
			frmS22 = get_result(setname='Frame',variable='S22',instance=FRL_A1,text='frL_S22')
			frmS11 = get_result(setname='Frame',variable='S11',instance=FRL_A1,text='frL_S11')
			frmS1 = get_result(setname='Frame',variable='S1',instance=FRL_A1,text='frL_S1')
			frmU = get_result(setname='Frame',variable='U3')
			frmPEEQ = get_result(setname='Frame',variable='PEEQ')

			suggest = edel_of_set('Frame')		## 格式：[2, 138.65, 'delta= 22.97%', 'PEEQ= 0.0']
			exec(suggest[-1])							## 得到PEEQ的值

			Frame0 = Frame0 + ['Frame_mass',frame_mass]
			Frame0 = Frame0 + ['sug_frS',suggest[1],'ndel=',suggest[0]]
			Frame0 = Frame0 + frmS1 + frmS11 + frmS22 + frmS + frmPEEQ

			if 'FRL_A1' in oa.instances.keys():
				Frame0 = Frame0 + get_result(text='frL_U',instance='FRL_A1',variable='U')
			Frame0 = Frame0 + frmU

##			Frame0 = Frame0 + ['sug_frS',suggest[1],'ndel=',suggest[0],'sug_PEEQ',PEEQ]

			if 'press_Pa' in globals().keys() and press_Pa > 0:
				ratP2U = round(frmU[1]/press_Pa,3)
				ratU2S = round(suggest[1]/frmU[1],2)
				Frame0 = Frame0 + ['ratP2U', ratP2U, 'ratU2S', ratU2S]

		vars0 = main_vars()
		if antype == 'thermal_stress':
			Glass0 = Glass0 + get_result(setname='f_back_glass_top',variable='NT11',text='Bglass_top_T',settype='surface')
			Glass0 = Glass0 + get_result(setname='f_back_glass_bot',variable='NT11',text='Bglass_bot_T',settype='surface')
			Glass0 = Glass0 + get_result(setname='f_front_glass_bot',variable='NT11',text='Fglass_bot_T',settype='surface')
			Glass0 = Glass0 + get_result(setname='f_front_glass_top',variable='NT11',text='Fglass_top_T',settype='surface')

		if find_odb_insts('Glass2') not in empty and has_frame == False:
			glass1 = 'Glass1'
		else:
			glass1 = 'Glass'

		star_mise = '**'
		star_S1 = ''

		GlassU = get_result(instance=glass1,variable='U3')
		GlassUa = ['GlassUa', GlassU[1] + 5]

		Glass_S1 = get_result(instance=glass1,variable='S1')
		Glass_mise = get_result(instance=glass1,variable='Mises')
		Glass_S10 = Glass_S1

		suggest_S1 = edel_of_set(glass1,stress='S1')
		S1_edel4 = edels['values'][4][1]
		S1_edel6 = edels['values'][6][1]

		suggest_mise = edel_of_set(glass1,stress='Mises')
		Mises_ed4 = edels['values'][4][1]
		Mises_ed6 = edels['values'][6][1]

		Glass0 = Glass0 + ['//']
		Glass0 = Glass0 + GlassU + GlassUa
		Glass0 = Glass0 + ['//']
		Glass0 = Glass0 + Glass_S1
		Glass0 = Glass0 + ['sug_S1',suggest_S1[1],'ndel=',suggest_S1[0]]
		Glass0 = Glass0 + ['S1_edel4', S1_edel4, star_S1+'S1_edel6', S1_edel6]   ## 去掉4个单元(双玻Diamond clamp安装情形)
		Glass0 = Glass0 + ['//']
		Glass0 = Glass0 + Glass_mise
		Glass0 = Glass0 + ['sug_Mise',suggest_mise[1],'ndel=',suggest_mise[0]]
		Glass0 = Glass0 + ['Mises_ed4', Mises_ed4, star_mise+'Mises_ed6', Mises_ed6]   ## 去掉4个单元(双玻Diamond clamp安装情形)
		Glass0 = Glass0 + ['//']

		if find_odb_insts('Glass2') not in empty:
			Glass_S1 = get_result(instance='Glass2',variable='S1')
			Glass_mise = get_result(instance='Glass2',variable='Mises')

			suggest_S1 = edel_of_set('glass2',stress='S1')
			S1_edel4 = edels['values'][4][1]
			S1_edel6 = edels['values'][6][1]

			suggest_mise = edel_of_set('glass2',stress='Mises')
			Mises_ed4 = edels['values'][4][1]
			Mises_ed6 = edels['values'][6][1]

			Glass0 = Glass0 + Glass_S1
			Glass0 = Glass0 + ['sug_S1',suggest_S1[1],'ndel=',suggest_S1[0]]
			Glass0 = Glass0 + ['S1_edel4', S1_edel4, star_S1+'S1_edel6', S1_edel6]   ## 去掉4个单元(双玻Diamond clamp安装情形)
			Glass0 = Glass0 + ['//']
			Glass0 = Glass0 + Glass_mise
			Glass0 = Glass0 + ['sug_Mise',suggest_mise[1],'ndel=',suggest_mise[0]]
			Glass0 = Glass0 + ['Mises_ed4', Mises_ed4, star_mise+'Mises_ed6', Mises_ed6]   ## 去掉4个单元(双玻Diamond clamp安装情形)
			Glass0 = Glass0 + ['//']

		if 'press_Pa' in globals().keys() and press_Pa > 0:
			ratP2U = round(GlassUa[1]/press_Pa, 3)
			ratU2S = round(Glass_S10[1]/GlassUa[1], 2)
	##		Glass0 = Glass0 + ['ratP2U', ratP2U, 'ratU2S', ratU2S]
			Glass0 = Glass0 + ['ratP2U', ratP2U, 'ratU2S', ratU2S, 'U2400', ratP2U*2400, 'U5400', ratP2U*5400]
			Glass0 = Glass0 + ['//']

		if find_odb_insts('cell') not in empty:
			Cell0 = Cell0 + get_result(setname='Si',variable='S1',text='cell_S1')
			Cell0 = Cell0 + get_result(setname='Si',variable='Mises',text='cell_Mises')
			Cell0 = Cell0 + get_result(setname='Si',variable='Tresca',text='cell_Tresca')
			Cell0 = Cell0 + ['//']

		if find_odb_insts('frL') not in empty and 'SILIC' in FRL_A1.elementSets.keys():
			Silic0 = Silic0 + get_result(setname='Silic',variable='Mises',scale=1000,float_num=1)
			Silic0 = Silic0 + get_result(setname='Silic',variable='S11',scale=1000,float_num=1)
			Silic0 = Silic0 + get_result(setname='Silic',variable='S22',scale=1000,float_num=1)
			Silic0 = Silic0 + get_result(instance='FRL_A1',setname='SILIC',variable='S23',scale=1000,float_num=1)

			LE = get_result(instance='FRL_A1',setname='SILIC',variable='LE')
			e = fn_strain_eng(LE[1])*100
			Silic0 = Silic0 + LE + ['Silic_strain_eng',e]

		elif find_odb_insts('frL') not in empty and 'TAPE' in FRL_A1.elementSets.keys():
			Silic0 = Silic0 + get_result(setname='Tape',variable='Mises',scale=1000,float_num=1)
			Silic0 = Silic0 + get_result(setname='Tape',variable='S11',scale=1000,float_num=1)
			Silic0 = Silic0 + get_result(setname='Tape',variable='S22',scale=1000,float_num=1)
			Silic0 = Silic0 + get_result(instance='FRL_A1',setname='Tape',variable='S23',scale=1000,float_num=1)

			LE = get_result(instance='FRL_A1',setname='TAPE',variable='LE')
			e = fn_strain_eng(LE[1])*100
			Silic0 = Silic0 + LE + ['Tape_strain_eng',e]

		elif find_odb_insts('frm') not in empty and 'SILIC' in FRM_A1.elementSets.keys():
			LE = get_result(instance='FRM_A1',setname='SILIC',variable='LE')
			e = fn_strain_eng(LE[1])*100
			Silic0 = Silic0 + LE + ['Silic_strain_eng',e]

		if get_eset(setname='Tape') not in empty:
			if 'tape2edge' in globals().keys():
				Tape0 = Tape0 + ['tape2edge', tape2edge]

			Tape0 = Tape0 + get_result(variable='Mises', setname='Tape',scale=1000,float_num=1)			## Mises stress, kPa
			Tape0 = Tape0 + get_result(setname='Tape',variable='S33',scale=1000,float_num=1)

			LE = get_result(setname='Tape',variable='LE')
			e = fn_strain_eng(LE[1])*100
			Tape0 = Tape0 + LE + ['Tape_strain_eng',e]

		if get_eset(setname='Rubber') not in empty:		## clamp with rubber cushion
			Rubber0 = Rubber0 + get_result(setname='Rubber',scale=1000,float_num=1)	## Mises stress, kPa

		if get_eset(setname='Rubber2') not in empty:		## clamp with rubber cushion
			Rubber0 = Rubber0 + get_result(setname='Rubber2',scale=1000,float_num=1)	## Mises stress, kPa

		Adhesive0 = Adhesive0 + Silic0 + Tape0 + Rubber0

		if 'CLAMP_A1' in oa.instances.keys():
			Clamp0 = Clamp0 + get_result(text='Clamp_U3',instance='CLAMP_A1',variable='U3')

	try:
		Others = Others + ['reduceM',reduceM]
		reduceM0 = ['reduceM',reduceM]
	except:
		print '****ReduceM is not available.'
		Others = Others + ['reduceM','NA']
		reduceM0 = ['reduceM','NA']
		pass

	try:
		Others = Others + ['bload',bload]
	except:
		print '****bload is not available.'
		pass

	elem_num, node_num = get_odb_mesh_data()
	Others = Others + ['elem_num',elem_num]
	for inst in oa.instances.values():
		Others = Others + [inst.name, len(inst.elements)]

	vpnow = get_vpnow
	display = vpnow.odbDisplay

	Others = Others + ['mats_num', len(display.materialAssignments.keys())]
	Others = Others + ['insts_num',len(oa.instances)]
	Others = Others + ['elem_num',elem_num]
	Others = Others + ['comp',get_computer_name()[:3]]

	try:
		Others = Others + ['contacts_num',contacts_num]
	except:
		pass

	try:
		Others = Others + ['module_mass',module_mass]
	except:
		pass

##	try:
##		frame_mass = frame_weight_of_module()
##		Others = Others + ['module_mass',module_mass, '**frame_mass', frame_mass]
##	except:
##		pass

	try:
		Others = Others + ['**lam_mass',lam_mass]
	except:
		pass

	try:
		Others = Others + ['module',_module_type]
	except:
		pass

	try:
		run_time = get_runtime(odb) + cae_time
	except:
		try:
			run_time = get_runtime(odb)
		except:
			run_time = 999

	run_time = round(run_time, 1)
	last_frame = odb.steps.values()[-1].frames[-1]
	Others = Others + ['INC=',last_frame.frameId,'runtime',run_time]

	step_time = odb.steps.values()[-1].frames[-1].frameValue
	if type_of(step_time) in ['INT','FLOAT']:
		step_time = round(step_time,3)
		Others = Others + ['step_time',step_time]

	Time0 = []
	if step_time > 0:
		time1 = str(round(step_time,2)) + '/' + str(last_frame.frameId) + '_' + str(run_time)
		Time0 = ['run_time/INC', time1.ljust(12)]

	for par in level_of_this_run.keys():
		Treats0 = Treats0 + [par, level_of_this_run[par]]

	for var in output_vars.keys():
		VIP_vars0 = VIP_vars0 + [var, output_vars[var]]

	variables = []
	if levels_list.keys() not in empty:
		for key in levels_list.keys():
			variables = variables + [key, globals()[key]]

	if antype == 'stress':
		output_list = Title0 + Time0 + variables + reduceM0 + Frame0 + Glass0 + Cell0 + Adhesive0 + Clamp0 + Treats0 + VIP_vars0 + Others
	elif antype == 'modal':
		output_list = Title0 + Time0 + variables + Frequencies + Treats0 + VIP_vars0 + Others

	print ' '
	print fnln_fnln(),'output_list=',output_list
	print ' '

	return output_list

def get_p1():
	## VER: 2017-02-17, v1.3

	refresh()
	dpo = get_dpo()
	if 'p1' in _m.parts.keys():
		p1 = _m.parts['p1']
	elif 'P1' in _m.parts.keys():
		p1 = _m.parts['P1']
	else:
		if type_of(dpo) == 'PART':
			p1 = dpo
		elif type_of(dpo) == 'ASSEMBLY':
			if len(a.instances) == 1:
				p1 = a.instances.values()[0]
			else:
				objs = objs_of_dg() ## 将不包含被suppressed的instance
				if len(objs) == 1 and objs[0] in a.instances.keys():  ## assembly有多个instance，但是通过replace displayGroup，可以仅仅显示其中一个instance
					p1 = a.instances[objs[0]]
##			elif len(_m.parts.keys()) == 1:  ## multiple instances for one part
##				p1 = _m.parts.values()[0]
				else:
					raise Exception('*** Fail to get p1. You should display only one instance or one part')

	globals()['p1'] = p1
	print ' '
	print fnln(),'Created global var p1. You can use in GUI command.'
	print fnln(),'p1.name=',p1.name
	print fnln(),'type of p1:',type_of(p1)
	print ' '

	return p1

def get_parameters(locals1,clear=None):
	## 2011-01-05, v1.1

	if type_of(locals1) != 'DICT':
		raise Exception('******Please provide the locals() for parmeter locals1')

	if clear == 'empty':
		for k,v in locals1.items():
			if v in empty:
				del locals1[k]

	elif clear != None:
		for k,v in locals1.items():
			if v == clear:
				del locals1[k]

	for k,v in locals1.items():
		if type_of(v) in ['PART','PINSTANCE']:
			try:
				locals1[k] = v.name
			except:
				pass
		elif type_of(v) in ['TUPLE','LIST'] and len(v) > 0:
			type1 = type_of(v)
			if type_of(v[0]) in ['PART','PINSTANCE']:
				list1 = []
				for item in v:
					try:
						list1.append(item.name)
					except:
						pass
				if type1 == 'TUPLE':
					list1 = tuple(list1)

				locals1[k] = list1

##	print ' '
##	print '--->parameters=',repr(locals1)

	return locals1

def get_PEEQ(variable=None):
	## VER: ('VER: 2015-07-07, v1.3')

	vpnow = get_vpnow()
	display = vpnow.odbDisplay

##	if variable in empty:
##		variable = display.primaryVariableLabel

	settings = current_variable_setting()
	main_var = settings['main']
	sub_var = settings['sub']

	vpnow.odbDisplay.setPrimaryVariable(variableLabel='PEEQ', outputPosition=INTEGRATION_POINT, )
	PEEQ = display.contourOptions.autoMaxValue
	PEEQ = round(PEEQ,4)

	plot_variable(main_var=main_var, sub_var=sub_var)	## variable= PEEQ (Avg: 75%)

	return PEEQ

def get_part_seed(part):
	## VER: 2014-06-11, v1.1
	## Refer: get_part_esize()

	part = check_part(part)

	if len(part.edges) > 0:
		seed1 = part.getPartSeeds(SIZE)   ## user defined
		seed2 = part.getPartSeeds(DEFAULT_SIZE)

		seed = seed1
		if seed1 == 0:
			seed = seed2

	else:
		seed = 'NA'   ## The part may have no geometry, or even only a orphan mesh part

	return seed

def get_part_space(part, double_check=True):
	## VER: ('VER: 2014-04-28, v1.4')
	## 有时，bounding box函数也有误差，此时，需要用objs_space 来double check.

	part = check_part(part)

	please_check
	if len(part.vertices) == 0:
		return (0,0,0,0,0,0)

	info = part.queryGeometry(printResults=False)

	if 'boundingBox' not in info.keys():
		raise Exception('****No any entity in the part yet. Failed to get the part space.')

	x1,y1,z1 = info['boundingBox'][0]
	x2,y2,z2 = info['boundingBox'][1]

##	x1,x2,y1,y2,z1,z2 = round5(x1,x2,y1,y2,z1,z2)
	x1,x2,y1,y2,z1,z2 = check_values(x1,x2,y1,y2,z1,z2)

##	if double_check == True:   ## 很可能导致出现abaqus非正常退出，如SMACKerMod错误，这是由于精度达到6位所致。
##		float_x = max(get_float_num(x1), get_float_num(x2))
##		float_y = max(get_float_num(y1), get_float_num(y2))
##		float_z = max(get_float_num(z1), get_float_num(z2))
##
##		if float_x >= 5 or float_y >= 5 or float_z >= 5:
##			if len(part.cells) > 0:
##				x1,x2,y1,y2,z1,z2 = objs_space(part.cells)
##
##			elif len(part.faces) > 0:
##				x1,x2,y1,y2,z1,z2 = objs_space(part.faces)
##
##			elif len(part.edges) > 0:
##				x1,x2,y1,y2,z1,z2 = objs_space(part.edges)

	return x1,x2,y1,y2,z1,z2


def get_poi(obj):
	## VER: 2014-06-25, v1.5
	## reference: check_poi(),check_pia()

##>>> RP = mdb.models['Model-1'].rootAssembly.features['RP-1']
##>>> RP
##mdb.models['Model-1'].rootAssembly.features['RP-1']
##>>> get_parent(RP)
##mdb.models['Model-1'].rootAssembly

	if type_of(obj) == 'SURFACE':
		info = get_surface_info(obj)
		poi = info['pois'][0]
		poi = check_poi(poi)
	else:
		poi = get_parent(obj)

	if type_of(poi) not in ['PART', 'PINSTANCE','ASSEMBLY']:
		raise Exception('*** Fail to get poi')

	return poi

def get_poi_length(poi,dir=None):
	## VER: 2012-03-04, v1.0

	poi = check_pias(poi)
	x1,x2,y1,y2,z1,z2 = poi_space(poi)

	xlen = round(x2-x1,6)
	ylen = round(y2-y1,6)
	zlen = round(z2-z1,6)

	result = max(xlen,ylen,zlen)
	if dir == 'x':
		result = xlen
	elif dir == 'y':
		result = ylen
	elif dir == 'z':
		result = zlen

	return result

def get_poi_position(poi):
	## VER: ('VER: 2012-10-11, v1.3')		##实际上只对poi有用，对于part，结果总为:
##	{'angle': 0.0, 'rotated': False, 'vector': (1, 0, 0), 'translated': False,
##		'translation': (0.0, 0.0, 0.0), 'rotation': ((0, 0, 0), (1, 0, 0), 0.0), 'rotate_center': (0, 0, 0)}

	poi = check_pias(poi)
	name = poi.name

	if type_of(poi) == 'PART':
		rotation = ((0, 0, 0), (1, 0, 0), 0.0)
		translation = (0,0,0)
	elif type_of(poi) == 'PINSTANCE':
		rotation = poi.getRotation()
		translation = poi.getTranslation()
	else:
		raise Exception('part or instance is required.')

	if rotation == ((0, 0, 0), (1, 0, 0), 0.0) and translation == (0,0,0):
##		print '**' + poi.name,'没有平动和转动'
		eqv_action = 'stay'	## 呆着不动
	else:
		if rotation[0] != translation:
##			print fnln_fnln(),'**' + poi.name,'只有平动，没有转动，rotate_center != translation'
			eqv_action = 'translation'

		else:
##			print fnln_fnln(),'**' + poi.name,'等效为只有转动，rotation_center = translation'
			eqv_action = 'rotation'

	position = {'translation':translation, 'rotate_center':rotation[0], 'angle':rotation[2],'vector':rotation[1],
		'eqv_action':eqv_action, 'rotation':rotation}

	return position

function_labels['get_peripheral_nodes'] = 'hole','radius','circle','loop'
def get_peripheral_nodes(nodes):
	## VER: 2016-10-13, v1.1
	## 获取外围边缘线的节点。但是有时edge nodes所在的单元会变形，导致不在一个平面内

	## Insert, hole axis = 'z'
##	face_nodes = nodes_by_face(p1,z=MIN,nz=-1)
##	edge_nodes = get_peripheral_nodes(face_nodes)   ## profile of the nodes surface

	nodes = tolist(nodes)
	plane = get_objs_plane(nodes)
	poi = get_poi(nodes)

	newlist1 = []
	for node in nodes:
		if len(node.getElements())<=2:
			newlist1.append(node)

	elems1 = nodes_to_elements(newlist1)
	nodes1 = elements_to_nodes(elems1)
	nodes = unselect(nodes,nodes1)

	if plane[0] == 'x':
		ns1 = node_select(poi,nodes=nodes,Gx=MID,err=1)
		ns1 = nodes_sort_byx(ns1)
	elif plane[0] == 'y':
		ns1 = node_select(poi,nodes=nodes,Gy=MID,err=1)
		ns1 = nodes_sort_byy(ns1)
	else:
		ns1 = node_select(poi,nodes=nodes,Gz=MID,err=1)
		ns1 = nodes_sort_byz(ns1)

	nodes2 = []
	for i in range(len(ns1)-1):
		dist = get_distance(ns1[i],ns1[i+1])
		if dist > 2: ## 2mm
			nodes2.append(ns1[i])
			nodes2.append(ns1[i+1])
	nodes2.append(ns1[0])
	nodes2.append(ns1[-1])
	nodes2 = remove_repeated_items(nodes2)

	newlist2 = []
	for node in nodes2:
		nodes1 = node.getNodesByFeatureEdge(20)  ## angle=20
		if len(nodes1) > 2:
			newlist2 = tolist(nodes1)
			break

	newlist = newlist1 + newlist2

	return newlist

function_labels['get_PH_PFH'] = 'powder compaction', 'PV, OB, PH, AB, PFH', 'mining button'
def get_PH_PFH(product_L=None,product_W=None,product_R=None,product_H=None, green_R=None, press_L=None, press_W=None,
	green_H=None, PH=None, grade=None,product_density=14.92,fill_density=3.2,sinter_loss=0.02522,
	contraction_W=None, contraction_L=None,green_section=None, product_section=None, shrinkage=None,contraction_H=None,
	top_punch_sketch=None, bot_punch_sketch=None, product_top_sketch=None, product_bot_sketch=None,
	green_section_sketch=None, green_weight=None, product_weight=None):
	## VER: 2014-04-10, v1.3
	## stages: 成品图纸 烧结 压坯 填粉 模具
	## 最好提供green_weight or product_weight，否则计算可能有误。

	## Example: R=5, PH=10
	##>>> pi*5*5*5 + 4./3*pi*5*5*5/2
	##654.498469497874
	##>>>

	if PH not in empty:
		green_H = PH

	if product_density > 1:
		product_density = product_density*1e3*KD   ## 例如, product_density=14.5

	if fill_density > 1:
		fill_density = fill_density*1e3*KD

	if grade in ['060','H10F']:
		product_density = 14.46e3*KD
		fill_density = 3.2e3*KD
		sinter_loss = 0.024   ## mexico data: 0.024, 0.02522

	elif grade in ['040','H6F']:
		product_density = 14.48e3*KD
		fill_density = 3.23e3*KD
		sinter_loss = 0.02511

	if grade in empty:
		grade = '060'

	if contraction_W in empty:
		contraction_W = 1.24  	## shrinkage = 19.35%,  1.23对应收缩率=18.70%

	if contraction_L in empty:
		contraction_L = 1.245	  ## shrinkage= 1.245, 对应收缩率=19.68%

	if shrinkage not in empty:
		contraction_H = 1/(1-shrinkage)
		contraction_L = 1/(1-shrinkage)
	else:
		shrinkage = 1 - 1/contraction_L

	if contraction_H in empty:
		contraction_H = contraction_L

	if green_weight not in empty and product_weight in empty:
		product_weight = green_weight*(1-sinter_loss)
	elif product_weight not in empty and green_weight in empty:
		green_weight = product_weight/(1-sinter_loss)

	please_check
	if product_H not in empty:
		green_H = product_H*contraction_H
	elif green_H not in empty:
		product_H = green_H/contraction_H   ;please_check  ## 已知green_H，推知product_H，即使有dome

	print fnln(),'green_H=',green_H
	print fnln(),'product_H=',product_H
##	print fnln(),'contraction_H=',contraction_H

	if product_R not in empty:
		product_section = pi*product_R*product_R
		green_section = pi*(contraction_W*product_R)**2
	elif green_R not in empty:
		green_section = pi*green_R*green_R
		product_section = green_section/(contraction_W*contraction_W)
	elif green_section_sketch not in empty:
		part1 = extrude_sketch_to_part(green_section_sketch)
		faces = face_select(part1,z=MIN)
		green_section = get_area(faces)
		product_section = green_section/(contraction_L*contraction_W)

	elif press_L not in empty and press_W not in empty:
		green_section = press_L*press_W
		product_section = green_section/(contraction_L*contraction_W)
	elif product_L not in empty and product_W not in empty:
		product_section = product_L*product_W
		green_section = product_section*(contraction_L*contraction_W)
	elif green_section not in empty:
		product_section = green_section/(contraction_L*contraction_W)
	elif product_section not in empty:
		green_section = product_section*(contraction_L*contraction_W)

	print fnln(),'green_section=',green_section
	print fnln(),'product_section=',product_section
##	product_vol = product_section*product_H   ;please_check

	product_top_H = 0
	product_mid_H = 0
	product_bot_H = 0

	product_top_vol = 0
	product_mid_vol = 0
	product_bot_vol = 0
	product_vol = 0

	green_top_H = 0
	green_mid_H = 0
	green_bot_H = 0

	green_top_vol = 0
	green_mid_vol = 0
	green_bot_vol = 0
	green_vol = 0

	dome_green = None
	dome_product = None

	if product_top_sketch not in empty or product_bot_sketch not in empty:
		if product_top_sketch not in empty:
			x1,x2,y1,y2 = space_of_sketch(product_top_sketch)
			product_top_H = y2 - y1

			if product_top_H > 0:
				product_top_vol = get_punch_volume(product_top_sketch, open='bot')
				dome_product = True

		if product_bot_sketch not in empty:
			x1,x2,y1,y2 = space_of_sketch(product_bot_sketch)
			product_bot_H = y2 - y1
			if product_bot_H > 0:
				product_bot_vol = get_punch_volume(product_bot_sketch, open='top')
				dome_product = True

		product_mid_H = product_H - product_top_H - product_bot_H
		if product_mid_H < 1:
			raise Exception('*** Error product_mid_H')
		product_mid_vol = product_section*product_mid_H
		product_vol = product_top_vol + product_mid_vol + product_bot_vol

	if top_punch_sketch not in empty or bot_punch_sketch not in empty:  ## 但也可能是无效的input (flat sketch)
		if top_punch_sketch not in empty:
			x1,x2,y1,y2 = space_of_sketch(top_punch_sketch)
			green_top_H = y2 - y1
			if green_top_H > 0:
				green_top_vol = get_punch_volume(top_punch_sketch, open='bot')
				dome_green = True

		if bot_punch_sketch not in empty:
			x1,x2,y1,y2 = space_of_sketch(bot_punch_sketch)
			green_bot_H = y2 - y1
			if green_bot_H > 0:
				green_bot_vol = get_punch_volume(bot_punch_sketch, open='top')
				dome_green = True

		green_mid_H = green_H - green_top_H - green_bot_H
		if green_mid_H < 1:
			raise Exception('*** incorrect green_H')
		green_mid_vol = green_section*green_mid_H
		green_vol = green_mid_vol + green_top_vol + green_bot_vol

##	if dome_green == True:
##		dome_product = True
##	elif dome_product == True:
##		dome_green = True

	if dome_green == None and dome_product == None:
		green_vol = green_section*green_H
		product_vol = product_section*product_H

	print fnln(),'dome_green=',dome_green
	print fnln(),'dome_product=',dome_product
	print fnln(),'green_vol=',green_vol
	print fnln(),'product_vol=',product_vol
	print fnln(),'green_weight=',green_weight
	print fnln(),'product_weight=',product_weight

	if product_vol not in empty and green_vol not in empty:
		ratio = round(product_vol/green_vol, 2)
		print fnln(),'product_vol/green_vol=',ratio

##	raise Exception

	if product_weight in empty and green_weight in empty:
		if product_vol > 0:
			product_weight = product_vol*product_density
			green_weight = product_weight/(1-sinter_loss)

		elif green_vol > 0:
			if dome_green == True:
				ratio = 0.6   ## 有dome，孔隙率可能偏大。
##				ratio = 1 - (1-shrinkage)**3
			else:
				ratio = 0.55

			print fnln(),'shrink ratio=',ratio

##			product_vol = green_vol*0.55   ## 20% PEG, 25% void
##			product_weight = green_vol*0.55*product_density
##			green_weight = product_weight/(1-sinter_loss)

			green_weight = green_vol*0.6*product_density   ;please_check   ## assume to be 60% of sinter density
			product_weight = green_weight*(1-sinter_loss)

			print fnln(),'Estimated green_weight=',green_weight
			print fnln(),'*** You should provide the green_weight or product_weight'

	print fnln(),'green_weight=',green_weight
	print fnln(),'product_weight=',product_weight

	if product_weight <= 0 or green_weight <= 0:
		raise Exception('*** Fail to get the product_weight or green_weight')

	if product_weight > green_weight:
		raise Exception('*** Error: product_weight > green_weight')

	green_density = green_weight/green_vol

	fill_weight = green_weight

	fill_bot_vol = green_bot_vol
	fill_bot_H = green_bot_H
	fill_bot_weight = fill_bot_vol*fill_density

	fill_mid_weight = fill_weight - fill_bot_weight
	fill_mid_vol = fill_mid_weight/fill_density
	fill_mid_H = fill_mid_vol/green_section

	fill_H = fill_mid_H + fill_bot_H
	fill_H = round(fill_H,2)
	fill_mid_H = round(fill_mid_H, 2)
	green_H = round(green_H,2)
	green_weight = smart_round(green_weight*1e6)   ## g

	press_ratio = round(fill_H/green_H,2)
	shrinkage = round(shrinkage,4)
	compressed_H = fill_H - green_H

	product_density = product_density/(1e3*KD)
	green_density = round(green_density/(1e3*KD),2)

	product_section = smart_round(product_section)
	green_section = smart_round(green_section)

	results = {
		'product_vol':product_vol, 'product_density':product_density, 'grade':grade,
		'product_section':product_section, 'sinter_loss':sinter_loss, 'shrinkage':shrinkage,
		'contraction_L':contraction_L, 'contraction_W':contraction_W,
		'green_H':green_H, 'green_mid_H':green_mid_H, 'green_top_H':green_top_H, 'green_bot_H':green_bot_H,
		'press_ratio':press_ratio, 'green_weight':green_weight, 'green_vol':green_vol,
		'green_section':green_section,'green_density':green_density,'green_R':green_R,
		'fill_H':fill_H, 'fill_mid_H':fill_mid_H, 'fill_bot_H':fill_bot_H, 'compressed_H':compressed_H,
		 }

	if caller_name() != 'cliCommand':
		myprint(results)

	return results

def get_plot_state():
	## VER: 2014-08-08, v1.2
	## CONTOURS_ON_DEF(有数值), UNDEFORMED(无数值)

##	NONE, DEFORMED, UNDEFORMED, CONTOURS_ON_UNDEF, ORIENT_ON_UNDEF, ORIENT_ON_DEF, CONTOURS_ON_DEF, SYMBOLS_ON_UNDEF or SYMBOLS_ON_DEF

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	plot_state = vpnow.odbDisplay.display.plotState[0]
	locs = vpnow.getPrimVarMinMaxLoc()
##	print fnln(),'state=',plot_state

	if type_of(dpo) in ['PART','ASSEMBLY','sketch']:
		plot_state = 'CAE'
	elif type_of(dpo) == 'XYPLOT':
		plot_state = 'XYPLOT'
	elif plot_state not in [NONE, DEFORMED, UNDEFORMED, CONTOURS_ON_UNDEF, ORIENT_ON_UNDEF, ORIENT_ON_DEF,
		CONTOURS_ON_DEF, SYMBOLS_ON_UNDEF or SYMBOLS_ON_DEF]:
		plot_state = type_of(viewport)

	return plot_state

def get_poa(obj):
	## VER: ('VER: 2013-04-24, v1.0')  get part or assembly, instance will return assembly

	obj = tolist(obj)   ## 对sequence也有效
	if len(obj) != 1:
		raise Exception('**** one object is required.')

	poa = 'NA'
	obj = obj[0]
	str1 = repr(obj)
	locs = locs_of_substring(str1,'.')
	if len(locs) > 2:
		if '.rootAssembly.' in str1:
			poa = a
		elif '.parts[' in str1:
			try:
				poa = eval(str1[:locs[2]])   ##利用cae对part name不能含有字符点(.)的规定。
			except:
				raise Exception('******Fail to the part by get_poa().')

	if poa == 'NA':
		raise Exception('******Fail to get_poa.')

	return poa

def get_pois(objs):
	## VER: ('VER: 2012-04-26, v1.5')	## 结果是一个list, 参考get_poi()

	if type_of(objs) == 'STR':
		return insts_by_set(objs)

	objs = tolist(objs)
	pois = []
	for obj in objs:   ##遍历所有objs
		poi = get_poi(obj)
		if poi not in pois:
			pois.append(poi)

	return pois

def poi_names_of_objs(objs):
	## VER: ('VER: 2014-05-09, v1.7')	## 结果是一个list, 参考get_poi()

	if objs in empty:
		return []

	if type_of(objs) == 'STR':
		return insts_by_set(objs)

	objs = tolist(objs)
	names = []
	for obj in objs:   ##遍历所有objs
		poi = get_poi(obj)
		name = poi.name
		if name not in names:
			names.append(name)

	if names not in empty:
		names = _sort(names)

	return names

def get_Pr(u_dynamic=None,Cp=None,Kf=None,fluid='air', flow_shape='shaft_external', Tg=None, Ts=None):
	## VER: 2013-08-08, v1.0
	## u_dynamic: 动力粘度，单位：Pa.S
	## Cp: 定压比热容，单位: J/(kg*K)
	## Kf: 流体的热导率

	if u_dynamic in empty:
		if fluid == 'air':
			u_dynamic = 17.9e-6

	if Cp in empty:
		if fluid == 'air':
			Cp = 1005

	if Kf in empty and fluid == 'air':
		Kf = get_air_conductivity(Tg=Tg, Ts=Ts)

	Pr = u_dynamic*Cp/Kf
	Pr = round(Pr,4)
	print 'Calculated Pr=',Pr
	if Pr < 0.7:
		Pr = 0.701

	globals()['Pr'] = Pr

	print 'Pr=',Pr
	print '--'

	return

def get_project_dirs(poi, point, face=None,edge=None, point2=None,point3=None):
	## VER: 2015-09-06, v1.1

## >>> get_project_dirs(powder, point=n1, point2=n2, point3=n3)   ## n1, n2, n3是一个单元的三个节点。
## ['+x', '+y', None]

	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a
	p1 = point

	p2 = get_project_point(poi, point=point, face=face, edge=edge, point2=point2, point3=point3)
	vector = vector_of_two_points(p1, p2)

	dirs = vector_directions(vector)

	return dirs

def get_project_point(poi, point=None,face=None,edge=None,point1=None, point2=None,point3=None):
	## VER: 2015-09-06, v1.3

	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	if point in empty and point1 not in empty:
		point = point1

	if type_of(point) == 'nodes':
		point = point.coordinates

	names0 = poi.features.keys()		;please_check
	if is_location(point):
		point = create_datum_point(poi,loc=point)
		name = obj_to_feature(point).name

	if type_of(point) not in ['DATUMPOINT', 'vertices']:
		raise Exception('*** a vertice, datumpoint or a location is rquired.')

	datum_point = None
	if type_of(face) in ['DATUMPLANE','faces']:
		feature = poi.DatumPointByProjOnFace(point=point, face=face)
		datum_point = poi.datums[feature.id]

	elif type_of(edge) in ['DATUMAXIS','edges']:
		feature = poi.DatumPointByProjOnEdge(point=point, edge=edge)
		datum_point = poi.datums[feature.id]

	elif point2 not in empty and point3 not in empty:
		edge = create_datum_axis(poi, point1=point2, point2=point3)
		name = obj_to_feature(edge).name

		feature = poi.DatumPointByProjOnEdge(point=point, edge=edge)
		datum_point = poi.datums[feature.id]

	else:
		raise Exception('*** fail to get the project point.')

	dels = unselect(poi.features.keys(),names0)

	loc = datum_point.pointOn
	datum_point = create_datum_point(poi,loc=loc)   ## 再次生成一个datum point，这是孤立的datum point point，前面的datum可以删除了。

	if dels not in empty:
		poi.deleteFeatures(totuple(dels))

	return datum_point  ## loc = datum_point.pointOn

def get_project_vector(poi, point, face=None,edge=None, point2=None,point3=None):
	## VER: 2014-10-17, v1.0

	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a
	p1 = point

	p2 = get_project_point(poi, point=point, face=face, edge=edge, point2=point2, point3=point3)
	vector = vector_of_two_points(p1, p2)

	return vector


def get_punch_volume(sketch,partname='punch_vol',open='top'):
	## VER: 2015-09-29, v1.3, to get the groove area from the sketch of top punch or bot punch

	sketch = check_sketch(sketch)
	partname = new_key(_m.parts.keys(),partname)

	sketch1_name = new_key(_m.sketches.keys(),sketch.name + '_volume')
	open = open.lower()

	copy_sketch(sketch.name,newname=sketch1_name)
	print fnln(),sketch1_name

	lines = geometry_select(sketch1_name,x=0)
	del_geometry(sketch1_name,lines)

##	stop1()
	if open == 'top': ## bot punch
		loc1 = find_loc(sketch1_name,y=MAX,groupX=MIN)
		loc2 = find_loc(sketch1_name,y=MIN,groupX=MIN)
		connect_points(sketch1_name,loc1,('2H',MIN),loc2)
	elif open == 'bot':
		loc1 = find_loc(sketch1_name,y=MIN,groupX=MIN)
		loc2 = find_loc(sketch1_name,y=MAX,groupX=MIN)
		connect_points(sketch1_name,loc1,{'2H':MIN},loc2)
	else:
		raise Exception('*** open should be top or bot')

	bias_cut_sketch(sketch1_name,x=loc1[0],side='+')


##	locs = locs_of_sketch(sketch1_name,x=0,pointOn=True,search_in='part')
##	print locs
##	raise Exception

##	if len(locs) >= 2:
##		connect_points(sketch1_name,locs[0],locs[-1])
##	sketch_to_shellpart(sketch1_name, partname=partname)

	revolve_sketch_to_part(partname=partname,sketch=sketch1_name,angle=360)
##	raise Exception

##	stop1()
	volume = get_volume(partname)
	volume = round(volume,5)

	return volume


def get_python_version():
	## VER: 2013-03-09, v1.0

	import sys
	version = sys.version
	ver = eval(version[:3])

	return ver

def get_delta_ratio(design,exp,FEM):
	## VER: 2015-07-28, v1.3

	delta1 = round(FEM - design,3)
	ratio1 = round(delta1/design*100,2)

	delta2 = round(FEM - exp,3)
	ratio2 = round(delta2/exp*100,2)

	delta3 = round(design-exp,3)
	ratio3 = round(delta3/exp*100,2)

	design,exp,FEM = to_str10(design,exp,FEM)
	delta1,ratio1,delta2,ratio2,delta3,ratio3 = to_str20(delta1,ratio1,delta2,ratio2,delta3,ratio3)

	result = design + exp + FEM  + delta1 + ratio1  + delta2 + ratio2 + delta3 + ratio3

	return result

def get_density(mat):
	## VER: 2014-07-01, v1.0

##	>>> get_density('H10pow')
##	3.49355e-09
##	>>>

##>>> _m.materials['Steel_WMoCrV'].density.table[0]
##(8.1e-09,)

	if mat not in _m.materials.keys():
		raise Exception('*** material name is required.')

	mat = _m.materials[mat]
	table = mat.density.table
	if table in empty:
		raise Exception('*** no density defined for mat=' + mat.name)

	density = table[0][0]

	return density	 ## ton/mm3   KD=1e-12

function_labels['get_diameter'] = 'radius','size','dimension'
def get_diameter(obj=None):
	## VER: 2014-07-10, v1.1
	## 选择一个面，建立set，然后，运行get_diameter()，就可以获得该面的直径。

	if obj in empty:
		obj = pick()

	radius = get_radius(obj)
	if is_number(radius) == False:
		raise Exception('*** obj is a straight line or plane.')
	else:
		diameter = 2*radius

	return diameter

def get_radius(obj=None):
	## VER: ('VER: 2016-05-19,v2.3')
	## This function returns the radius of circular edges. 如果不是circular，则结果为None
	## get_radius(3 points) -> RC_shape(one point)

	## 有两种极限情形：第一种是复杂得不得了（崎岖不平），结果为complex; 另一种为平坦的不得了, 结果为straight，
	## 对于面，可能某个方向是平坦的，例如圆柱面和圆锥面。

	if obj in empty:
		obj = pick()

	if type_of(obj) not in ['edges','faces']:
		if type_of(obj) in ['LIST','TUPLE'] and len(obj) > 0 and type_of(obj[0]) in ['edges','faces']:
			obj = obj[0]
		else:
			raise Exception('******An edge or face is required.')

	obj_type = type_of(obj)
	R = None
	try:
		R = obj.getRadius()  ## 无需参数。face should be cylindrical or conical, not a sphere face
		## 若f1是一个球面，则f1.getRadius()的结果是Face is not cylindrical

		## 圆锥：R其实是上下口的半径的平均值。
		##>>> get_radius(e1)
		##4.0
		##>>> get_radius(e2)
		##3.25
		##>>> (4+3.25)/2.0
		##3.625
		##>>>
		##		print fnln(),'R=',R,'by obj.getRadius()'   ## note: a conical face also have a radius

	except:  ## 以下会很慢，且老是出现setting display...
		if type_of(obj) == 'edges':
			edge = obj
			locs = locs_of_edge(edge,[0.2, 0.5, 0.8])
			R1,C1,S1 = RC_shape(edge,pointOn=locs[0])
			R2,C2,S2 = RC_shape(edge,pointOn=locs[1])
			R3,C3,S3 = RC_shape(edge,pointOn=locs[2])

##			print fnln(),'Radius at 3 points: R1,R2,R3 =',(R1,R2,R3)
			if type_of(R1) == 'STR' and type_of(R2) == 'STR' and type_of(R3) == 'STR':
##				if R1 == R2 == R3:
				if [R1,R2,R3] == ['flat']*3:
					R = R1

					if R == 'flat':
						vector1 = vector_of_two_points(locs[0],locs[1])
						vector2 = vector_of_two_points(locs[0],locs[2])
						if vector1 != vector2:
							R = 'polyline'   ## 折线，例如在mesh模块ignore vertices之后合并得到的折线
				else:
					R = 'complex'

			elif is_numbers(R1,R2,R3): ## 直线与弧线merge之后(by merge_edges())，几何改动较大，会变成spline
				if PK(R1,R2) == 0 and PK(R1,R3) == 0:
					if R1 != 'flat':
						print 'This is a circle or an arc.'
					R = R1
				else: 	## have different R at different locations
					R = 'spline'

			else:
				if 'flat' in (R1,R2,R3):   ## 例如ejector land与倒角弧线ignore_vertices之后。
					R = 'merge_line'

		elif type_of(obj) == 'faces':
			face = obj

			R = face_ndir(face)   ## 'x','y','z','slope'
			if R in ['x','y','z','slope']:
				R = 'flat'

			if R == 'sphere':
				curvature = get_curvature(face)
				if curvature['curvature1'] == curvature['curvature2'] and is_number(curvature['curvature1']):
					R = abs(1/curvature['curvature1'])

	if R == None:
		raise Exception('*** Fail to get the radius.')

	if is_number(R):   ## 如果结果显示诸如：3.0000000000001，是显示器显示的问题，不是计算的问题,结果是对的，即结果为3.0，显示为3.0000000000001
		num1 = get_float_num(R)
		num2 = get_float_num(smart_round(R))
		if num1 - num2 > 3:
			R = smart_round(R)

	return R

def get_rail_dir(support_option):
	## VER: ('VER: 2012-08-26, v1.0')

	if support_option.startswith('short_edge+') or support_option.startswith('long_edge//'):
		rail_dir = 'y'
	elif support_option.startswith('short_edge//') or support_option.startswith('long_edge+'):
		rail_dir = 'x'
	else:
		rail_dir = 'NA'

	return rail_dir

def get_Re(velocity=None,feature_L=None, fluid='air', flow_shape='shaft_external', rotate_R=None, rotate_D=None, eqv_D=None,
	w=None, rpm=None, v_movement=None, u_dynamic=None, density=None, temperature=None, Re_critical=None):
	## VER: 2013-08-09, v1.1
	## 使用标准单位制。雷诺数无量纲。

	## velocity: 平均流速, 单位：m/s
	## feature_L: 特征尺寸，单位：m
	## v_movement: 运动粘度, 单位：m2/s
	## u_dynamic: 动力粘度，单位：Pa.S (好多时候，说的粘度是指动力粘度) (Pa.S = kg/(m*S))
	## density: 密度, 单位: kg/m3
	## w: 管子或圆柱体或轴本身的角速度(rad/s)
	## rpm: 每分钟多少周

	## rotate_R: 界面质点的旋转半径。
	## rotate_D: 内径。对于圆管，内径=直径。单位: m. 如果是绕着轴流动(外场流)，rotate_D = 轴的直径。
	## eqv_D: 当量直径。对于圆管，当量直径为直径的两倍。单位: m
	## 由于eqv_D = 2*rotate_D，所以，前者的Re是后者的4倍。一般取rotate_D为特征尺寸。

	## Rec: 临界雷诺数。无量纲。如果Re < Rec: 层流，如果Re > Rec: 紊流。不同的流动状态有不同的换热规律。
	## 对于圆形光滑管，Rec = 2000-2300，对于橡胶管: Rec=1600-2000

	if feature_L in empty:
		if rotate_D not in empty:
			feature_L = rotate_D
		elif eqv_D not in empty:
			feature_L = eqv_D
		elif rotate_R not in empty:
			feature_L = 2*rotate_R

	if feature_L in empty:
		raise Exception('*** feature_L is required.')

	if rpm not in empty:
		w = 2*pi*rpm/60

	if u_dynamic not in empty:
		if density in empty:
			if fluid == 'air':
				density = get_air_density(temperature=temperature)
			else:
				raise Exception('*** fluid density is required.')

		v_movement = u_dynamic/density

	if v_movement in empty:
		if fluid=='air':
			v_movement = 14.8e-6
		elif fluid == 'water':
			v_movement = 1.01e-6
		elif fluid == 'oil':
			v_movement = 1.19e-3

	if flow_shape == 'shaft_external':
		if w in empty:
			raise Exception('*** rotate speed w is required, you can provide both rpm and radius.')

		velocity = w*feature_L/2   ## 此时的feature_L为直径D

##	if flow_shape == 'shaft_external':
##		Re = w*feature_L*feature_L/v_movement   ## feature_L为shaft的直径 （但此公式会使计算结果偏大3倍, hc偏大一倍)
##		Re = w*feature_L*feature_L/(4*v_movement)   ## feature_L为shaft的直径 （但此公式会使计算hc缩为一半)

##	else:
	if velocity not in empty:
		Re = velocity*feature_L/v_movement
	else:
		raise Exception('*** velocity is unknow for the fluid.')

	Re = int(Re)

	globals()['Re'] = Re
	globals()['feature_L'] = feature_L

##	print "def get_Re(velocity=None,feature_L=None, fluid='air', flow_shape='pipe_external', rotate_R=None, rotate_D=None, eqv_D=None, "
##	print "    w=None, rpm=None, v_movement=None, u_dynamic=None, density=None, Rec=None)"
	print 'Re=',Re
	print 'feature_L=',feature_L,'m'
	print '--'

	return


def get_real_angle(*angles):
	## VER: 2013-05-25, v1.0

	angles_list = []
	for angle in angles:
		if type_of(angle) in numerics:
			angle = abs(angle)

			if angle > 270:
				angle = 360 - angle
			elif angle > 180:
				angle = 270 - angle
			elif angle > 90:
				angle = 180 - angle

##			angle = angle*pi/180

		angles_list.append(angle)

	return angles_list

def get_repeated(v1,v2,v3):
	## VER: 2014-05-23, v1.0

	v = None
	if PK(v1,v2) == 0:  ## PK by tor=1e-5
		v = v1
	elif PK(v1,v3) == 0:
		v = v1
	elif PK(v2,v3) == 0:
		v = v2

	return v

def type_of_repository(repository):
	## VER: 2014-10-19, v1.0
	## reference: get_parent(), get_repository, get_repository_key(), type_of_repository()

	if type_of(repository) != 'REPOSITORY':
##		obj = repository
##		key = get_repository_key(obj)
##
##		key = totext(key)
##		text1 = totext(obj)
##		loc = text1.rfind(key)

		raise Exception('*** a repository is required.')

	text = totext(repository)
	loc = text.rfind('.')
	name = text[loc + 1:]

	return name


def get_result(instance=None, setname=None,surface=None,variable='Mises',text='',stepname=None, settype='element', scale=1,interval = -1,float_num = 2,value_loc='',save=False):
	## VER: ('VER: 2016-11-13, v4.3')

	## Example:
	## get_result(setname='set_silic2',variable='S1')  ## 共有4个instances具有set_silic2
	## get_result(instance='TPUNCH_A1',variable='RF')
	## result = get_result(stepname=stepname, instance=name,variable=variable)
	## result = get_result(stepname=stepname, instance=key,variable=variable,value_loc=value_loc,save=save,scale=scale)
	## result = get_result(stepname=stepname, setname=key,variable=variable,value_loc=value_loc,save=save,scale=scale)
	## frmS1 = get_result(setname='Frame',variable='S1',instance=FRL_A1,text='frL_S1')
	##  get_result(instance='FRL_A1',setname='Tape',variable='S23',scale=1000,float_num=1)

	## 获取surface的结果：
	## get_result(surface='surf_padtie_tie4',variable='S1')
	## get_result(surface='surf_padtie_tie4',variable='U')

	global _m, a, odb

	if is_odb_inst(variable):
		variable,instance = instance,variable

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	display.contourOptions.setValues(maxAutoCompute=ON)
	display.display.setValues(plotState=(CONTOURS_ON_DEF, ))

	if type_of(instance)=='STR':
		instance = instance.upper()

	if stepname not in empty:
		set_step_and_frame(step=stepname)

	if setname not in empty:
		if setname in oa.instances.keys():
			instance = oa.instances[setname]
			setname = None
		elif setname in oa.instances.values():
			instance = setname
			setname = None
		else:
			if type_of(setname) == 'STR':
				setname = setname.upper()
			else:
				raise Exception('*** Error setname.')

	if surface not in empty:
		surface = surface.upper()

	if type_of(instance) == 'STR':
		instance = instance.upper()

	settype = settype.lower()

	if setname in oa.surfaces.keys():
		surface = setname
		setname = None

	if text in empty:
		if type_of(setname) == 'STR':
			text = setname + '_' + variable
		elif type_of(surface) == 'STR':
			text = surface + '_' + variable
		elif type_of(instance) == 'STR':
			text = instance + '_' + variable
		else:
			text = variable

	if is_empties(setname,surface,instance) == True:
		setname = 'MODEL'

	locs = current_view_location()
	plot_all()
	print fnln(),'variable=',variable

	plot_variable(variable)	;please_check
##	raise Exception

	vpnow = get_vpnow()
##	vpnow.odbDisplay.display.setValues(plotState=(UNDEFORMED, ))

	if setname not in empty:
		if setname in ['ALL', 'MODEL']:
			leaf = dgo.Leaf(leafType=DEFAULT_MODEL)
			vpnow.odbDisplay.displayGroup.replace(leaf=leaf)
		else:
			if settype == 'element':
				inst_eset = get_eset(setname,instance=instance)	## similar: get_leaf_of_odb_sets()
				if inst_eset in empty:
					return []

				leaf = dgo.LeafFromElementSets(elementSets=inst_eset)
				vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

	elif surface not in empty:
		ssets = totuple(surface)	## 可能有多个surface
		leaf = dgo.LeafFromSurfaceSets(surfaceSets=ssets)
		vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

	elif instance not in empty:
		if type_of(instance) == 'STR':
		 	if instance not in oa.instances.keys():  ## show display group by part instance.
		 		print fnln_fnln(),'****No such instance=',repr(instance)
		 		return []
		elif type_of(instance) == 'ODBINSTANCE':
			instance = instance.name
		else:
 			print fnln_fnln(),'****No such instance=',repr(instance)
	 		return []

		leaf = dgo.LeafFromPartInstance(partInstanceName=(instance, ))
		vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

##	plot_variable(variable)	;please_check
##	display.contourOptions.setValues(spectrum='Rainbow')

	apply_view_location(locs)

	results = update_odb_viewport(value_loc=value_loc)

	data = results['data']
	if results['scale'] > 1:
		text = text + '(x' + str(results['scale']) + ')'

	text = modify_string(text,' ','_')
	text = modify_string(text,'__','_')

	if save != False:
		save_image(prefix='_')

	return [text, data]

function_labels['get_RP_names'] = 'RP','referencePoints','name','feature','index'
def get_RP_names(poi):
	## VER: 2017-10-30, v1.1

	## usage: del poa.features[name]

##>>> a.referencePoints.keys()   ## not RP name
##[231]
##>>>
##>>> get_RP_names(a)
##['RP-1']
##>>> get_RP_objs(a)
##[mdb.models['Model-1'].rootAssembly.features['RP-1']]
##>>>

	poi = check_pias(poi)
	if type_of(poi) == 'ASSEMBLY':
		poi = a

	dict1 = RP_names_and_index(poi)
	names = dict1.keys()

	return names

def RP2set(inst,name=None):
	## VER: 2016-08-26, v1.0

##	set_ejector = RP2set(ejector_A1,name='set_ejector')
##	set_die = RP2set(die_A1,name='set_die')
##	set_pin = RP2set(pin_A1,name='set_pin')
##	_m.HistoryOutputRequest(name='his_die',
##	    createStepName='under filling', variables=('U3', 'RF3'), frequency=1,
##	    region=set_die, sectionPoints=DEFAULT, rebar=EXCLUDE)


	if is_pia(name):
		inst,name = name,inst

	inst = check_inst(inst)
	if len(inst.referencePoints) == 0:
		raise Exception('***No reference point in the inst yet')

	if name in empty:
		name = 'RP_set_' + inst.name

	RP = inst.referencePoints.values()[0]
	set1 = create_set(RP=RP,name=name)

	return set1

function_labels['RP_names_and_index'] = 'RP','referencePoints','index','dict','map'
def RP_names_and_index(poi):
	## VER: 2017-10-30, v1.0
	## index is the same in poi.features and poi.referencePoints[index]

##	>>> RP_names_and_index('die')
##	{'RP_die': 24}
##	>>> p1.features['RP_die']
##	mdb.models['Model-1'].parts['die'].features['RP_die']
##	>>> p1.features['RP_die'].index
##	AttributeError: 'Feature' object has no attribute 'index'
##	>>> p1.features['RP_die'].id
##	24
##	>>> p1.referencePoints[24]
##	mdb.models['Model-1'].parts['die'].referencePoints[24]
##	>>>

	poi = check_pias(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	pairs = {}
	indexs = poi.referencePoints.keys()
	for id in indexs:
		for name in poi.features.keys():
			feature = poi.features[name]
			id1 = feature.id
			if id == id1:
				pairs[name] = id
				break

	return pairs

function_labels['RP_names_and_index'] = 'RP','referencePoints','feature','name','dict','index'
def RP_names_and_index(poi):
	## VER: 2017-10-30, v1.0
	## index is the same in poi.features and poi.referencePoints[index]

##	>>> RP_names_and_index('die')
##	{'RP_die': 24}
##	>>> p1.features['RP_die']
##	mdb.models['Model-1'].parts['die'].features['RP_die']
##	>>> p1.features['RP_die'].index
##	AttributeError: 'Feature' object has no attribute 'index'
##	>>> p1.features['RP_die'].id
##	24
##	>>> p1.referencePoints[24]
##	mdb.models['Model-1'].parts['die'].referencePoints[24]
##	>>>

	poi = check_pias(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	pairs = {}
	indexs = poi.referencePoints.keys()
	for id in indexs:
		for name in poi.features.keys():
			feature = poi.features[name]
			id1 = feature.id
			if id == id1:
				pairs[name] = id
				break

	return pairs

function_labels['RP_index_and_names'] = 'RP','referencePoints','feature','name','dict','index'
def RP_index_and_names(poi):
	## VER: 2017-10-30, v1.0
	## index is the same in poi.features and poi.referencePoints[index]

##	>>> RP_names_and_index('die')
##	{'RP_die': 24}
##	>>> p1.features['RP_die']
##	mdb.models['Model-1'].parts['die'].features['RP_die']
##	>>> p1.features['RP_die'].index
##	AttributeError: 'Feature' object has no attribute 'index'
##	>>> p1.features['RP_die'].id
##	24
##	>>> p1.referencePoints[24]
##	mdb.models['Model-1'].parts['die'].referencePoints[24]
##	>>>

	poi = check_pias(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	pairs = {}
	indexs = poi.referencePoints.keys()
	for id in indexs:
		for name in poi.features.keys():
			feature = poi.features[name]
			id1 = feature.id
			if id == id1:
				pairs[id] = name
				break

	return pairs

function_labels['get_RP_name'] = 'RP','referencePoint','feature','index','name'
def get_RP_name(RP):
	## VER: 2017-11-02, v1.1, this name is the feature name. poi.features[name]
	## reference: get_RP_objs(), get_RP_names(), get_RP_index(), get_RP_name()

	if type_of(RP) != 'referencePoints':
		raise Exception('*** RP object is required.')

	poa = get_parent(RP)
	if type_of(poi) == 'PINSTANCE':
		poa = a

	index = get_RP_index(RP)
	dict1 = RP_index_with_names(poa)
	name = dict1[index]

	return name

function_labels['get_RP_index'] = 'RP','referencePoint','feature','index'
def get_RP_index(RP):
	## VER: 2017-10-30, v1.0
	## reference: get_RP_objs(), get_RP_names(), get_RP_index(), get_RP_name()

	if type_of(RP) != 'referencePoints':
		raise Exception('*** RP object is required.')

	return get_index(RP)

function_labels['get_RP_objs'] = 'RP','referencePoint','feature'
def get_RP_objs(poi=None,name=None):
	## VER: 2017-11-01, v1.2   reference: get_RP_objs(), get_RP_names(), get_RP_index(), get_RP_name()

##>>> a.referencePoints.keys()   ## not RP name
##[231]
##>>>
##>>> get_RP_names(a)
##['RP-1']
##>>> get_RP_objs(a)
##[mdb.models['Model-1'].rootAssembly.features['RP-1']]
##>>>

	## feature有名字，referencePoint没有名字。但type不同，虽然都属于feature，同一个东西
	## 比如:p1.features['RP']               p1.referencePoints[1]
	## type_of(p1.features['RP'] = 'FEATURE'
	## type_of(p1.referencePoints[1]) = 'referencePoints'
	## 每一个feature都有name和id和xValue,yValue和zValue
	## 参考点没有name, xValue,yValue和zValue
## 例子：原来assembly没有referencePoint，现在分别在两个vertice的位置建立了两个参考点，名字自动为RP-1,RP-2(在assembly的feature里看得到)
##	>>> a.referencePoints[0]
##	KeyError: 0
##	>>> a.referencePoints[1]
##	KeyError: 1
##	>>> a.referencePoints.values()
##	[mdb.models['Model-1'].rootAssembly.referencePoints[34], mdb.models['Model-1'].rootAssembly.referencePoints[33]]
##	>>>
##	>>> rp2 = a.referencePoints.values()[0]
##	>>> rp2
##	mdb.models['Model-1'].rootAssembly.referencePoints[34]
##	>>> get_RP_index(rp2)
##	34
##	>>> a.referencePoints.values()
##	[mdb.models['Model-1'].rootAssembly.referencePoints[34], mdb.models['Model-1'].rootAssembly.referencePoints[33]]


	if poi in empty:
		poi = a

##	print type_of(poi)
##	print poi
	poi = check_pias(poi)
	if type_of(poi) == 'ASSEMBLY':
		poi = a

	RPs = []
	for name1 in poi.features.keys():
		if is_RP(poi.features[name1]):  ## 逐个feature判断，是不是RP。也可以通过看看feature.id是不是在referencePoints.keys()来判断。
			RPs.append(poi.features[name1])

	## usage: del poa.features[name]

	return RPs

##def get_RP_obj(poa,name=None):
##	## VER: 2014-06-26, v1.0
##	## feature有名字，referencePoint没有名字。但type不同，虽然都属于feature，同一个东西
##	## 比如:p1.features['RP']               p1.referencePoints[1]
##	## type_of(p1.features['RP'] = 'FEATURE'
##	## type_of(p1.referencePoints[1]) = 'referencePoints'
##	## 每一个feature都有name和id和xValue,yValue和zValue
##	## 参考点没有name, xValue,yValue和zValue
#### 例子：原来assembly没有referencePoint，现在分别在两个vertice的位置建立了两个参考点，名字自动为RP-1,RP-2(在assembly的feature里看得到)
####	>>> a.referencePoints[0]
####	KeyError: 0
####	>>> a.referencePoints[1]
####	KeyError: 1
####	>>> a.referencePoints.values()
####	[mdb.models['Model-1'].rootAssembly.referencePoints[34], mdb.models['Model-1'].rootAssembly.referencePoints[33]]
####	>>>
####	>>> rp2 = a.referencePoints.values()[0]
####	>>> rp2
####	mdb.models['Model-1'].rootAssembly.referencePoints[34]
####	>>> get_RP_index(rp2)
####	34
####	>>> a.referencePoints.values()
####	[mdb.models['Model-1'].rootAssembly.referencePoints[34], mdb.models['Model-1'].rootAssembly.referencePoints[33]]
##
##	poa = check_pia(poa)
##
##	dict1 = poa_feature_objs(poa)
##	RPs = dict1['RPs']
##
##	if RPs in empty:
##		raise Exception('*** No RP defined.')
##	if len(RPs) > 1:
##		raise Exception('*** There are more than on RPs')
##
##	RP = RPs[0]
##
##	return RP

##def get_RP_objs(poa,name=None):
##	## VER: 2014-06-26, v1.0, reference:
##	## return a list. totuple(RPs) will be the RP sequence, used to create a set like region.
##
##	dict1 = poa_feature_objs(poa)
##	RPs = dict1['RPs']
##
##	return RPs

def get_rpy():
	## VER: 2017-07-25, v1.4

##	>>> get_rpy()
##	0.012586
##	'abaqus.rpy'

##	>>> get_rpy()
##	0.158121
##	'abaqus.rpy.4'

	rand1 = round(random(),6)
	print rand1
	file = files_in_folder('abaqus.rpy',content=str(rand1))[0]  ## 纯粹按时间排序，有时会出错，反应比较慢。

	return file

def get_runtime(odbname=None):
	## VER: 2014-09-14, v1.6

	import os

##	if odbname == None:
##		odbname = odb_file_title   ## post processing, get by refresh()
##	elif type_of(odbname) == 'ODB':
##		odbname = odbname.name
##
##	loc = odbname.rfind('.')
##	odbname = odbname[:loc]
##
##	sta_file = odbname + '.sta'
##	odb_file = odbname + '.odb'

##	print fnln(),'sta_file=',sta_file
##	statinfo = eval("os.stat(r'" + odbname	+ "')")
##	sta_file = get_work_dir() + sta_file
##	statinfo = os.stat(sta_file)
	statinfo = os.stat(odb.path)
	run_time1 = statinfo.st_ctime
	run_time2 = statinfo.st_mtime
	run_time = round((run_time2 - run_time1)/60,2)

	if 'cae_time' in globals().keys():
		print 'cae time =',cae_time,'min'
##	print 'solving time =',run_time,'min'

	return run_time

def get_inp_file_title(job_seq, added_info=''):
	## VER: 2014-03-31, v1.4

	global inp_file_title, var_file_full, options

	script_file_name0 = get_file_name()[:-3]
	loc = script_file_name0.find('_')
	if loc == -1:
		loc = len(script_file_name0)

	if len(run_indexs0) > 0 or len(run_indexs) > 1:
		run_seq_str = str(job_seq)
	else:
		run_seq_str = ''

	added_info0 = ''
	if type_of(added_info) == 'DICT':
		for k,v in added_info.items():
			added_info0 = added_info0 + k + str(globals()[v])

	inp_file_title = script_file_name0[:loc] + run_seq_str + script_file_name0[loc:] + added_info0

	inp_file_title = remove_sub(inp_file_title,'.')
	inp_file_title = remove_sub(inp_file_title,' ')
	insts_space['cae_file_title'] = inp_file_title
##	created_odb_file = inp_file_title + '.odb'

	print fnln(),'run_seq =',run_seq_str
	print fnln_fnln(),'inp_file_title =',inp_file_title

	var_file_full = inp_file_title + '.vars'

	options = [inp_file_title]
##	stop1()

	return

def side_radius_of_insert(p1,sym=None):
	## VER: 2016-10-11, v1.2

	## side_radius_of_insert('green',sym='xy')

	p1 = check_part(p1)

##	if sym in empty:
##		sym = get_sym_type(p1)

##	if sym not in ['xsym','ysym','xysym','full']:
##		raise Exception('*** sym should be xsym, ysym, xysym, or full')

	if sym in empty:
		sym = 'full'

##	vpnow = get_vpnow()
##	vpnow.view.setValues(session.views['Iso'])
##	dome = get_insert_dome(p1)
	if len(session.viewports) != 2:
		raise Exception('*** please run show_two_viewports() first.')

	vp1,vp2 = session.viewports.values()
##	vp1,vp2 = show_two_viewports()

	vp1.view.setValues(session.views['Iso'])
	vp2.view.setValues(session.views['Right'])
	vp2.makeCurrent()

	Lx = Ly = 5
	correct = 'no'

	Lx0 = Ly0 = 5
	correct0 = 'no'

##	if dome == 'zmin':
##		start = -0.1
##	elif dome == 'zmax':
##		start = -0.6
##	else:
##		start = -0.4

	start = start0 = -0.4
	sym0 = 'full'
	i = 0

	nodes_ymax = nodes_by_face(p1,yend=MAX)
	nodes_ymax = node_select(p1,nodes=nodes_ymax,y=(MID,MAX))

	nodes_xmax = nodes_by_face(p1,xend=MAX)
	nodes_xmax = node_select(p1,nodes=nodes_xmax,x=(MID,MAX))

	while correct not in ['yes','y']:
		unlight()
		if sym != 'full':
##			nodes1 = node_select(p1,z=_zmid(p1)+start,x=(0.2,Lx),err=0.15,poiRefY=(MAX,-2))
##			nodes2 = node_select(p1,z=_zmid(p1)+start,y=(0.2,Ly),err=0.15,poiRefX=(MAX,-2))

			nodes1 = node_select(p1,z=_zmid(p1) + start,x=(0,Lx),err=0.15,nodes=nodes_ymax)
			nodes2 = node_select(p1,z=_zmid(p1)+start,y=(0,Ly),err=0.15,nodes=nodes_xmax)

			vp1.makeCurrent()
			light(nodes1 + nodes2)
			vp2.makeCurrent()
			light(nodes1 + nodes2)
			vp2.makeCurrent()

		else:
##			nodes1 = node_select(p1,z=_zmid(p1)+start,x=(-Lx,Lx),err=0.15,poiRefY=(MAX,-2))
##			nodes2 = node_select(p1,z=_zmid(p1)+start,y=(-Ly,Ly),err=0.15,poiRefX=(MAX,-2))

			nodes1 = node_select(p1,z=_zmid(p1)+start,x=(-Lx,Lx),err=0.15,nodes=nodes_ymax)
			nodes2 = node_select(p1,z=_zmid(p1)+start,y=(-Ly,Ly),err=0.15,nodes=nodes_xmax)

			vp1.makeCurrent()
			light(nodes1 + nodes2)
			vp2.makeCurrent()
			light(nodes1 + nodes2)
			vp2.makeCurrent()

		if i > 1:
			vp1.view.setValues(session.views['Iso'])
			vp2.view.setValues(session.views['Right'])
			vp2.makeCurrent()

		fields = (('sym',str(sym)), ('offset in z',str(start)),('Half Lx',str(Lx)),('Half Ly:',str(Ly)),('Length correct ?',str(correct)))
		sym,start,Lx, Ly, correct = getInputs(fields=fields, label='Provide half length Lx, Ly. \nIf correct input correct=yes or y')
		if sym == None:
			sym = sym0
		if start == None:
			start = start0
		if Lx == None:  ## click cancel
			Lx = Lx0
		if Ly == None:
			Ly = Ly0
		if correct == None:
			correct = correct0

		start = -abs(float(start))
		Lx = abs(float(Lx))
		Ly = abs(float(Ly))
		correct = correct.lower()

		print ''
		print 'Your selection: Lx=',Lx,', Ly=', Ly, ', correct=',correct

		start0 = start
		Lx0 = Lx
		Ly0 = Ly
		correct0 = correct
		sym0 = sym

		i = i + 1

	Radius = []
##	if sym == 'xysym':
	if 'xy' in sym:
		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,x=(0,Lx),err=0.15,nodes=nodes_ymax)
			R1 = radius_of_fit_nodes(nodes1,axis='xy')
			Radius.append(R1)

		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,y=(0,Ly),err=0.15,nodes=nodes_xmax)
			R1 = radius_of_fit_nodes(nodes1,axis='yx')
			Radius.append(R1)

##	elif sym == 'xsym':
	elif 'x' in sym:
		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,x=(0,Lx),err=0.15,nodes=nodes_ymax)
			R1 = radius_of_fit_nodes(nodes1,axis='xy')
			Radius.append(R1)

		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,y=(-Ly,Ly),err=0.15,nodes=nodes_xmax)
			R1 = radius_of_fit_nodes(nodes1,axis='yx')
			Radius.append(R1)

##	elif sym == 'ysym':
	elif 'y' in sym:
		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,x=(-Lx,Lx),err=0.15,nodes=nodes_ymax)
			R1 = radius_of_fit_nodes(nodes1,axis='xy')
			Radius.append(R1)

		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,y=(0,Ly),err=0.15,nodes=nodes_xmax)
			R1 = radius_of_fit_nodes(nodes1,axis='yx')
			Radius.append(R1)

	elif sym == 'full':
		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,x=(-Lx,Lx),err=0.2,nodes=nodes_ymax)
			R1 = radius_of_fit_nodes(nodes1,axis='xy')
			Radius.append(R1)

		for offset in [start,start+0.3,start+0.6,start+0.9,start+1.2]:
			nodes1 = node_select(p1,z=_zmid(p1)+offset,y=(-Ly,Ly),err=0.2,nodes=nodes_xmax)
			R1 = radius_of_fit_nodes(nodes1,axis='yx')
			Radius.append(R1)

	if len(Radius) == 0:
		raise Exception('*** No nodes selected for radius evaluation.')

	print ' '
	print fnln(),'side radius =',Radius
	print fnln(),'average =',sum(Radius)/len(Radius)

	vp1.makeCurrent()

	return

def get_size(objs,float=None):
	## VER: 2014-09-14, v1.0
	## get volume, area, length, and space

	size = 0
	if is_poi(objs):
		size = poi_space(objs)
	else:
		objs = tolist(objs)
		if objs not in empty:
			if type_of(objs[0]) == 'faces':
				size = get_area(objs)
			elif type_of(objs[0]) == 'cells':
				size = get_volume(objs)
			elif type_of(objs[0]) == 'edges':
				size = edges_length(objs)
		else:
			print '*** Fail to get size of objs.'

	if is_number(size) and size > 0 and type_of(float) == 'INT':
		size = round(size,float)

	return size

def ndir_of_sketch(sketch):
	## VER: 2013-05-27, v1.0
	## reference: get_sketch_ndir()

##	sketch = check_sketch(sketch)
##	ndir = ndir_of_sketch(sketch)

	sketch = check_sketch(sketch)
	show_sketch(sketch)

	sketch.resetView()

	vpnow = get_vpnow()
##	screen_H = vpnow.view.displayedObjectScreenHeight
##	screen_W = vpnow.view.displayedObjectScreenWidth
##	Area = screen_H*screen_W
	## 在resetView视图下，area有最大值。

	vector = vpnow.view.viewVector
	x0,y0,z0 = vector
	x0 = abs(x0)
	y0 = abs(y0)
	z0 = abs(z0)
	max_value = max(x0,y0,z0)
	if max_value == x0:
		ndir = 'x'
	elif max_value == y0:
		ndir = 'y'
	elif max_value == z0:
		ndir = 'z'
	else:
		raise Exception('*** Fail to get ndir of sketch')

	return ndir

def get_sketch_transform(ndir,origin=None,offset=None):
	## VER: 2013-09-03, v1.0
	## xoyz, yozx, zoxy

## 总是如下放置。

## 纵轴
##	^
##	|
##	|
##	0----> 横轴

	if ndir not in ['x','y','z']:
		raise Exception('*** ndir is required.')

	## 法线排在第三组向量，也就是某条线在某一点的tangent向量。
	if ndir == 'x':
		matrix = [0, 1, 0,   0, 0, 1,   1, 0, 0]   ## +y, +z, +x   => yoz  , 横轴=+y, 纵轴+z
	elif ndir == 'y':
		matrix = [1, 0, 0,   0, 0, -1,   0, 1, 0]  ## +x, -z, +y   => xoz-,  横轴=
	elif ndir == 'z':
		matrix = [1, 0, 0,   0, 1, 0,    0, 0, 1]  ## +x, +y, +z   => xoy,   横轴=+x, 纵轴=+y

	if is_location(origin) and len(origin) == 3:
		origin = list(origin)
	elif type_of(offset) in numerics:
		if ndir == 'x':
			origin = [offset,0,0]
		elif ndir == 'y':
			origin = [0,offset,0]
		elif ndir == 'z':
			origin = [0,0,offset]
	else:
		raise Exception('*** 3D origin or offset is required.')

	matrix = matrix + origin
	matrix = tuple(matrix)

	return matrix

def get_SN(list1,digits=3):
	## VER: 2011-05-26, v1.0

	try:
		seq = len(list1) + 1
	except:
		raise Exception('******len() for unsized object')

	if seq <= 9:
		seq = '000' + str(seq)
	elif seq < 99:
		seq = 'infinite' + str(seq)
	elif seq < 999:
		seq = '0' + str(seq)
	else:
		seq = str(seq)

	if digits == 3:
		seq = seq[-3:]
	elif digits == 2:
		seq = seq[-2:]
	elif digits == 1:
		seq = seq[-1]

	return seq

def fn_strain_eng(TrueX):
	## VER: 2011-08-04, v1.0。TrueX也就是LE结果，即对数应变（真应变）。

	import math
	x = math.exp(TrueX) - 1
	x = round(x,3)

	print '--->真应变TrueX为',round(TrueX*100,1),'%, 工程应变x=',x*100,'%'

	return x

def fn_strain_true(x):
	## VER: 2011-08-04, v1.0。TrueX也就是LE结果，即对数应变（真应变）。
	## x = dL/L

	import math
	TrueX = math.log(1+x)
	TrueX = round(TrueX,3)

	print '--->真应变TrueX为',round(TrueX*100,1),'%, 工程应变x=',x*100,'%'

	return TrueX

def current_step_frame_time():
	## VER: 2015-04-30, v1.1

	vpnow = get_vpnow()
	frame_info = vpnow.odbDisplay.fieldFrame
	if len(frame_info) == 2:
		current_step, frame_id = vpnow.odbDisplay.fieldFrame   ## current_step id start from 0. frame_id is correct.
		step_name = odb.steps.values()[current_step].name
		frame_time = odb.steps.values()[current_step].frames[frame_id].frameValue
	##	frame_time = round(frame_time,8)
		frame_time = smart_round(frame_time)

	elif frame_info == ('Session Step', 'Session Frame', 0, 0):
		odbname = odb.name
		current_step = session.scratchOdbs[odbname].steps['Session Step']
##			current_step = odb.steps['Session Step']
		step_name = 'Session Step'
		frame_id = 0
		step_info = 'Customized output variable'
		frame_time = current_step.frames[frame_id].frameValue

	return step_name, frame_id, frame_time


def get_step_frame_time():
	## VER: 2014-02-20, v1.0
	## Example: step,frame,time = get_step_frame_time()
	## reference: set_step_and_frame()

	##stress = odb.steps['step1'].frames[-1].fieldOutputs['S']		## step1 is the step name
	##stressSet= odb.steps['step1'].frames[-1].fieldOutputs['S'].values

	vpnow = get_vpnow()
	current_step, frame_id = vpnow.odbDisplay.fieldFrame   ## current_step id start from 0. frame_id is correct.
	## The frame ID will be the frame index seen in Results->Step/Frame

	step_name = odb.steps.values()[current_step].name
	last_name = odb.steps.values()[-1].name

	frame_time = odb.steps.values()[current_step].frames[frame_id].frameValue

##	last_frame = odb.steps.values()[current_step].frames[-1].frameId	## Error, especially for explicit dynamics. The increment num is not the frame id.
	last_frame = len(odb.steps.values()[current_step].frames) - 1	## start from 0
##	print fnln(),'last_frame=',last_frame
	last_time = odb.steps.values()[current_step].frames[last_frame].frameValue

##	if frame_id != last_frame:
##		print 'Not the last frame'

	print '(step_name,last_name), (frame_id, last_frame), (frame_time, last_time)'
	results = (step_name,last_name), (frame_id, last_frame), (frame_time, last_time)

	return results

def get_step_time(step):
	## VER: 2014-08-06, v1.0

	step = check_odb_step(step)
	time1 = step.frames[-1].frameValue

	return time1


def get_steps_sequence():
	## VER: 2013-06-08, v1.0

	steps = ['Initial']
	if len(_m.steps) <= 2:
		steps = _m.steps.keys()

	else:
		steps0 = _m.steps.keys()[1:]
		for i in range(len(steps0)):
			for step in steps0:
				if _m.steps[step].previous == steps[-1]:
					steps.append(step)
			if len(steps) == len(_m.steps):
				break

	if steps == _m.steps.keys():
		print 'stepnames are sorted by creating sequence.'
	else:
		print 'stepnames are *not* sorted by creating sequence.'

	return steps

def get_stress_direction():

	## VER: ('VER: 2012-07-06, v1.0')

	vpnow = get_vpnow()
	display = vpnow.odbDisplay

	plot_variable('Mises')
	Mises = round(display.contourOptions.autoMaxValue,3)

	plot_variable('S11')
	S1 = [display.contourOptions.autoMaxValue, display.contourOptions.autoMinValue]
	if abs(S1[0]) >= abs(S1[1]):
		S1 = round(S1[0],3)
	else:
		S1 = round(S1[1],3)

	plot_variable('S22')
	S2 = [display.contourOptions.autoMaxValue, display.contourOptions.autoMinValue]
	if abs(S2[0]) >= abs(S2[1]):
		S2 = round(S2[0],3)
	else:
		S2 = round(S2[1],3)

	plot_variable('S33')
	S3 = [display.contourOptions.autoMaxValue, display.contourOptions.autoMinValue]
	if abs(S3[0]) >= abs(S3[1]):
		S3 = round(S3[0],3)
	else:
		S3 = round(S3[1],3)

	axis_max = ['S11',S1]
	plot_variable('S11')
	if abs(S2) > abs(axis_max[1]):
		axis_max = ['S22',S2]
		plot_variable('S22')
	elif abs(S3) > abs(axis_max[1]):
		axis_max = ['S33',S3]
		plot_variable('S33')

	print ' '
	print 'Mises stress=',Mises,'MPa. Stress is mainly from',axis_max

	return

def all_valid_insts():
	## VER: 2014-05-09, v1.0

	get_current_model()
	suppr = get_suppressed_insts()
	insts = unselect(a.instances.keys(),suppr)

	return insts

def get_stress_volume(value,variable=None,ids=None,objs=None,sign=1):
	## VER: 2014-12-30, v1.4
	## Example: get_stress_volume(600)
	## use to evaluate the damage, besides the PEEQ.
	## 注意，如果统计单元数，且单元数小于5，此时，用edel()结合比较。取edel()和get_stress_volume()中num相对较小者。

	if is_number(value) == False:
		raise Exception('** a numeric value is required.')

	step_name,frame,time1 = current_step_frame_time()
	IVOLs = odb.steps[step_name].frames[frame].fieldOutputs['EVOL'].values
##	print len(stress)

	if variable == 'S1':
		variable = 'maxPrincipal'
	elif variable == 'Mises':
		variable = 'mises'

	if variable in empty:
		setting = current_variable_setting()
		label = setting['label']
		if label == 'PEEQ':
			variable = 'PEEQ'
		elif label == 'S, Mises':
			variable = 'mises'
		elif label == 'S, Max. Principal':
			variable = 'maxPrincipal'
		elif label == 'S, S11':
			variable = 'S11'
		elif label == 'S, S22':
			variable = 'S22'
		elif label == 'S, S33':
			variable = 'S33'
		elif label == 'S, S12':
			variable = 'S12'    ## for powder compaction, 2D model, crack checking
		elif label == 'S, S13':
			variable = 'S13'
		elif variable == 'S, S23':
			variable = 'S23'
		else:
			raise Exception('*** Error stress variable shown in the viewport.')

	if variable not in ['mises','maxPrincipal','S11','S22','S33','S12','S13','S23','PEEQ']:
		raise Exception('*** Error stress variable')

	if variable == 'PEEQ':
		stress = odb.steps[step_name].frames[frame].fieldOutputs['PEEQ'].values   ## attribute data
	else:
		stress = odb.steps[step_name].frames[frame].fieldOutputs['S'].values

	vpnow = get_vpnow()
	dpo = vpnow.odbDisplay

	vol = 0
	total = 0
	num = 0
	ids1 = []
	elems = []

	objs = tolist(objs)
	if objs in empty:
		objs = objs_of_dg()

	for set1 in objs:
		if set1 in dpo.elementSets.keys():  ## element set
##			print 'Reading data from element set',set1,', variable=',variable
			elemset = dpo.elementSets[set1]
			elems = elemset.elements
			for list1 in elems.values():
				for id in list1:
					stress0 = None
					vol0 = IVOLs[id - 1].data
					total = total + vol0

					if variable == 'maxPrincipal':
						stress0 = stress[id - 1].maxPrincipal
					elif variable == 'mises':
						stress0 = stress[id - 1].mises
					elif variable == 'PEEQ':
						stress0 = stress[id - 1].data

					if sign == 1 and stress0 >= value:
						vol = vol + vol0
						ids1.append(id)
					elif sign == -1 and stress0 <= value:
						vol = vol + vol0
						ids1.append(id)

		elif set1 in oa.instances.keys():
##			print fnln(),'Reading data from inst=',set1,', variable=',variable
##			print ' '
			inst = set1
			num0 = len(oa.instances[set1].elements)

			if ids not in empty:
				inst_ids = ids
			else:
				inst_ids = element_ids_in_odb(set1)

			for id in inst_ids:
				vol0 = IVOLs[id].data
				total = total + vol0
				if variable == 'maxPrincipal':
					stress0 = stress[id].maxPrincipal
				elif variable == 'mises':
					stress0 = stress[id].mises
				elif variable == 'PEEQ':
					stress0 = stress[id].data
				elif variable == 'S11':
					stress0 = stress[id].data[0]
				elif variable == 'S22':
					stress0 = stress[id].data[1]
				elif variable == 'S33':
					stress0 = stress[id].data[2]
				elif variable == 'S12':
					stress0 = stress[id].data[3]
				elif variable == 'S13':
					stress0 = stress[id].data[4]
				elif variable == 'S23':
					stress0 = stress[id].data[5]

				else:
					stress0 = None

				if stress0 >= value:
					elem = stress[id].elementLabel
					if elem not in elems:    	## an element may have more than one integration point
						elems.append(elem)
						num = num + 1			## how many elements

					vol = vol + vol0
					ids1.append(id)

	if total == 0:
		raise Exception('*** Error to collect the total volume. total=0')

	ratio = smart_round(vol/total*100)

	vol = smart_round(vol)
	total = smart_round(total)
	length = vol/(0.5*0.5)

	dict1 = {}
	dict1['vol'] = vol
	dict1['total_vol'] = total
	dict1['ratio%'] = ratio
	dict1['num'] = num
	dict1['elems'] = elems
	dict1['ids'] = ids1
	dict1['length'] = length

	return dict1

def get_suppressed_insts():
	## VER: 2014-04-29, v1.0, a suppressed inst is hiden, but a hiden insts may not be suppressed.

	insts = []
	for inst in a.instances.keys():
		if a.features[inst].isSuppressed():
			insts.append(inst)

	if insts not in empty:
		insts = sorted(insts)

	return insts

def get_set_info(set1,pia=None):
	## VER: 2014-06-10, v1.0 load and BC may use set like region

	if pia not in empty:
		pia = check_pias(pia)
	else:
		pia = a

	if type_of(set1) == 'STR':
		if set1 in a.allInternalSets.keys():
			set1 = a.allInternalSets[set1]
		elif set1 in pia.sets.keys():
			set1 = pia.sets[set1]

	if type_of(set1) != 'SET':
		raise Exception('*** set1 is required.')

	inst_ids = set1.instances
	pois = leaf_ids_to_insts(inst_ids)   ## for part set, inst_ids=[1000], then pois=[]; but when transferred to inst, leaf_ids_to_insts() works
	if pois in empty:
		poi = get_parent(set1)
		if type_of(poi) == 'PART':
			pois = [poi.name]

	objs = []
	obj_type = 'NA'
	if len(set1.cells) > 0:
		objs = list(set1.cells)
		obj_type = 'cells'
	elif len(set1.faces) > 0:
		objs = list(set1.faces)   ## face type surface
		obj_type = 'faces'
	elif len(set1.edges) > 0:    ## edge type surface
		objs = list(set1.edges)
		obj_type = 'edges'
	elif len(set1.elements) > 0:	## element type surface
		objs = list(set1.elements)
		obj_type = 'elements'
	elif len(set1.nodes) > 0:
		objs = list(set1.nodes)
		obj_type = 'nodes'
	else:
		try:
			if len(set1.referencePoints) != 0:
				objs = list(set1.referencePoints)
				obj_type = 'referencePoints'
		except:
			pass

	if '.allInternalSets' in repr(set1):
		name = get_repository_key(set1,'allInternalSets')
		parent = get_parent(set1)
	elif '.sets' in repr(set1):
		name = get_repository_key(set1,'sets')
		parent = get_parent(set1)    ## for assembly set, parent=assembly, not instance
	else:
		name = 'NA'
		parent ='NA'

	info = {}
	info['region_name'] = name   ## set name
	info['pois'] = pois 	## part or insts who have the objs
	info['parent'] = parent  ## parent of surface, usually is assembly
	info['objs'] = objs
	info['region_type'] = 'set'
	info['obj_type'] = obj_type

	return info

def get_surface_info(surface,pia=None):
	## VER: 2014-06-10, v1.0  ## interact, constraint, load can have surface

	if pia not in empty:
		pia = check_pias(pia)
	else:
		pia = a

	if type_of(surface) == 'STR':
		if surface in a.allInternalSurfaces.keys():
			surface = a.allInternalSurfaces[surface]
		elif surface in pia.surfaces.keys():
			surface = pia.surfaces[surface]

	if type_of(surface) != 'SURFACE':
		raise Exception('*** surface is required.')

	inst_ids = surface.instances
	pois = leaf_ids_to_insts(inst_ids)   ## for part surface, inst_ids=[1000], then pois=[]; but when transferred to inst, leaf_ids_to_insts() works
	if pois in empty:
		poi = get_parent(surface)
		if type_of(poi) == 'PART':
			pois = [poi.name]

	sides = surface.sides
	sides0 = []
	for side in sides:
		if side not in sides0:
			sides0.append(side)
	sides = sides0

	objs = []
	obj_type = 'NA'
	if len(surface.faces) > 0:
		objs = list(surface.faces)   ## face type surface
		obj_type = 'faces'
	elif len(surface.edges) > 0:    ## edge type surface
		objs = list(surface.edges)
		obj_type = 'edges'
	elif len(surface.elements) > 0:	## element type surface
		objs = list(surface.elements)
		obj_type = 'elements'
	elif len(surface.nodes) > 0:
		objs = list(surface.nodes)
		obj_type = 'nodes'

	if '.allInternalSurfaces' in repr(surface):
		name = get_repository_key(surface,'allInternalSurfaces')
		parent = get_parent(surface)
	elif '.surfaces' in repr(surface):
		name = get_repository_key(surface,'surfaces')
		parent = get_parent(surface)
	else:
		name = 'NA'
		parent ='NA'

	info = {}
	info['region_name'] = name   ## surface name
	info['pois'] = pois 			## insts who have the objs
	info['parent'] = parent  	## parent of set, parent=assembly for assembly sets,
										## parent=part or inst for part or inst sets (inst set is inheritage from part set)
	info['objs'] = objs
	info['region_type'] = 'surface'
	info['obj_type'] = obj_type
	info['sides'] = sides

	return info

def surface2objs(surface,pia=None):
	## VER: 2014-06-27, v1.0

	info = get_surface_info(surface=surface, pia=pia)
	objs = info['objs']

	return objs

def space_of_surface(surface):
	## VER: 2014-06-27, v1.0

	objs = surface2objs(surface)
	space = objs_space(objs)

	return space

def get_surface_side(surface_name,poi=None):
	## VER: 2014-10-14, v1.2
	## 对于element surface,得到的结果是FACE1, FACE2, FACE3, ...
	## 对于几何surface, 得到的结果是SIDE1, SIDE2, SIDE3, ...

## Example, for element surface:
##	>>> get_surface_side('powder','Surf-1')   ## 'powder' is the partname
##	[FACE1]
##	>>>

##	>>> get_surface_side('bpunch_surf1')
##	[SIDE2]
##	>>> get_surface_side('bpunch_surf_yellow')
##	[SIDE2]
##	>>>

	if is_poi(surface_name):
		surface_name, poi = poi, surface_name

	if poi not in empty:
		poi = check_poi(poi)
	else:
		poi = a

	if type_of(poi) == 'PINSTANCE':
		poi = a

	sides0 = []
	sides = []

	if surface_name in poi.allInternalSurfaces.keys():
		sides = poi.allInternalSurfaces[surface_name].sides   ## there is no part.internalSurfaces
	elif surface_name in poi.surfaces.keys():
		sides = poi.surfaces[surface_name].sides
	elif type_of(surface_name) == 'SURFACE':
		surface = surface_name
		sides = surface.sides

	for side in sides:
		if side not in sides0:
			sides0.append(side)

	return sides0

def get_sym_type(p1=None):
	## VER: 2016-09-13, v1.1

	if p1 in empty:
		p1 = get_p1()
	else:
		p1 = check_poi(p1)

	nodes_x = node_select(p1, x=-1) + node_select(p1, x=-2)
	nodes_y = node_select(p1, y=-1) + node_select(p1, y=-2)

	if len(nodes_x) == 0 and len(nodes_y) == 0:
		model = 'xysym'
	elif len(nodes_x) > 0 and len(nodes_y) == 0:
		model = 'ysym'
	elif len(nodes_x) == 0 and len(nodes_y) > 0:
		model = 'xsym'
	else:
		model = 'full'
		nodes1 = node_select(p1,x=(0,MAX))
		nodes2 = node_select(p1,x=(0,MIN))
		n1 = len(nodes1)
		n2 = len(nodes2)
		print fnln(),'differ in x=',abs(n2-n1)/max(n1,n2)
		if abs(n2-n1)/max(n1,n2) < 0.015:
			model = 'full,xsym'

		nodes1 = node_select(p1,y=(0,MAX))
		nodes2 = node_select(p1,y=(0,MIN))
		n1 = len(nodes1)
		n2 = len(nodes2)
		print fnln(),'differ in y=', abs(n2-n1)/max(n1,n2)
		if abs(n2-n1)/max(n1,n2) < 0.015:
			model = model + ',ysym'

	create_csys(p1)   ## create at (0,0,0)

	return model

def get_text(obj):

	## VER: ('VER: 2013-05-01, v1.2')	## 获取所显示的字符
	## 例如：
	## obj = DIRECT_UNSYMMETRIC		(符号常量)
	## 则 get_text(obj) = 'DIRECT_UNSYMMETRIC'
	## 注意：repr(obj) = “'DIRECT_UNSYMMETRIC'”，而不是'DIRECT_UNSYMMETRIC'

	try:
		string = repr(obj)
	except AccessError:
		string = ''
		return string

	loc1 = 0
	loc2 = len(string) - 1

	for i in range(len(string)):
		if string[i] not in ['"', "'"]:
			loc1 = i
			break

	for i in range(len(string) -1, -1, -1):
		if string[i] not in ['"', "'"]:
			loc2 = i
			break

	string = string[loc1:loc2 + 1]

##	if string[0] in ['"',"'"]:
##		string = string[1:]
##
##	if string[-1] in ['"',"'"]:
##		string = string[:-1]

	return string

def get_thermal_diffusivity(Kf=None, density=None, Cp=None, fluid='air', Tg=None, Ts=None):
	## VER: 2013-08-09, v1.0 计算热扩散系数（不是热导率)
	## 空气在300K下为1.9e-5

	if Kf in empty and fluid == 'air':
		Kf = get_air_conductivity(Tg=Tg, Ts=Ts)

	if density in empty:
		if fluid == 'air':
			density = get_air_density()
		else:
			raise Exception('*** fluid density is required.')

	if Cp in empty:
		if fluid == 'air':
			Cp = 1005

	alpha = Kf/(density*Cp)

	print 'Thermal diffusivity =', alpha

	return


def get_time():
	## VER: 2010-01-09

##	timenow = time.strftime('%H:%M:%S')
	timenow = time.strftime("%m-%d-%H-%M-%S")
##	hr = int(timenow[0:2])
##	timenow = str(hr) + timenow[2:]	## 字符串类型

	return timenow

def time_slot():
	## VER: 2014-12-18, v1.2

	import time

	timenow = time.strftime("%m%d_%H%M_%S")
##	sec1 = eval(time.strftime("%S"))
##	sec = int(round(sec1/10))
##	timenow = timenow + '_' + str(sec)

	return timenow  ## such as: 1114_1008_4

def get_treat_setting(seq=1):
	## VER: 2011-04-22, v1.1
	## get treat settings from DOE_table

	global level_of_this_run

	if 'level_of_this_run' not in globals().keys():
		level_of_this_run = {}

	if seq == 0:
		raise Exception('******Error seq=0, range should be: 1~' + str(len(DOE_table)))

	if seq > len(DOE_table):
		raise Exception('******Error seq=' + str(seq) + ', range should be: 1~' + str(len(DOE_table)))

	if seq < 0:
		print 'seq range: 1~' + str(len(DOE_table))
		seq = len(DOE_table) + seq + 1

	treat = DOE_table[seq-1]
	for i in range(len(DOE_factors)):
		factor = DOE_factors[i]
		level_of_this_run[factor] = treat[i]

	treat = str(treat)
	treat = modify_string(treat,',',' '*13)
	treat = treat[1:-1]

	print DOE_factors
	print (str(seq)+':').ljust(4),treat
	print 'Factor values have been stored in global variable level_of_this_run.'
	print ' '

	return

def get_true_stress_and_plastic_strain(stress_strain_table,modulus=None,strain_limit=None, stress_limit=None, true_stress_strain=True,test_type='compressive'):
	## VER: 2013-08-22, v1.0
	## modulus: unit in MPa, stress: unit in MPa.
	## 线性极限点: stress_limit, strain_limit

	## Example: H10F
##	get_true_stress_and_plastic_strain(((1000, 0), (2750, 0.005), (4250, 0.01), (5000, 0.014), (5500, 0.02), (5700, 0.03), (5700, 0.04), (5600, 0.06)), modulus=583000, strain_limit=0.0037)
	##modulus= 583000.0 , elastic yield stress= 2157.1 , elastic strain_limit = 0.37%
	##true_stress vs. plastic strain table = ((2157.1, 0), (4250, 0.0027), (5000, 0.0054), (5500, 0.0106), (5700, 0.0202), (5700, 0.0302), (5600, 0.0504))

	## 6UF
##	get_true_stress_and_plastic_strain(((1000, 0), (3000, 0.005), (5500, 0.01), (7000, 0.016), (7600, 0.02), (8000, 0.026)), modulus=595000, strain_limit=0.006)
##	modulus= 595000.0 , elastic yield stress= 3570.0 , elastic strain_limit = 0.6%
##	true_stress vs. plastic strain table = ((3570.0, 0), (7000, 0.0042), (7600, 0.0072), (8000, 0.0126))

	test_type = test_type.lower()
	if 'compress' in test_type:
		test_type = 'compressive'
	else:
		test_type = 'tensile'

	if true_stress_strain == False:
		if strain_limit not in empty:
			if test_type == 'tensile':
				strain0 = (1 + strain_limit)
			elif test_type == 'compressive':
				strain0 = (1 - strain_limit)

			strain_limit = log(strain0)
			stress_limit = stress_limit*strain0

	## modulus, stress_limit和strain_limit三者不能同时提供。
	list1 = [modulus,strain_limit,stress_limit]
	list1 = remove_empty(list1)
	if len(list1) not in [0,2]:
		raise Exception('*** Confusing to provide modulus,strain_limit,stress_limit')

	if modulus not in empty:
		modulus = float(modulus)
		if stress_limit not in empty:
			strain_limit = stress_limit/modulus
		elif strain_limit not in empty:
			stress_limit = modulus*strain_limit
	else:
		if stress_limit not in empty and strain_limit not in empty:
			modulus = stress_limit/strain_limit

	if true_stress_strain == False:
		new_list = []
		for item in stress_strain_table:
			eng_stress,eng_strain = item
			if eng_strain <= 0: ## 只要非零点
				continue

			if test_type == 'tensile':
				strain0 = (1 + eng_strain)
			elif test_type == 'compressive':
				strain0 = (1 - eng_strain)

			true_strain = log(strain0)
			true_stress = eng_stress*strain0
			new_list.append((true_stress,true_strain))
		stress_strain_table = new_list

	new_list = []
	for item in stress_strain_table:
		true_stress,true_strain = item
		if true_strain > 0:
			new_list.append((true_stress,true_strain))
	stress_strain_table = new_list

	if modulus in empty:
		stress_limit, strain_limit = stress_strain_table[0]
		modulus = stress_limit/strain_limit

	table1 = []
	for i in range(len(stress_strain_table)):
		true_stress,true_strain = stress_strain_table[i]  ## 塑性应变=真应变-真应力/弹性模量
		if true_stress > stress_limit and true_strain > strain_limit:
			plastic_strain = true_strain - true_stress/modulus  ## 所以，数据点之间是孤立的，不互相影响。当然，第一个点，即屈服点也很关键。
			plastic_strain = round(plastic_strain,4)
			if plastic_strain > 0.002:
				table1.append((true_stress, plastic_strain))

	table1 = [(stress_limit,0)] + table1

	if len(table1) == 1:
		table1 = (table1[0],)
	elif len(table1) > 1:
		table1 = tuple(table1)
	else:
		raise Exception('*** Fail to get the true stress vs. plastic strain table.')

	print 'modulus=',modulus, ', elastic yield stress=',stress_limit,', elastic strain_limit =',str(strain_limit*100) + '%'
	print 'true_stress vs. plastic strain table =', table1
	print '*** Please ensure the yield stress is the linear limit of the true stress-strain curve, and ensure the correct of modulus.'
	print '1.  If you know the modulus, then you provide modulus, and provide stress_limit or strain_limit.'
	print '2.  If you do not know the modulus, then provide the linear limit of true stress and true strain.'
	print ' '

	return table1

def get_uncover_faces(inst1,Xinsts,x=None,y=None,z=None):
	## VER: 2012-10-31, v1.0

	inst1 = check_inst(inst1)
	Xinsts = real_insts(Xinsts)
	x,y,z = real_xyz(inst1,x,y,z)

	faces1 = faces_of_cut(inst1,x=x,y=y,z=z)
	if faces1 in empty:
		raise Exception('No faces was selected in',inst1.name)

	len1 = len(faces1)
	for inst in Xinsts:
		faces2 = faces_of_cut(inst,x=x,y=y,z=z)
		if faces2 in empty:
			continue

		space2 = objs_space(faces2)

		faces0 = face_select(inst1,faces=faces1,space=space2)
		faces1 = unselect(faces1,faces0)

		if faces1 in empty:
			break

	len2 = len(faces1)
	if len2 == 0:
		print 'No uncover face was selected.'
	else:
		print len2,'faces were found by uncover.'

	return faces1

def get_unmeshed_region(part):
	## VER: 2014-11-12, v1.0

	part = check_part(part)
	region = part.getUnmeshedRegions()
	unmesh_objs = []

	if region != None:
		cells0 = region.cells   ## unmeshed region for 3D model
		faces0 = region.faces   ## unmeshed region for 2D model
		edges0 = region.edges   ## unmeshed region for 1D model

		if cells0 not in empty:
			print '**** There are',len(cells0),'cells unmeshed.'
			unmesh_objs = cells0
		elif faces0 not in empty:
			print '**** There are',len(faces0),'faces unmeshed.'
			unmesh_objs = faces0
		elif edges0 not in empty:
			print '**** There are',len(edges0),'edges unmeshed.'
			unmesh_objs = edges0

	return unmesh_objs


##def get_user_functions():
##	## VER: 2012-11-15, v1.2
##
##	global user_functions
##
##	globals1 = globals().keys()
##
##	user_functions = {}
##	for item in globals1:
##		if item not in aba_globals:
####			try:
##			type1 = type_of(eval(item))
####			except:
####				type1 = 'NA'		## 例如，已经被删除了的part、instance所对应的尚存的全局变量。
##
####			if type1 == 'FUNCTION':
##			user_functions[item.lower()] = item    ## key保存的是索引，排序等用。value()保存的是真值。
##
####	print fnln(),'There are',len(user_functions),'user defined functions.'
##
##	return

def get_user_functions():
	## VER: 2016-12-16, v1.4

	global user_functions, abc

	globals1 = globals().keys()

	user_functions = {}
	list1 = []
	for item in globals1:
		if item not in aba_globals and type_of(item) == 'STR':
			list1.append(item)

##	raise Exception
	list2 = []
	for item in list1:
		try:
			var = eval(item)
			list2.append(var)
			str1 = repr(var)
			if str1.startswith('<function '):
				user_functions[item.lower()] = item 	## key保存的是索引，排序等用。value()保存的是真值。
		except:
			type1 = 'NA' ## 例如，已经被删除了的part、instance, sketch所对应的尚存的全局变量。

##	print fnln(),'There are',len(user_functions),'user defined functions.'

	return

def get_user_parameters():
	## VER: 2013-05-01, v1.1

	global user_parameters

	if 'user_parameters' in globals().keys():
		print '**** user_paramters has been collected, will not collect again. To reflesh, please close abaqus cae and rerun again.'
	else:
		var_panel = unselect(globals().keys(),vars_old)
		excludes = ['BOM', 'BOM32_BE', 'BOM32_LE', 'BOM64_BE', 'BOM64_LE', 'BOM_BE', 'BOM_LE', 'BOM_UTF16', 'BOM_UTF16_BE', 'BOM_UTF16_LE', 'BOM_UTF32', 'BOM_UTF32_BE',
			 'BOM_UTF32_LE', 'BOM_UTF8', 'HAVE_ARGUMENT','M5', 'M6', 'M8', 'M9', 'M10', 'MAX1', 'MIN1', 'MID', 'MonitorError', 'O1', 'O2', 'O3', 'O4', 'SubmitError', '_',  '_divide_num', '_err_info', '_first_run', '_function_error', '_time11', '_time2', '_time21',
			 '_trace_path', 'accept2dyear', 'additional_datum', 'all_treats', 'altzone', 'contact_pairs', 'created_odb_file', 'current_model_name', 'daylight', 'debug', 'debug2', 'default_plot',
			 'empty', 'err', 'fdict_collected', 'fdict_space', 'file_path', 'find_contact_com', 'four_parts', 'function_start',  'g', 'image_parts',  'insts_space', 'jobPattern','loc', 'local_csys',
			 '_max', '_min', '_scale', 'msfaces_determined', 'msfaces_trace', 'my_steps', 'odb_insts_space', 'options0',  'owner',
			  'part_holes', 'parts_space',  'plot_history', 'plugin_path', 'print_date', 'jobnum', 'purpose', 'request_date', 'result_file', 'room_temperature',
			  'run_indexs', 'run_indexs0', 'script_file_name0',  'seeded_edges', 'seeding_seq', 'slow_call', 'start_time',  'timezone', 'treat_written', 'tzname', 'varname_to_poiname', 'var_file_full',
			  'viscoDataDict','xdir', 'ydir', 'zdir']

		var_panel1 = []
		for item in var_panel:
			if item in excludes:
				continue
			if item in empty:
				continue

			var = globals()[item]
			type1 = type_of(var)
			if type1 not in basic_types:
				continue

			text1 = get_text(var)
			if len(text1) > 100 or text1 == '':
				continue

			var_panel1.append(item)

		var_panel1.sort()
		var_panel = var_panel1

		user_parameters = var_panel

	return user_parameters

def value_of_current_viewport(value_loc='', scale=1, print_result=True):
	## VER: 2015-04-30, v2.4
	## current leaf, current variable setting, current value

	## Create new field output variable
##	session.viewports['Viewport: 1'].odbDisplay.setPrimaryVariable(
##	    variableLabel='LE', outputPosition=INTEGRATION_POINT, refinement=(
##	    INVARIANT, 'Max. Principal'), )
##	s1f17_LE = session.odbs['E:/FEM/A0242_sintering_simple/B8_A0242_sintering_simple.odb'].steps['step1'].frames[17].fieldOutputs['LE']
##	tmpField = 100*s1f17_LE   ## main var = LE, frame_ID = 17
##	currentOdb = session.odbs['E:/FEM/A0242_sintering_simple/B8_A0242_sintering_simple.odb']
##	scratchOdb = session.ScratchOdb(odb=currentOdb)
##	sessionStep = scratchOdb.Step(name='Session Step',
##	    description='Step for Viewer non-persistent fields', domain=TIME,
##	    timePeriod=1.0)
##	sessionFrame = sessionStep.Frame(frameId=0, frameValue=0.0,
##	    description='Session Frame')
##	sessionField = sessionFrame.FieldOutput(name='Shrinkage',
##	    description='100*s1f17_LE', field=tmpField)

	vpnow = get_vpnow()
	display = vpnow.odbDisplay

	setting = current_variable_setting()
	main_var = setting['main']
	sub_var = setting['sub']
	main_var0 = setting['main0']
	data_type = setting['data_type']
	description = setting['description']
	step_name = setting['step_name']
	frame_id = setting['frame_ID']
	frame_time = setting['frame_time']
	frame_time = smart_round(frame_time)

##	step_name, frame_id, frame_time = current_step_frame_time()

##	result_min,result_max = minmax_value_of_step()     ## last frame
	result_min,result_max = minmax_value_of_viewport() ## current frame
	result_min = result_min[2]
	result_max = result_max[2]

	if step_name != 'Session Step':	## customized field output
		if data_type == 'Strain':
			scale = 100
		elif data_type == 'Density':
			scale = 1e9

	float = set_decimal()	## 会自动改变云图的数值的小数位数。
##	print fnln_fnln(),'float=',float
	if float > 0:
		result_max = round(result_max,float)*scale
		result_min = round(result_min,float)*scale

	else:
		result_max = int(round(result_max*scale,0))
		result_min = int(round(result_min*scale,0))

	if value_loc in empty:
		if sub_var not in empty:
			if sub_var in ['U1', 'U2', 'U3','S12','S13','S23']:
				value_loc = '|max|'
			elif sub_var in ['S11','S22','S33']:
				value_loc = 'max'
			elif sub_var == 'Max. Principal':
				value_loc = 'max'
			elif sub_var == 'Min. Principal':
				value_loc = 'min'
		else:
			if main_var == 'NT11':
				value_loc = 'gap'
	elif value_loc == 'range':
		value_loc = 'gap'

	if value_loc in empty:
		value_loc = 'max'

##	raise Exception

	value_loc = value_loc.lower()
	if value_loc == 'range':
		result = (result_min, result_max)
	elif value_loc == 'max':
		result = result_max
	elif value_loc == 'min':
		result = result_min
	elif value_loc == '|max|':
		result = result_max
		if abs(result_min) > result:
			result = result_min
	elif value_loc == '|min|':
		result = result_min
		if abs(result_max) > result:
			result = result_max
	elif value_loc == 'gap':
		result = abs(result_max - result_min)
	else:
		raise Exception('*** Not know what kind of result to get.')

##	variables = odb_variables()
##	description = variables[main_var]['description'].lower()

	unit = ''
	vname = data_type
	if main_var0 in ['S','COPEN','CSHEAR1', 'CSHEAR2', 'CSLIP1', 'CSLIP2'] \
		or 'stress' in description or 'pressure' in description or 'PRESS' in main_var0:
		unit = 'MPa'

		if check_mm_unit() == False:
			if type_of(result) in numerics:
				result = round(result/1e6,2)
			elif type_of(result) == 'TUPLE':
				result = round(result[0]/1e6,2),round(result[1]/1e6,2)
		elif get_magnitude(result) >=6:
			if type_of(result) in numerics:
				result = round(result/1e6,2)
			elif type_of(result) == 'TUPLE':
				result = round(result[0]/1e6,2),round(result[1]/1e6,2)

##		raise Exception

	elif main_var0 in ['CF', 'RF'] or 'force' in description:
		unit = 'N'
	elif main_var0 == 'U' or 'displacement' in description:
		unit = 'mm'
		if check_mm_unit() == False:
			if type_of(result) in numerics:
				result = result*1000   ## from m to mm
			elif type_of(result) == 'TUPLE':
				result = result[0]*1000, result[1]*1000

		if get_magnitude(result) <= -3:
			if type_of(result) in numerics:
				result = result*1000   ## from m to mm
			elif type_of(result) == 'TUPLE':
				result = result[0]*1000, result[1]*1000
			unit = 'um'

	elif main_var0 in ['NT11','TEMP'] or 'temperature' in description:	##'HFL','RFL11','RFLE11'
		unit = 'degC'
	elif 'ENER' in main_var0 or 'energy' in description:
		unit = ''
	elif main_var0 in ['PEEQ','LE','PE'] or 'strain' in description:   ## LE=对数应变，即真应变。
		unit = '%'
	elif main_var0 == 'DENSITY':
		result = average_density()
		unit = 'g/cc'
		value_loc = 'avg.'
	elif main_var0 in ['HFL','HFL11']:
		unit = ''
	elif 'velocity' in description:
		if check_mm_unit() == True:
			unit = 'mm/s'
		else:
			unit = 'm/s'

	setting = current_variable_setting()
	position = setting['position']
	refinement = setting['refinement']
	var_sum = setting['variable']

	if vname == '':
		vname = main_var0
	elif vname == 'Displacement':
		vname = 'Displace./Deform.'

	## vname: variable name, value name
	if value_loc in ['gap','range']:
		vname = vname + ' ' + value_loc

	if refinement == (INVARIANT, 'Mises'):
		vname = 'Mises ' + vname
	elif refinement == (INVARIANT, 'Max. Principal'):
		if setting['main0'] == 'LE':
			vname = 'true ' + vname
		vname = 'Tensile ' + vname
	elif refinement == (INVARIANT,'Tresca'):
		vname = 'Tresca ' + vname + ' (shear)'
	elif refinement == (COMPONENT, 'S11'):
		if 'cylind' in display.primaryVariableLabel.lower():
			vname = 'Radial tensile ' + vname
		else:
			vname = 'X-dir tensile ' + vname
	elif refinement == (COMPONENT, 'S22'):
		if 'cylind' in display.primaryVariableLabel.lower():
			vname = 'Circular tensile ' + vname
		else:
			vname = 'Y-dir tensile ' + vname
	elif refinement == (COMPONENT, 'S33'):
		if 'cylind' in display.primaryVariableLabel.lower():
			vname = 'Axial tensile ' + vname
		else:
			vname = 'Z-dir ' + vname
	elif refinement == (COMPONENT, 'U1'):
		if 'cylind' in display.primaryVariableLabel.lower():
			vname = 'Radial ' + vname
		else:
			vname = 'X-dir ' + vname
	elif refinement == (COMPONENT, 'U2'):
		if 'cylind' in display.primaryVariableLabel.lower():
			vname = 'Circular ' + vname
		else:
			vname = 'Y-dir ' + vname
	elif refinement == (COMPONENT, 'U3'):
		if 'cylind' in display.primaryVariableLabel.lower():
			vname = 'Axial ' + vname
		else:
			vname = 'Z-dir ' + vname
	elif main_var0 == 'PEEQ':
		vname = 'Plastic ' + vname
	elif main_var0 == 'DENSITY':
		vname = 'Average ' + vname
	elif main_var0 == 'CPRESS':
		vname = 'Contact ' + vname

	dg = dg_now()
##	objs = dg['objs']
	objs = dg['names']
##	print fnln(),'objs=',objs
	component = ''
	if len(objs) <= 3 and '#' not in repr(objs):   ## such as: objs= [('ANVIL_A1', 1, ('[#0:361 #1000000 ]',))]   ## by leaf.elementPick
		for i in range(len(objs)):
			name1 = objs[i]
##			print fnln(),'name1=',name1
			if name1[-3:] in ['_A1','_A2','_A3','_A4']:
				name1 = name1[:-3]
			loc = name1.rfind('.')
			if loc > 0:
				name1 = name1[loc+1:]  ## such as: compound_A1.PCD => PCD
			objs[i] = name1
		objs = remove_repeated_items(objs)
##		vname = repr(objs)[1:-1] + ':    ' + vname
		component = repr(objs)[1:-1]
	else:
		name1 = _sort(objs)
		name2 = _sort(oa.instances.keys())
		if name1 == name2:
##			vname = 'Whole model ( ' + str(len(objs)) + ' insts ):    ' + vname
			component = 'Whole model ( ' + str(len(objs)) + ' insts )'
		else:
			text11 = repr(objs)[1:-1]
			loc1 = locs_of_substring(text11,' ')
			loc2 = locs_of_substring(text11,',')
			loc = min(loc1[1],loc2[1])
			component = text11[:loc] + '...'

	component = modify_string(component,"'")

##	raise Exception
##	step_name, frame_id, frame_time = current_step_frame_time()
##	frame_time = smart_round(frame_time)

	results = {'main':main_var,'sub':sub_var, 'scope':value_loc, 'data':result, 'vname':vname, 'component':component, 'data_type':data_type, 'refinement':refinement,
		'unit':unit, 'description':description, 'position':position, 'position0':setting['position0'], 'objs':objs, 'scale':scale}
	results['stepname'] = step_name
	results['frame'] = frame_id
	results['time'] = frame_time

	if print_result == True:
		print ' '
		print fnln(),'Refresh the viewport...'
		print fnln(),'objs    =', objs
		print fnln(),'variable =',var_sum
		print fnln(),'main_var=',main_var,', data_type=',data_type,', value position at',position
		print fnln(),'sub_var =', sub_var, ', refinement=', refinement, ', description=',description
		print fnln(),'result  =', result, unit, '(scale =',scale,'), value_loc  =', value_loc
		print fnln(),'step =', step_name, ', time =', frame_time
		print ' '

	return results

def var_info(main_var):
	## VER: 2014-11-28, v1.0
	## reference: odb_variables()

##	>>> var_info('MISES')
##	[]
##	>>>

##	>>> var_info('COORD')
##	[('COORD', 'Coordinates', 1, 'at nodes', 4, 'vector', 0, (('Magnitude', 10),), (('COOR1', 0), ('COOR2', 1), ('COOR3', 2)), (), 0, 0, -3.40282346638529e+38, 3.40282346638529e+38),
##	('COORD', 'Coordinates', 2, 'at integration points', 4, 'vector', 0, (), (('COORD1', 0), ('COORD2', 1), ('COORD3', 2)), (), 0, 0, -3.40282346638529e+38, 3.40282346638529e+38)]
##	>>>    ## COORD的积分点结果没有Magnitude

##	>>> contour.primaryVariable		## plot 积分点结果下的COORD1时，显示为COORD1
##	('COORD', 2, 4, 0, 2, 'COORD1', 0, 0, ('',), 0, -3.40282346638529e+38, 3.40282346638529e+38, 0)
##	>>>
##	>>> contour.primaryVariable		## plot 节点结果下的COORD1时，显示为COOR1
##	('COORD', 1, 4, 0, 2, 'COOR1', 0, 0, ('',), 0, -3.40282346638529e+38, 3.40282346638529e+38, 0)
##	>>>
##	>>> contour.primaryVariable		## plot 节点结果下的Magnitude时
##	('COORD', 1, 4, 0, 1, 'Magnitude', 10, 0, ('',), 0, -3.40282346638529e+38, 3.40282346638529e+38, 0)
##	>>>

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	list1 = display.fieldVariables.variableList

	if type_of(main_var) != 'STR':
		raise Exception('*** primary var name is required.')

	main_var = main_var.upper()
##	print fnln(),'main_var=',main_var

	vars = []
	for var in list1:
		var1 = var
		if main_var == var[0]:
			if main_var == 'CEEQ':
				var1 = tolist(var)
				var1[1] = 'Equivalant creep strain'
				var1 = totuple(var1)

			vars.append(var1)

	if len(vars) > 1:
		print '--->',len(vars),'variables found for', main_var

	return vars

def get_velocity(gap=2,Hc=None,Pc=0.2, m=69.06,volume=None):
	## VER: 2014-07-08, v1.1   moving volume=8742756   right=1565330.75
	## Pc: MPa

	S = 7854.0   ## mm2

	if Hc in empty:
		Hc = 15.0   ;changing ## mm   30

	K = 22.3   ## N/mm
	g = 9800.0  ## mm/s2
	L = 16.0   ## mm
	nu = 1.4		;changing
	K_energy = 1000 ## unit: m*J
	density = 7.9e3*KD 	;changing

	if type_of(volume) in numerics:  ## total volume, not half
		m = volume*density

	m = m/2000    ## ton. total 69.07 kg

	Coeff = Pc*S*(Hc**nu)/(1-nu)

	speeds = []
	num = 40
	for i in range(num + 1):
		y = float(gap)/num*i
		energy = Coeff*((Hc - gap + y)**(1-nu) - (Hc - gap)**(1-nu)) - K*y*y - y*(2*K*L - 2*K*gap + m*g)

		velocity = sqrt(2*energy/m)
		velocity = round(velocity)

		energy = energy*2/K_energy
		energy = round(energy,2)

		speeds.append((y, velocity, energy))

	for loc,v,ener in speeds:
		print loc,'  ',v,'  ', ener

	print ' '
	print 'working pressure:', Pc,'MPa'
	print 'anvil gap=',gap,'mm'
	print 'cylinder Hc =', Hc,'mm'
	print 'moving mass =',m*2000,'kg'
	print 'impact velocity =',velocity,'mm/sec'
	print 'kinetic energy =',energy,'J'
	print ' '

##	if volume in empty:
##		volume = 8742756/2.0
##	density = 7.9e3*KD
##	mass = volume*density
##	mass0 = round(mass*1000,2)
##	print 'weight of moving parts:',mass0,'kg'
##
##	vol_right = 1565330.75
##	mass_right = vol_right*density
##	mass_right = round(mass_right*1000,2)
##	print 'weight of moving parts(right):',mass_right,'kg'


	return

def get_velocity1(gap=2):
	## VER: 2014-07-02, v1.0

	gap = gap/1000.0
	Pc = 0.2e6    ## 0.2 MPa
	S = 7854e-6   ## m2
	Hc = 30e-3    ## m
	K = 22.3e3    ## N/m
	m = 34.53        ## kg, total
	g = 9.8       ## m/s2
	L = 16e-3     ## m
	nu = 1.4

	Coeff = Pc*S*(Hc**nu)/(1-nu)
	m = m/2.0

	y = gap
	energy = Coeff*((Hc - gap + y)**(1-nu) - (Hc - gap)**(1-nu)) - K*y*y - y*(2*K*L - 2*K*gap + m*g)

	velocity = sqrt(2*energy/m)
	velocity = round(velocity*1000)

	energy = round(2*energy,2)


	return

##def get_velocity(gap=2, volume=None):
##	## VER: 2014-06-20, v1.0  volume=8742756/2.0   right=1565330.75
##
##	Fac = 1570 ## N
##	Ks = 22.3  ## N/mm
##	L = 16
##	compress_max = 16
##	compress_gap = L - gap
##	compress_mean = (compress_max + compress_gap)/2.0
##
##	Fs_contact = Ks*compress_max
##	Fs_gap = Ks*compress_gap
##	Fs_mean = Ks*compress_mean
##
##	if volume in empty:
##		volume = 8742756/2.0
##	density = 7.9e3*KD
##	mass = volume*density
##	mass0 = round(mass*1000,2)
##	print 'weight of moving parts:',mass0,'kg'
##
##	vol_right = 1565330.75
##	mass_right = vol_right*density
##	mass_right = round(mass_right*1000,2)
##	print 'weight of moving parts(right):',mass_right,'kg'
##
##	g = 9800
##
##	a_contact = (Fac - Fs_contact*2 - mass*g)/mass
##	a_mean = (Fac - Fs_mean*2 - mass*g)/mass
##	a_gap = (Fac - Fs_gap*2 - mass*g)/mass
##
##	V_contact = sqrt(2*gap*a_contact)
##	V_mean = sqrt(2*gap*a_mean)
##	V_gap = sqrt(2*gap*a_gap)
##
##	V_contact = round(V_contact,2)
##	V_mean = round(V_mean,2)
##	V_gap = round(V_gap,2)
##
##	a_contact = round(a_contact,2)
##	a_mean = round(a_mean,2)
##	a_gap = round(a_gap)
##
##	print '(V_gap, V_mean, V_contact),(a_gap,a_mean,a_contact)'
##
##	return (V_gap, V_mean, V_contact),(a_gap,a_mean,a_contact)

def get_viewport_annotations(viewport=None):
	## VER: 2014-04-18, v1.0

	if viewport in empty:
		viewport = get_vpnow()
	else:
		viewport_type, viewport = check_viewport(viewport)
	annotations = tolist(viewport.annotationsToPlot)  ## must change to a list, otherwise, its contents is changing.

	return annotations

def vol_of_insts(insts):
	## VER: 2014-05-04, v1.1

	insts = real_insts(insts)
	vol = 0
	for inst in insts:
		sequence = inst.cells[:]
		vol1 = a.getMassProperties(regions=sequence)['volume']
##		vol1 = get_volume(p=inst)
		vol = vol + vol1

	return vol

def edges_sort_by_length(edges):
	## VER: 2017-05-27, v1.0

	edges = tolist(edges)
	list1 = map(lambda edge: (round(edge_length(edge),4),edge), edges)
	dict1 = {}
	for len1,edge1 in list1:
		if len1 not in dict1.keys():
			dict1[len1] = []
		dict1[len1].append(edge1)

	list2 = sort_by_key(dict1)

	return list2

def edges_to_cells(edges):
	## VER: 2014-08-04, v1.0

	edges = tolist(edges)
	faces = edges_to_faces(edges)
	cells = faces_to_cells(faces)

	return cells

def faces_of_node(node):
	## VER: 2014-10-11, v1.0
	## may be error, always FACE1

	if type_of(node) != 'nodes':
		raise Exception('*** a node is required.')

	faces = node.getElemFaces()

	sides = []
	for face in faces:
		sides.append(face.face)

##	sides = remove_repeated_items(sides)

	return sides

def rat(base,ratio):
	y = base*10000*ratio/100
	m = int(y/12.0)
	y = int(y)
	return (y,m)

def faces_to_cells(faces):
	## VER: 2014-08-04, v1.0

	## Example:
##	faces = face_select(anvil,diameter=anvil_OD)
##	cells = faces_to_cells(faces)
##	create_set(anvil,cells=cells, name='table')

	faces = tolist(faces)

	cells = []
	for face in faces:
		poi = get_poi(face)
		ids = face.getCells()
		for id in ids:
			cell = poi.cells[id]
			if cell not in cells:
				cells.append(cell)

	return cells

def cells_in_x(poi,x=None,y=0,z=0,inc=0.005):
	## VER: 2014-08-12, v1.1
	## 对于弯曲的cell可能会有误，例如两头弯，但穿过的是低凹处。

	get_current_model()
	poi = check_poi(poi)
	x,y,z = real_xyz(poi,x,y,z,empty2space=True)
	if type_of(x) not in ['TUPLE','LIST']:
		raise Exception('*** x range is required.')

	x1,x2 = x
	if x2 < x1:
		x1,x2 = x2,x1

	try:
		locs = through_points_in_y(poi,x=x,y=y,z=z)
		wire_method = True
	except:
		wire_method = False

		cells = []
		x0 = x1 + inc
		while x0 < x2:
			cell = cell_at(poi,loc=(x0,y,z))
			if cell != None and cell not in cells:
				cells.append(cell)
				space = space_of_cell(cell)
				x0 = space[1]

			x0 = x0 + inc

	if wire_method == True:
		cells = []
		for loc in locs:
			x0,y0,z0 = loc
			x0 = x0 + inc
			cell = cell_at(poi,loc=(x0,y0,z0))
			if cell != None and cell not in cells:
				cells.append(cell)

	get_current_model()

	return cells


def cells_in_y(poi,y=None,x=0,z=0,inc=0.005):
	## VER: 2014-08-12, v1.1
	## 对于弯曲的cell可能会有误，例如两头弯，但穿过的是低凹处。

	get_current_model()
	poi = check_poi(poi)
	x,y,z = real_xyz(poi,x,y,z,empty2space=True)

	if type_of(y) not in ['TUPLE','LIST']:
		raise Exception('*** y range is required.')

	y1,y2 = y
	if y2 < y1:
		y1,y2 = y2,y1

	try:
		locs = through_points_in_y(poi,x=x,y=y,z=z)
		wire_method = True
	except:
		wire_method = False

		cells = []
		y0 = y1 + inc
		while y0 < y2:
			cell = cell_at(poi,loc=(x,y0,z))
			if cell != None and cell not in cells:
				cells.append(cell)
				space = space_of_cell(cell)
				y0 = space[3]

			y0 = y0 + inc

	if wire_method == True:
		cells = []
		for loc in locs:
			x0,y0,z0 = loc
			y0 = y0 + inc
			cell = cell_at(poi,loc=(x0,y0,z0))
			if cell != None and cell not in cells:
				cells.append(cell)

	get_current_model()

	return cells

def cells_in_z(poi,z=None,x=0,y=0,inc=0.005):
	## VER: 2014-08-12, v1.1
	## 对于弯曲的cell可能会有误，例如两头弯，但穿过的是低凹处。

	get_current_model()
	poi = check_poi(poi)

	if type_of(z) not in ['TUPLE','LIST']:
		raise Exception('*** z range is required.')

	z1,z2 = z
	if z2 < z1:
		z1,z2 = z2,z1

	try:
		locs = through_points_in_y(poi,x=x,y=y,z=z)
		wire_method = True
	except:
		wire_method = False

		cells = []
		z0 = z1 + inc
		while z0 < z2:
			cell = cell_at(poi,loc=(x,y,z0))
			if cell != None and cell not in cells:
				cells.append(cell)
				space = space_of_cell(cell)
				z0 = space[5]

			z0 = z0 + inc

	if wire_method == True:
		cells = []
		for loc in locs:
			x0,y0,z0 = loc
			z0 = z0 + inc
			cell = cell_at(poi,loc=(x0,y0,z0))
			if cell != None and cell not in cells:
				cells.append(cell)

	get_current_model()

	return cells


def cells_of_insts(insts):
	## VER: 2014-06-22, v1.0

	get_current_model()
	insts = real_insts(insts)
	cells = None
	for inst in insts:
		if cells in empty:
			cells = inst.cells[:]
		else:
			cells = cells + inst.cells[:]

##	print fnln(),'type_of(cells)=',type_of(cells)

	return cells

def get_volume(cells=None,p=None,insts=None, setname=None,mat=None):
	## VER: ('2016-08-10, v1.9')
	## Example: get_volume(insts=insts4)

	get_current_model()  ## run this command to avoid: 程序发生异常：未知的软件异常。

	if is_pia(cells):
		cells,p = p,cells

	if is_empties(cells, p, insts, setname, mat):
		vpnow = get_vpnow()
		dpo = vpnow.displayedObject
		if type_of(dpo) == 'PART':
			p = dpo
		else:
			insts = objs_of_dg()
			insts = real_insts(insts)

	if type_of(cells) in ['PART', 'PINSTANCE']:
		cells,p = p,cells

	if p not in empty:
		p = check_poi(p)

	if type_of(cells) in ['TUPLE','LIST']:
		if type_of(cells[0]) == 'PINSTANCE' or cells[0] in a.instances.keys():
			cells,insts = insts, cells

	if type_of(cells) == 'STR':
		name = cells
		if name in _m.parts.keys():
			p = _m.parts[name]
			cells = None
		elif name in a.instances.keys():
			p = a.instances[name]
			cells = None
		else:
			cells = set2objs(name,p=p)

	if setname not in empty:
		cells = set2objs(setname=setname,p=p)
	elif mat not in empty:
		cells = set2objs(setname=mat,p=p)

	if cells in empty:
		if p not in empty:  ## now p is a part or instance
			cells = tolist(p.cells)
		elif insts not in empty:
			cells = cells_of_insts(insts)

	if cells in empty:
		return 0

	sequence = list2sequence(cells)   ## cells may come from many instances, so get_poi(cells) is wrong.

	volume = 0
	if len(sequence) > 0:
		if p in empty:
			p = get_poi(cells[0])

		type1 = type_of(p)
		if type1 == 'PART':
			volume = p.getVolume(sequence)
		elif type1 == 'PINSTANCE':
			volume = a.getMassProperties(regions=sequence)['volume']

	else:
		query = p.getMassProperties()
		volume = query['volume']

	volume = smart_round(volume)

	return volume

def get_warpage():
	## VER: 2011-03-15, v1.0, 获取相对的最大值减去最小值，如硅片相对的挠度warpage。

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	max = display.contourOptions.autoMaxValue
	min = display.contourOptions.autoMinValue

	value1 = round(max - min,2)

	return value1


def get_wire_points(radius=22, length=200, alpha=45, unit_num=21):
	## VER: 2014-07-09, v1.0, x0y plane, and grow in -z direction

##	blank_part('p1')
##	points = get_wire_points()
##	p1.WireSpline(points=points, mergeWire=OFF, meshable=ON, smoothClosedSpline=ON)


	## 螺距
	pitch = 2*pi*radius/tanD(alpha)

	i = 0  ## points
	locs = []
	while i <= unit_num*length/pitch:    ## how many pitch: length/pitch
		x = radius*cos(2*pi*i/unit_num)
		y = radius*sin(2*pi*i/unit_num)
		z = -i*pitch/unit_num
		locs.append((x,y,z))
		i = i + 1

	locs = totuple(locs)

##	for x,y,z in locs:
##		print x, '   ', y, '   ', z

	return locs

def get_xyplot_variables():
	## VER: 2014-12-02, v1.1

	dpo = get_dpo()
	if type_of(dpo) != 'XYPLOT':
		raise Exception('*** a xyplot viewport is required.')

	curves = dpo.curves.values()

	variables = ''
	for curve in curves:
		var0 = curve.data.contentDescription
		var1 = curve.data.axis2QuantityType.label
		print fnln(),'var0=',var0
		print fnln(),'var1=',var1

		loc = var0.find('(')
		if loc > 0:
			var0 = var0[:loc]
		var0 = smart_modify_string(var0)

		if var0 in empty:
			var = var1
		else:
			num = var0.count('_')
			if num <= 3:
				var = var0
			else:
				var = var1

##		if ' ' in var0:
##			var = var1
##		else:
##			var = var0

		if var not in variables:
			variables = variables + '_' + var

	var = curves[0].data.axis1QuantityType.label
	variables = variables + '_' + var

	variables = variables[1:]

	return variables


def global_vars_for_this_run(all_treats,job_seq):
	## VER: 2014-03-31, v2.4
	## global constants are also included and refreshed.
	## job_seq is local variable in this function, start from 1. job_seq = 1,2,3,...

	global level_of_this_run, single_level

	level_of_this_run = {}

##	del_all_models_and_odbs()

	keys0 = locals().keys()

	## run time
	start_time = time.time();		_time11 = get_time()
	_time2 = '';					_time21 = ''
	run_times = []

	locals2globals(keys0,locals())

	if type_of(all_treats) not in ['LIST','TUPLE']:
		raise Exception('**** all_treats are required.')

	if type_of(job_seq) != 'INT':
		raise Exception('**** job_seq is required.')

	if job_seq == 0:
		job_seq = 1

#	globals()['job_seq'] = job_seq

	try:
		_m.setValues(absoluteZero=-273)		##绝对温度
	except:
		pass

	global_var_initiate()

	## Reflesh for every run
	if all_treats not in empty and job_seq - 1 in range(len(all_treats)):
		level_of_this_run = all_treats[job_seq-1]   ## 引用

	for par in level_of_this_run.keys():
		globals()[par] = level_of_this_run[par]

	for par in single_level.keys():
		globals()[par] = single_level[par]

##	refresh()
	get_current_model()

	return

def fn_h_surf(T,Tair=25,speed=0,emiss=0.84,a=2.8,b=3.0):
	## VER: 2010-09-21, v1.2
	## emiss: 发射率, for glass: emiss=0.84

	T = T + 273
	Tair = Tair + 273
	sigma = 5.67e-8 	## Stefan-Boltzmann constant, unit: W/(m^2.K^4)

	if emiss <0 or emiss > 1:
		raise Exception("error emissivity, value should be in range (0,1). emiss=1 is the worst.")   ## ********

	h_rad = emiss*sigma*(T**2 + Tair**2)*(T + Tair)
	h_rad = round(h_rad,1)

	if T <= Tair:
		h_rad = 0

	q_rad = h_rad*(T - Tair)
	q_rad = round(q_rad,1)

	h_conv = a + b*speed

	hsurf = h_conv + h_rad

	print 'Conditions: T=',T-273,'degC, Tair=', Tair - 273, 'degC, wind speed=',speed,'m/s, emissivity=',emiss
	print '--->Results: h_rad=',h_rad,'W/(m^2.K), q_rad =',q_rad,'W/m^2'
	print '             h_conv=',h_conv, 'W/(m^2.K), hsurf = h_rad + h_conv=',hsurf,'W/(m^2.K)'
	print ' '

	return hsurf

def half_bolt(partname,inst_name='',csys_KP='',ndir='x',center0=(0,0,0),D0=12,D1=24,L=5,rotate='no'):
	## VER: 2010-03-23

	bolt = blank_part(partname)
	if inst_name == '':
		inst_name = partname + 'A'
	cap_thick = 4
	x0 = center0[0];	y0 = center0[1];	z0 = center0[2]

	sign = 1
	if L < 0:
		rotate = 'yes'
		L = -L

	if rotate == 'yes':
		sign = -1

	if ndir == 'x':
		cover_O = (x0 - sign*cap_thick, y0, z0)
		pin_O = (x0 + sign*L, y0, z0)
	elif ndir == 'y':
		cover_O = (x0, y0 - sign*cap_thick, z0)
		pin_O = (x0, y0 + sign*L, z0)
	elif ndir == 'z':
		cover_O = (x0, y0, z0 - sign*cap_thick)
		pin_O = (x0, y0, z0 + sign*L)

	cylinder_grow(bolt,ndir=ndir,center0=cover_O,OD=D0,L=sign*(L + cap_thick))
	cylinder_grow(bolt,ndir=ndir,center0=cover_O,OD=D1,L=sign*cap_thick)

	divide(bolt,x=x0)
	divide(bolt,y=y0)
	divide(bolt,z=z0)

	if csys_KP == '':
		csys_KP = 'O1'

	KP_set(bolt, loc=center0)
	KP_set(bolt,pin_O, 'p_pin_end')

	if ndir == 'x':
		face1 = faces_of_cut(bolt,x=x0)
		create_set(bolt, objs=face1, name='f_assembly')

		face1 = faces_of_cut(bolt,x=pin_O[0])
		create_set(bolt, objs=face1, name='f_pin_end')

		face1 = faces_of_cut(bolt,x=cover_O[0])
		create_set(bolt, objs=face1, name='f_cover')

		edges = edge_select(bolt,x=pin_O[0], radius = D0/2)
		create_set(bolt,objs=edges, name='e_pin_circle')

		edges = edge_select(bolt,x=(x0,pin_O[0]))
		create_set(bolt, objs=edges, name='e_pin_length')

	elif ndir == 'y':
		face1 = faces_of_cut(bolt,y=y0)
		create_set(bolt, objs=face1, name='f_assembly')

		face1 = faces_of_cut(bolt,y=pin_O[1])
		create_set(bolt, objs=face1, name='f_pin_end')

		face1 = faces_of_cut(bolt,y=cover_O[1])
		create_set(bolt, objs=face1, name='f_cover')

		edges = edge_select(bolt,y=pin_O[1], radius = D0/2)
		create_set(bolt, objs=edges, name='e_pin_circle')

		edges = edge_select(bolt,y=(y0,pin_O[1]))
		create_set(bolt, objs=edges, name='e_pin_length')

	elif ndir == 'z':
		face1 = faces_of_cut(bolt,z=z0)
		create_set(bolt, objs=face1, name='f_assembly')

		face1 = faces_of_cut(bolt,z=pin_O[2])
		create_set(bolt, objs=face1, name='f_pin_end')

		face1 = faces_of_cut(bolt,z=cover_O[2])
		create_set(bolt, objs=face1, name='f_cover')

		edges = edge_select(bolt,z=pin_O[2], radius = D0/2)
		create_set(bolt, objs=edges, name='e_pin_circle')

		edges = edge_select(bolt,z=(z0,pin_O[2]))
		create_set(bolt, objs=edges, name='e_pin_length')

	faces = face_select(bolt,radius=D0/2)
	create_set(bolt, objs=faces, name='f_pin_circum')

	faces = face_select(bolt,radius=D1/2)
	create_set(bolt, objs=faces, name='f_cover_circum')

	cells = tolist(bolt.cells)
	bolt.SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE, region=cells,
		sectionName='Rigid_sec', thicknessAssignment=FROM_SECTION)
	create_set(bolt, objs=cells, name='bolt')

	a.Instance(dependent=ON, name=inst_name, part=bolt)
	boltA = a.instances[inst_name]

	print '--->Created one new bolt, name=',partname, ', instance=', inst_name, ', D0=', D0, ', D=',D1,', L=',L

	return

def have_common(list1,list2):
	## VER: ('2012-07-30, v1.2')

##>>> list1 = ['+x', 'y', '-z']
##>>> list2 = ['+x']
##>>> have_common(list1,list2)
##True
##>>>

	list1 = tolist(list1)
	list2 = tolist(list2)

	if type_of(list1) not in ['LIST','TUPLE'] or type_of(list2) not in ['LIST','TUPLE']:
		raise Exception('List or tuple is required.')

	exist = False
	if len(list1) > 0 and len(list2) > 0:
		for item in list1:
			if item in list2:
				exist = True
				break

	return exist

def have_curve(faces):
	## VER: 2012-12-20, v1.0  判断faces中有没有curved edges.

	edges = faces_to_edges(faces)
	result = False
	for edge in edges:
		if get_curvature(edge) not in empty:
			result = True

	return result

def have_running_job():
	## VER: 2013-12-31, v1.0

	running = False
	for job1 in mdb.jobs.values():
##		print job1.status
		if job1.status in [RUNNING,SUBMITTED]:
			running = True
			break

	return running

function_labels['powder_to_model'] = 'powder compaction','PV, OB, AB, PFH, PH', 'press tool','ejector','top punch','bot punch','die'
def powder_to_model(sym='full'):
	## VER: 2016-08-25, v1.0
	## import parts in stp first: powder, ejector, punch
	## sym = full, xy, x, y

	refresh()
	sym = sym.lower()

	locals0 = locals().keys()

	locals2globals(locals0,locals())

	material_database()
	create_contact_props(friction=0.2)

	for mat in _m.materials.keys():
		if mat != 'H10pow':
			del _m.materials[mat]

	names = part_names_with('punch')
	punch_found = False
	if len(names) == 1:
		p1 = _m.parts[names[0]]
		plot(p1)
		punch_found = True

		if len(p1.cells) > 0:
			faces = face_select(p1,nz=1,z=(MID,MAXp))
		else:
			faces = p1.faces

		punch = faces_to_shellpart(faces,name='punch')

	names = part_names_with('powder')
	if len(names) != 1:
		raise Exception('*** There is no powder part or more than one powder part.')

	p1 = _m.parts[names[0]]
	plot(p1)

	save_mdb(p1.name)

	powder = copy_part(p1,'powder')

	faces = face_select(p1,z=MAX)
	loops = edge_loops_of_faces(faces)

	ext_loop = loops[-1]
	faces = edges_to_faces(ext_loop)
	die_faces = face_select(p1,faces=faces,parallel='z')
	die = faces_to_shellpart(die_faces,name='die')

	faces1 = face_select(p1,z=MAX)
	faces2 = die_faces
	remove_faces(p1,faces1 + faces2)

	names = part_names_with('ejector')
	if len(names) > 1:
		raise Exception('*** There are more than one ejector in the model.')

	faces = face_select(p1,poiRefZ=(MINp,0.5),nz=-1)
	faces1 = face_select(p1,faces=faces,ndir='cylindrical')
	faces2 = face_select(p1,faces=faces,ndir='conical')
	ejector_faces = unselect(faces,faces1 + faces2)
	ejector = faces_to_shellpart(ejector_faces,name='ejector')

	remove_faces(p1,ejector_faces)
	if 'pin' in _m.parts.keys():
		copy_part('pin','pin_backup')
		del_parts('pin')

	rename(p1,'pin')
	pin = 'pin'
	_part(pin).setValues(space=THREE_D, type=DISCRETE_RIGID_SURFACE)

	if len(names) == 1:
		del_parts(ejector)
		p1 = _m.parts[names[0]]

		faces = face_select(p1,poiRefZ=(MINp,0.5),nz=-1)
		faces1 = face_select(p1,faces=faces,ndir='cylindrical')
		faces2 = face_select(p1,faces=faces,ndir='conical')
		ejector_faces = unselect(faces,faces1 + faces2)
		ejector = faces_to_shellpart(ejector_faces,name='ejector')


	if punch_found:
		move_part(punch,z1=MIN,z2 = _zmax(powder) + 0.1)

##	raise Exception

	## extend parts: die
	length0 = _zlength(die)
	edges = find_edge_loops(die,sort='z')

	extend_faces_by_edges(edges[0],distance=0.5)   ## bottom extend
	length1 = _zlength(die)

	edges = find_edge_loops(die,sort='z')   ## 编号改变了
	extend_faces_by_edges(edges[1],distance=1)   ## top extend
	length2 = _zlength(die)

	print ' '
	print fnln(),'length of die:',length0,length1,length2

	## extend parts: pin
	length0 = _zlength(pin)
	edges = find_edge_loops(pin,sort='z')

	extend_faces_by_edges(edges[0],distance=0.5)   ## bottom extend
	length1 = _zlength(pin)

	edges = find_edge_loops(pin,sort='z')   ## 编号改变了
	extend_faces_by_edges(edges[1],distance=2)   ## top extend
	length2 = _zlength(pin)

	print ' '
	print fnln(),'length of pin:',length0,length1,length2

	## extend parts: ejector

	area0 = get_area(ejector)
	edges = find_edge_loops(ejector,sort='size')

	OK_ejector = 'successful'
	try:
		extend_faces_by_edges(edges[1],distance=1)
	except:
		try:
			extend_faces_by_edges(edges[1],distance=0.5)
		except:
			try:
				extend_faces_by_edges(edges[1],distance=1.5)
			except:
				OK_ejector = 'failed'
				pass

	area1 = get_area(ejector)

	edges = find_edge_loops(ejector,sort='size')
	extend_faces_by_edges(edges[0],distance=0.5)
	area2 = get_area(ejector)

	print fnln(),'area of ejector:', area0,area1,area2

	print ' '
	print fnln(),'extend of ejector is',OK_ejector

##	raise Exception

	## extend parts: top punch
	if punch_found == True:
		area0 = get_area(punch)
		edges = find_edge_loops(punch,sort='size')

		OK_punch = 'successful'
		try:
			extend_faces_by_edges(edges[1],distance=1)
		except:
			try:
				extend_faces_by_edges(edges[1],distance=0.5)
			except:
				try:
					extend_faces_by_edges(edges[1],distance=1.5)
				except:
					OK_punch = 'failed'
					pass

		area1 = get_area(punch)

		edges = find_edge_loops(punch,sort='size')
		extend_faces_by_edges(edges[0],distance=0.5)
		area2 = get_area(punch)

		print fnln(),'area of punch:', area0,area1,area2

		print ' '
		print fnln(),'extend of punch is',OK_punch


	## assembly
	powder_A1 = new_instance(powder)

	die_A1 = new_instance(die)
	pin_A1 = new_instance(pin)
	ejector_A1 = new_instance(ejector)

	if punch_found == True:
		punch_A1 = new_instance(punch)

##	raise Exception

	## symmetric
	if sym == 'xy':
		cut_instances(x=0,sides='-')
		cut_instances(y=0,sides='-')
	elif sym == 'x':
		cut_instances(x=0,sides='-')
	elif sym == 'y':
		cut_instances(y=0,sides='-')
	else:
		divide_instances(x=0)
		divide_instances(y=0)


	raise Exception

	## material
	set_density('H10pow',table=3.15)
	set_mat(powder,mat='H10pow')

	## Reference point
	edges = edge_select(die,groupZ=MAX)
	create_RP(die,name='RP_die',loc=edges[0].pointOn[0])

	edges = edge_select(pin,groupZ=MAX)
	create_RP(pin,name='RP_pin',loc=edges[0].pointOn[0])

	create_RP(ejector,name='RP_ejector',loc=poi_centroid(ejector))

	if punch_found:
		create_RP(punch,name='RP_punch',loc=poi_centroid(punch))

	## create RP set for tools
	set_ejector = RP2set(ejector_A1,name='set_ejector')
	set_die = RP2set(die_A1,name='set_die')
	set_pin = RP2set(pin_A1,name='set_pin')

	if punch_found:
		set_punch = RP2set(punch_A1,name='set_punch')

	## steps and output
	time1 = 0.4
	time2 = 0.5
	time3 = 0.1

	please_check('scale_factor')
	create_dynamic_explicit_step(step='under filling', timePeriod=time1,scale_factor=800)
	create_dynamic_explicit_step(step='low pressing', timePeriod=time2,scale_factor=800)
	create_dynamic_explicit_step(step='up pressing', timePeriod=time3,scale_factor=800)

	field_output_request()
	_m.fieldOutputRequests['field output'].setValues(numIntervals=10)

##	raise Exception

	## history output
	del _m.historyOutputRequests['H-Output-1']

	history_output_request(name='his_die',variables=('U3','RF3'),region_set=set_die)
	history_output_request(name='his_pin',variables=('U3','RF3'),region_set=set_pin)
	history_output_request(name='his_ejector',variables=('U3','RF3'),region_set=set_ejector)
	if punch_found == True:
		history_output_request(name='his_punch',variables=('U3','RF3'),region_set=set_punch)

	## mesh

	seed_edges(powder,edges=_part(powder).edges,esize=0.5,min_num=4)
	mesh_region(powder,sweep=True)	;changing1

	powder_elems = create_set(powder,elements=_inst(powder_A1).elements,name='ALE_powder')

	control = adaptive_mesh_control(predictor='previous', curvature=0.05, weight=(0.5,0,0.5), order='first')
	apply_adaptive_mesh(step='step1',region=powder_elems,solid_time=2,fluid_time=1, controls=control)
	apply_adaptive_mesh(step='step2',region=powder_elems,solid_time=2,fluid_time=1, controls=control)
	apply_adaptive_mesh(step='step3',region=powder_elems,solid_time=2,fluid_time=1, controls=control)
	## OB这个阶段可以考虑不要ALE，但有时到这一阶段是会出现

##	raise Exception

	seed_edges(pin,edges=_part(pin).edges,esize=0.5,min_num=4)
	mesh_region(pin)	;changing1

	seed_edges(die,edges=_part(die).edges,esize=0.5,min_num=4)
	mesh_region(die)	;changing1

	seed_edges(ejector,edges=_part(ejector).edges,esize=0.5,min_num=4)
	mesh_region(ejector)	;changing1

	if punch_found == True:
		seed_edges(punch,edges=_part(punch).edges,esize=0.5,min_num=4)
		mesh_region(punch)	;changing1


	## create surface. 检查side的正确性: 在GUI下highlight该surface，填满颜色的那一侧为所建的surface
	m_die = create_surface(die_A1,side_num=2)  ## side_num = 2，凹的一面
	m_ejector = create_surface(ejector_A1,side='+z')  ## side_num = 2, 凹的一面
	if sym == 'xy':
		m_pin = create_surface(pin_A1,side='+x')  ## 外侧
	elif sym == 'y':
		m_pin = create_surface(pin_A1,side='+y')
	elif sym == 'x':
		m_pin = create_surface(pin_A1,side='+x')

	if punch_found == True:
		m_punch = create_surface(punch_A1,side='-z')  ## side_num = 2, 凹的一面


	faces_top = face_select(powder_A1,z=MAX)
	surf_top = create_surface(name='surf_powder_top',faces=faces_top)

	faces_bot = face_select(powder_A1,nz=-1,poiRefZ=(MIN,0.5),no_shape=['conical','cylindrical'])
	surf_bot = create_surface(name='surf_powder_bot',faces=faces_bot)

	faces_side = face_select(powder_A1,nx=1) + face_select(powder_A1,ny=1)
	faces_side = unselect(faces_side, faces_bot)
	surf_side = create_surface(name='surf_powder_side',faces=faces_side)

	faces_sym = face_select(powder_A1,x=0) + face_select(powder_A1,y=0)
	faces_inner = unselect(powder_A1,faces_top + faces_bot + faces_side + faces_sym)
	surf_inner = create_surface(name='surf_powder_hole',faces=faces_inner)


	## contacts
	please_check('friction')  ## 对于中模，摩擦系数可以小些。
	s2s_interact_exp(name='cont_ejector',mfaces=m_ejector, sfaces=surf_bot,friction=0.2)
	s2s_interact_exp(name='cont_die',mfaces=m_die, sfaces=surf_side,friction=0.2)
	s2s_interact_exp(name='cont_pin',mfaces=m_pin, sfaces=surf_inner,friction=0.2)	;please_check

	if punch_found == True:
		s2s_interact_exp(name='cont_punch',mfaces=m_punch, sfaces=surf_top,friction=0.2)

##	raise Exception

	## loads and BC
	apply_gravity(Gz=-9800,insts=powder_A1)

	_m.TabularAmplitude(name='amp_lowpressing', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=((0.0, 0.0), (time1, 1.0)))
	_m.TabularAmplitude(name='amp_underfilling', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=((0.0, 0.0), (time2, 1.0)))	 ## 如果step time=0.4, 而amplitude的time=0.5，则没有完整地用去整个幅值
	_m.TabularAmplitude(name='amp_uppressing', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=((0.0, 0.0), (time3, 1.0)))

	## amplitude可以不加，如果加,不要加错
	apply_disp_fix(name='pin',region=set_pin)
	apply_disp_fix(name='ejector',region=set_ejector)

	apply_disp_fix(name='die',region=set_die,	step_modifys=
		[('step2','u3',-5.811,'amp_lowpressing'),  ## die走PV
		('step3','u3',0) ])

	## PH 来着_zlength(green_A1), PFH = _zlength(powder_A1)
	if punch_found == True:
		apply_disp_fix(name='punch',region=set_punch, step_modifys =
			[('step1','u3',-2,'amp_underfilling'),    ## underfilling = PFH - PH - PV - OB + (_zmax(punch_A1) - _zmax(powder_A1))
			('step2','u3',-5.811,'amp_lowpressing'),  ## PV
			('step3','u3',-0.5,'amp_uppressing')  ])  ## OB

##	raise Exception

	## sym BC，对于powder compaction，可能是一种过渡约束，对网格自适应不利。
	faces = face_select(powder_A1,x=0)
	set1 = create_set(name='sym_powder_x',faces=faces)
	create_xsym(name='sym_powder_x',region=set1)

	edges = edge_select(pin_A1,x=0) + edge_select(die_A1,x=0) + edge_select(ejector_A1,x=0)
	if punch_found:
		edges = edges + edge_select(punch_A1,x=0)

	set2 = create_set(name='sym_tools_x',edges=edges)
	create_xsym(name='sym_tools_x',region=set2)

	faces = face_select(powder_A1,y=0)
	set1 = create_set(name='sym_powder_y',faces=faces)
	create_ysym(name='sym_powder_y',region=set1)

	edges = edge_select(pin_A1,y=0) + edge_select(die_A1,y=0) + edge_select(ejector_A1,y=0)
	if punch_found:
		edges = edges + edge_select(punch_A1,y=0)

	set2 = create_set(name='sym_tools_y',edges=edges)
	create_ysym(name='sym_tools_y',region=set2)

	save_mdb()

	print ' '
	print fnln(),'extend of ejector is',OK_ejector
	if punch_found:
		print fnln(),'extend of top punch is',OK_punch

	print fnln(), 'You can now try create job and submit'

	return


def pressure_on_area(L=None,W=None,R=None,D=None,P=None,ton=None,lateral_coefficient=0.6):
	## VER: 2016-02-29, v1.2
	## such as: axial_pressure_max = 164MPa
	## P is axial pressure

	text1 = ''
	if is_numbers(L,W):
		area = L*W
		text1 = 'L=' + str(L) + 'mm, W=' + str(W) + 'mm'
	elif is_number(R):
		area = 3.1415926*R*R
		text1 = 'R=' + str(R) + 'mm'
	elif is_number(D):
		area = 3.1415926*D*D/4
		text1 = 'D=' + str(D) + 'mm'
	else:
		raise Exception('*** vertically press area is required.')

	if is_number(P):
		force = area*P
##		print fnln(),'area=',area
##		print fnln(),'force=',force
		ton = force/9800
	elif is_number(ton):
		force = ton*9800
##		print fnln(),'area=',area
##		print fnln(),'force=',force
		P=force/area

	wall_pressure = P*lateral_coefficient

	ton = round(ton,2)
	area = round(area,2)
	P = round(P,2)
	wall_pressure = round(wall_pressure,2)

	print ' '
##	print fnln(),'force=',force,', area=',area
##	print fnln(),'P=',P, ', wall_pressure=',wall_pressure
##	print fnln(),'lateral_coefficient=',lateral_coefficient
##	print fnln(),'(ton, area, P, wall_pressure,lateral_coefficient)=',ton, area, P, wall_pressure, lateral_coefficient

	print text1,', area=',area, 'mm2, P=',P,'MPa, force=',ton,'ton, wall_pressure=',wall_pressure,', lateral_coefficient=',lateral_coefficient

	return ton, area, P, wall_pressure

def prices(value):

	if is_number(value) == False:
		raise Exception('A number is required.')

	dict1 = {}
	dict1[-10] = value*0.9
	dict1[-8] = value*0.92
	dict1[-6] = value*0.94
	dict1[-5] = value*0.95
	dict1[-3] = value*0.97
	dict1[-2] = value*0.98
	dict1[0] = value
	dict1[2] = value*1.02
	dict1[3] = value*1.03
	dict1[5] = value*1.05
	dict1[6] = value*1.06
	dict1[8] = value*1.08
	dict1[10] = value*1.1

	myprint(dict1)

	return

def print2(*vars):
	## VER: 2013-06-26, v1.1
	## Example:
	## print2('Results of',get_caller_code(),':')

	info = get_traceback()
	info = info[:-2]
	if len(info) >= 4:
		info = info[-4:]

##	print ' '
	print info,
	for item in vars:
		print item,
	print ' '

	return

def get_current_chart():
	## VER: 2014-12-03, v1.0

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	if type_of(dpo) != 'XYPLOT':
		raise Exception('*** An xyplot is required.')
	elif len(dpo.charts.values()) > 1:
		raise Exception('*** More than one chart in the current viewport.')
	chart = dpo.charts.values()[0]

	return chart   ## chart object

def chart_curves_axis_of_xyplot(xyp=None):
	## VER: 2014-08-14, v1.0   axis -> axes
	## 一个xyp有很多chart, 每一个chart有很多curves

	if xyp in empty:
		xyp = get_dpo()
		if type_of(xyp) != 'XYPLOT':
			raise Exception('*** a xyplot viewport is required.')
	else:
		xyp = check_obj(xyp,session.xyPlots)

	if len(xyp.charts.values()) > 1:
		raise Exception('*** There are more than on chart in the xyplot.')

	chart = xyp.charts.values()[0]
	curves = xyp.curves.values()   ## curves is a list

	return chart, curves, chart.axes1[0], chart.axes2   ## chart.axes1 and chart.axes2 are all tuple

function_labels['cost'] = 'amount','cost'
def cost(cost0,amount0,cur,*opts):
	## v1.9

## 注意:cost(23.98,300,14,(14.02,100),(13.4,200),(14.02,-100))的成本为(19.79,500)
## 而:  cost(23.98,300,14,(14.02,100),(13.4,200),(14.02,-100))的成本为(19.77,500)
## 二者的结果是一样的，只是相差了一个手续费。

##	>>> cost(18.748,600,(14,-100),(12,100))
##	['cost', 44685] cur= 14
##	['cost', 44686] opts= [(14, -100), (12, 100)]

##	>>> cost(23.98,300,14,(14.02,100))
##	Current cost=        (23.98, 300, 7194.0, 0)
##	after (14.02, +100)-> (21.502, 400, 8600.8, 0) , fee= 4.907
##
##	Total input    = 8600.907
##	Current account= 5600
##	Gain = -3000.907 , -34.891% , cost= 21.502 , amount= 400 , current 14 need increase 53.586% to 21.502
##	Gain without operation: -2994.0 , -41.618% , cost= 23.98
##	Diff = -6.907

	## 注意:(13.5,300)与(14,100),(13.5,200)的效果一样的，但后者更容易操作。(先极端，再分散)
##	>>> cost(24,300,14,(13.5,300))
##	Current cost=        (24, 300, 7200, 0)
##	after (13.5, +300)-> (18.75, 600, 11250.0, 0)
##
##	Total input = 11251.21
##	Current account= 8400
##	Gain = -2851.21 , -25.34% , cost= 18.75
##	Diff = 148.79
##
##	>>> cost(24,300,14,(14,100),(13.5,200))
##	Current cost=        (24, 300, 7200, 0)
##	after (14  , +100)-> (21.5, 400, 8600.0, 0)
##	after (13.5, +200)-> (18.83, 600, 11298.0, 0)
##
##	Total input = 11301.23
##	Current account= 8400
##	Gain = -2901.23 , -25.67% , cost= 18.83
##	Diff = 98.77

##	>>> target_cost(24,300,loss=0.21,cur=14)  ## target loss=0.21
##	current p1,n1= (24, 300)
##	target p= 17.72
##	[(11.44, 300), (13.01, 400), (13.95, 500), (14.58, 600), (15.03, 700), (15.36, 800), (15.63, 900), (15.84, 1000)]
##	>>> cost(24,300,14,(13.95,500))
##	Current cost=        (24, 300, 7200, 0)
##	after (13.95, +500)-> (17.72, 800, 14176.0, 0)
##
##	Initial input = 7200
##	Account at current price without operation= 4200
##	Gain without operation: -3000 , -41.67% , cost= 24
##	--
##	Total input    = 14177.09
##	Current account= 11200
##	Gain = -2977.09 , -21.0% , cost= 17.72 , amount= 800
##	Diff = 22.91

	rat = 3e-4
	if cost0>=100 and amount0<100:
		cost0,amount0 = amount0,cost0

	if is_number(cur) and len(opts) == 1 and is_number(opts[0]):
		n1 = opts[0]
		if cur>=100 and n1<100:
			cur,n1 = n1,cur
		opts=((cur,n1),)

	if opts in empty and type_of(cur) == 'TUPLE':
		opts = cur
		opts = totable(opts)
		if is_number(opts[0]):
			cur = opts[0]
			if cur in [100,200,300,400,500,600,700,800]:
				cur = opts[1]
		else:
			cur = opts[0][0]
			if cur in [100,200,300,400,500,600,700,800]:
				cur = opts[0][1]

	elif opts in empty and type_of(cur) == 'LIST' and type_of(cur[0]) == 'TUPLE':
		opts = cur
		opts = totable(opts)
		if is_number(opts[0]):
			cur = opts[0]
			if cur in [100,200,300,400,500,600,700,800]:
				cur = opts[1]
		else:
			cur = opts[0][0]
			if cur in [100,200,300,400,500,600,700,800]:
				cur = opts[0][1]

	elif type_of(cur) == 'TUPLE' and opts not in empty:
		opt1 = [cur]
		for item in opts:
			opt1.append(item)

		opts = opt1
		cur = opts[0][0]
		if cur in [100,200,300,400,500,600,700,800]:
			cur = opts[0][1]

##	print fnln(),'cur=',cur
##	print fnln(),'opts=',opts
##	raise Exception

	gain0 = (cur - cost0)*amount0
	gain_ratio0 = round(gain0/(amount0*cost0)*100,2)
	inc_ratio0 = round((cost0 - cur)/cur*100,2)

	if cost0 > cur:
		cur0 = cur
		gap1 = round((cost0 - cur0)*100/(amount0+100),2)
		gap2 = round((cost0 - cur0)*200/(amount0+200),2)
		gap3 = round((cost0 - cur0)*300/(amount0+300),2)
		gap4 = round((cost0 - cur0)*400/(amount0+400),2)
		unit_effect = (100,gap1),(200,gap2),(300,gap3),(400,gap4)

	if opts in empty:
		print 'gain =',gain0
		print 'gain_ratio =',gain_ratio0,'%'
		print 'current',cur,'need to increase',inc_ratio0,'% to reach',cost0,'(current cost)'
		if cost0 > cur:
			print 'effect=',unit_effect,'for',cur

		print target_gap(cost0,amount0,gap=1,n2=100)
		print target_gap(cost0,amount0,gap=1,n2=200)

		return

	if type_of(cur) == 'LIST' and len(cur) == 1:
		times = cur[0]
		if times <100:
			times = times*amount0

		list1 = (cost0*0.9,times),(cost0*0.8,times),(cost0*0.7,times),(cost0*0.6,times),(cost0*0.5,times),(cost0*0.4,times),(cost0*0.3,times)

		for pr2,amount2 in list1:
			print '==',pr2
			cost(cost0,amount0,pr2*1.2,(pr2,times))

	else:
		if is_number(cur)== False:
			raise Exception('*** Current price is required.')

		if opts not in empty:
			pr1 = cost0
			amount1 = amount0
			print 'Current cost=       ',(pr1,amount1,pr1*amount1,0)  ## before: cash=0
			expense = cost0*amount0
			cash = 0
			inv = cost0*amount0
			for pr,qty in opts:
##				fee = round(abs(pr*qty)*0.0035,3)  ;please_check ## 交易费用:千分之三点五
				fee = round(abs(pr*qty)*rat,3)
				if fee < 5:
					fee = 5

				if qty < 0:
					cash = cash + abs(pr*qty)  ## 套现的筹码
					inv = inv + fee

					if pr < pr1: ## 低卖，就有损失，这要计入成本
						expense = (amount1 + qty)*pr1 + (pr - pr1)*qty + fee
					else: ## 高卖套现，不增加成本，只增加交易费
						expense = (amount1 + qty)*pr1 + fee

				else: ## 买入, cash不变
					expense = amount1*pr1 + qty*pr + fee
					inv = inv + qty*pr + fee

				amount1 = amount1 + qty
				pr1 = round(expense/amount1,3)  ## 成本是相对于目前市值的成本。

				if qty > 0:
					str1 = '+' + str(qty)
				else:
					str1 = str(qty)
				str1 = '(' + str(pr).ljust(4) + ', ' + str1 + ')'
				str1 = str1.ljust(12)
				print 'after ' + str1 + '->',(pr1,amount1,pr1*amount1,cash),', fee=',fee

			out = amount1*cur + cash
			real_gain = out - inv

			loss_ratio = round(real_gain/inv*100,2)
			inc_ratio = round((pr1 - cur)/cur*100,2)

			print ' '
##			print 'Initial input =',amount0*cost0
##			print 'Account at current price without operation=',amount0*cur
##			print '--'
			print 'Total input    =',inv
			print 'Current account=',out
			print 'Gain =',real_gain,', ' + str(loss_ratio) + '%', ', cost=',pr1, ', amount=',amount1,', current '+ str(cur) + ' need increase',str(inc_ratio) + '% to',pr1,'(new cost)'
			print 'Gain without operation:',gain0,', ' + str(gain_ratio0) + '%', ', cost=', cost0,', current '+ str(cur) + ' need increase',str(inc_ratio0) + '% to',cost0,'(current cost)'
			print 'Diff =',real_gain - amount0*(cur-cost0)
			if cost0 > opts[-1][0] and len(opts)==1:
				cur0 = opts[-1][0]
				gap1 = round((cost0 - cur0)*100/(amount0+100),2)
				gap2 = round((cost0 - cur0)*200/(amount0+200),2)
				gap3 = round((cost0 - cur0)*300/(amount0+300),2)
				gap4 = round((cost0 - cur0)*400/(amount0+400),2)
				unit_effect = (100,gap1),(200,gap2),(300,gap3),(400,gap4)
				print 'effect=',unit_effect,'for',cur0

			print ' '

		print target_gap(cost0,amount0,gap=1,n2=100)
		print target_gap(cost0,amount0,gap=1,n2=200)

	return

function_labels['jiacha'] = 'suggest','cost','price'
def jiacha(cost0,amount0,cost1,current):
	## V1.0

	if cost0>=100 and amount0<100:
		cost0,amount0 = amount0,cost0

	cost01 = round(cost0*0.89,2)
	list1 = target_cost(cost0,amount0,cost01)
	newlist = []
	for p,num in list1:
		if p<= current:
			newlist.append((p,num))

	if newlist in empty:
		newlist = [list1[0]]

	cost11 = round(cost1*0.89,2)
	newlist.append((cost11,100))
	newlist.append((cost11,200))

	newlist = sort_tuple_type_elements(newlist,index=0,reverse=True)
	newlist2 = []
	for p,num in newlist:
		if p not in newlist2:
			newlist2.append(p)

	list2 = []
	for item in newlist2:
		list2.append((item,100))

	cost(cost0,amount0,list2)
	print ' '
	print 'Suggestion:'

	return list2

def target_gap(p1,n1,gap,n2=100):
	## V1.1, 目的是降本，而且用尽量少的数量。原有数量越多，降本越困难。
##	>>> target_gap(18.748,600,0.95)
##	(12.06, 100, 17.798, -0.95)
##	>>> target_gap(18.748,600,1)
##	(11.71, 100, 17.748, -1)
##	>>>

	if p1>=100 and n1<100:
		p1,n1 = n1,p1

	gap = abs(gap)
	if gap > 30:
		raise Exception('*** Error gap')

##	print 'gap=',gap
	p2 = ((n1+n2)*(p1-gap) - p1*n1)/(1.0035*n2)
	p2 = round(p2,2)

	return ('<='+str(p2),p2,n2,'now='+str(n1+n2),p1-gap,-gap)

def target_gaps(p1,n1,gap):
	## v1.0

##	>>> target_gaps(18.748,600,1)
##	options:
##	('<=11.71', 100, 17.748, -1)
##	('<=14.7', 200, 17.748, -1)
##	('<=15.69', 300, 17.748, -1)
##	>>> target_gaps(18.748,600,2)
##	options:
##	('<=4.73', 100, 16.748, -2)
##	('<=10.71', 200, 16.748, -2)
##	('<=12.7', 300, 16.748, -2)
##	>>>

	print 'options:'
	num = 0
	opt1=target_gap(p1,n1,gap,100)
	opt2=target_gap(p1,n1,gap,200)
	opt3=target_gap(p1,n1,gap,300)

	ps = []
	if opt1[1]>p1/4.0:
		print opt1
		ps.append(opt1[1])
	if opt2[1]>p1/4.0:
		print opt2
		ps.append(opt2[1])
	print opt3
	ps.append(opt3[1])

	if len(ps) >1:
		p12 = (ps[0] + ps[1])/2
		print 'p12=',p12

	return

def target_cost(p1,n1,p=None,cur=None,loss=None,list1=(),ref=None):
	## V1.0
	## p是目标成本

##	>>> target_cost(24,300,18)
##	current p1,n1= (24, 300)
##	target p= 18
##	[(9.0, 200), (12.0, 300), (13.5, 400), (14.4, 500), (15.0, 600), (15.43, 700), (15.75, 800), (16.0, 900), (16.2, 1000)]
##	>>>

##	>>> target_cost(24,300,loss=0.21,cur=14)  ## target loss=0.21
##	current p1,n1= (24, 300)
##	target p= 17.72
##	[(11.44, 300), (13.01, 400), (13.95, 500), (14.58, 600), (15.03, 700), (15.36, 800), (15.63, 900), (15.84, 1000)]
##	>>> cost(24,300,14,(13.95,500))
##	Current cost=        (24, 300, 7200, 0)
##	after (13.95, +500)-> (17.72, 800, 14176.0, 0)
##
##	Initial input = 7200
##	Account at current price without operation= 4200
##	Gain without operation: -3000 , -41.67% , cost= 24
##	--
##	Total input    = 14177.09
##	Current account= 11200
##	Gain = -2977.09 , -21.0% , cost= 17.72 , amount= 800
##	Diff = 22.91

	if p1>=100 and n1<100:
		p1,n1 = n1,p1

	if is_numbers(cur,loss):
		if loss > 1:
			loss = loss/100

		p = round(cur/(1-loss),2)

	else:
		if p < 2: ## p is ratio
			if ref in empty and is_number(p):
				p = p*p1
			elif is_number(ref):
				loss = (p1-ref)*p   ## 参考价
				p = p1 - loss
			elif type_of(ref) in ['LIST','TUPLE']: ## loss ratio
				loss1,loss2 = ref
	##			p = p1*(100 - loss2)/100.
				gap = (p1*loss1 - p1*loss2)/100.
				p = p1 - gap

	if is_number(list1):
		list1 = tolist(list1)

	if list1 in empty:
		list1 = [100,200,300,400,500,600,700,800,900,1000]

	list2 = []
	print 'current p1,n1=',(p1,n1)
	print 'target p=',p
	for n2 in list1:
		p2 = p - n1/n2*(p1-p)
		p2 = round(p2,2)
		if p2 > p1*0.35:
			list2.append((p2,n2))

##	print list2

	return list2

def ratioP(p1,ratio1,ratio2):
	## VER: 1.0, no change in amount

##	>>> ratioP(14.16,0.14,0.07)
##	13.29
##	>>> ratioP(14.16,0.14,0)
##	12.42
##	>>>

	if ratio1 > 1:
		ratio1 = ratio1/100
	if ratio2 >1:
		ratio2 = ratio2/100

	p2 = (1+ratio2)/(1+ratio1)*p1
	p2 = round(p2,2)

	return p2

def check1():
	## VER: 2013-12-04, v1.0
	## Please mannualy run debug1 = False in command window for a new try if stopped by stop1() just now.

	globals()['debug1'] = True

	return

def stop1():
	## VER: 2013-12-04, v1.0

	global debug1

	caller = caller_fnln()
	if debug1 == True:
		print ' '
		print ('*** stop1() at ' + repr(caller))
		raise Exception('*** stop1() at ' + repr(caller))

	return

def split_file_path(file1):
	## VER: 2014-07-07, v1.0

	if type_of(file1) != 'STR':
		raise Exception('*** file name or file path is required.')

	path = ''
	name = ''
	extension = ''

	loc = file1.rfind('.')
	if loc > 0:
		sub = file1[loc + 1:]
		if 1<= len(sub) <= 5:
			extension = sub
		file1 = file1[:loc]

		loc = file1.rfind('/')
		name = file1[loc + 1:]

		if loc > 0:
			file1 = file1[:loc]
		else:
			file1 = ''

	if file1 not in empty:
		path = file1

	return path, name, extension

function_labels['square_insert'] = 'GUI','toolkit','hole','extrude','insert'
def square_insert(jobname='A1_square_compact',partname='powder',width=15, PFH=16, PV=3, OB=0.6, PH=6, PW=8, pinD=8, friction=0.2):
	## VER: 2017-09-25, v1.3

	clear()

	if type_of(partname) != 'STR':
		raise Exception('*** partname is required.')

	width = float(width)
	PFH = float(PFH)
	pinD = float(pinD)
	OB = float(OB)
	PV = float(PV)
	mouthD = pinD

	if pinD > width:
		raise Exception('*** pinD should be less than width')

	dip = PFH - PH - OB - PV
	if dip <= 0:
		print fnln(),'dip=',dip
		raise Exception('*** displacement of punch at first step is <=0')

	if partname in _m.parts.keys():
		del_parts(partname)
	material_database()

	if is_number(friction) == False:
		friction = 0.2
	create_contact_friction(name='Friction',friction=friction)

	powder = blank_part(partname)
	create_block(powder,x=(-width/2,width/2),y=(-width/2,width/2),z=(0,PFH),mat='H10pow')
	drill_hole(powder,ndir='z',D=pinD)
	divide(powder,x=0)
	divide(powder,y=0)

	density = smart_round(PW/get_volume(powder)*1e-6)
	set_density('H10pow',table=density)   ## 3.234
	print ' '
	print fnln(),'density=',density
	if by_GUI == True:
		if density > 3.4e-9:
			print "*** Calculated filling density is too high (normal=3.2-3.3), please decrease the PW or increase the PFH, then click OK again"
			raise Exception
		elif density < 3.0e-9:
			print "*** Calculated filling density is too low (normal=3.2-3.3), please increase the PW or decrease the PFH, then click OK again"
			raise Exception

	## tpunch
	if 'tpunch' in _m.parts.keys():
		del_parts('tpunch')

	faces = face_select(powder,z=MAX)
	tpunch = faces_to_shellpart(faces,name='tpunch',rigid=True) ## 3D, discrete rigid
	V_height = 0.5

	move_part(tpunch,z1=MAX,z2=_zmax(powder) + V_height)

	edges = exterior_edges(tpunch)
	edges1 = edge_select(tpunch,D=pinD)
	edges = unselect(edges,edges1)
	extend_faces_by_edges(edges,distance=0.5)

	edges = edge_select(tpunch,D=pinD)
	extend_faces_by_edges(edges,distance=0.5)

	## ejector
	if 'ejector' in _m.parts.keys():
		del_parts('ejector')

	faces = face_select(powder,nz=-1)
	ejector = faces_to_shellpart(faces,name='ejector',rigid=True)

	edges = exterior_edges(ejector)
	edges1 = edge_select(ejector,D=pinD)
	edges = unselect(edges,edges1)
	extend_faces_by_edges(edges,distance=0.5)

	edges = edge_select(ejector,D=pinD)
	extend_faces_by_edges(edges,distance=0.5)

	## pin
	if 'pin' in _m.parts.keys():
		del_parts('pin')

	faces = face_select(powder,D=pinD)
	pin = faces_to_shellpart(faces,name='pin',rigid=True)

	edges = edge_select(pin,z=MAX)
	extend_faces_by_edges(edges,distance=1)

	edges = edge_select(pin,z=MIN)
	extend_faces_by_edges(edges,distance=1)

	## die
	if 'die' in _m.parts.keys():
		del_parts('die')

	faces = face_select(powder,z=MID)
	faces1 = face_select(powder,diameter=pinD)
	faces = unselect(faces,faces1)
	die = faces_to_shellpart(faces,name='die')

##	faces = face_select(powder,x=MIN) + face_select(powder,x=MAX) + face_select(powder,y=MIN) + face_select(powder,y=MAX)
##	die = faces_to_shellpart(faces,name='die',rigid=True)

	edges = edge_select(die,z=MAX)
	extend_faces_by_edges(edges,distance=1)

	edges = edge_select(die,z=MIN)
	extend_faces_by_edges(edges,distance=1)

	## Assembly
	new_instance(powder)
	new_instance(tpunch)
	new_instance(ejector)
	new_instance(pin)
	new_instance(die)

##	refresh()
##	plot(a)

	save_as(jobname)

	## steps and outputs, adaptive mesh
	period0 = 0.1
	period1 = 0.3
	period2 = 0.3
	period3 = 0.1

	create_dynamic_explicit_step('form V',timePeriod=period0,scale_factor=800)
	create_dynamic_explicit_step('upper pressing',timePeriod=period1,scale_factor=800)
	create_dynamic_explicit_step('lower pressing',timePeriod=period2,scale_factor=800)
	create_dynamic_explicit_step('OB',timePeriod=period3,scale_factor=800)

	field_output_request(intervals=10)

	## divide for mesh
	divideD = mouthD + 2	;changing
	circular_divide(powder,ndir='z',D=divideD)
	divide(powder,y=0)

	locs1 = zlocs(ejector)
	if len(locs1) > 1:  ## concave
		locs = zlocs(powder)
		divide(powder,z=locs[1])

	## mesh powder
	set_element_shape(powder,technique='SWEEP')

	edges = edge_select(powder,z=MAX,diameter=divideD) + edge_select(powder,z=MAX,diameter=pinD)
	seed_edges(powder,edges=edges,enum=20)	;changing

	edges = edge_select(powder,z=MAX,length=(divideD-pinD)/2)
	seed_edges(powder,edges=edges,enum=3)	;changing

##	edges = edge_select(powder,z=MAX)
##	edges = exterior_edges(edges)
##	list1 = edges_sort_by_length(edges)
##
##	seed_edges(powder,edges=list1[0][1],enum=2)
##	seed_edges(powder,edges=list1[1][1],enum=4)
##
##	edges = edge_select(powder,z=MIN1)
##	edges = exterior_edges(powder,edges)
##	seed_edges(powder,edges=edges,enum=3)

	mesh_part(powder,esize=width/30)	;changing

	control = adaptive_mesh_control(predictor='previous', curvature=0.05, weight=(0.5,0,0.5), order='first')
##	control = adaptive_mesh_control(predictor='previous', curvature=1, weight=(1,0,0), order='first')
	powder_elems = _inst('powder_A1').elements

	apply_adaptive_mesh(step='form V',region=powder_elems,frequence=2,sweep=1, controls=control)
	apply_adaptive_mesh(step='upper pressing',region=powder_elems,frequence=2,sweep=1, controls=control)
	apply_adaptive_mesh(step='lower pressing',region=powder_elems,frequence=3,sweep=1, controls=control)
	apply_adaptive_mesh(step='OB',region=powder_elems,frequence=4,sweep=1, controls=control)

	create_tabular_amplitude('amp_step1',time_table=[(0,0),(period0,1)])
	create_tabular_amplitude('amp_step2',time_table=[(0,0),(period1,1)])
	create_tabular_amplitude('amp_step3',time_table=[(0,0),(period2,1)])
	create_tabular_amplitude('amp_step4',time_table=[(0,0),(period3,1)])

	## mesh punch
	divide(tpunch,y=0)
	divide(tpunch,x=0)
	mesh_part(tpunch,esize=0.5)

	## mesh die
	mesh_part(die,esize=0.5)

	## mesh ejector
	mesh_part(ejector,esize=0.5)

	## mesh ejector
	mesh_part(pin,esize=0.5)

	## surfaces & interaction
	powder_A1 = 'powder_A1'
	faces = face_select(powder_A1,z=MID)
	faces1 = face_select(powder_A1,diameter=pinD)
	faces = unselect(faces,faces1)
	powder_die = create_surface(name='powder-die',faces=faces)

	faces = face_select(powder_A1,nz=-1)
	powder_ejector = create_surface(name='powder-ejector',faces=faces)

	faces = face_select(powder_A1,nz=1)
##	faces1 = face_select(powder_A1,diameter=pinD)
	powder_punch = create_surface(name='powder-punch',faces=faces)

	faces = face_select(powder_A1,D=pinD)
	powder_pin = create_surface(name='powder-pin',faces=faces)

	m_die = create_surface(name='surf-die', poi='die_A1',side_num=2)
	m_ejector = create_surface(name='surf-ejector',poi='ejector_A1',side='+z')
	m_punch = create_surface(name='surf-punch',poi='tpunch_A1',side_num=2)
	m_pin = create_surface(name='surf-pin',poi='pin_A1',side_num=2)  ## pin的外侧

	s2s_interact_explicit('powder-die',mfaces=m_die, sfaces=powder_die)
	s2s_interact_explicit('powder-punch',mfaces=m_punch, sfaces=powder_punch)
	s2s_interact_explicit('powder-ejector',mfaces=m_ejector, sfaces=powder_ejector)
	s2s_interact_explicit('powder-pin',mfaces=m_pin, sfaces=powder_pin)

	## RP, set, amplitude, BC (RSAB)
	apply_gravity(Gz=-9800,insts='powder_A1')

	try:
		del _part('tpunch').features['O']
	except:
		pass

	vertices = vertice_select(tpunch,z=MAX)
	vertices = vertices_sort_byx(vertices)
	create_RP(tpunch,loc=vertices[0][1][0],name='RP_punch')
##	set_punch = create_set('tpunch_A1',name='RP_punch',RP=_inst('tpunch_A1').referencePoints.values()[0])
	set_punch = create_set('tpunch_A1',name='RP_punch',RP=PI('tpunch').referencePoints)

	try:
		del _part('pin').features['O']
	except:
		pass

	vertices = vertice_select(pin,z=MAX)
	vertices = vertices_sort_byx(vertices)
	create_RP(pin,loc=vertices[0][1][0],name='RP_pin')
	set_pin = create_set('pin_A1',name='RP_pin',RP=_inst('pin_A1').referencePoints)

	try:
		del _part('die').features['O']
	except:
		pass

	vertices = vertice_select(die,z=MAX)
	vertices = vertices_sort_byy(vertices)
	create_RP(die,loc=vertices[-1][1][0],name='RP_die')
	set_die = create_set('die_A1',name='RP_die',RP=_inst('die_A1').referencePoints)

	try:
		del _part('ejector').features['O']
	except:
		pass

	vertices = vertice_select(ejector,z=MIN)
	vertices = vertices_sort_byy(vertices)
	create_RP(ejector,loc=vertices[-1][1][0],name='RP_ejector')
	set_ejector = create_set('ejector_A1',name='RP_ejector',RP=_inst('ejector_A1').referencePoints)

	apply_disp_fix('punch_xy',region=set_punch,Ux=0,Uy=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix('die_xy',region=set_die,Ux=0,Uy=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix('ejector_xyz',region=set_ejector,Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix('pin_xyz',region=set_pin,Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

	apply_disp_fix('punch_move',region=set_punch,U3=0,step_modifys=[('step1','u3',-V_height,'amp_step1'),
		('step2','u3',-dip,'amp_step2'),('step3','u3',-PV,'amp_step3'),('step4','u3',-OB,'amp_step4')])
	apply_disp_fix('die_move',region=set_die,U3=0,step_modifys=[('step3','u3',-PV,'amp_step3'),('step4','u3',0)])

	save_as(jobname)
	create_job(jobname)

	print ' '
	print 'PFH=',PFH
	print 'density of filling part:',get_density('H10pow')
##	print fnln(),'ref_PFH=',ref_PFH
##	print fnln(),'PFH_default=1.61*PH+PV=',PFH_default

##	print caller_fnln()  ## square_insert()
	## 如果在命令窗口中运行square_insert()，结果为：['cliCommand', 79, '<module>', 1]
	## 如果GUI菜单命令调用square_insert()，结果为[]

	return

function_labels['square_insert_compaction'] = 'powder compaction','PV, OB, PH, AB', 'insert', 'sintering'
def square_insert_compaction(length=15,width=None,corner_round=0, sideR=None, surf_neck=None,
	big_L=None,small_L=None, hole_angle_top=None,bot_chamfer=None, small_D_surf=None,small_D_mid=None,
	sink_shape='T', down_slope=None, up_slope=None, big_D_surf=None,big_D_mid=None,
	transition_angle=None, hole_angle_bot=None,pin_D=None, info='insert',
	sink2bot=None,bot_grind=0,top_grind=0,topR=None,botR=None,product_H=None,
	shrinkage=0.19,th=14.44,C1=2.505, compaction_ratio=2.3,PVPH=0.61,
	filling_density=None,PFH=None,PFH_by='factor',reverse_press=False):

	## VER: 2016-09-05, v3.2, reference: powder_to_model()

##	square_insert_compaction(length=15.62,sideR=80,surf_neck=15.31,small_D_surf=7.3,small_L=1.32, big_D_surf=8.5, big_L=3.43, hole_angle_top=4,hole_angle_bot=-4,
##		sink2bot=1.32, bot_grind=0.15, bot_chamfer=0.5, topR=25, product_H=[5.2,4.75], PFH_by='factor',ABPH=1.61,filling_density=3.2)  ## priority 4: sinter_H = 4.9


	## 关于compaction ratio
##	>>> _ylength('fill_part')/_ylength('green')
##	2.20445459737293
##	>>>

##	_m.TabularAmplitude(name='amp_lowpressing', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=((0.0, 0.0), (time1, 1.0)))
##	_m.TabularAmplitude(name='amp_underfilling', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=((0.0, 0.0), (time2, 1.0)))	 ## 如果step time=0.4, 而amplitude的time=0.5，则没有完整地用去整个幅值
##	_m.TabularAmplitude(name='amp_uppressing', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=((0.0, 0.0), (time3, 1.0)))
##
##	## amplitude可以不加，如果加,不要加错
##	apply_disp_fix(name='pin',region=set_pin)
##	apply_disp_fix(name='ejector',region=set_ejector)
##
##	apply_disp_fix(name='die',region=set_die,	step_modifys=
##		[('step2','u3',-5.811,'amp_lowpressing'),  ## die走PV
##		('step3','u3',0) ])
##
##	## PH 来着_zlength(green_A1), PFH = _zlength(powder_A1)
##	if punch_found == True:
##		apply_disp_fix(name='punch',region=set_punch, step_modifys =
##			[('step1','u3',-2,'amp_underfilling'),    ## underfilling = PFH - PH - PV - OB + (_zmax(punch_A1) - _zmax(powder_A1))
##			('step2','u3',-5.811,'amp_lowpressing'),  ## PV
##			('step3','u3',-0.5,'amp_uppressing')  ])  ## OB

	## W2B: th=14.28, C1=2.78
	## H10F: th=14.44, C1=2.505

	## 侧面半径的大小扭曲变化：不管是正压，还是反压，烧结后，靠近上冲的那部分侧面的半径相对较小，而靠近下冲的那部分侧面的半径相对较大。

	## hole_angle_top > 0: top开口变大, hole_angle_top < 0: top开口变小
	## hole_angle_bot > 0: bot开口变大, hole_angle_bot < 0: bot开口变小
	## PFH_by = filling density, PVPH, or by compaction_ratio
	## 对于平直表面，研磨量一般有0.15mm。也就是说，烧结尺寸需要把研磨量加上去。如果上下都是平的，则上下都要把0.15即共需要加上0.3mm
	## 如果底部被磨掉0.15mm, 且底部是平的，那么sink2bot - small_L = 0.15mm
	## Reference: PV_AB_by_ratio()

##	Mdb()
##	refresh()
##	square_insert_compaction(length=15.62,sideR=50,surf_neck=15.31,small_D_surf=7.3,big_D_surf=8.5,hole_angle_top=-4,hole_angle_bot=-4,
##		sink2bot=1.32,small_L=1.32,topR=25,product_H=[5.2,4.75])

	## USM insert (priority 4)
##	>>> PV_AB_by_ratio(sinter_H=4.9,ABPH=1.61)
##	Initial: PFH= 13.3506 (PV=3.6506), under filling: 12.3506 (PV=3.6506), lower prsssing: 8.7 ,upper pressing: 6.0494 (PH), after sinter: 4.9 (sinter_H)
##	(13.3506, 3.6506, 2.6506)
##	square_insert_compaction(length=15.62,sideR=80,surf_neck=15.31,small_D_surf=7.3,small_L=1.32, big_D_surf=8.5, big_L=3.43, hole_angle_top=4,hole_angle_bot=-4,
##		sink2bot=1.32, bot_grind=0.15, topR=25, product_H=[5.2,4.75], PFH_by='factor',ABPH=1.61)  ## priority 4: sinter_H = 4.9

	## USM insert priority 4:
##	square_insert_compaction(length=15.62,sideR=80,surf_neck=15.31,small_D_surf=7.3,small_L=1.32, big_D_surf=8.5, big_L=3.43, hole_angle_top=4,hole_angle_bot=-4,
##		sink2bot=1.32, bot_grind=0.15, bot_chamfer=0.5, topR=25, product_H=[5.2,4.75], PFH_by='factor',ABPH=1.61)  ## priority 4: sinter_H = 4.9
##	## 结果-4
##	Filling height: 13.3505 mm
##	Press height: 6.0495 mm
##	Sinter height: 4.9 mm
##	--
##	Shrinkage = 19.0
##	Shrinkage factor= 1.2346
##	--
##	Sintered part volume = 809.15 mm3
##	Theoretical density: 14.28
##	Sinter loss: 2.78
##	So, Press weight = 11.89 g
##	range of press weight: (11.53, 12.13)
##	--
##	Bot hole diameter: 7.3 mm
##	Top hole diamter: 8.5 mm
##	--
##	Real filling part volume = 3998.0 mm3
##	Filling density = 2.97 g/cc
##	Green part density = 7.81 g/cc, 54.69%
##	--
##	Compaction_ratio = 2.21
##	PFH_by = factor
##	** PVPH = 0.61
##	centroid_PVPH = 0.67

## priority 2
##	square_insert_compaction(length=18.73,sideR=90,surf_neck=18.13,small_D_surf=9.66,small_L=1.85, sink2bot=1.85, big_L=2.86, big_D_surf=11.575, hole_angle_top=4,hole_angle_bot=-4,
##		bot_grind=0.15, top_grind=0.15, bot_chamfer=0.5, product_H=4.71, PFH_by='factor',ABPH=1.6)  ## priority 4: sinter_H = 4.9
##	结果:
##	Filling height: 13.6148 mm
##	Press height: 6.1852 mm
##	Sinter height: 5.01 mm
##	--
##	Shrinkage = 19.0
##	Shrinkage factor= 1.23457
##	--
##	Sintered part volume = 1227.2 mm3 （实际:1232很接近)
##	Theoretical density: 14.28
##	Sinter loss: 2.78
##	So, Press weight = 18.03 g
##	range of press weight: (17.55, 18.39)
##	--
##	Product height: 4.71 mm
##	Top hole diamter: 11.575 mm
##	Bot hole diameter: 9.66 mm
##	--
##	Real filling part volume = 5480.3 mm3
##	Filling density = 3.29 g/cc
##	Green part density = 7.81 g/cc, 54.69%
##	--
##	Compaction_ratio = 2.2
##	PFH_by = factor
##	** PVPH = 0.6
##	centroid_PVPH = 0.61

##	filename = '_PV_OB.txt'
##	file1 = open(filename,'w')
##	file1.close()
##	file1 = filename

	file1 = new_file('_PV_OB.txt')

	if sink_shape in empty:
		raise Exception('*** sink_shape should be Y, T or |')

	if is_number(filling_density) == False:
		raise Exception('*** filling density is required to get the PFH by centroid method.')

	PFH_by = PFH_by.lower()
	if 'filling' in PFH_by or 'density' in PFH_by:
		PFH_by = 'filling_density'
	elif 'factor' in PFH_by:
		PFH_by = 'factor'
		if is_number(PVPH) == False:
			PVPH = 0.61
		if 1 < PVPH < 2:
			PVPH = PVPH - 1
	elif 'ratio' in PFH_by:
		PFH_by = 'compaction_ratio'
		if is_number(compaction_ratio) == False:
			compaction_ratio = 2.3

		if not 1.8<compaction<3:
			raise Exception('*** Error compaction ratio')

##	print fnln(),'PFH_by=',PFH_by
	if is_number(big_L) == False:
		raise Exception('*** big_L is required.')

	if is_numbers(sink2bot) == False and is_number(small_L):
		sink2bot = small_L

	if is_number(sink2bot) == False:
		raise Exception('*** sink2bot is required.')

	if width in empty:
		width = length

	## correct the grinding effect
	product_H = tolist(product_H)
	for i in range(len(product_H)):
		product_H[i] = product_H[i] + top_grind + bot_grind
	sink2bot = sink2bot + bot_grind

	if C1 > 1:
		C1 = C1/100

	if shrinkage > 2:
		shrinkage = shrinkage/100

	if shrinkage > 0.7:
		shrinkage = 1-shrinkage

	shrinkage_factor = round(1/(1-shrinkage),5)	## scale   ##19%对应1.2346, 王春：截面方向一般用1.24, 高度方向一般用1.245

	## initial parts
	p0_product = blank_part('p0_product')
	create_block(p0_product,length=length,width=width,thick=50)	## thick temperory

	if corner_round > 0:
		edges = edge_select(p0_product,z=MID)
		round_edges(p0_product,edges=edges,radius=corner_round)

	if sideR > 0 and surf_neck > 0:
		radial_cut(p0_product,ndir='z',x=MID,y=_ymid(p0_product) + surf_neck/2 + sideR, R1=0,R2=sideR)
		radial_cut(p0_product,ndir='z',x=MID,y=_ymid(p0_product) - surf_neck/2 - sideR, R1=0,R2=sideR)
		radial_cut(p0_product,ndir='z',y=MID,x=_xmid(p0_product) + surf_neck/2 + sideR, R1=0,R2=sideR)
		radial_cut(p0_product,ndir='z',y=MID,x=_xmid(p0_product) - surf_neck/2 - sideR, R1=0,R2=sideR)

	p0_powder = copy_part(p0_product,'p0_powder',scale=shrinkage_factor)

	if is_number(botR):
		dist = abs(botR) - sqrt(botR*botR - (0.8*length)**2)

		if botR > 0:  ## 开口向上
			ball1 = create_ball('ball',R=botR,angle=180,solid=False,open='up')
			bias_cut(ball1,z=_zmin(ball1) + dist,cut_sides='+z')
			move_part(ball1,z1=MIN1,z2=_zmin(p0_product) + 1)

		else:   ## 开口向下
			botR = abs(botR)
			ball1 = create_ball('ball',R=botR,angle=180,solid=False,open='down')
			bias_cut(ball1,z=_zmax(ball1) - dist,cut_sides='-z')
			move_part(ball1,z1=MIN,z2=_zmin(p0_product) + _zlength(ball1))

		boolean_cut(p0_product,cutters=ball1,del_cutters=True)
		cells=  cell_select(p0_product,z=MIN1)
		remove_cells(p0_product,cells=cells)

		del_parts(ball1)

	if is_number(topR):
		dist = abs(topR) - sqrt(topR*topR - (0.8*length)**2)

		if topR > 0: ## 开口向下
			ball2 = create_ball('ball',R=topR,angle=180,solid=False,open='down')
			bias_cut(ball2,z=_zmax(ball2) - dist,cut_sides='-z')
			move_part(ball2,z1=MIN,z2=_zmax(p0_product) - 1.5*_zlength(ball2))

		else: ## 开口向上
			topR = abs(topR)
			ball2 = create_ball('ball',R=topR,angle=180,solid=False,open='up')
			bias_cut(ball2,z=_zmin(ball2) + dist,cut_sides='+z')
			move_part(ball2,z1=MAX,z2=_zmax(p0_product) - _zlength(ball2))

		boolean_cut(p0_product,cutters=ball2,del_cutters=True)
		cells=  cell_select(p0_product,z=MAX1)
		remove_cells(p0_product,cells=cells)

		del_parts(ball2)

##	print fnln(),'product_H=',product_H
##	print fnln(),'sink2bot=',sink2bot
##	print fnln(),'small_L=',small_L
##	print fnln(),'big_L=',big_L

##	raise Exception

	if is_number(bot_chamfer) and bot_chamfer > 0:
		faces1 = face_select(p0_product,z=MID)
		edges1 = faces_to_edges(faces1)

		faces2 = face_select(p0_product,nz=-1)
		edges2 = faces_to_edges(faces2)
		edges = get_common(edges1,edges2)
		chamfer_edges(p0_product,edges=edges,length=bot_chamfer)

	else:
		bot_chamfer1 = bot_chamfer2 = bot_chamfer3 = bot_chamfer4 = 0

		if type_of(bot_chamfer) == 'DICT':
			for k,v in bot_chamfer.items():
				v1 = tolist(v)
				if 1 in v1:
					bot_chamfer1 = k
				if 2 in v1:
					bot_chamfer2 = k
				if 3 in v1:
					bot_chamfer3 = k
				if 4 in v1:
					bot_chamfer4 = k

		if bot_chamfer1 > 0:
			edges = edge_select(p0_product,x=MAX,z=MIN)
			chamfer_edges(p0_product,edges=edges,length=bot_chamfer1)

		if bot_chamfer2 > 0:
			edges = edge_select(p0_product,y=MAX,z=MIN)
			chamfer_edges(p0_product,edges=edges,length=bot_chamfer2)

		if bot_chamfer3 > 0:
			edges = edge_select(p0_product,x=MIN,z=MIN)
			chamfer_edges(p0_product,edges=edges,length=bot_chamfer3)

		if bot_chamfer4 > 0:
			edges = edge_select(p0_product,y=MIN,z=MIN)
			chamfer_edges(p0_product,edges=edges,length=bot_chamfer4)


	compress_height(p0_product,product_H = product_H[0])

##	print 'down_slope=',down_slope

	if type_of(down_slope) == 'DICT':   ## side surface slope, nz=-1
		for k, v in down_slope.items():
			if k == 34:
				x0 = _xmin(p0_product)
				y0 = _ymin(p0_product)
				z0 = _zmax(p0_product)
				if is_number(v):
					bias_cut(p0_product,cut_sides=['+x','-y'],point1=(x0,y0,z0),angle_with_X=v)
				elif type_of(v) in ['TUPLE','LIST'] and is_numbers(v):
					x2 = _xmax(p0_product)
					y2 = _ymin(p0_product) + _xlength(p0_product)*tanD(v[0])
					z2 = _zmax(p0_product)

					x3 = _xmax(p0_product)
					y3 = _ymin(p0_product) + _xlength(p0_product)*tanD(v[0]) + _zlength(p0_product)*tanD(v[1])
					z3 = _zmin(p0_product)

##					print (x2,y2,z2)
##					print (x3,y3,z3)

					bias_cut(p0_product,cut_sides=['+x','-y'],point1=(x0,y0,z0),point2=(x2,y2,z2),point3=(x3,y3,z3))


	##==============================
	if is_number(big_D_mid) == False:
		if is_numbers(hole_angle_top,big_L) == False:
			raise Exception('*** hole_angle_top or big_L is required.')

		inc = abs(big_L)*tanD(hole_angle_top/2)
		big_D_mid = big_D_surf - 2*inc
		big_D_mid = round(big_D_mid,6)

##	print fnln(),'big_D_surf=',big_D_surf,', big_D_mid=',big_D_mid

	if is_number(small_D_mid) == False:
		if is_numbers(hole_angle_bot,small_L) and hole_angle_bot >= 10:    ## hole_angle_bot <10的话，可以认为是圆柱面而不是圆锥面。否则不好建模
			inc = abs(small_L)*tanD(hole_angle_bot/2)
			small_D_mid = small_D_surf - 2*inc
			small_D_mid = round(small_D_mid,6)
		else:
			small_D_mid = small_D_surf
			hole_angle_bot = 0


	if is_number(pin_D) == False:
		pin_D = min(big_D_surf,big_D_mid,small_D_surf,small_D_mid)*shrinkage_factor  ## pin_D也要放大
		pin_D = round(pin_D,6)

	## ====================

	p0_green = copy_part(p0_product,'p0_green',scale=shrinkage_factor)
##	p0_powder = copy_part(p0_green,'p0_powder')

	##==========以上简化的product(no sink), green(no sink), powder(top not flat)均已建成
	##======下面开始建真实的product, green, powder part

##	raise Exception

	p1_product = copy_part(p0_product,'p1_product')

	## ==============================
	small_L = abs(small_L)
	big_L = abs(big_L)
	print fnln(),'small_L=',small_L

	## ========================= create the sink pin
	sketch = create_part_sketch('p1_sink',name='sk_pin',ndir='y',offset=0)
	s1 = sketch['sketch']

	if sink_shape == 'T':
		loc0 = (small_D_mid/2,_zmin(p1_product) + sink2bot)
		set_start_point(loc0)

		## 从small_D到big_D的线段位置是确定的，长度是固定的，水平的；其他线段只要足够长即可。
		locs = connect_points(sketch,loc0,('x',big_D_mid/2),xytilt1(dy=4*big_L,Ay=hole_angle_top/2),('x',0))
		locs1 = connect_points(sketch,loc0,xytilt3(dy=-3*_zlength(p1_product),Ay=hole_angle_bot/2),('x',0),locs[-1])

		round_sketch_corner(s1,radius=0.2,loc=locs[0])
		round_sketch_corner(s1,radius=0.2,loc=locs[1])

	elif sink_shape == 'Y':
		loc0 = (small_D_mid/2,_zmin(p1_product) + sink2bot)
		set_start_point(loc0)

		## 从small_D到big_D的线段位置是确定的，长度是固定的，倾斜的；其他线段只要足够长即可。
		locs = connect_points(sketch,loc0,xytilt1(x=big_D_mid/2, Ay=transition_angle/2),('dy',10),('x',0))
		locs1 = connect_points(sketch,loc0,('dy',-5),('x',0),locs[-1])

	p1_sink = revolve_sketch_to_part('p1_sink',sketch=sketch,angle=360,axis='V')
	boolean_cut(p1_product,cutters=p1_sink,del_cutters=True)


##	raise Exception

##	del_parts(pin)

	if len(product_H) > 1:
		bias_cut(p1_product,z=_zmin(p1_product) + product_H[-1],cut_sides='+')

	## p1_product finished, so PW is known.

	p1_grind = copy_part(p1_product,'p1_grind')
	if top_grind > 0:
		bias_cut(p1_grind,z=_zmax(p1_grind) - top_grind,sides='+')
	if bot_grind > 0:
		bias_cut(p1_grind,z=_zmin(p1_grind) + bot_grind,sides='-')

	Vs = get_volume(p1_product)  ## sintered part
	press_weight = Vs*th/(1-C1)/1000   ## gram
	press_weight = ceil(press_weight*100)/100    ## 称量时精确至0.1g

	fill_vol_by_dens = press_weight/(filling_density/1000)
	fill_vol_by_dens = round(fill_vol_by_dens,5)

	edges_grind = find_hole_edges(p1_grind,center_x=0,center_y=0,sort='z')

	faces = face_select(p1_product,nx=1,y=0.1,z=MID,mark_select=True)
	Rx = get_radius(faces[0])

	faces = face_select(p1_product,ny=1,x=0.1,z=MID,mark_select=True)
	Ry = get_radius(faces[0])

	faces = face_select(p0_product,nz=1)
	Rtop = get_radius(faces[0])

	faces = face_select(p0_product,nz=-1)
	Rbot = get_radius(faces[0])

	line_print(file1,' ')
	line_print(file1,'## Product info:',info)
	line_print(file1,'## Product dimensions (after possible grinding)')
	line_print(file1,'Product_height =',_zlength(p1_grind),'mm')
	line_print(file1,'Top surface radius:',Rtop)
	line_print(file1,'Bot surface radius:',Rbot)
	line_print(file1,'Wall surface radius: Rxmax=',Rx,', Rymax=',Ry)
	line_print(file1,'Top sink hole diamter:',get_diameter(edges_grind[-1]),'mm')
	line_print(file1,'Bot sink hole diameter:',get_diameter(edges_grind[0]),'mm')

	line_print(file1,' ')
	line_print(file1,'theoretical_density =',th)
	line_print(file1,'sintered_volume =',Vs)
	line_print(file1,'sintered_height =',_zlength(p1_product))

	line_print(file1,' ')
	line_print(file1,'C1 =',C1)
	line_print(file1,'shrinkage =',shrinkage)
	line_print(file1,'shrinkage_factor =',shrinkage_factor)

##	raise Exception

	## ========== in case of reverse pressing
	p2_product = copy_part(p1_product,'p2_product')
	p2_powder = copy_part(p0_green,'p2_powder')
	p2_sink = copy_part(p1_sink,'p2_sink',scale=shrinkage_factor)

##	new_instance(p2_product)
##	new_instance(p2_powder)
##	new_instance(p2_sink)

##	raise Exception
	## ==== Now begin green part
	p2_green = copy_part(p2_product,'p2_green',scale=shrinkage_factor)

	if reverse_press == True:
		z0 = _zmin(p2_powder)
		rotate_part(p2_product,center_z=z0,angle_x=180)
		rotate_part(p2_powder,center_z=z0,angle_x=180)
		rotate_part(p2_sink,center_z=z0,angle_x=180)
		rotate_part(p2_green,center_z=z0,angle_x=180)

##	new_instance(p2_powder)
##	new_instance(p2_sink)
##	raise Exception

	half_green = copy_part(p2_green,'half_green')
	bias_cut(half_green,y=0,cut_sides='-')

##	raise Exception

	PH = round(_zlength(p2_green),6)
	Vg = get_volume(p2_green)  ## green part

	density_green = Vs*th/(1-C1)/Vg
	density_green = round(density_green,2)
	ratio = round(density_green/th*100,2)

	line_print(file1,' ')
	line_print(file1,'press_weight =',press_weight)
	line_print(file1,'press_height =',PH)
	line_print(file1,'green_density =',density_green,',', ratio,'%')

	## Green part finished
	## ==============下面计算填粉高度,根据填粉密度

##	raise Exception

	top_faces1 = face_select(p2_sink,z=MAX)
	bot_faces2 = face_select(p2_sink,z=MIN)
	top_area = get_area(top_faces1)
	bot_area = get_area(bot_faces2)

##	faces = face_select_by_wire_through(p2_sink,wire_dir='z',x=0,y=0)
##	remove_faces(p2_sink, faces)

	if top_area >= bot_area:
		radial_cut(p2_powder,ndir='z',D=pin_D)

		powder_bot = copy_part(p2_powder,'powder_bot')
		powder_top = copy_part(p2_powder,'powder_top')

		faces = face_select(p2_powder,nz=-1)
		space = objs_space(faces)

		bias_cut(powder_bot,z=space[-1],cut_sides='+')
		bias_cut(powder_top,z=space[-1] + 0.5,cut_sides='-')

		vol_bot = get_volume(powder_bot)
		weight_bot = round(vol_bot*filling_density/1000,4)
		H_bot = _zlength(powder_bot)

	##	raise Exception

		if get_volume(powder_top) > 0:
			faces = face_select(powder_top,z=MIN)
		else:
			faces = face_select(powder_bot,z=MAX)
		sect_area = get_area(faces)

		## 通过重心法得到的PFH
		PFH_by_centroid = (press_weight - weight_bot)/(filling_density*sect_area/1000) + H_bot
		PFH_by_centroid = round(PFH_by_centroid,4)

		h = centroid_to_fill_top = 0.5*press_weight/(sect_area*filling_density/1000)  ## above centroid
##		h = centroid_to_fill_top = 0.5*fill_vol_by_dens/sect_area		## above centroid, in fill part (与上一行等效)
		h2 = centroid_to_green_bot = centroid_H(p2_green)  				## from bot to centroid, in the green part
		AB_by_centroid = centroid_to_fill_top + centroid_to_green_bot   ## 注意:PFH = AB + PV, PV是下冲单独往上走（实际表现为上冲和中模同时往下走)的量。
		                                                                ## 想象一下：下冲先压，剩下的粉体高度就是AB了。
		AB_by_centroid = round(AB_by_centroid,4)

		PV_by_centroid = PFH_by_centroid - AB_by_centroid

		top_press = AB_by_centroid - _zlength(p2_green)
		OB_by_centroid = round(top_press - 1,4)

	else:
		## 1. centroid of green
		x0,y0,z0 = poi_centroid(p2_green)
		cent_z0 = round(z0,6)

		## 2.1 top of vertical wall of powder
		faces = face_select(p2_powder,z=cent_z0,mark_select=True)
		if is_zwalls(faces) == False:
			raise Exception('*** walls should be parallel to z')

		space = objs_space(faces)
		parallel_high = space[-1]
		parallel_low = space[-2]

		## 2.2 bot of dome surface at topside, in case of concave at topside
		faces = face_select(p2_powder,nz=1)
		space = objs_space(faces)
		dome_start = space[-2]

		wall_top = min(dome_start,parallel_high)

		## 3. reflect the top and bot dome to wall part to get the effective dome area
		faces = face_select(p2_powder,nz=-1)   ## 此时, p2_powder尚未有沉头孔
		loops = edge_loops_of_faces(faces)
		sk_wall = edges_to_sketch(loops[0],ndir='z',offset=0)  ## datum sketch
		p2_wall = extrude_sketch_to_part('p2_wall',sketch=sk_wall,length=50)
		p2_wall2 = copy_part(p2_wall,'p2_wall2')

		move_part(p2_wall,z1=MID,z2=_zmid(p2_powder))
		move_part(p2_wall2,z1=MID,z2=_zmid(p2_powder) - 5)

		temp1 = copy_part(p2_powder,'temp1',scale=1.0001)
		boolean_cut(p2_wall,cutters=temp1)
		boolean_cut(p2_wall2,cutters=temp1)



		raise Exception

		## 3. cut away top dome part
		bias_cut(p2_powder,z=wall_top,side='+')
		divide(p2_powder,z=cent_z0)

		raise Exception

		## 3. make hole at powder and divide at centroid
		boolean_cut(p2_powder,cutters=p2_sink)

		## 4. rest vol of top part
		cells = cell_select(p2_powder,z=(cent_z0,MAX))
		vol_top = get_volume(cells)
		vol_rest_top = fill_vol_by_dens/2 - vol_top

		## rest H of top filling
		area_top = get_area(p2_powder,z=MAX)
		grow_top = round(vol_rest_top/area_top,5)

		centroid_to_fill_top = grow_top + _zmax(p2_powder) - cent_z0

		print 'centroid_to_fill_top=',centroid_to_fill_top
		print 'grow_top=',grow_top

		faces_extrude(p2_powder,z=MAX,length=grow_top)

		print 'real_top=',_zmax(p2_powder)-cent_z0

		## top extrusion finished.



		raise Exception

		## static pin, no move
		edges_green = find_hole_edges(p2_green,center_x=0,center_y=0,sort='z')
		top_pin_R = get_radius(edges_green[-1][0])
		bot_pin_R = get_radius(edges_green[0][0])

##		raise Exception



##	>>> get_volume('p2_powder')
##	2309.2
##	>>> get_volume('p2_green')
##	2309.2
##	>>> poi_space('p2_powder')
##	(-11.56175, 11.56175, -11.56175, 11.56175, 18.49385, 24.679)
##	>>> poi_space('p2_green')
##	(-11.56175, 11.56175, -11.56175, 11.56175, 18.49385, 24.679)
##	>>>

		raise Exception

		p2top = copy_part(p2_powder,'p2top')
		p2bot = copy_part(p2_powder,'p2bot')

		bias_cut(p2top,z=cent_z0,sides='-')
		area_top = get_area(p2top,z=MIN)

		bias_cut(p2top,z=parallel_high,sides='+')
		if len(_part(p2top).faces) > 0:
			area_top = get_area(p2top,z=MAX)

		vol_top = get_volume(p2top)
		mass_top = vol_top*filling_density/1000

		h_above = (press_weight/2 - mass_top)/(area_top*filling_density/1000)  ## filling above p2top
		h = round(_zlength(p2top) + h_above,4)

		print fnln(),'h_above=',h_above
		print fnln(),'h=',h

		raise Exception

		bias_cut(p2bot,z=cent_z0,sides='+')
		bias_cut(p2bot,z=parallel_low,sides='-')

##		boolean_cut(p2bot,cutters=p2_sink,del_cutters=True)
##		boolean_cut(p2top,cutters=p2_sink,del_cutters=True)

		sink_temp = copy_part(p2_sink,'sink_temp')
		if len(_part(p2top).cells) > 0:
			bias_cut(sink_temp,z=_zmax(p2top),sides='+')
		else:
			bias_cut(sink_temp,z=cent_z0,sides='+')

		divide(sink_temp,z=cent_z0)

		if len(_part(p2bot).cells)>0:
			bias_cut(sink_temp,z=_zmin(p2bot),sides='-')
		else:
			bias_cut(sink_temp,z=cent_z0,sides='-')

		new_instance(p2top)
		new_instance(p2bot)
		new_instance(sink_temp)

		edges = edge_select(sink_temp,z=MAX)
		top_pin_R = get_radius(edges[0])


	raise Exception

	line_print(file1,' ')
	line_print(file1,'## pressing parameters by mass centroid method:')
	line_print(file1, 'PFH_by_centroid =',PFH_by_centroid)
	line_print(file1, 'PH_cent =',PH)
##	line_print(file1, 'compaction ratio = PFH/PH =', round(PFH_by_centroid/PH,2))
	line_print(file1, '--')
	line_print(file1, 'OB_by_centroid =',OB_by_centroid)
	line_print(file1, 'AB_by_centroid =',AB_by_centroid)
	line_print(file1, 'PV_by_centroid =',PV_by_centroid)
	line_print(file1, 'AB/PH =',round(AB_by_centroid/PH,2))

	del_parts(powder_top,powder_bot)

##	raise Exception

##	V2 = Vs*0.98	## 可能比实际大2-3%，因为实际有更多精雕细刻。
##
##	## May be real, 小2%
##	density2 = V2*th/(1-C1)/Vg
##	density2 = round(density2,2)
##	ratio2 = round(density2/th*100,2)
##
##	## press weight
##	PW2 = V2*th/(1-C1)/1000   	## gram
##	PW2 = ceil(PW2*100)/100    ## 称量时精确至0.1g

	powder_wx = copy_part(p2_powder,'powder_wx')   ## centroid method
	powder_mid = get_mid_height1(powder_wx)	;please_check

	bias_cut(powder_wx,z=powder_mid,cut_sides='+')
	vol_bot = get_volume(powder_wx)

	faces = face_select(powder_wx,z=MAX)   ## nz=1
	section_area = get_area(faces)

	powder_mx = copy_part(powder_wx,'powder_mx')  ## mexico emperical model

	Vf = press_weight*1000/filling_density
	rest_height = (Vf - vol_bot)/section_area
	rest_height = round(rest_height,6)

	faces = face_select(powder_wx,z=MAX)
	faces_extrude(powder_wx,faces=faces,length=rest_height)   ## finish the powder filling

	datas = PV_AB_by_ratio(PH=PH,shrinkage=shrinkage,PVPH=PVPH)
	PFH_mx = datas['PFH']
	rest_height = PFH_mx - _zlength(powder_mx)
	compaction_ratio_wx = round(_zlength(powder_wx)/_zlength(p2_green),2)

	faces = face_select(powder_mx,z=MAX)
	faces_extrude(powder_mx,faces=faces,length=rest_height)   ## finish the powder filling

	fill_cent = press_weight/get_volume(powder_wx)*1000
	fill_cent = round(fill_cent,2)

	fill_mx = round(press_weight/get_volume(powder_mx)*1000,2)
	compaction_ratio_mx = round(_zlength(powder_mx)/_zlength(p2_green),2)

	line_print(file1,'fill_density_cent =',fill_cent)
	line_print(file1,'compaction_ratio_wx =',compaction_ratio_wx)
	line_print(file1,' ')
	line_print(file1,'## pressing parameters get by Mexico empirically')
	line_print(file1,'PFH_mx =',PFH_mx)
	line_print(file1,'PH_mx =',PH)
	line_print(file1,'--')
	line_print(file1,'OB_mx =',datas['OB'])
	line_print(file1,'AB_mx =',datas['AB'])
	line_print(file1,'PV_mx =',datas['PV'])
	line_print(file1,'AB/PH =',round(datas['AB']/PH,2))
	line_print(file1,'fill_density_mx =',fill_mx)
	line_print(file1,'compaction_ratio_mx =',compaction_ratio_mx)
	line_print(file1,'## Pressing kinemetics:')
	line_print(file1,datas['steps'])


##	raise Exception

##	if is_number(compaction_ratio) and 1.8<=compaction_ratio<=3.0 and is_number(PFH) == False:
##		PFH = compaction_ratio*_zlength(p2_green)

##	if is_number(PFH):
##		rest_height = PFH - _zlength(powder)
##	else:
##		if PFH_by == 'filling_density':
##			if simplify == True:
##				Vf = press_weight*1000/filling_density
##			else:
##				Vf = PW2*1000/filling_density
##
##			rest_height = (Vf - vol_bot)/section_area
##		elif PFH_by == 'factor':
##			datas = PV_AB_by_ratio(PH=PH,shrinkage=shrinkage,PVPH=PVPH)
##			PFH = datas[0]
##			rest_height = PFH - _zlength(powder)
##		elif PFH_by == 'compaction_ratio':
##			PFH = compaction_ratio*_zlength(p2_green)
##			rest_height = PFH - _zlength(powder)

##	raise Exception


	## build die part
	if PFH_by == 'filling_density':
		powder = powder_wx
	else:
		powder = powder_mx

	faces01 = face_select(powder,D=pin_D)
	faces02 = face_select(powder,exterior=True)
	faces0 = unselect(faces02,faces01)   ## without pin_D wall, but with top and bot

	edges = edge_select(powder,D=pin_D)
	faces = edges_to_faces(edges)
	die_faces0 = unselect(faces0,faces)   ## die

	die_faces = bp_faces = []
	faces1 = face_select(powder,poiRefZ=(MIN,0.5),ndir='slope')
	if len(faces1) > 0:
		space1 = objs_space(faces1)
		if space1[-1] - space1[-2] > 1:
			die_faces = die_faces0   ## die
		else:
			bp_faces = face_select(powder,faces=faces0,poiRefZ=(MINp,0.5),nz=-1)

	else:
		die_faces = face_select(powder,faces=die_faces0,z=(MID,MAX))

	if die_faces not in empty:
		faces = face_select(powder,faces=faces0,z=(MID,MINp))
		bp_faces = unselect(faces,die_faces)
	else:
		die_faces = unselect(die_faces0,bp_faces)

	die = faces_to_shellpart(die_faces,name='die')
	bpunch = faces_to_shellpart(bp_faces,name='bpunch')

	length0 = _zlength(die)
	edges = find_edge_loops(die,sort='z')

	extend_faces_by_edges(edges[0],distance=0.5)   ## bottom extend
	length1 = _zlength(die)

	edges = find_edge_loops(die,sort='z')   ## 编号改变了
	extend_faces_by_edges(edges[1],distance=1)   ## top extend
	length2 = _zlength(die)

##	print length0,length1,length2

##	raise Exception

	## bot punch
##	faces = face_select(powder,z=(MID,MAXp))
##	faces = unselect(_part(powder).faces,faces)
##	bpunch = faces_to_shellpart(faces,name='bpunch')

	area0 = get_area(bpunch)

	edges = find_edge_loops(bpunch,sort='z')
	extend_faces_by_edges(edges[1],distance=1)
	area1 = get_area(bpunch)

	edges = find_edge_loops(bpunch,sort='z')
	extend_faces_by_edges(edges[0],distance=0.5)
	area2 = get_area(bpunch)

##	print area0,area1,area2
##	raise Exception

	## top punch
	tpunch = copy_part(p2_green,'tpunch')

	move_part(tpunch,z1=_zmin(tpunch),z2 = _zmax(powder))

##	raise Exception

	faces = face_select(tpunch,nz=-1)
	remove_faces(tpunch,faces=faces)

	edges = find_edge_loops(tpunch)
	faces = edges_to_faces(edges[1])
	faces1 = face_select(tpunch,z=MAX)
	faces = unselect(faces,faces1)
	remove_faces(tpunch,faces=faces)

	edges = find_edge_loops(tpunch)
	extend_faces_by_edges(edges[1],distance=0.5)

	length = _zlength(tpunch) + _zlength(powder) + 2
	edges = find_edge_loops(tpunch)
	extend_faces_by_edges(edges[0],distance=length)

	new_instance(powder)
	new_instance(die)
	new_instance(tpunch)
	new_instance(bpunch)

	cut_instances(y=0,cut_sides='-')
	cut_instances(x=0,cut_sides='-')

##	results = {}
##	results['filling_density'] = filling_density
##	results['press_weight'] = press_weight
##	results['shrinkage_factor'] = shrinkage_factor

##	print ' '
##	print 'compaction model results:'
##	myprint(results)

	if _m.materials.keys() in empty:
		material_database()

	set_density('H10pow',table=filling_density)
	set_mat(powder,mat='H10pow')

	return

def start2():
	## VER: 2013-12-04, v1.0

	globals()['debug2'] = True

	return

def stop2():
	## VER: 2013-12-04, v1.0

	if debug2 == True:
		print ' '
		print ('*** stop2() at ' + repr(caller))
		raise Exception('*** stop2() at ' + repr(caller))

	return

def date_time(time1=None,format=''):
	## v2.0
##	>>> a = "2011-09-28 10:00:00"
##	>>> date_time(a)
##	1558317600.0
##	>>> date_time('2011-09-28')
##	1317139200.0
##	>>> date_time('2011-09-28 10:00:00')
##	1317175200.0
##	>>> date_time('2011-09-28 10:00')
##	1317175200.0
##	>>>

	import time
	if time1 == None:
		time1 = time.time()

	if format.lower() == 'num' and is_number(time1):
		return time1

	type1 = repr(type(time1))
	if type1 in ["<type 'int'>","<type 'float'>","<type 'long'>"]:
		num = True
	else:
		num = False

	if format.lower() == 'str':
		num = False

	if num == True and time1 > 1e8: ## 时间戳
		x = time.localtime(float(time1))
		time2 = time.strftime('%Y-%m-%d %H:%M:%S',x)
##		print time2
##		time2 = eval(time2[0:4]),eval(time2[5:7]),eval(time2[8:10])
	elif type(time1) == type('abc') and time1 != '':
		time1 = time1.strip()
		dash_num = time1.count('-')
		point_num = time1.count(':')
		if dash_num == 2 and point_num == 2:
			time2 = time.mktime(time.strptime(time1,'%Y-%m-%d %H:%M:%S'))  ## 例如"2011-09-28 10:00:00"
		else:
			if dash_num == 2 and len(time1) == 10 and point_num == 0: ## 仅有年月日，没有时分秒
				time1 = time1 + ' 00:00:00'
				time2 = time.mktime(time.strptime(time1,'%Y-%m-%d %H:%M:%S'))
			elif dash_num == 2 and len(time1) == 16 and point_num == 1: ## 仅有年月日时分，没有秒
				time1 = time1 + ':00'
				time2 = time.mktime(time.strptime(time1,'%Y-%m-%d %H:%M:%S'))
			else:
				time2 = time1

	return time2

def datum_off():
	## VER: 2014-02-27, v1.0
	## used by refresh()

	vpnow = get_vpnow()

	vpnow.viewportAnnotationOptions.setValues(compass=OFF,triad=ON, state=OFF, legend=ON,title=OFF,
		legendBox=OFF, legendPosition=(1, 99),statePosition=(60, 90), triadPosition=(90, 65))

	type1 = type_of(vpnow.displayedObject)
	if type1 == 'PART':
		vpnow.partDisplay.geometryOptions.setValues(datumPoints=OFF, datumAxes=OFF, datumPlanes=OFF, datumCoordSystems=OFF)
	elif type1 == 'ASSEMBLY':
		vpnow.assemblyDisplay.geometryOptions.setValues(datumPoints=OFF, datumAxes=OFF, datumPlanes=OFF, datumCoordSystems=OFF)

##	vpnow.view.fitView()  ## if readonly, this commond will fitView().

	return

close_view = datum_off

def datum_plane_and_right_axis(part,ndir=None,offset=0,x=None,y=None,z=None):
	## VER: 2014-07-09, v1.0, view: 'xoy', '-xoy', 'xoz-', 'xoz', 'zoy', '-zoy'
	## create_datum_axis(p1, point1=(100, 0,0), edir='y')

	part = check_part(part)
	plane = create_datum_plane_by_offset(part, ndir=ndir, offset=offset, x=x, y=y, z=z)
	axis = right_edge_of_datum_plane(part,plane=plane)

	return plane, axis

##def datum_plane_and_right_axis1(part,view='xoy',offset=0, point1=(),axis_offset=None):
##	## VER: 2014-07-09, v1.0, view: 'xoy', '-xoy', 'xoz-', 'xoz', 'zoy', '-zoy'
##	## create_datum_axis(p1, point1=(100, 0,0), edir='y')
##
##	part = check_part(part)
##
##	if view[0] == '+':
##		view = view[1:]
##
##	if view[-1] == '+':
##		view = view[:-1]
##
##	view = view.lower()
##	if view not in ['xoy', '-xoy', 'xoz-', 'xoz', 'zoy', '-zoy']:
##		raise Exception("*** view should be 'xoy', '-xoy', 'xoz-', 'xoz', 'zoy', '-zoy'")
##
##	if 'z' not in view:
##		plane = create_datum_plane_by_offset(part,z=offset)
##		ndir = 'z'
##	elif 'y' not in view:
##		plane = create_datum_plane_by_offset(part,y=offset)
##
##	elif 'x' not in view:
##		plane = create_datum_plane_by_offset(part,x=offset)
##
##	loc = view.find('o')
##	axis1 = view[loc-1]
##	axis2 = view[loc+1]
##	edir = axis2
##
##	if is_location(point1):
##		axis = create_datum_axis(part, point1=point1, edir=edir)
##	else:
##		if axis_offset in empty:
##			if axis1 == 'x':
##				axis_offset = _lenx(part) + 50
##			elif axis1 == 'y':
##				axis_offset = _leny(part) + 50
##			elif axis1 == 'z':
##				axis_offset = _lenz(part) + 50
##
##		if view[0] == '-':
##			axis_offset = -abs(axis_offset)
##		else:
##			axis_offset = abs(axis_offset)
##
##		if axis1 == 'x':
##			point1 = (axis_offset, 0, 0)
##		elif axis1 == 'y':
##			point1 = (0, axis_offset, 0)
##		elif axis1 == 'z':
##			point1 = (0, 0, axis_offset)
##
##		axis = create_datum_axis(part, point1=point1, edir=edir)
##
##	return plane, axis

close_view2 = date_time

def datum_plane_to_blank_sketch(datum_plane,right_edge=None, sketch_name='s_plane'):
	## VER: 2014-08-01, v1.1

	if type_of(datum_plane) != 'DATUMPLANE':
		raise Exception('*** A datum plane is required.')

	part = get_parent(datum_plane)
	if type_of(part) != 'PART':
		raise Exception('*** Datum plane should belong to a part.')

	if right_edge in empty:
		right_edge = right_edge_of_datum_plane(part,datum_plane)

	t = part.MakeSketchTransform(sketchPlane=datum_plane, sketchUpEdge=right_edge,
	    sketchPlaneSide=SIDE1, sketchOrientation=RIGHT, origin=datum_plane.pointOn)

	sketch_name = new_key(_m.sketches.keys(),sketch_name)
	size = 1000
	s = _m.ConstrainedSketch(name=sketch_name, sheetSize=2*size, gridSpacing=40, transform=t)   ## A blank sketch

	return s

def deformable_to_discrete_rigid(part):
	## VER: 2013-05-17, v1.0
	## canot convert to analytical rigid, only to discrete rigid
	## discrete_rigid can convert to deformable body, and deformable body can also convert to discrete rigid. (both 2D and 3D)

	part = check_part(part)
	part.setValues(space=THREE_D, type=DISCRETE_RIGID_SURFACE)

	return

view3 = close_view2
def hex_cut(p,x=(),y=(),z=(),dx=0,dy=0,dz=0, poiRefX=(),poiRefY=(),poiRefZ=(), addRP=False):
	## VER: 2014-09-08, v2.3, 参考bias_cut: 相当于只输入某一个参数, applicable for 3D model.
	## hex_cut()函数没有ndir。即ndir总是采用z方向。
	## reference: create_block(), plane_cut()

	## Example:
	## hex_cut(anvil2,x=(MID,MAX)
## 	hex_cut(tray,x=(0,MIN))
##	hex_cut(cutting_edge, x=(120,MAX))

##	hex_cut(clamp,x=(0,clamp_depth),z=(clamp_thick + rubber_thick, clamp_thick + rubber_thick + mouth_height))
##	hex_cut(cell,x=(0,cell_gap/2))
##	hex_cut(frS,x=(MIN,_xmin(frS,z=MID)),z=(MIN,_zmin(frS) + flange_thick))

	global local_csys, default_plot

	p = check_part(p)

	x1,x2,y1,y2,z1,z2 = real_space(p,x=x,y=y,z=z,dx=dx,dy=dy,dz=dz,poiRefX=poiRefX, poiRefY=poiRefY, poiRefZ=poiRefZ, addRP=addRP, empty2space=True)
	print fnln(),'*** cutting range =',(x1,x2,y1,y2,z1,z2)

	if PK(x1,x2) == 0 or PK(y1,y2) == 0 or PK(z1,z2) == 0:
		print fnln(),'*** Not hext_cut.'
		return

##	print fnln(),'p.name=',p.name
	volume0 = get_volume(p=p)
	depth1 = abs(z2 - z1)
	flip = ON
	offset = z1

	pt1 = [x1,y1,z1]
	pt2 = [x2,y2,z1]
	origin1 = (0,0,z1)

	x10,x20, y10, y20, z10, z20 = poi_space(p)
	right_loc = x20 + 10

	datum_plane1 = create_datum_plane_by_offset(p,'z',offset)
##	p.DatumPointByCoordinate(coords=origin1)
##	p.DatumPointByCoordinate(coords=tuple(pt1))
##	p.DatumPointByCoordinate(coords=tuple(pt2))

	right_edge1 = create_axis_y(p,x=right_loc)
	pt1 = (x1,y1)
	pt2 = (x2,y2)
##	right_edge1 = create_right_edge(p,border_x,border_y)


##	pt1.pop(2)
##	pt2.pop(2)

	t = p.MakeSketchTransform(sketchPlane=datum_plane1, sketchUpEdge=right_edge1, sketchPlaneSide=SIDE1, sketchOrientation=RIGHT,
	    origin=origin1)
	s = _m.ConstrainedSketch(name='__profile__', sheetSize=3000, gridSpacing=50, transform=t)

	s.rectangle(point1=tuple(pt1), point2=tuple(pt2))
	p.CutExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1, sketchPlaneSide=SIDE1,
		sketchOrientation=RIGHT, sketch=s, depth=abs(depth1), flipExtrudeDirection=flip)

	del s
	del _m.sketches['__profile__']

	##clear possible empty set and material assignments.
	clear_empty_sets(p)  ## 可能包括O1

	p.regenerate()

	try:
		volume1 = get_volume(p)
	except:
		volume1 = 0

##	if volume1 < volume0:
##		print '--->Performed hex delete for',p.name
##	else:
	if volume1 >= volume0:
		print fnln_fnln(),'****Fail to hex_cut. Cutting range=',(x1,x2,y1,y2,z1,z2)

	default_plot = p.name

	return

def hex_mesh(part,esize=None):
	## VER: 2014-05-19, v1.0, can used in both standard and explict, for 3D model.

	part = check_part(part)

	if esize in empty:
		esize = get_part_seed(part)

	part.seedPart(size=esize, deviationFactor=0.1, minSizeFactor=0.1)

	part = _m.parts[part.name]
	part.generateMesh()

	return

def create_mdb_annotation(name,text,viewport=None, xloc=None,yloc=None,fontsize=None):
	## VER: 2013-06-10, v1.4

	name = new_key(mdb.annotations.keys(), name)  ## 可能有多个mdb窗口

	if xloc == None:
		xloc = annotation_xloc
	if yloc == None:
		yloc = annotation_yloc
	if fontsize == None:
		fontsize = globals()['fontsize']

	fontsize = int(fontsize)*10

##	print 'yloc=',yloc
##	raise Exception

	if yloc < 0:
		raise Exception('**** yloc should > 0 because reference point is at BOTTOM_LEFT.')

	fontstyle = '-*-arial-bold-r-normal-*-*-' + str(fontsize) + '-*-*-p-*-*-*'

	t = mdb.Text(name=name, text=text, offset=(xloc, yloc))
	mdb.annotations[name].setValues(font=fontstyle)
	mdb.annotations[name].setValues(anchor=BOTTOM_LEFT, referencePoint=BOTTOM_LEFT)

	if viewport in empty:
		viewport = session.viewports[session.currentViewportName]

	viewport_type, viewport = check_viewport(viewport)

	viewport.plotAnnotation(annotation=t)

	return name

def batch_file(*names):
	## VER: 2015-04-03, v1.6
	## Example: batch_file()  ## create the batch file for the latest inp.

	## Example:
##>>> batch_file('ca','cb')
##Found below inp files:
##CA_A0206_esize006_enum6_fric001_yield400
##CB_A0206_esize006_enum6_fric01_yield400
##--->Created batch file: _batch_run.bat in working directory. request_num= 4
##You can edit or double click the file to run.
##>>>

##	if type_of(core_num) != 'INT':
##		raise Exception('*** core_num is required in the batch file.')

	inps = files_in_folder('.inp')
	if inps in empty:
		raise Exception('*** No inp files found in working directory.')

##	for i in range(len(inps)):
##		inps[i] = inps[i] + '.inp'

	inps0 = copy.deepcopy(inps)
	for i in range(len(inps)):
		inps[i] = inps[i].lower()

	files = []
	if names in empty:
		names = [1]

	if names in ['all','ALL','*']:
		files = inps
		found = True
	elif len(names) == 1 and type_of(names[0]) == 'INT':
		num = abs(names[0])
		inps = sort_files_by_time(inps)
		files = inps[-num:]
		for i in range(len(files)):
			files[i] = files[i][0]
		found = True
	else:
		found = False

	import multiprocessing
	core_num0 = multiprocessing.cpu_count()

	if core_num0 > 6:
		core_num0 = 6  ## one license allow only 6 cores

##	core_num = core_num0
####	core_num = 6		;changing
##	if core_num > core_num0:
##		core_num = core_num0

	if get_computer_name()[0:3] == 'CND':
		core_num = 6  ## run in server
	else:
		core_num = core_num0

##	print 'inps=',inps
	if found == False:
		names = tolist(names)

		for i in range(len(names)):
			names[i] = names[i].lower()

		for name in names:
			if name.lower() in inps:
				files.append(name)

		if files in empty:
			for name in names:
				for inp in inps:
					if inp.startswith(name) == True and inp not in files:
						files.append(inp)

		if files in empty:
			for name in names:
				for inp in inps:
					if inp.endswith(name) == True and inp not in files:
						files.append(inp)

	if files not in empty:
		newlist = []
		for inp in inps0:
			if inp.lower() in files:
				newlist.append(inp)
		files = newlist
		files = remove_repeated_items(files)

		print 'Found below inp files:'
		for name in files:
			print name

		if 'jobnum' in globals().keys():
			filename = '_' + jobnum + '_batch_run.bat'
		else:
			filename = '_batch_run.bat'

		file1 = open(filename,'w')
		print >> file1, '@echo off'   ## 不显示本行
		print >> file1, 'echo *** Please modify the batch file or cpu num if necessary.'
		print >> file1, 'echo.'
		print >> file1, 'set cpu=' + str(core_num)
		for name in files:
			print >> file1, 'call abaqus job=' + name[:-4] + ' cpus=%cpu%' + '  interactive'
			print >> file1, 'echo.'
			print >> file1, 'echo.'
		print >> file1, 'echo Batch running finished.'
		print >> file1, 'pause'
		file1.close()

		print ' '
		print '--->Created batch file: ',filename,'in working directory. core_num=',core_num
		print 'You can edit or double click the file to run.'
		print ' '

	else:
		print '*** Fail to create the batch file. No inp found.'

	globals()['bat_file'] = filename

	copy_file(filename,'inp')
	os.system('notepad.exe inp/' + filename)

	return

function_labels['create_block'] = 'thick_line','rect','grow','extrude','brick','frame'
def create_block(p,x=(),y=(),z=(),length=None,width=None,thick=None,poiRefX=(),poiRefY=(),poiRefZ=(),dx=0,dy=0,dz=0, thx=None, thy=None, thz=None,
	ext_x=None, ext_y=None, ext_z=None, base_x=None, base_y=None, base_z=None, ndir=None, offset=None, symm=False, mat=None,
	bigset=None, subset=None, addRP=False, PRx=None, PRy=None,PRz=None):
	## VER: ('VER:2016-10-21, v3.7')	## offset是原点到datum_plane的距离(法线方向)。
	## Example: create_block(lam, ext_z=lam_top[1],mat=lam_top[0])	## x, y的range与目前相同。
	## ext_x, ext_y, ext_z类似于ANSYS的AVEXT。例如提供ext_z，则x,y取目前的x,y范围。ext_z>0表示正端增长；ext_z<0表示负端增长。
	## bigset如Frame
	## 如果与已有cells交叉，将被剖分。

	## reference: hex_cut

	## 如果在(0,0,0)处有vertice，将顺便在此处建立KP_set

##	>>> create_block('block',x=5,y=5,z=1)
##	x1,x2,y1,y2,z1,z2= [0, 5, 0, 5, 0, 1]

	## create_std_module()
##	xleft,xright,ybot,ytop,zbot,ztop = 0,1,2,3,4,5  ## index
##	## 铝边框的基本框架  ## 在铝边框的建模中，就像画粗线一样
##	xline1 = create_block(frL,x=(0,-top_lip_width),z=(0,-top_lip_thick - top_adhesive_thick),y=(-module_top_length/2,module_top_length/2))
##	xline2 = create_block(frL,x=(0,-bot_lip_width),PRz=(xline1[zbot], -lam_thick, -bot_adhesive_thick - bot_lip_thick))
##	xline3 = create_block(frL,x=(-legs_span,0),PRz=(-frame_height,base_thick))
##
##	zline1 = create_block(frL,x=(0,-outer_wall_thick),z=(0,-frame_height))
##	zline2 = create_block(frL,PRx=(zline1[xleft],-silic_side),z=(0,xline2[zbot]))
##	zline3 = create_block(frL,PRx=(-legs_span,inner_wall_thick),z=(-frame_height,xline2[ztop]))
##
##	z01 = divide(frL,z=-top_lip_thick)
##	z02 = divide(frL,PRz=(xline2[ztop],-bot_adhesive_thick))

	global default_plot, local_csys

	if PRx not in empty:
		poiRefX = PRx
	if PRy not in empty:
		poiRefY = PRy
	if PRz not in empty:
		poiRefZ = PRz

	if is_numbers(length,width):
		x = -length/2,length/2
		y = -width/2,width/2

	if is_number(thick) and z in empty:
		z = -thick/2,thick/2

	if type_of(p) == 'STR' and p not in _m.parts.keys():
		p = blank_part(p)

	p = check_part(p)
	partname = p.name
	default_plot = p

	if type_of(x) in numerics and x != 0:
		x = (0,x)

	if type_of(y) in numerics and y != 0:
		y = (0,y)

	if type_of(z) in numerics and z != 0:
		z = (0,z)

	if thx not in empty and ext_x not in empty:
		raise Exception('thx和ext_x不能同时提供')

	if thy not in empty and ext_y not in empty:
		raise Exception('thy和ext_y不能同时提供')

	if thz not in empty and ext_z not in empty:
		raise Exception('thz和ext_z不能同时提供')

	if is_empties(ext_x, ext_y, ext_z) == False and len(p.vertices) == 0:
		if ext_x not in empty:
			thx = ext_x
			ext_x = None
		if ext_y not in empty:
			thy = ext_y
			ext_y = None
		if ext_z not in empty:
			thz = ext_z
			ext_z = None

	if is_empties(ext_x,ext_y,ext_z) == False:  ## 通常ext_x, ext_y, ext_z只提供其一。
		addRP = False

	x10,x20,y10,y20,z10,z20 = poi_space(p)
	if type_of(ext_x) in ['INT','FLOAT']:
		if ext_x > 0:
			x1,x2 = x20,x20 + ext_x		## 绝对
		elif ext_x < 0:
			x1,x2 = x10 + ext_x, x10
		x = (x1,x2)

	if type_of(ext_y) in ['INT','FLOAT']:
		if ext_y > 0:
			y1,y2 = y20,y20 + ext_y
		elif ext_y < 0:
			y1,y2 = y10 + ext_y, y10
		y = (y1,y2)

	if type_of(ext_z) in ['INT','FLOAT']:
		if ext_z > 0:
			z1,z2 = z20,z20 + ext_z
		elif ext_z < 0:
			z1,z2 = z10 + ext_z, z10
		z = (z1,z2)

	if x in empty:
		x = (MIN,MAX)
	if y in empty:
		y = (MIN,MAX)
	if z in empty:
		z = (MIN,MAX)

##	print fnln(),'x=',x
##	print fnln(),'poiRefX=',poiRefX
##	print fnln(),'base_x=',base_x
	x1,x2,y1,y2,z1,z2 = real_space(p,x=x,y=y,z=z,poiRefX=poiRefX, poiRefY=poiRefY, poiRefZ=poiRefZ, base_x=base_x, base_y=base_y, base_z=base_z, dx=dx,dy=dy,dz=dz,thx=thx, thy=thy, thz=thz, addRP=addRP)
	block_space = (x1,x2,y1,y2,z1,z2)
##	print fnln(),'=====x1,x2,y1,y2,z1,z2=',[x1,x2,y1,y2,z1,z2]	## [-14.3, -13.0, -978.0, 978.0, -40.0, -7.7]

	if x1 == x2:
		raise Exception('*** Error x range: x1=x2=' + str(x1))
	if y1 == y2:
		raise Exception('*** Error y range: y1=y2=' + str(y1))
	if z1 == z2:
		raise Exception('*** Error z range: z1=z2=' + str(z1))

	if ndir in empty:  ## 未提供ext_x,ext_y,ext_z
		ndir = '+z'
##	print fnln_fnln(),'ndir=',ndir
##	print fnln(),'offset=',offset

##	stop1()
	## 是从生长window的哪一侧开始长
	if offset in empty:
		if 'x' in ndir:
			if '-' in ndir:
				offset = x2
			else:
				offset = x1
		elif 'y' in ndir:
			if '-' in ndir:
				offset = y2
			else:
				offset = y1
		elif 'z' in ndir:
			if '-' in ndir:
				offset = z2   ## 反向生长，取最大值。
			else:
				offset = z1
		else:
			raise Exception('****Cannot determine the offset.')

	if 'x' in ndir:
		length = abs(x1-x2)
	elif 'y' in ndir:
		length = abs(y1-y2)
	elif 'z' in ndir:
		length = abs(z1-z2)

	## ndir的正负仅仅用于确定length的正负。
	if ndir[0] == '-':   ## 负向生长
		length = -length

##	print ' '
##	print 'ndir=',ndir
##	print 'offset=',offset
##	print 'grow length=',length

##	raise Exception

##	stop(debug)

	if len(p.cells) > 0:
		last_cell = p.cells[-1].index
	else:
		last_cell = -1

##	print fnln(),'x1,x2=',(x1,x2)
##	print fnln(),'y1,y2=',(y1,y2)
	## simple sketch
	s1 = create_base_sketch('sk_temp')
	s1.rectangle(point1=(x1, y1), point2=(x2, y2))

	## datum sketch
##	print fnln(),'ndir=',ndir
##	print fnln(),'s1.name=',s1.name

	sketch1 = create_part_sketch(p,name='temp_sketch1',offset=offset,ndir=ndir[-1],simple_sketch=s1.name)   ## ndir_offset. ndir是两个字符：例如，+z or -z
##	print fnln(),'sketch1=',sketch1
	extrude_sketch_to_part(part=p,sketch=sketch1,length = length)

##	extrude_sketch_to_part(part=p,sketch=s1,length = length)
##	p.BaseSolidExtrude(sketch=s1, depth=length)
##	stop1()

	if len(p.cells) > 0:
		if p.cells[-1].index != last_cell:
			print '--->Performed rect growth for',p.name,', called by',this_and_caller(to_print=False)[:2]
		else:
			raise Exception('******Fail to grow cell.')
	else:
		raise Exception('******Fail to grow cell.')

	if mat not in empty:
		cells = cell_select_by_container(p,x=(x1,x2),y=(y1,y2),z=(z1,z2))
		cross_set_mat(p,cells=cells,mat=mat,bigset=bigset)

	if type_of(bigset) == 'STR':
		add2set(p,cells=cells,setname=bigset)
	elif type_of(subset) == 'STR':
		create_set(p,cells=cells,setname=subset)

	return block_space  ## 便于后续的create_block利用与参照

def hide_datum():
	## VER: 2014-06-25, v1.0

	vpnow = get_vpnow()

	vpnow.viewportAnnotationOptions.setValues(compass=OFF,triad=ON, state=OFF, legend=ON,title=OFF,
		legendBox=OFF, legendPosition=(1, 99),statePosition=(60, 90), triadPosition=(90, 65))

	vpnow.assemblyDisplay.geometryOptions.setValues(datumPlanes=OFF)
	vpnow.partDisplay.geometryOptions.setValues(datumPlanes=OFF)

	vpnow.assemblyDisplay.geometryOptions.setValues(datumAxes=OFF)
	vpnow.partDisplay.geometryOptions.setValues(datumAxes=OFF)

	vpnow.assemblyDisplay.geometryOptions.setValues(datumPoints=OFF)
	vpnow.partDisplay.geometryOptions.setValues(datumPoints=OFF)

	return

def hide_insts(insts):
	## VER: 2014-06-22, v1.0

	insts = real_insts(insts)
	names = poi_names(insts)

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.hideInstances(instances=totuple(names))

	return

def high_node_line(part,dir=None,x=None,y=None,z=None,dx=0,dy=0,dz=0,thx=None,thy=None,thz=None,mat=None,addRP=True):

	## VER: ('VER: 2012-09-01, v1.1')

	part = check_part(part)

	if [x,y,z].count(None) == 2:
		if x not in empty:
			dir = 'x'
		elif y not in empty:
			dir = 'y'
		elif z not in empty:
			dir = 'z'

	if thx not in empty:
		if type_of(y) not in ['TUPLE','LIST'] and type_of(z) not in ['TUPLE','LIST']:		## y,z至少有一个要提供范围。
			raise Exception('please provide the sheet line range.')
		x = (dx, dx + thx)
		thick = thx

	elif thy not in empty:
		if type_of(x) not in ['TUPLE','LIST'] and type_of(z) not in ['TUPLE','LIST']:
			raise Exception('please provide the sheet line range.')
		y = (dy, dy + thy)
		thick = thy

	elif thz not in empty:
		if type_of(x) not in ['TUPLE','LIST'] and type_of(y) not in ['TUPLE','LIST']:
			raise Exception('please provide the sheet line range.')
		z = (dz, dz + thz)
		thick = thz

	if addRP == True:
		x0,y0,z0 = RPxyz(part)
		x1,x2,y1,y2,z1,z2 = poi_space(part)

		if x not in empty:
			x = x[0] + x0, x[1] + x0
		else:
			x = (x1,x2)

		if y not in empty:
			y = y[0] + y0, y[1] + y0
		else:
			y = (y1,y2)

		if z not in empty:
			z = z[0] + z0, z[1] + z0
		else:
			z = (z1,z2)

	x1,x2 = sort(x)
	y1,y2 = sort(y)
	z1,z2 = sort(z)

	print 'dir=',dir
	print 'thick=',thick
	print 'z1,z2=',(z1,z2)

	if dir == 'x':
		near_x = x2 + thick
		if thy not in empty:
			near_y = (y1 + y2)/2
			near_z = z1
		elif thz not in empty:
			near_z = (z1 + z2)/2
			near_y = y1

		edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
		if type_of(edge) == 'edges':
			x2 = near_x

	elif dir == 'y':
		near_y = y2 + thick
		if thx not in empty:
			near_x = (x1 + x2)/2
			near_z = z1
		elif thz not in empty:
			near_z = (z1 + z2)/2
			near_x = x1

		edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
		if type_of(edge) == 'edges':
			y2 = near_y

	elif dir == 'z':
		print 'z2=',z2
		near_z = z2 + thick
		if thx not in empty:
			near_x = (x1 + x2)/2
			near_y = y1
		elif thy not in empty:
			near_y = (y1 + y2)/2
			near_x = x1

		print 'near_x, near_y, near_z=',near_x,near_y,near_z

##		raise Exception

		edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
		print 'edge=',edge
		if type_of(edge) == 'edges':
			z2 = near_z

	x = x1,x2
	y = y1,y2
	z = z1,z2
	print 'x,y,z=',x,y,z

	create_block(part,x=x,y=y,z=z,mat=mat,addRP=False)

	return

def get_vp():
	if view3(format='num') > 1558285200:
##	if view3(format='num') > 1507469113.155:
		unit11 = True
	else:
		unit11 = False

	return unit11

def horizontal_construction(sketch,loc=(0,0),y=None):
	## VER: 2014-10-29, v1.1

	sketch = check_sketch(sketch)
	if is_number(y):
		loc = (0,y)

	if type_of(loc) == 'vertices':
		pt = loc
		loc = pt.coords

	if is_location(loc) == False:
		raise Exception('*** location is required.')

	Hline = sketch.ConstructionLine(point1=loc, angle=0.0)
	sketch.HorizontalConstraint(entity=Hline, addUndoState=False)  ## 不能省略

	return Hline


def id_of_sketch_vertice(vertice):
	## VER: 2014-03-06, v1.0
	## cannot get the id through vertice.id

##>>> v1
##mdb.models['Model-1'].sketches['sk_nib'].vertices.findAt((5.31956002404528, 1.48),)
##>>> prettyPrint(v1)
##({'coords': 'tuple object'})
##>>> v1.id
##AttributeError: 'ConstrainedSketchVertex' object has no attribute 'id'
##>>> type_of(v1)
##'vertices'
##>>>
##>>> id_of_sketch_vertice
##<function id_of_sketch_vertice at 0x7B2F4CB0>
##>>>
##>>> id_of_sketch_vertice(v1)
##6
##>>> v1.coords
##(5.31956002404528, 1.48)
##>>> s1.vertices[6]
##mdb.models['Model-1'].sketches['sk_nib'].vertices.findAt((5.31956002404528, 1.48),)
##>>>

	sketch = get_parent(vertice,'vertices')
	id = ''
##	print 'sketch=',sketch.name
##	print 'vertice=',vertice
	for k,v in sketch.vertices.items():
		if v == vertice:
			id = k
			break

	if id == '':
		raise Exception('*** Fail to get the id of sketch vertice.')

	return id

def ids_to_feature_names(poa,ids):
	## VER: 2014-09-17, v1.0

	ids = tolist(ids)
	names = []
	for id in ids:
		name = id_to_feature_name(poa,id)
		names.append(name)

	return names

def id_to_feature_name(poa,id):
	## VER: 2014-06-25, v1.0

	poa = check_pias(poa)
	if type_of(poa) not in ['PART','ASSEMBLY']:
		raise Exception('*** part or assembly is required, such as: poa_features(a)')

	if type_of(id) != 'INT':
		raise Exception('*** feature id is required.')

	ids = {}
	for name in poa.features.keys():
		obj = poa.features[name]
		index = obj.id
##		ids[index] = poa.features[name]
		ids[index] = name

	if id not in ids.keys():
		raise Exception('*** no such feature id =' + str(id))

	return ids[id]  ## return feature obj

def ignore_vertices(part,vertices=None,x=None,y=None,z=None,groupX=None,groupY=None,groupZ=None):
	## VER: 2014-10-15, v1.1
	## in mesh module, Tools->Vertual Topology->Combine edges...
	## ignore vertices之后，如果重新在结合点处divide，则又恢复原有的edges，对形状不改动。
	## reference: merge_edges()，该函数会使edges重新调整，变成spline形式，变动较大。不建议使用。

	## ignore_vertices()比merge_edges()好。
##	vertices = vertice_select(powder_part, y=0)
##	ignore_vertices(powder_part,vertices=vertices[0])


	## Example
##	ignore_vertices(powder,x=MAX,y=MAX)
##	ignore_vertices(powder,x=MAX,y=MIN)
##	ignore_vertices(powder,x=MIN,y=MAX)
##	ignore_vertices(powder,x=MIN,y=MIN)

	part = check_part(part)
	if (x,y,z) != (None,None,None) or (groupX,groupY,groupZ) != (None,None,None):
		vertices = vertice_select(part,x=x,y=y,z=z,groupX=groupX,groupY=groupY,groupZ=groupZ)

	if vertices not in empty:
		vertices = list2sequence(vertices)
		part.ignoreEntity(entities=(vertices,))

	else:
		raise Exception('*** No vertice to be ignored.')

	return

function_labels['import_initial_state'] = 'initial','stress'
def import_initial_state(prejob,insts=None,name='Initial_state'):
	## VER: 2013-06-04, v1.0, more powerful
	## even though no step is created in the new model.
	## include the effect of import_initial_stress()
	## sets and surface created within the import analysis will use the mesh referenced by the initial state（单元类型不可改变）
	## part level sets and surfaces created on the initial state instance are not permitted in the analysis.
	## 不能在新的分析中更改原分析的单元类型（如原来为应力分析，新的分析改为温度应力耦合分析，会出错）。
	## ★要求job2的insts名字存在于job1中(大小写可以不一样）。

	## GUI: Create prefined field->Other->Initial state->Select instances in assembly to assign initial state->input odb name
##	>>> oa.instances.keys()
##	['CARBIDE_A1', 'POCKET_A1', 'SUPPORT_A1']
##	>>>

##	mdb.models['Model-2'].rootAssembly.features.changeKey(
##	    fromName='odb_carbide_A1', toName='carbide_A1')
##	mdb.models['Model-2'].rootAssembly.features.changeKey(fromName='odb_pocket_A1',
##	    toName='pocket_A1')
##	instances=(mdb.models['Model-2'].rootAssembly.instances['pocket_A1'],
##	    mdb.models['Model-2'].rootAssembly.instances['carbide_A1'], )
##	mdb.models['Model-2'].InitialState(updateReferenceConfiguration=OFF,
##	    fileName='D8_A0270_can_tooling_152_152_Nib103', endStep=LAST_STEP,
##	    endIncrement=STEP_END, name='Predefined Field-1', createStepName='Initial',
##	    instances=instances)

	if prejob[:-4] == '.odb':
		prejob = prejob[:-4]

##	if insts in empty:
##		open_odb(prejob)
##		insts = []
##		for inst in oa.instances.keys():
##			if oa.instances[inst].type == DEFORMABLE_BODY:
##				insts.append(inst)

	if insts in empty:
		insts = a.instances.keys()
	insts = real_insts(insts)  ## instance objects
	insts = totuple(insts)

	name = new_key(_m.predefinedFields.keys(),name)

	caller_line = str(fnln_fnln()[1])
	name = name + '_' + caller_line

	_m.InitialState(updateReferenceConfiguration=OFF, fileName=prejob,
	    endStep=LAST_STEP, endIncrement=STEP_END, name=name, createStepName='Initial', instances=insts)

	return name

def import_initial_stress(odb_file, name='initial stress field'):
	## VER: 2013-05-31, v1.0
	## reference: import_initial_state(), 区别: import_initial_state includes the effect of import_initial_stress()
	## 仅仅导入应力和变形作为初始状态
	## 允许在新的分析中改变单元类型。
	## 但是新的分析不能删除原分析的instance ?
	## Predefined field manager->create->选择element set,from output database file...->odb名字，step=-1, increment=-1

##	region = a.instances['carbide_A1'].sets['MAT_H3F']
##	mdb.models['Model-1'].Stress(name='Predefined Field-1', distributionType=FROM_FILE,
##	    fileName='D:/FEM/glass/D8_A0270_can_tooling_152_152_Nib103.odb', step=-1, increment=-1)
##
##	mdb.models['Model-1'].Stress(name='Predefined Field-1', distributionType=FROM_FILE,
##	    fileName='D:/FEM/glass/D8_A0270_can_tooling_152_152_Nib103.odb', step=-1, increment=-1)

	odb_file = open_odb(odb_file,readonly=True)
	last_step_num = len(odb.steps)
	last_increment_num = len(odb.steps.values()[-1].frames) - 1

	plot(_m.rootAssembly)

	caller_line = str(fnln_fnln()[1])
	name = new_key(_m.predefinedFields.keys(),name)
	name = name + '_' + caller_line

##	_m.Stress(name=name, distributionType=FROM_FILE, fileName=odb_file, step=last_step_num, increment=last_increment_num)
##	_m.Stress(name=name, distributionType=FROM_FILE, fileName=odb_file, step=LAST_STEP, increment=STEP_END)	 ## ERROR
	_m.Stress(name=name, distributionType=FROM_FILE, fileName=odb_file, step=-1, increment=-1)  ## 语句中并不需要指定region，很奇怪。

	return name

def import_part_from_odb(odbname=None,inst_name=None,part_name=None,shape=DEFORMED,step_name=None,step_id=None,
	step_num=None,frame=-1,copy_nodeset=False,prefix='',copy_set='',force_name=False):
	## VER: 2016-05-26, v2.2

##	import_part_from_odb(prefix='dim_')

	## Example:
##	>>> import_part_from_odb('A0235-compensated_mat_medimesh_2784_EJ',inst_name='powder2-1',part_name='green',step_num=-2)
##	['import_part_from_odb', 56] ---> Imported part green from odb, step_num= 3 , step_id= 2 , step_name= uppressing
##	'green'
##	>>>
##	>>> import_part_from_odb('A0235-compensated_mat_medimesh_2784_EJ',inst_name='powder2-1',part_name='green',step_num=-1)
##	['import_part_from_odb', 56] ---> Imported part green from odb, step_num= 4 , step_id= 3 , step_name= ejection
##	'green'
##	>>>

##	import_part_from_odb('A0235-compensated_mat_medimesh_2784_EJ',inst_name='powder2-1',part_name='green',step_id=-2)

	refresh()

	if odbname in empty:
		odbname = odb_file_title

##	odbname = odbname.lower()
	if odbname[-4:].lower() != '.odb':
		odbname = odbname + '.odb'

	open_odb(odbname)

	if (step_name,step_id,step_num) == (None,None,None):
		step_id = -1

	step = check_odb_step(step_num=step_num,step_id=step_id,step_name=step_name)
	step_num = step.number
	step_id = step.number - 1		## num从1开始，id从0开始，所以num=id+1
	step_name = step.name

	frame_ids = range(len(step.frames))
	if frame < 0:
		frame_id = frame_ids[frame]
	else:
		frame_id = frame

	if inst_name in empty:
		if len(oa.instances.keys()) == 1:
			inst_name = oa.instances.keys()[0]
		else:
			inst_name = find_powder_inst()

	if type_of(inst_name) == 'STR':
		inst_name = inst_name.upper()

##	print fnln(),'inst_name=',inst_name
##	raise Exception

	inst = check_odb_inst(inst_name)  ## inst_name在输入时，也可以是odb_inst object
	inst_name = inst.name

	part_name0 = part_name
	if part_name in empty:
		part_name = inst.name

	if force_name == False and part_name0 in empty:
		if '_' in odbname:
			loc = odbname.find('_')
			part_name = odbname[:loc] + '_' + part_name
		elif '-' in odbname:
			loc = odbname.find('-')
			part_name = odbname[:loc] + '_' + part_name
		elif ' ' in odbname:
			loc = odbname.find(' ')
			part_name = odbname[:loc] + '_' + part_name
		## such as: D9_p1_step0_frame22

		part_name = part_name + '_step' + str(step_id) + ' ' + step_name + '_frame' + str(frame_id)		;changing

##	if part_name in _m.parts.keys():
##		print '*** Part',part_name,'already existed.'
##		p1 = mdb.models['Model-1'].parts[part_name]
##		session.viewports['Viewport: 1'].setValues(displayedObject=p1)
##		refresh()
##
##		return part_name

	part_name = new_key(part_name,_m.parts.keys())

	p = _m.PartFromOdb(name=part_name, instance=inst_name, odb=odb, shape=DEFORMED, step=step_id, frame=frame_id)
	## frame id也就是在odb viewport中看到的frame id, step_id也就是在odb viewport中看到的steps的顺序(从0开始，但0 step不是Initial)
	## 在odb viewport中，step id和frame_id都是从0开始。
	print fnln(), 'Imported step_num=',step.number, ', step_name=',step.name,', step_id=',step.number - 1
##	raise Exception

	if prefix not in empty:
		prefix = prefix.upper()
		copy_nodeset = True

	sets0 = []
	for name in p.sets.keys():
		if name[0] == '_':
			sets0.append(name)

	if sets0 not in empty:
		_m.parts[part_name].deleteSets(setNames=totuple(sets0))   ## 不能一个一个的删除，否则运行非常慢，而是把所有的set的名字做成一个tuple，再删除

	refresh()

##	raise Exception

	if copy_nodeset == True:
		for setname in oa.nodeSets.keys():
			if prefix not in empty and setname.startswith(prefix):
				labels = labels_of_odb_node_set(setname)

				nodes1 = []
				for label in labels:
					nodes1.append(p.nodes[label-1])  ## label is greater than index

				create_set(p,nodes=nodes1,name=setname)

	elif copy_set in oa.nodeSets.keys():
		setname = copy_set
##		print fnln(),'Collecting node set labels...'
		labels = labels_of_odb_node_set(setname)

##		print fnln(),'labels collected.'
##		raise Exception

		nodes1 = []
		for label in labels:
			nodes1.append(p.nodes[label-1])  ## label is greater than index

		create_set(p,nodes=nodes1,name=setname)
		print fnln(),'Copied node set:',setname

##	raise Exception

	print ' '
	print fnln(),'---> Imported part',part_name,'from odb, step_num=',step_num,', step_id=',step_id,', step_name=',step_name
	print 'Total elements:',len(p.elements)
	print ' '

	return part_name

def get_mod():
	if not get_vp():
		result = 'ASSEMBLY'
	else:
		result = 'Part'

	file1 = open('vars0.txt','w')
	print >>file1,result
	file1.close()

	return result

def import_stp(stp_file,prefix='part_',model_name=None,part_numbers=(),part_names={},partname=None,scale=1, create_instance=True):
	## VER: 2014-07-29, v1.5

	global step, _m, a

	## import_stp('458400001_new.stp', part_names={1:'carbide',2:'diamond'},scale=25.4)

	## Example:
##	import_stp('424180101.stp', partname='carbide')

	## Exmaple:
##	stp_path = 'D:\JYQ\source\A0192_pressing_die_Matthew\stp\die_holder_2_asm.stp'
##	import_stp(stp_path,part_names = {1:'steel',38:'carbide1',40:'carbide2'})

##	stp_path = 'C:/FEM/A0198/incomming/cur__534u0516.stp'
##	import_stp(stp_path,part_numbers=(1,2,3,9),part_names={1:'shaft',2:'anvil',3:'bearing',9:'lock'})   ## 6: bearing, 10: lock

	vpnow = get_vpnow()
	stp_file = real_dir(stp_file)
	try:
		step = mdb.openStep(stp_file,scaleFromFile=OFF)
	except:
		raise Exception('*** Please check stp file stp_file= ' + stp_file)

	if type_of(partname) == 'STR':
		partname = new_key(_m.parts,partname)
		part_names={1:partname}

	numbers = range(1,step.numberOfParts + 1)
	if part_numbers in empty:
		part_numbers = numbers   ## create all parts

	if type_of(model_name) == 'STR':
		if model_name not in mdb.models.keys():
			mdb.Model(name=model_name, modelType=STANDARD_EXPLICIT)   ## create it
			vpnow.setValues(displayedObject=None)

	elif model_name in empty:
##		refresh()
		get_current_model()
		model_name = current_model_name

	if model_name not in mdb.models.keys():
		raise Exception('**** Error model name = ' + repr(model_name))

	_m = mdb.models[model_name]

	names = {}
	for number in part_numbers:
		if number in part_names.keys():
			partname = part_names[number]
		else:
			partname = prefix + str(number)
		names[number] = partname

		if scale == 1:	 ## not scale
			_m.PartFromGeometryFile(name = partname, geometryFile=step,
				bodyNum=number, combine=False, dimensionality=THREE_D, type=DEFORMABLE_BODY)  ## start from 1, not zero
		else:
			_m.PartFromGeometryFile(name = partname, geometryFile=step,
				bodyNum=number, combine=False, dimensionality=THREE_D, type=DEFORMABLE_BODY, scale=scale)  ## start from 1, not zero

	a = _m.rootAssembly
	vpnow.setValues(displayedObject=a)
	vpnow.assemblyDisplay.setValues(optimizationTasks=OFF, geometricRestrictions=OFF, stopConditions=OFF)
	a.DatumCsysByDefault(CARTESIAN)

	if create_instance == True:
		for partname in _m.parts.keys():
			new_instance(partname)

	refresh()

	return part_numbers

def index2objs(indices,poi,type='faces'):
	## VER: 2011-10-18, v1.1

	if type_of(indices) in ['PART', 'PINSTANCE']:
		indices,poi = poi,indices

	if type not in ['cells','faces','edges','vertices']:
		raise Exception('Error object type.')

	poi = check_pias(poi)

	indices = tolist(indices)

	objs = []
	full = eval(poi.name + '.' + type)

	if len(indices) > len(full):
		raise Exception(poi.name + ' has been changed: some ' + type + ' are deleted. Mapping failed.')

	for index in indices:
		obj = full[index]
		if obj not in objs:
			objs.append(obj)

	print '--->Indices of',type,'are mapped to',type,'in',poi.name

	return objs

def index_range(list1,n1='',n2=''):
	#VER: 2011-03-11, v1.7. list1也可能是dict

	if n1 == '':
		n1 = 1

	if n2 == '':
		n2 = len(list1) + 1

	return range(n1,n2)

def fn_inertia_of_faces(faces):
	## VER: 2011-10-18, v1.2

	faces = tolist(faces)
	ndir = face_ndir(faces[0])
	if ndir not in ['x','y','z']:
		raise Exception('Error face normal')

	ndir = dir2num(ndir)

	dir_list = [0,1,2]
	plane_dirs = unselect(dir_list,ndir)
	centroid_all = centroid_of_faces(faces)

	x1,y1,z1 = centroid_all
	x1 = round(x1,3)
	y1 = round(y1,3)
	z1 = round(z1,3)

	if abs(x1) < 1e-6:
		x1 = 0
	if abs(y1) < 1e-6:
		y1=0
	if abs(z1) < 1e-6:
		z1 = 0

	centroid_all = [x1,y1,z1]

	area_all = get_area(faces)

	print 'centroid of faces =',centroid_all
	print 'plane_dirs =',num2dir(plane_dirs[0]),',', num2dir(plane_dirs[1]),', ndir=',num2dir(ndir)
	print 'area =',area_all

	dir1 = plane_dirs[0]
	dir2 = plane_dirs[1]

	inertia = {0:0, 1:0, 2:0}
	for face in faces:
		shape = area_shape(face)
		space = objs_space(face)
		centroid_one = face.getCentroid()[0]
		area = face.getSize(printResults=False)

		if shape == 'axis_plane_rectangle':
			## inertia about dir1
			b = space[2*dir1 + 1] - space[2*dir1]
			h = space[2*dir2 + 1] - space[2*dir2]
			dist = abs(centroid_one[dir2] - centroid_all[dir2])
			I1 = b*h**3/12 + dist*dist*area
			inertia[dir1] = inertia[dir1] + I1

			## inertia about dir2
			b,h = h,b
			dist = abs(centroid_one[dir1] - centroid_all[dir1])
			I2 = b*h**3/12 + dist*dist*area
			inertia[dir2] = inertia[dir2] + I2

		else:
			edges = faces_to_edges(face)
			if len(edges) == 1 and edge_shape(edges[0]) == 'O_curve':
				R = get_radius(edges[0])
				I1 = I2 = pi*R**4/4
				inertia[dir1] = inertia[dir1] + I1
				inertia[dir2] = inertia[dir2] + I2

		## inertia about ndir
		I3 = I1 + I2
		inertia[ndir] = inertia[ndir] + I3

	inertia = {'x':round(inertia[0],3), 'y':round(inertia[1],3), 'z':round(inertia[2],3)}
	inertia = [inertia['x'],inertia['y'],inertia['z']]

	print 'Inertia of faces around axises through centroid: Ix,Iy,Iz=',
	print inertia

	return inertia

def index_to_cells(poi,ids):
	## VER: 2014-12-04, v1.0

	poi = check_poi(poi)

	ids = tolist(ids)

	cells = []
	for id in ids:
		cell = poi.cells[id]
		if cell not in cells:
			cells.append(cell)

	return cells

def index_to_nodes(poi,index):
	## VER: 2016-11-2, v1.0
	## node[index:label]  label = index + 1

	## Example: light(labels_to_nodes(get_p1(),labels=[167, 629, 2821, 7910]))

	poi = check_poi(poi)
	index = tolist(index)
	nodes = []
	for ind in index:
		node = poi.nodes[ind]
		nodes.append(node)

	return nodes

def info():
	## VER: 2010-04-21

	vpnow = get_vpnow()
	odb = vpnow.displayedObject
	try:
		for item in odb.userData.annotations.values():
			if item.name != 'Title':
				print item.text
				print ' '
	except:
		print 'Not available'

	return

def insert_dimensions(test=None):
	## VER: 2015-07-28, v1.6
	## coplanar: 0.108, test1
	## 060粉，虽然证书的搜索率可能为19%，但是实际上设计时一般用接近20%，即0.8032。19%仅对应压得很实，压机压力很大的情形。
	## test=-1: compensated model with W2B powder

	## Example: 仅仅输出弧线的坐标，以便Origin拟合，然后人工方程靠近该拟合线
##	odb_coords_by_xydata(nodes='dim_arc_ymax',axis1='x',axis2='y',sort='x',frame=-1)

	refresh()

	if test in empty:
		if 'test1' in odb_file_title.lower():
			test = 1  ## H10F, test1
		elif 'test2' in odb_file_title.lower():
			test = 2   ## H10F, test2

	if test in empty:
		test = -1	## WB powder, from mexico

	print fnln(),'test=',test

	D_design = 10.905
	D_exp = 10.643
	if test == 1:
		D_exp = 10.593

	D1=distance_of_odb_nodes('dim_bigR_x')
	D2=distance_of_odb_nodes('dim_bigR_y')
	D_FEM = round((D1+D2)/2,3)
	if 'test1' in odb_file_title:
		loc1 = coord_of_node(34471)
		loc2 = coord_of_node(214)
		D1 = abs(loc1[0] - loc2[0])

		loc3 = coord_of_node(3567)
		loc4 = coord_of_node(982)
		D2 = abs(loc3[1] - loc4[1])
		D_FEM = round((D1+D2)/2,3)

	if odb_file_title.startswith('DE_'):
		D_FEM = 10.875	;changing
	elif odb_file_title.startswith('DJ_'):
		D_FEM = 10.650	;changing
	D_result = get_delta_ratio(D_design,D_exp,D_FEM)
	D_note = 'dim_bigR_x, dim_bigR_y'

	d_design = 5.413
	d_exp = 5.364
	if test == 1:
		d_exp = 5.309

	d1=distance_of_odb_nodes('dim_smallR_x')
	d2=distance_of_odb_nodes('dim_smallR_y')
	d_FEM = round((d1+d2)/2,3)

	d_result = get_delta_ratio(d_design,d_exp,d_FEM)
	d_note = 'dim_smallR_x, dim_smallR_y'

	## mid
	length_design = 16.063  ## 19% shrinkage
	if test == 1:
		length_exp = 16.247 ## (test1)
	elif test == 2:
		length_exp = 16.266 ## test2
	elif test == -1:
		length_exp = 16.19  ## test data for WB sample.
		length_design = 16.595

	length_FEM = span_of_odb_nodes('dim_length_mid',dir='x')
	length_result_mid = get_delta_ratio(length_design,length_exp,length_FEM)
	length_mid_note = 'dim_length_mid'

	## side
	length_design = 15.973  ## 19% shrinkage
	if test == 1:
		length_exp = 16.204 ## (H10F, test1)
	elif test == 2:
		length_exp = 16.165 ## test2
	elif test == -1:
		length_exp = 16.027
		length_design = 16.502

	length_FEM_ymax = span_of_odb_nodes('dim_length_ymax',dir='x')
	length_FEM_ymin = span_of_odb_nodes('dim_length_ymin',dir='x')
	length_FEM = round((length_FEM_ymax + length_FEM_ymin)/2,3)
	length_result_side = get_delta_ratio(length_design,length_exp,length_FEM)
	length_side_note = 'dim_length_ymax, dim_length_ymin'

	## width, large edge
	width_design = 12.472	## 19% shrinkage
	if test == 1:
		width_exp = 12.359 ## H10F,test1
	elif test == 2:
		width_exp = 12.359 ## test2
	elif test == -1:
		width_exp = 12.383
		width_design = 12.885

	width_FEM = span_of_odb_nodes('dim_width_big',dir='y')
	width_result = get_delta_ratio(width_design,width_exp,width_FEM)
	width_note = 'dim_width_big'

	width_mid = span_of_odb_nodes('dim_width_mid',dir='y')
	width_short = span_of_odb_nodes('dim_width_small',dir='y')

	## Height, larger edge
	height_design = 5.035	## 19% shrinkage
	if test == 1:
		height_exp = 5.059 ## H10F, test1
	elif test == 2:
		height_exp = 5.085 ## test2
	elif test == -1:
		height_exp = 5.09
		height_design = 5.202

	height_FEM = span_of_odb_nodes('dim_height_left',dir='z')
	height_result = get_delta_ratio(height_design,height_exp,height_FEM)
	height_right_mid = span_of_odb_nodes('dim_height_right',dir='z')
	height_note = 'dim_height_left'

	Coplanar_bot_mid_green = span_of_odb_nodes('dim_bot_mid',dir='z',frame=0)   ## no arc
	Coplanar_bot_mid_sinter = span_of_odb_nodes('dim_bot_mid',dir='z',frame=-1)

	Coplanar_bot_arc_green = span_of_odb_nodes('dim_bot_arc',dir='z',frame=0)   ## with arc
	Coplanar_bot_arc_sinter = span_of_odb_nodes('dim_bot_arc',dir='z',frame=-1)

	Coplanar_top_mid_green = span_of_odb_nodes('dim_top_mid',dir='z',frame=0)
	Coplanar_top_mid_sinter = span_of_odb_nodes('dim_top_mid',dir='z',frame=-1)

	Coplanar_top_arc_green = span_of_odb_nodes('dim_top_arc',dir='z',frame=0)
	Coplanar_top_arc_sinter = span_of_odb_nodes('dim_top_arc',dir='z',frame=-1)

	Coplanar_top_ymax_green = span_of_odb_nodes('dim_length_ymax',dir='z',frame=0)
	Coplanar_top_ymax_sinter = span_of_odb_nodes('dim_length_ymax',dir='z',frame=-1)

	Coplanar_top_ymin_green = span_of_odb_nodes('dim_length_ymin',dir='z',frame=0)
	Coplanar_top_ymin_sinter = span_of_odb_nodes('dim_length_ymin',dir='z',frame=-1)

	dir1 = make_dir('results')
	file1 = '_' + odb_file_title[0:2] + '_dimensions.txt'
	file1 = open(dir1 + '/' + file1,'w')

	print >>file1, ' '
	print >>file1, 'odb file =',odb_file_title + '.odb'
	print >>file1, ' '
	print >>file1, 'Name'.ljust(7), 'Design'.ljust(10) + 'Exp'.ljust(10) + 'FEM'.ljust(10) + 'FEM_design_delta'.ljust(20)  \
		+ 'FEM_design_ratio'.ljust(20) + 'FEM_exp_delta'.ljust(20) + 'FEM_exp_ratio'.ljust(20) + 'Design_exp_delta'.ljust(20) + 'Design_exp_ratio' + '       Note'

	print >>file1, 'L_mid'.ljust(8) + length_result_mid + length_mid_note    ## 最大值
	print >>file1, 'L_side'.ljust(8) + length_result_side + length_side_note ## 最小值
	print >>file1, 'W_big'.ljust(8) + width_result + width_note
	print >>file1, 'H_mid'.ljust(8) + height_result + height_note
	print >>file1, 'D'.ljust(8) + D_result + D_note
	print >>file1, 'd'.ljust(8) + d_result + d_note

	print >>file1, ' '
	print >>file1, 'Other dimenions:'
	print >>file1, 'width_mid =',width_mid
	print >>file1, 'width_short =',width_short
	print >>file1, 'height_right_mid =',height_right_mid
	print >>file1, ' '

	print >>file1, '★★Coplanar before sintering:'
	print >>file1, 'Coplanar_bot_mid =',Coplanar_bot_mid_green
	print >>file1, 'Coplanar_bot_arc =',Coplanar_bot_arc_green
	print >>file1, ' '
	print >>file1, 'Coplanar_top_mid =',Coplanar_top_mid_green
	print >>file1, 'Coplanar_top_arc =',Coplanar_top_arc_green
	print >>file1, ' '
	print >>file1, 'Coplanar_top_ymax =',Coplanar_top_ymax_green
	print >>file1, 'Coplanar_top_ymin =',Coplanar_top_ymin_green

	print >>file1, ' '
	print >>file1, '★★Coplanar after sintering:'
	print >>file1, 'Coplanar_bot_mid =',Coplanar_bot_mid_sinter
	print >>file1, 'Coplanar_bot_arc =',Coplanar_bot_arc_sinter
	print >>file1, ' '
	print >>file1, 'Coplanar_top_mid =',Coplanar_top_mid_sinter
	print >>file1, 'Coplanar_top_arc =',Coplanar_top_arc_sinter
	print >>file1, ' '
	print >>file1, 'Coplanar_top_ymax =',Coplanar_top_ymax_sinter
	print >>file1, 'Coplanar_top_ymin =',Coplanar_top_ymin_sinter

	partname = import_part_from_odb(odb_file_title, inst_name='green_A1',step_name='step1',frame=0)
	spanx,spany,spanz = spans_of_poi(partname)

	print >> file1,' '
	print >> file1,'part dimensions, frame=0:'
	print >> file1,(spanx,spany,spanz)

	partname = import_part_from_odb(odb_file_title, inst_name='green_A1',step_name='step1',frame=-1)
	spanx,spany,spanz = spans_of_poi(partname)

	print >> file1,' '
	print >> file1,'part dimensions, frame=-1:'
	print >> file1,(spanx,spany,spanz)

	print >> file1,' '
	print >> file1,'Stress (S1):'
	stress1 = get_result(variable='S1',instance='green_A1')
	print >> file1,stress1

	print >> file1,' '
	print >> file1,'Deformation (U):'
	U = get_result(variable='U',instance='green_A1')
	print >> file1,U

	print >>file1, ' '

	file1.close()

	print '--->Dimensions have been written to',dir1 + '/' + file1.name



	odb_coords_by_xydata(nodes='dim_top_arc',axis1='x',axis2='z',frame=-1)
	odb_coords_by_xydata(nodes='dim_bot_arc',axis1='x',axis2='z',frame=-1)
	odb_coords_by_xydata(nodes='dim_mid_profile',axis1='x',axis2='z',frame=-1)
	odb_coords_by_xydata(nodes='dim_xy_frame',axis1='x',axis2='y',frame=-1)

	odb_coords_by_cae('dim_top_arc',rotate_reference='dim_bigR_x',frame=0)
	odb_coords_by_cae('dim_top_arc',rotate_reference='dim_bigR_x',frame=-1)

	odb_coords_by_cae('dim_bot_arc',rotate_reference='dim_smallR_x',frame=0)
	odb_coords_by_cae('dim_bot_arc',rotate_reference='dim_smallR_x',frame=-1)

	return

function_labels['insert_sintering'] = 'density','sinter_loss','C1','powder compaction','sintering','insert'
def insert_sintering(compaction_odb='',job_name='',density_th=14.44, sinter_loss = 2.505,offset=-0.2, shrinkage=0.19, C1=None, grade=None, manual=True,expansion=False,by_menu=False,jobname='job-1'):
	## VER: 2017-06-07, v2.1
	## Open the ODB, then run insert_sintering()
	## Change at least the script file name and compaction_odb
	## Default = H10F
	## manual=True: 需要手工建立fix hole nodes的set, 并约束其中的几个点，然后提交运算。
	## job#: A0279

	## job#: A0277
	## insert_sintering(grade='AM70')

	## job#: A0279
	## insert_sintering(C1=2.57)

	## W2B similar to H10F powder, 回收粉，类似于1072粉。
	## grade: 503DPSM, W2B
##	density_th =  14.28     ;changing ##  14.44		;changing1    12EF, AM70, 1024
##	sinter_loss = 2.78     	;changing ##  2.174, 2.418		;changing

	## grade: H10F （060粉）
##	density_th =  14.435     ## 或14.44
##	sinter_loss = 2.505
## 	H10pow_C1 = 2.505	## 不同批次会不同，例如：2.42, 2.45, 2.505, 2.52, 2.61 (sinter loss)

##	if fnln()[0] != 'cliCommand':
##		BC = True

	global inp_file_title

	if grade not in empty:
		dict1 = powder_properties(grade)
		density_th = dict1['density_th']
		sinter_loss = dict1['sinter_loss']
		shrinkage = dict1['shrinkage']

	if is_number(C1):
		sinter_loss = C1

	GUI_odb = False
	if compaction_odb in empty:
		auto()
		refresh()
		dpo = get_dpo()
		vpnow = get_vpnow()

		if type_of(dpo) != 'ODB':
			if session.odbs.keys() in empty:
				raise Exception('*** Please open the compaction odb for sintering simulation.')
			else:
				if len(session.odbs.keys()) == 1:
					odb1 = session.odbs.values()[0]
					vpnow.setValues(displayedObject=odb1)
				else:
					raise Exception('*** Several odbs existed. Please display the exact compaction odb first.')

		dpo = get_dpo()
		if type_of(dpo) != 'ODB':
			raise Exception('*** Please open the compaction odb for sintering simulation.')

		powder_inst = find_powder_inst()
		if powder_inst in empty:
			raise Exception('*** A compaction odb is required for open')
		compaction_odb = get_odb_file_title()

##		raise Exception

		if job_name[-3:] == '.py':
			job_name = job_name[:-3]

		if job_name in empty or job_name == compaction_odb:
			job_name = 'sinter_' + compaction_odb

##		print fnln(),'caller name:',caller_names()
##		print fnln(),'density_th=',density_th
##		print fnln(),'sinter_loss=',sinter_loss
##		print fnln(),'by_menu=',by_menu
##		print type_of(density_th)
##		raise Exception

		if caller_names() in empty:
			by_menu = True

		if by_menu == False:
			if grade in empty:
				fields = (('inp job name:',str(job_name)),
						  ('theoretical density:',str(density_th)),
						  ('sinter loss:',str(sinter_loss)))

				job_name, density_th, sinter_loss = getInputs(fields=fields, label=str(fnln_fnln()) + ': Confirm the jobname and powder properties')
				density_th = float(density_th)
				sinter_loss = float(sinter_loss)

				if job_name == compaction_odb:
					fields = (('inp job name:',str(job_name)),
							  ('theoretical density:',str(density_th)),
							  ('sinter loss:',str(sinter_loss)))
					job_name, density_th, sinter_loss = getInputs(fields=fields, label=str(fnln_fnln()) + ': **Error:Job name should not the same as odb')
					density_th = float(density_th)
					sinter_loss = float(sinter_loss)

				if job_name in mdb.jobs.keys():
					fields = (('inp job name:',str(job_name)),
							  ('theoretical density:',str(density_th)),
							  ('sinter loss:',str(sinter_loss)))
					job_name, density_th, sinter_loss = getInputs(fields=fields, label=str(fnln_fnln()) + ': **Error:job name has been existed')
					density_th = float(density_th)
					sinter_loss = float(sinter_loss)
		GUI_odb = True

	if compaction_odb in empty:
		raise Exception('*** compaction_odb is required.')

##	raise Exception

	if len(_m.parts) > 0:
		clear()

	print fnln(),'density_th=',density_th
	print fnln(),'compaction_odb=',compaction_odb

	locals0 = locals().keys()

	globals()['density_th'] = density_th

	sinter_loss = sinter_loss
##	density_th = density_th

	bulk_modulus = 400e3	;changing1	## 400GPa

	deltaT = 1				;changing1
##	dens_range = (0.1,0.15,0.8,0.9)
	dens_range = (0.05,0.1,0.85,0.90)	;changing


	design_shrinkage = 0.19     ;changing ## Used for tool compensation only ##  prefer 19%? (AM70 powder)		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
##	offset = -0.3		    	;changing   ## parameter of apply_CTE_from_density_with_PEG(). 当收缩率大于19%时（例如12EF)，可考虑offset=-0.35或-0.4，当收缩率小于18时，可考虑offset=-0.25或-0.2

	hole_axis = 'z'
	small_hole_side = MAX 		;changing 	## z direction, toppunch side, with high density at suroundings; or with smaller hole，约束小孔一侧不易引起翻转
	## 如果反着压，则小孔在上，大孔在下，压制过程中芯杆不动。大孔一侧可能有突起，开孔大后就要在厚度上加强。如果正着压，则大孔在上，小孔在下，此时芯杆与上冲一起往下压。

	auto_label = True	;changing
##	model = 'quarter'	;changing

	locals2globals(locals0,locals())

	## import part from odb
	## 检查p1的名字可以知道所导入的模块
##	p1 = import_part_from_odb(odbname=compaction_odb,part_name='p1',step_id=-1,frame=-1)
##	globals()['p1'] = p1   ## p1 is the part name, such as: p1='A0267-B-USM_p1_step2_frame30'

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	## offset=-0.4: avg shrinkage=20.77, offset=-0.3: average shrinkage=20.41
	## use real_shrinkage() to get the real shrinkage

##	target_density = shrinkage_to_density_with_PEG(shrinkage,C1=sinter_loss, Rho_th = density_th)  ## 8.42
##	print ' '
##	print fnln(),'sinter_loss =',sinter_loss, ', density_th =',density_th
##	print fnln(),'shrinkage =',design_shrinkage, ', target_density=',target_density

##	raise Exception

	open_odb(compaction_odb)
	compaction_odb = get_odb_file_title()

##	raise Exception

	job_name = new_key(mdb.jobs.keys(),job_name)
	inp_file_title = job_name

	distribution= density_distribution(Rho_th=density_th,low=0.02,high=0.97)
	avg = distribution['relative_avg']
	if avg < 0.4:  ## 防止压型参数错误导致压坯密度偏低。
		print fnln(),'green part density=',avg
		raise Exception('*** T	he
	green
	part
	density is lower
	than
	40 %
	for sintering.')

	density_processing(Rho_th=density_th,low=0.02,high=0.97)
	dens1 = _density_vol
	density_processing(Rho_th=density_th,ranges=dens_range,retreat=True,density_vol=dens1,method='linear')
	dens2 = _density_vol
	## provided shrinkage in powder certificate or engineering design does not affect the density_processing()

	write_density_and_element_labels(density_vol=dens2,filename=density_file)	;changing

		## Kevin: the last step name is uppressing
	green_part = import_part_from_odb(odbname=compaction_odb,part_name='green',step_id=-1,frame=-1, copy_nodeset=False,force_name=True)	;changing
	p1 = new_instance(green_part)	;please_check

	save_mdb(job_name)

##	raise Exception

##	open_odb(compaction_odb)
##	density_avg = density_distribution(th=density_th)['average']
##	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
##	print fnln(),'density_avg=',density_avg
##	print fnln(),'density_lab=',density_lab
##	session.viewports['Viewport: 1'].odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

	## SMIL
	densities = read_density_and_element_labels(density_file)

##	density file:
##	density  = 7.636
##	elements = [52772, 50924, 52765, 52665, 50951, 50934, 52658, 50926, 50755, 50753, 52775, 51117, 50754, 52603, 50792, 52889, 52784, 50694, 52597, 50942, 52590, 52601, 50933, 52663, 50925, 50780, 52591, 52867, 50777, 50734, 52888, 50785, 52754, 52774, 52776, 50778, 52605, 52810, 50696, 50756, 50927, 52657, 52593, 52592, 51114, 50935, 50697, 51089, 50736, 52585, 52887, 52639, 52661, 50758, 50674, 52897, 52785, 50784, 52607, 51115, 50944, 50775, 52891, 52608, 52586, 52645, 50907, 50675, 50752, 52579, 51098, 50803, 52581, 52571, 52773, 52638, 50676, 52898, 50802, 50932, 50773, 52885, 52621, 52783, 51120, 50931, 50890, 52540, 52573, 52884, 50760, 52777, 50889, 52539, 51121, 50761, 50772, 52637, 52565, 52704, 50762, 52782, 52870, 52635, 50679, 50764, 50809, 52557, 52871, 50937, 50950, 50669, 52786, 50908, 52636, 52610, 51113, 50936, 50765, 52876, 50815, 52778, 50670, 52780, 52533, 51108, 50671, 50928, 50151, 52611, 50300, 52532, 52779, 50150, 50684, 50153, 52653, 51097, 50930, 52556, 50771, 50128, 50767, 52882, 52552, 52041, 52730, 52167, 52781, 51080, 50127, 50067, 51974, 51104, 50769, 52656, 52159, 50680, 50825, 52650, 50315, 50681, 50770, 52649, 52158, 50107, 52272, 50126, 50490, 52646, 52551, 50069, 51973, 50306, 50827, 52040, 50047, 51980, 51984, 50487, 52046, 50462, 52137, 52271, 52631, 51986, 51975, 50165, 52022, 51976, 50070, 50109, 51968, 52044, 50048, 52270, 50131, 51988, 50158, 52280, 52028, 50125, 50488, 51969, 52250, 40276, 40292, 50157, 50280, 5181, 40266, 5182, 51962, 5799, 5219, 40265, 52274, 40275, 50471, 5836, 50148, 5174, 40903, 52281, 5074, 51964, 39665, 40893, 50176, 4564, 5798, 50305, 4557, 40919, 51954, 39648, 40892, 39638, 50049, 52021, 52157, 5791, 52268, 4457, 49524, 5691, 50129, 40902, 51990, 50297, 50299, 50175, 52155, 50304, 51991, 52048, 39649, 52166, 4565, 40291, 52282, 50146, 39639, 50307, 52004, 50493, 51956, 4602, 50073, 50781, 5195, 49673, 50106, 52149, 50491, 50494, 52168, 51981, 40918, 50317, 51983, 52150, 50133, 49523, 52160, 50108, 5812, 52042, 50124, 51923, 50525, 52248, 39664, 51985, 50263, 52273, 50152, 52249, 49440, 50068, 52267, 52387, 51542, 51987, 4578, 35477, 49480, 49500, 50479, 51550, 51429, 51356, 39496, 50316, 50182, 52020, 50783, 50460, 49420, 40123, 51972, 49688, 50166, 50134, 51423, 51358, 50496, 35104, 133, 50324, 49860, 51655, 49442, 49526, 51357, 51922, 39038, 50149, 3940, 3947, 52023, 50262, 52151, 49863, 39495, 50314, 4603, 35510, 35431, 49499, 5220, 39021, 51822, 53121, 51714, 35076, 52247, 51948, 51426, 50750, 51209, 51363, 52595, 49955, 51520, 49443, 51365, 51210, 49482, 39011, 53056, 51654, 52599, 49835, 50902, 51136, 52275, 49956, 50787, 52792, 52338, 52948, 49533, 73, 51405, 338, 51359, 49679, 50564, 3840, 50277, 51361, 336, 50145, 50171, 52043, 50323, 51351, 50621, 35101, 35060, 51989, 51224, 49421, 52515, 51963, 51892, 53053, 49648, 51367, 51369, 52907, 52986, 35448, 51513, 49882, 3948, 50558, 50135, 51248, 52747, 52642, 50308, 39022, 50269, 71, 39497, 53132, 50901, 50271, 51139, 50188, 51541, 49501, 50581, 35025, 52169, 51424, 52609, 49885, 39012, 49647, 239, 52289, 52253, 51970, 51411, 52413, 52245, 52018, 52087, 35058, 52194, 49504, 49931, 132, 4913, 51186, 35449, 51360, 51673, 50066, 35118, 52436, 49970, 53030, 62, 50898, 52175, 52955, 51752, 3985, 39471, 339, 50463, 51653, 52594, 49649, 6416, 51190, 50313, 75, 51663, 52374, 51132, 49538, 135, 52333, 4401, 51971, 4456, 52148, 50576, 52991, 49525, 51208, 49496, 52279, 51278, 52509, 35248, 50505, 51696, 38869, 51894, 51514, 52019, 49936, 51721, 53040, 38868, 6453, 40122, 35443, 39037, 50466, 51241, 240, 35515, 51898, 52987, 35020, 35229, 52161, 49898, 52588, 50732, 52025, 50024, 6415, 35535, 51716, 50052, 72, 51245, 599, 51371, 49652, 372, 51425, 52930, 50903, 50123, 3986, 52950, 52949, 51203, 51558, 50147, 3961, 49861, 49669, 421, 53050, 477, 52906, 49954, 51940, 50693, 41519, 605, 53128, 51819, 52742, 428, 49994, 529, 51796, 35534, 50614, 51631, 50137, 49650, 51753, 52329, 51364, 51508, 52269, 49644, 265, 50272, 50310, 423, 41530, 49653, 52423, 35415, 51352, 51366, 49852, 337, 51890, 52260, 35230, 6308, 49531, 35227, 35228, 49446, 49441, 6408, 50492, 221, 49497, 35075, 50906, 68, 35573, 38870, 49478, 113, 52394, 380, 50904, 52946, 51533, 49479, 50692, 3784, 51408, 49481, 35266, 35461, 51715, 365, 52748, 50160, 38844, 50899, 51978, 41520, 36142, 35412, 52331, 363, 49869, 52791, 4296, 35268, 49878, 52433, 35112, 50159, 40124, 51222, 51757, 52156, 49439, 51354, 3839, 49844, 51979, 51355, 51532, 51345, 40098, 49932, 50064, 52439, 503, 53039, 49836, 51259, 40750, 52130, 50234, 35549, 5530, 35226, 50582, 49987, 51672, 35223, 50275, 35111, 52583, 51428, 220, 52259, 49539, 49949, 50571, 52045, 50486, 52165, 35231, 5073, 601, 52138, 50618, 50691, 39013, 51656, 52584, 52596, 51806, 526, 35533, 51982, 49687, 36162, 51664, 52905, 1040, 50555, 52369, 52288, 51632, 689, 35856, 50274, 5837, 50583, 51770, 35464, 53126, 52174, 403, 51198, 49968, 52152, 882, 77, 50512, 52027, 50281, 49991, 41546, 459, 5018, 50897, 49833, 52738, 38843, 52756, 52312, 838, 997, 51260, 51177, 51977, 3949, 1045, 51406, 464, 35018, 53, 52743, 50563, 49549, 51712, 752, 51630, 51955, 50065, 241, 51816, 35702, 50181, 35457, 379, 52039, 49678, 52364, 50597, 35875, 49864, 50509, 50132, 36161, 67, 1146, 52313, 50298, 115, 51347, 35858, 41529, 39031, 35855, 52422, 1222, 51633, 3960, 35528, 36200, 52131, 49923, 50633, 36088, 35854, 51350, 61, 52981, 50276, 50301, 1038, 51504, 50296, 35123, 51368, 51522, 51427, 51269, 51966, 50478, 52126, 51557, 49498, 35552, 50138, 50600, 335, 50632, 49645, 49521, 685, 49651, 50651, 50105, 51916, 50699, 49973, 35516, 41545, 51534, 35566, 51337, 1218, 50155, 49544, 39640, 49422, 52370, 51957, 49438, 49937, 35511, 50923, 51651, 50567, 52505, 52290, 513, 51671, 53124, 51362, 51805, 50278, 50887, 35603, 3783, 53041, 419, 51346, 49437, 52254, 52193, 1120, 52332, 35739, 51629, 51123, 51628, 50144, 35850, 6429, 50642, 35057, 60, 49944, 51349, 460, 51657, 52425]
##
##	density  = 7.637
##	elements = [52162, 52995, 39470, 52504, 39175, 36176, 53042, 52278, 51194, 1143, 52136, 52938, 597, 50489, 50559, 4566, 402, 36160]
##	...

	print fnln(),'sinter_loss=',sinter_loss   ## No problem

	CTEs = apply_CTE_from_density_with_PEG(green_part,densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=offset,
		density_th=density_th)	;changing

	save_mdb(job_name)

	print ' '
	print 'C1=',sinter_loss,', offset=',offset
	print 'first 10 CTEs:',CTEs[:10]
	print 'last 10 CTEs:',CTEs[-10:]
	print ' '

##	C1= 2.26 , offset= 0.1  ★
##	first 10 CTEs: [0.17879, 0.17882, 0.17886, 0.17889, 0.17892, 0.17896, 0.17899, 0.17902, 0.17906, 0.17909]
##	last 10 CTEs: [0.19368, 0.19371, 0.19375, 0.19378, 0.19382, 0.19385, 0.19389, 0.19392, 0.19395, 0.19399]
##
##	C1= 2.26, offset= 0
##	first 10 CTEs: [0.18215, 0.18218, 0.18222, 0.18225, 0.18228, 0.18232, 0.18235, 0.18238, 0.18242, 0.18245]
##	last 10 CTEs: [0.19716, 0.1972, 0.19723, 0.19727, 0.1973, 0.19734, 0.19737, 0.19741, 0.19744, 0.19748]
##
##	C1= 2.26 , offset= -0.1
##	first 10 CTEs: [0.18554, 0.18557, 0.1856, 0.18564, 0.18567, 0.18571, 0.18574, 0.18577, 0.18581, 0.18584]
##	last 10 CTEs: [0.20068, 0.20071, 0.20075, 0.20078, 0.20082, 0.20086, 0.20089, 0.20093, 0.20096, 0.201]
##
##	C1= 2.26 , offset= -0.2
##	first 10 CTEs: [0.18895, 0.18898, 0.18902, 0.18905, 0.18909, 0.18912, 0.18916, 0.18919, 0.18923, 0.18926]
##	last 10 CTEs: [0.20423, 0.20426, 0.2043, 0.20433, 0.20437, 0.2044, 0.20444, 0.20447, 0.20451, 0.20455]
##
##	C1= 2.26 , offset= -0.3  ★
##	first 10 CTEs: [0.1924, 0.19243, 0.19246, 0.1925, 0.19253, 0.19257, 0.1926, 0.19264, 0.19267, 0.19271]
##	last 10 CTEs: [0.2078, 0.20784, 0.20788, 0.20791, 0.20795, 0.20798, 0.20802, 0.20806, 0.20809, 0.20813]
##
##	C1= 2.36 , offset= -0.3
##	first 10 CTEs: [0.19267, 0.1927, 0.19274, 0.19278, 0.19281, 0.19284, 0.19288, 0.19291, 0.19295, 0.19298]
##	last 10 CTEs: [0.20808, 0.20811, 0.20815, 0.20818, 0.20822, 0.20825, 0.20829, 0.20833, 0.20836, 0.2084]
##
##	C1= 2.46 , offset= -0.3
##	first 10 CTEs: [0.19295, 0.19298, 0.19302, 0.19305, 0.19309, 0.19312, 0.19315, 0.19319, 0.19322, 0.19326]
##	last 10 CTEs: [0.20835, 0.20838, 0.20842, 0.20845, 0.20849, 0.20852, 0.20856, 0.2086, 0.20863, 0.20867]
##
##	C1= 2.57 , offset= -0.3  ★
##	first 10 CTEs: [0.19325, 0.19329, 0.19332, 0.19335, 0.19339, 0.19342, 0.19346, 0.19349, 0.19353, 0.19356]
##	last 10 CTEs: [0.20864, 0.20868, 0.20872, 0.20875, 0.20879, 0.20882, 0.20886, 0.20889, 0.20893, 0.20897]
##
##	C1= 2.57 , offset= 0.1 ★
##	first 10 CTEs: [0.17966, 0.17969, 0.17972, 0.17976, 0.17979, 0.17983, 0.17986, 0.17989, 0.17993, 0.17996]
##	last 10 CTEs: [0.19453, 0.19456, 0.1946, 0.19464, 0.19467, 0.1947, 0.19474, 0.19477, 0.19481, 0.19484]

## C1变大, CTE变大; offset变小, CTE变大. offset的影响比C1的影响更大。
## 更小的CTE: C1更小, offset更正
## 更大的CTE: C1更大, offset更负
## job:A0282, 测试发现C1= 2.57 , offset=-0.3的结果与C1= 2.26 , offset= 0.1的结果非常接近(surface distortion, flatness),
##			pin hole diameter: offset=0.1:D=4.936; offset=-0.3:D=4.864, SPEC = 4.875 +/- 0.075 mm (4.8-4.95)


##	raise Exception

	for i in range(10):
		print '------'

	## loads and BC
	create_general_static_step()

	set1 = a.Set(nodes=_inst(p1).nodes[:], name='all_nodes')
	if expansion == False:
		set_temperature_predefined_field('Temp_field',region=set1, initial_step=25+deltaT, modify=25)
	else:
		set_temperature_predefined_field('Temp_field',region=set1, initial_step=25-deltaT, modify=25)

	print fnln(),'--->Please switch to Assembly module, create a node set in GUI for hole nodes for fix, set name=hole'
	print fnln(),'--->Please also create surfaces in GUI which is helpful for deformation checking.'

	nodes = []
	try:
		nodes = node_select_by_feature_angle(p1,axis='z',end=MIN)
	except:
		pass

	if manual == True:
		f1 = _m.predefinedFields.values()[0]
		f1.suppress()

	if len(nodes) > 0:
		fix_hole_and_create_job(nodes)
		message_box('Job has been created. You can just simply submit the job',title='Job',buttons='OK')

##	raise Exception

	## A0277, A0279, triangle insert
	## Create the hole node set in GUI  ## You can deactivated the predefined field for ease of operation
##	a = mdb.models['Model-1'].rootAssembly
##	n1 = a.instances['green_A1'].nodes
##	nodes1 = n1[14:15]+n1[511:560]
##	a.Set(nodes=nodes1, name='hole')
##	#: The set 'hole' has been created (50 nodes).

##	>>> fix_hole_and_create_job('hole')
##	['apply_disp_fix', 5554] --->Created displacement fix: _01_BC_x_73
##	['apply_disp_fix', 5554] --->Created displacement fix: _02_BC_y_74
##	>>>

	return job_name

##	## boundary conditions
##	nodes = node_select(p1,z=MID,err=0.25)
##	create_set(setname='dim_zmid',nodes=nodes)
##
##	nodes = node_select(p1,x=0,err=0.25)
##	create_set(setname='dim_xmid',nodes=nodes)
##
##	nodes = node_select(p1,y=0,err=0.25)
##	create_set(setname='dim_ymid',nodes=nodes)
##
##	try:
##		nodes = nodes_by_face(p1,nx=-1,x=MIN)
##		nodes = node_select(p1,nodes=nodes,x=(MID,MIN))
##		elems = nodes_to_elements(nodes)
##		elements_to_surface(elems,name='surf_xmin',axis='x',by_fine=True)
##	except:
##		pass
##
##	try:
##		nodes = nodes_by_face(p1,nx=1,x=MAX)
##		nodes = node_select(p1,nodes=nodes,x=(MID,MAX))
##		elems = nodes_to_elements(nodes)
##		elements_to_surface(elems,name='surf_xmax',axis='x',by_fine=True)
##	except:
##		pass
##
##	try:
##		nodes = nodes_by_face(p1,ny=-1,y=MIN)
##		nodes = node_select(p1,nodes=nodes,y=(MID,MIN))
##		elems = nodes_to_elements(nodes)
##		elements_to_surface(elems,name='surf_ymin',axis='y',by_fine=True)
##	except:
##		pass
##
##	try:
##		nodes = nodes_by_face(p1,ny=1,y=MAX)
##		nodes = node_select(p1,nodes=nodes,y=(MID,MAX))
##		elems = nodes_to_elements(nodes)
##		elements_to_surface(elems,name='surf_ymax',axis='y',by_fine=True)
##	except:
##		pass
##
##	try:
##		nodes = nodes_by_face(p1,nz=-1,z=MIN)
##		nodes = node_select(p1,nodes=nodes,z=(MID,MIN))
##		elems = nodes_to_elements(nodes)
##		elements_to_surface(elems,name='surf_zmin',axis='z',by_fine=False)
##	except:
##		pass
##
##	try:
##		nodes = nodes_by_face(p1,nz=1,z=MAX)
##		nodes = node_select(p1,nodes=nodes,z=(MID,MAX))
##		elems = nodes_to_elements(nodes)
##		elements_to_surface(elems,name='surf_zmax',axis='z',by_fine=True)
##	except:
##		pass
##
##	nodes_x = node_select(p1,x=0,err=0.3)  ## 148, 420
##	nodes_y = node_select(p1,y=0,err=0.3)  ## 1, 5
##	create_set(name='nodes_x0',nodes=nodes_x)
##	create_set(name='nodes_y0',nodes=nodes_y)
##
##	if manual != True:
##		please_check
##		found_BC_nodes = False
##		model = get_sym_type(p1)
##		if 'full' in model:
##			nodes_x0 = nodes_x0 = []
##			if auto_label == True:
##				labels = fix_nodes_of_insert(p1,axis_side=small_hole_side,angle=10,return_label=True)	;changing  ## angle=40 太大
##				nodes_x0 = labels[:2]
##				nodes_y0 = labels[2:4]
##
##			else:
##				## Query节点时：按住shift键，把两个节点都选出来后，再按done。注意选择small_hole_side的节点
##
##				if compaction_odb == 'A0267-B-USM_insert_B104_R60':
##					nodes_x0 = [149, 420]
##					nodes_y0 = [1, 5]
##
##			if len(nodes_x0) == len(nodes_y0) == 2:
##				found_BC_nodes = True
##
##				## Not symmetric BC
##				apply_disp_fix(name='BC_x',nodes=nodes_x0,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
##				apply_disp_fix(name='BC_y',nodes=nodes_y0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)
##
##		elif model in ['quarter', '1/4','xysym']:  ## Automatically find the nodes for fix
##			nodes = node_select(p1,x=MIN)
##			create_xsym(name='sym_x',nodes=nodes)
##
##			nodes = node_select(p1,y=MIN)
##			create_ysym(name='sym_y',nodes=nodes)
##
##			nodes = node_select(p1,y=MIN)
##			nodes1 = node_select(p1,nodes=nodes,groupZ=MIN)
##			nodes2 = node_select(p1,nodes=nodes1,groupX=MIN)
##			apply_disp_fix(name='BC_z',nodes=nodes2[0],Uz=0)
##
##			if len(nodes2) > 0:
##				found_BC_nodes = True
##
##		job_name = create_inp(job_name,request_num=1,submit=False)
##
##		if GUI_odb == True:
##			mdb.jobs[job_name].submit()
##			print 'Job is submitted.'
##
##		print ' '
##		print 'Found BC nodes =',found_BC_nodes
##
##	return	job_name

def inside(p,loc,obj):
	## VER: 2011-03-22, v1.2

	x01,x02,y01,y02,z01,z02 = obj_space(p,obj)

	result = False
	if within_range(loc[0],x01,x02) and within_range(loc[1],y01,y02) and within_range(loc[2],z01,z02):
		result = True

	return result

def inspect_trace():
	## VER: 2012-12-26, v1.0

	global trace
	trace = inspect.stack()
	trace1 = []
	for item in trace:
		if '.py' in item[1]:
			item1 = []
			for data in item[1:]:
				if type_of(data) in ['STR','INT']:   ## STR代表文件名或function name，INT代表行号。
					item1.append(data)
				else:
					break
			if item1 != []:
				trace1.append(item1)

	trace2 = []
	for i in range(1,len(trace1) + 1):
		trace2.append(trace1[-i])
	trace1 = trace2

	trace2 = []
	num = 0
	for func in trace1:
		num = num + 1
		if num == 1:
			trace2.append(func)
		else:
			if 'inspect_trace' not in func:
				if func[0] == trace2[-1][0]:	## same py file
					trace2[-1] = trace2[-1] + func[1:]
				else:
					trace2.append(func)
	trace1 = trace2

##	print ' '
##	print os.path.abspath('.')
##	print os.getcwd()

	return trace1

def inspect_trace1():
	## VER: 2012-12-26, v1.0

	global trace
	trace = inspect.stack()
	trace1 = []
	for item in trace:
		if '.py' in item[1]:
			frame = item[0].f_code
			line_info = Codeline()
			line_info.filename = frame.co_filename
			line_info.frame_name = frame.co_name
			line_info.command_lineno = frame.co_firstlineno
			trace1.append(line_info)
	trace1.reverse()

	return trace1

def inst_dot_esets(setname,inst=None):

	## VER: ('VER: 2012-09-08, v1.7')

	if type_of(setname) == 'ODBINSTANCE':
		setname,inst = inst, setname

	esets = []
	setname = setname.upper()
	if inst not in empty:
		inst = check_odb_inst(inst)
		if setname in inst.elementSets.keys():
			esets.append(inst.name + '.' + setname)
		else:
			raise Exception('No such eset=' + setname + ' in ' + inst.name)
	else:
		for inst in oa.instances.values():
			for eset in inst.elementSets.keys():
				if eset == setname:
					esets.append(inst.name + '.' + eset)

		if setname in oa.elementSets.keys():  ## assembly 下edge类型的set，到了后处理，变成了element set，名称不变。
			esets.append(setname)

	esets = totuple(esets)

	if len(esets) > 0:
		print 'Found',len(esets),'element sets','by name=',setname,': ',esets

	return esets

def inst_names_with(*strs):
	## VER: 2016-12-22, v1.1
	## reference: inst_of_pre()

##	>>> inst_names_with('die')
##	['die_A1']
##	>>>

##>>> inst_names_with('powder')
##['powder_A1']
##>>>
##	>>> inst_names_with('punch')
##	['bpunch_A1', 'tpunch_A1']
##	>>>

	insts0 = all_valid_insts()
	insts = []
	for name in insts0:
		inside = True
		for str1 in strs:
			if str1.lower() not in name.lower():
				inside = False

		if inside == True:
			insts.append(name)

	return insts

def part_names_with(str1):
	## VER: 2014-10-21, v1.0

##>>> part_names_with('powder')
##['powder']
##>>>

	str1 = str1.lower()
	parts = []
	for name in _m.parts.keys():
		if str1 in name.lower():
			parts.append(name)

	return parts

def inst_of_pre(prefix):
	## VER: 2010-01-15

	p_instances = []
	num = len(prefix)
	for inst in a.instances.keys():
		if inst[0:num] == prefix:
			p_instances.append(a.instances[inst])

	print 'Selected',len(p_instances),'instances with prefix',prefix

	return p_instances

def inst_select(insts=[], x=(),y=(),z=(),setrange=(), exclude=[], tryone=True):
	## VER: 2010-08-13, v1.1

	global insts_space

	if insts in empty:
		insts = a.instances

	if type_of(exclude) == 'PINSTANCE':
		exclude = [exclude]

	if setrange == ():
		x1,x2,y1,y2,z1,z2 = tospace(x,y,z)
	else:
		x1,x2,y1,y2,z1,z2 = setrange

	prior = 'x'
	if abs(y1-y2) < 1e-6:
		ndir = 'y'
	elif abs(z1-z2) < 1e-6:
		ndir = 'z'

	insts1 = []
	for inst in insts:
		if inst in exclude:
			continue

		cross = cross_of_spaces((x1,x2,y1,y2,z1,z2),poi_space(inst))
		if cross['gap_dir'] in empty:
			insts1.append(inst)
			if tryone == True:
				break

##	print len(insts1),'instances are selected by inst_select(), tryone=',tryone

	return insts1

def instance_method(inst):
	## VER: 2012-10-11, v1.0  实例的生成方法: stay, translation, rotation

	position = get_poi_position(inst)
	return position['eqv_action']

def instances_of_BC(BC):
	## VER: 2016-12-16, v1.0

##	>>> instances_of_BC('fix_RP_bpunch_A1')
##	[mdb.models['Model-1'].rootAssembly.instances['bpunch_A1']]
##	>>>

	if BC in _m.boundaryConditions.keys():
		BC = _m.boundaryConditions[BC]

	if BC not in _m.boundaryConditions.values():
		raise Exception('*** BC is required.')

	setname = BC.region[0]
	insts = instances_of_set(setname)

	return insts

def instances_of_set(setname):
	## VER: 2016-12-16, v1.0
	## 该setname显示在树形目录中，可能带'.'。如果不在此目录中，被认为是一个internal set
	## 默认该setname只对应一个region

##	>>> instances_of_set('powder_A1.mat_H10pow')
##	[mdb.models['Model-1'].rootAssembly.instances['powder_A1']]
##	>>> instances_of_set('ALEarea')
##	[mdb.models['Model-1'].rootAssembly.instances['powder_A1']]
##	>>> instances_of_set('_PickedSet42')
##	[mdb.models['Model-1'].rootAssembly.instances['die_A1']]
##	>>> instances_of_set('_PickedSet40')
##	[mdb.models['Model-1'].rootAssembly.instances['bpunch_A1']]
##	>>>

	if type_of(setname) != 'STR':
		raise Exception('*** setname is required.')

	insts = []
	if '.' in setname:
		loc = setname.find('.')
		inst = check_inst(setname[:loc])
		insts = [inst]
	else:
		if setname in a.sets.keys():
			set1 = a.sets[setname]
		elif setname in a.allInternalSets.keys():
			set1 = a.allInternalSets[setname]
		else:
			raise Exception('*** setname is not an intrnal set')

		insts = leaf_ids_to_insts(set1.instances)
		insts = real_insts(insts)

	return insts

def insts_by_set(setname):
	## VER: 2010-10-27, v1.5

	if len(a.instances) == 0:
		return []

	instances = []
	key1 = []
	for inst in a.instances.keys():
		if setname in a.instances[inst].sets.keys():
			key1.append(inst)
			inst1 = a.instances[inst]
			instances.append(inst1)

	if len(instances) == 0:
		try:
			vpnow = get_vpnow()
			odb = vpnow.displayedObject
			a1 = odb.rootAssembly
			setname = setname.upper()
			for inst in a1.instances.keys():
				if setname in a1.instances[inst].elementSets.keys():
					key1.append(inst)
					inst1 = a1.instances[inst]
					instances.append(inst1)
		except:
			pass

##	if len(instances) > 0:
##		print 'For setname=',setname,': Found instance=',key1
##	else:
##		print 'No instance with setname=',setname,'. It maybe in the rootAssembly. Please check.'

	return instances

def insts_of_part(part):
	## VER: 2013-03-03, v1.0

	part = check_part(part)
	insts = []
	for inst in a.instances.values():
		if inst.part == part:
			insts.append(inst)

	return insts

def insts_of_parts(*partlist):
	## VER: 2011-02-26, v1.6

	partlist = tolist(partlist)
	partlist = real_parts(partlist)

	insts = []
	for inst in a.instances.values():
		p1 = inst.part
		if p1 in partlist:
			insts.append(inst)

	num1 = len(insts)
##	if num1 > 0:
##		print num1,'instances selected by defined parts:',part_names
##		print 'Instances of parts',poi_names(partlist),'are',poi_names(insts)

	return insts

def find_hole_edges(poi,edges=None,center_x=None,center_y=None,center_z=None,sort='z'):
	## VER: 2016-11-15, v1.5
	## edges = find_hole_edges('green1',center_x=0,center_y=0,sort='z')

	poi = check_pia(poi)
	if edges not in empty:
		edges = tolist(edges)
	else:
		edges = tolist(poi.edges)

	if len(edges) == 0:
		raise Exception('*** geometry edge is required.')

	edges = exterior_edges(edges)

	newlist = []
	for edge in edges:
		if edge_shape(edge) not in ['arc','circle','spline']:
			continue

		faces = edges_to_faces(edge)
		for face in faces:
			if face_shape(face) in ['conical','cylindrical']:
				if (center_x,center_y,center_z) != (None,None,None):
					center,vector0,axis = center_axis_of_cylind_face(face)
					x0,y0,z0 = center
					if is_number(center_x) and center_x!= x0:
						continue
					if is_number(center_y) and center_y!= y0:
						continue
					if is_number(center_z) and center_z!= z0:
						continue
				newlist.append(edge)
				continue

	edges = newlist
	if len(edges) > 0:
		if sort in ['x','y','z']:
			dict1 = {}
			for edge in edges:
				space = objs_space(edge)
				if sort == 'x':
					loc = (space[0] + space[1])/2
				elif sort == 'y':
					loc = (space[2] + space[3])/2
				elif sort == 'z':
					loc = (space[4] + space[5])/2

				loc = round(loc,3)
				if loc not in dict1.keys():
					dict1[loc] = []
				dict1[loc].append(edge)

			edges = []
			for loc in _sort(dict1.keys()):  ## sort by loc first
				if len(dict1[loc]) == 1:
					edges.append(dict1[loc])
				else:
					dict2 = {}
					for edge in dict1[loc]:
						length = edge_length(edge)
						length = round(length,3)
						if length not in dict2.keys():
							dict2[length] = []
						dict2[length].append(edge)

					for length in _sort(dict2.keys()):  ## Then sort by length
						edges = edges + dict2[length]

		elif sort == 'size':
			dict2 = {}
			for edge in edges:
				length = edge_length(edge)
				length = round(length,3)
				if length not in dict2.keys():
					dict2[length] = []
				dict2[length].append(edge)

			edges = []
			for length1 in _sort(dict2.keys()):  ## sort by length
				edges = edges + dict2[length1]

	return edges

def find_loc(poi,curves=None, edges=None, vertices=None, faces=None, x=None,y=None, z=None, groupX=None, groupY=None, groupZ=None ):
	## VER: 2015-04-14, v1.9，找到的位置可能有很多个小数点。
	## use for sketch. For poi, use vertice_select()
	## reference: locs_of_poi() use divide method
	## ★locs_of_sketch()获得多个vlocs(更加可靠)，而find_loc()仅获得一个loc
	## reference: loc_at()

	## Example: find_loc('s_ejector',x=6) = (5.99999999999709, -7.69789581639261)
	## find_loc('s_ejector',y=MAX,groupX=MIN) = (9.76, 0.0)
	## Example: round_sketch_corner('s_punch',radius=0.18, loc=find_loc('s_punch',y=MIN,groupX=MIN))

	if is_poi(poi):
		poi = check_poi(poi)
		vertices = vertice_select(poi,edges=edges, faces=faces,vertices=vertices, x=x,groupY=groupY, y=y, groupX=groupX, z=z, groupZ=None)
		loc = None
		if len(vertices) > 0:
			loc = vertices[0].pointOn[0]
		else:
			x,y,z = real_xyz(poi,x=x,y=y)
			if is_numbers(x) or is_numbers(y):
				temp_part = temp_part_of_poi(poi)
				if is_numbers(x):
					divide(temp_part,x=x)
				if is_numbers(y):
					divide(temp_part,y=y)

				vertices = vertice_select(temp_part,edges=edges, faces=faces,vertices=vertices, x=x,groupY=groupY, y=y, groupX=groupX, z=z, groupZ=None)
				if len(vertices) > 0:
					loc = vertices[0].pointOn[0]

##				del _m.parts[temp_part]   ## Error
				del_parts(temp_part)

			if loc in empty:
				raise Exception('*** Fail to get the loc.')

##			print 'loc=',loc
			x1,y1,z1 = loc
			if abs(x1) < 1e-6:
				x1 = 0

			if abs(y1) < 1e-6:
				y1 = 0

			if abs(z1) < 1e-6:
				z1 = 0

			loc = (x1,y1,z1)


	else:
		sketch = poi
		sketch = check_sketch(sketch)
		sketch2 = copy_sketch(sketch)

		if all_regular_geometry(sketch) in empty:
			raise Exception('*** No regular geometry in the sketch yet.')

		loc = None
		if x in empty and y in empty:
			if groupX not in empty:
				x = groupX
				groupX = None
			elif groupY not in empty:
				y = groupY
				groupY = None

		if x not in empty:
			x = real_xy_sketch(sketch2,x=x,Xonly=True)
			divide_geometry(sketch2,x=x)
			locs = points_at_geometry_y(sketch2,x=x)

			if groupY == MAX:
				loc = locs[-1]
			elif groupY == MIN:
				loc = locs[0]
			elif groupY == MID:
				x0 = x
				y0 = (locs[0][1] + locs[-1][1])/2
				loc = (x0,y0)
			elif type_of(groupY) in numerics:
				loc = (x,groupY)
			else:
				loc = locs[0]

		elif y not in empty:
			y = real_xy_sketch(sketch2,y=y,Yonly=True)
			divide_geometry(sketch2,y=y)
			locs = points_at_geometry_x(sketch2,y=y)
##			print fnln(),'y=',y
##			print fnln(),'locs=',locs
##			raise Exception

			if groupX == MAX:
				loc = locs[-1]
			elif groupX == MIN:
				loc = locs[0]
			elif groupX == MID:
				y0 = y
				x0 = (locs[0][0] + locs[-1][0])/2
				loc = (x0,y0)
			elif type_of(groupX) in numerics:
				loc = (groupX, y)
			else:
				loc = locs[0]

		show_sketch(sketch)
		del _m.sketches[sketch2]

		x1,y1 = loc
		if abs(x1) < 1e-6:
			x1 = 0

		if abs(y1) < 1e-6:
			y1 = 0

		loc = (x1,y1)

	return loc

def find_mdb_insts(*str1):
	## VER: 2012-01-05, v1.3
	## 例如：find_mdb_insts('frL','frS')的结果为[frL_A1,frS_A1]

	shorts = tolist(str1)
	if type_of(shorts[0]) != 'STR':
		raise Exception('****** A string is needed.')

	insts = []
	for str1 in shorts:
		len1 = len(str1)
		for name in a.instances.keys():
			if str1.upper() == name[:len1].upper():
				if a.instances[name] not in insts:
					insts.append(a.instances[name])

	print '--->',len(insts),'instances are found with prefix =',shorts,':',poi_names(insts)

	return insts

def find_mdb_parts(*str1):
	## VER: 2012-01-05, v1.3

	shorts = tolist(str1)
	if type_of(shorts[0]) != 'STR':
		raise Exception('****** A string is needed.')

	parts = []
	for str1 in shorts:
		len1 = len(str1)
		for name in _m.parts.keys():
			if str1.upper() == name[:len1].upper():
				if _m.parts[name] not in parts:
					parts.append(_m.parts[name])

	print '--->',len(parts),'parts are found with prefix =',shorts,':',poi_names(parts)

	return parts

def find_odb_insts(*str1):
	## VER: 2011-12-14, v1.1

	shorts = tolist(str1)
	if type_of(shorts[0]) != 'STR':
		raise Exception('****** A string is needed.')

	insts = []
	names = []
	for str1 in shorts:
		len1 = len(str1)
		for name in oa.instances.keys():
			inst = oa.instances[name]
			if str1.upper() == name[:len1].upper():
				insts.append(inst)
				names.append(name)

			if str1.upper() in inst.elementSets.keys() and inst not in insts:
				insts.append(inst)

	print '--->',len(insts),'instances are found with prefix =',shorts,':',names

	return insts

def int6(num):
	## VER: 2017-08-02, v1.0 比round(x,6)好，更能反映坐标位置。

##	>>> int6(6)
##	6.0

	if is_number(num) == False:
		raise Exception('*** a number is required.')

	num1 = int(num*1e6)/1e6

	return num1

function_labels['intersect_point_of_4points_edges'] = 'intersect','point','edge','line','vector','vertice'
def intersect_point_of_4points_edges(points1,points2,ndir='z'):
	## VER: 2017-07-27, v1.0 这四个点必须在共同的平面内。可以根据平面图（已经倒角）绘制草图
	## reference: intersect_point_of_two_edges()

##	>>> intersect_point_of_4points_edges([(42.499,0.,0.),(51.99016,0.,0.)],[(64.466,13.5,0.),(63.71807,7.408598,0.)])
##	(62.808408, 0.0)

	if type_of(points1) == 'edges':
		pt1,pt2 = edges_to_vertices(points1)
		loc1 = pt1.pointOn[0]
		loc2 = pt2.pointOn[0]
	else:
		if is_location(points1):  ## such as a vector
			loc1 = (0,0,0)
			loc2 = points1
		else:
			loc1,loc2 = points1

	if type_of(points2) == 'edges':
		pt1,pt2 = edges_to_vertices(points2)
		loc3 = pt1.pointOn[0]
		loc4 = pt2.pointOn[0]
	else:
		if is_location(points2):  ## such as a vector
			loc3 = (0,0,0)
			loc4 = points2
		else:
			loc3,loc4 = points2

	loc1 = point_loc(loc1)
	loc2 = point_loc(loc2)
	loc3 = point_loc(loc3)
	loc4 = point_loc(loc4)

	ndir = ndir.lower()
	if ndir not in ['x','y','z']:
		raise Exception('*** ndir should be x,y or z')

	if len(loc1) == 3 or len(loc2) == 3 or len(loc3) == 3 or len(loc4) == 3:
		if ndir == 'z':
			loc1 = loc1[0],loc1[1]
			loc2 = loc2[0],loc2[1]
			loc3 = loc3[0],loc3[1]
			loc4 = loc4[0],loc4[1]
		elif ndir == 'x':  ## Y is x
			loc1 = loc1[1],loc1[2]
			loc2 = loc2[1],loc2[2]
			loc3 = loc3[1],loc3[2]
			loc4 = loc4[1],loc4[2]
		elif ndir == 'y':
			loc1 = loc1[0],loc1[2]
			loc2 = loc2[0],loc2[2]
			loc3 = loc3[0],loc3[2]
			loc4 = loc4[0],loc4[2]

	if len(loc1) !=2 or len(loc2) != 2 or len(loc3) != 2 or len(loc4) != 2:
		raise Exception('*** point location should be such as (x,y)')

	x1,y1 = loc1
	x2,y2 = loc2
	x3,y3 = loc3
	x4,y4 = loc4

	## line1: y = K1*x + B1, 通过loc1和loc2
	## line2: y = K2*x + B2, 通过loc3和loc4

	K1 = (y2-y1)/(x2-x1)
	K2 = (y4-y3)/(x4-x3)
	B1 = y1 - K1*x1
	B2 = y3 - K2*x3

	if K1 - K2 == 0:
		raise Exception('*** No intersect point for two parallel lines.')

	## intersect point
	x0 = (B2-B1)/(K1-K2)
	y0 = (B2*K1 - B1*K2)/(K1-K2)

	## 不要采取四舍五入获得点的位置，而是通过取整
##	x0 = round(x0,6)
##	y0 = round(y0,6)

	x0 = int(x0*1e6)/1e6
	y0 = int(y0*1e6)/1e6

	return (x0,y0)

function_labels['intersect_point_of_two_edges'] = 'intersect','point','edge','line','vector','vertice'
def intersect_point_of_two_edges(edge1,edge2):
	## VER: 2015-09-06, v1.2
	## 获得线线交点。
	## reference: intersect_point_of_4points_edges()

	poi = get_parent(edge1)
	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	if type_of(edge1) not in ['edges','DATUMAXIS'] or type_of(edge2) not in ['edges','DATUMAXIS']:
		raise Exception('*** an edge or datum axis is required.')

	angle = get_intersect_angle(edge1,edge2)
	if angle[0] == 0:
		raise Exception('*** Edges are parallel.')

	loc1, loc2 = two_points_of_edge(edge1)   ## loc1, and loc2 are location

	pt1 = get_project_point(poi, point=loc1, edge=edge2)  ## return datum point
	x1,y1,z1 = pt1.pointOn

	pt2 = get_project_point(poi, point=loc2, edge=edge2)	## return datum point
	x2,y2,z2 = pt2.pointOn

	d1 = get_distance(loc1, (x1,y1,z1))
	d2 = get_distance(loc2, (x2,y2,z2))

	d11 = get_distance(loc1,loc2)
	d22 = get_distance((x1,y1,z1), (x2,y2,z2))

	if PK(d1,d2) == 0 and PK(d11,d22) == 0:
		raise Exception('*** Lines are parallel')

	if d1 == 0:
		loc = loc1
	elif d2 == 0:
		loc = loc2
	else:
		k = d1/d2
		vect1 = create_datum_axis_by_2points(poi,start=loc1,end=(x1,y1,z1))
		vect2 = create_datum_axis_by_2points(poi,start=loc2,end=(x2,y2,z2))

		x10,y10,z10 = vect1.direction
		x20,y20,z20 = vect2.direction

		x10,y10,z10 = check_values(x10,y10,z10)
		x20,y20,z20 = check_values(x20,y20,z20)

		if (x10,y10,z10) != (x20,y20,z20) and (x10,y10,z10) != (-x20,-y20,-z20):
			print '*** No intersect point between these two axis.'
			return ()

		if (x10,y10,z10) == (-x20,-y20,-z20):
			k = -k

		x = (x1 - k*x2)/(1-k)
		y = (y1 - k*y2)/(1-k)
		z = (z1 - k*z2)/(1-k)
		x,y,z = check_values(x,y,z)
		loc = (x,y,z)

	create_datum_point(poi, loc=loc)
	print fnln_fnln(),'Intersect point is shown by:', poi.features.keys()[-1]

	return loc

def insts_to_cae(insts, caename='some_insts'):
	## VER: 2014-07-17, v1.1

	setting_display()
	get_current_model()

	if type_of(insts) == 'STR':
		if insts in a.sets.keys():
			setname = insts
			set1 = a.sets[setname]
			insts = leaf_ids_to_insts(set1.instances)
		else:
			insts,caename = caename,insts

	insts = real_insts(insts)
	if insts	in empty:
		raise Exception('*** insts are required.')

	parts = parts_of_insts(insts)
	partnames = poi_names(parts)
	instnames = poi_names(insts)

	caenames = get_files_in_dir(extension='cae')
	caename = new_key(caenames,caename)

	mdb.saveAs('_temp')

	get_current_model()
	show_hiden_insts()

	if a.sets.keys() not in empty:
		a.deleteSets(setNames=totuple(a.sets.keys()))

	if a.surfaces.keys() not in empty:
		a.deleteSurfaces(surfaceNames=totuple(a.surfaces.keys()))

	insts1 = unselect(a.instances.keys(),instnames)
	del_insts(insts1)

	parts = unselect(_m.parts.keys(),partnames)
	del_parts(parts)

	mdb.saveAs(caename)
	get_current_model()

	mdb.save()

	return

def insts_to_region(insts,info=''):
	## VER: 2015-05-15, v1.2

	insts = real_insts(insts)
	objs = None

	for inst in insts:
		if len(inst.cells) > 0:
			if objs in empty:
				objs = inst.cells[:]
			else:
				objs = objs + inst.cells[:]
		elif len(inst.faces) > 0:
			if objs in empty:
				objs = inst.faces[:]
			else:
				objs = objs + inst.faces[:]
		elif len(inst.edges) > 0:
			if objs in empty:
				objs = inst.edges[:]
			else:
				objs = objs + inst.edges[:]
		else:
			if info == 'elements':
				if len(inst.elements) > 0:
					if objs in empty:
						objs = inst.elements[:]
					else:
						objs = objs + inst.elements[:]
			elif info == 'nodes':
				if len(inst.nodes) > 0:
					if objs in empty:
						objs = inst.nodes[:]
					else:
						objs = objs + inst.nodes[:]
			else:
				raise Exception('*** Please specify elements region or nodes region. BC is node region.')

	print fnln_fnln(),'obj_type=',type_of(objs[0])
	if objs not in empty:
		region = create_set(objs=objs)
	else:
		raise Exception('*** Fail to get the region from insts')

	return region

def intersect_point_of_line_and_plane(line,plane):
	## VER: 2015-09-06, v1.1
	## 获得线面交点。

	poi = get_parent(line)
	poi = check_pia(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	if type_of(plane) in ['edges','DATUMAXIS'] and type_of(line) in ['faces','DATUMPLANE']:
		line, plane = plane, line

	angle = get_intersect_angle(line,plane)
	if angle[0] == 0:
		raise Exception('*** line is parallel to plane.')

	loc1, loc2 = two_points_of_edge(line)

	pt1 = get_project_point(poi, point=loc1, face=plane)
	x1,y1,z1 = pt1.pointOn

	pt2 = get_project_point(poi, point=loc2, face=plane)
	x2,y2,z2 = pt2.pointOn

	d1 = get_distance(loc1, (x1,y1,z1))
	d2 = get_distance(loc2, (x2,y2,z2))

	d11 = get_distance(loc1,loc2)
	d22 = get_distance((x1,y1,z1), (x2,y2,z2))

	if PK(d1,d2) == 0 and PK(d11,d22) == 0:
		raise Exception('*** line is parallel to plane')

	if d1 == 0:
		loc = loc1
	elif d2 == 0:
		loc = loc2
##	elif PK(d1,d2) == 0:  ## k=1
##		x = (x1+x2)/2
##		y = (y1+y2)/2
##		z = (z1+z2)/2
##		loc = (x,y,z)
	else:
		k = d1/d2
		vect1 = create_datum_axis_by_2points(poi,start=loc1,end=(x1,y1,z1))
		vect2 = create_datum_axis_by_2points(poi,start=loc2,end=(x2,y2,z2))

		vect1 = vect1.direction
		vect2 = vect2.direction

		if vect1[0]*vect2[0] < 0:
			k = -k
		elif vect1[1]*vect2[1] < 0:
			k = -k
		elif vect1[2]*vect2[2] < 0:
			k = -k

		x = (x1 - k*x2)/(1-k)
		y = (y1 - k*y2)/(1-k)
		z = (z1 - k*z2)/(1-k)
		x,y,z = check_values(x,y,z)
		loc = (x,y,z)

	create_datum_point(poi, loc=loc)
	print fnln_fnln(),poi.features.keys()[-1]

	return loc


def intervals(x1,x2,num='',size=''):
	## VER: 2010-08-10, v1.0

	if x1 > x2: x1,x2 = x2,x1

	list1 = [x1 + _nearby, x2 - _nearby]

	if num == '' and size == '':
		num = 5

	if num != '':
		step = (x2 - x1)/float(num)
		for i in range(1,num):
			list1.append(x1 + step*i)

	elif size != '':
		x = x1 + size
		while x < x2:
			list1.append(x1)
			x = x + size

	list1.sort()

	return list1

def is_2D_or_3D(poi=None):
	## VER: 2014-05-01, v1.0
	## reference: is_faces_model(),is_cells_model()

	part = None
	if poi not in empty:
		part = check_poi(poi)
		if type_of(part) == 'PINSTANCE':
			part = poi.part
	else:
		for part1 in _m.parts.values():
			if len(part1.faces) > 0:
				part = part1
				break

	if part in empty:
		raise Exception('*** Fail to determine 2D or 3D')

	shape1 = part_shape(part)[1]
	if '2D' in shape1:
		shape = '2D'
	elif '3D' in shape1:
		shape = '3D'
	else:
		raise Exception('*** Fail to determin 2D or 3D')

	return shape

def is_3D_loc(loc):
	## VER: 2012-12-20, v1.0

	result = True
##	loc = totuple(loc)

	while True:
		if type_of(loc) != 'TUPLE':
			result = False
			break

		if len(loc) != 3:
			result = False
			break

		x1,y1,z1 = loc
		if type_of(x1) not in numerics or type_of(y1) not in numerics or type_of(z1) not in numerics:
			result = False
		break

	return result

def is_amplitude(amp):
	## VER: 2014-11-18, v1.0

	if amp in _m.amplitudes.keys():
		result = True
	else:
		result = False

	return result

def is_cylind_faces(faces):
	## VER: 2012-12-20, v1.0   观察面内的点有无曲率。一个面为平面，但组成该面的线可能有曲线。

	faces = tolist(faces)

	result = True
	radius = get_radius(faces[0])
	if not is_number(radius):
		result = False

	if result == True:
		faces1 = random_sub_set(faces,num=4)
		for face in faces1:
			radius = get_radius(face)
			if not is_number(radius):
				result = False
				break

	return result

def _len(obj):
	## VER: 2014-10-14, v1.0

	num = -1
	try:
		num = len(obj)
	except:
		pass

	return num

def is_cells_model():
	## VER: 2014-11-19, v1.0

	result = False
	for inst in a.instances.values():
		if len(inst.cells) > 0:
			result = True
			break

	return result

function_labels['is_empty'] = 'empties','None','list','length'
def is_empty(obj):
	## VER: 2014-10-14, v1.4
	## reference: in empty, 但is_empty()的用途更广

	result = False
	if obj in empty:
		result = True
	else:
		if _len(obj) == 0:  ## 一个REPOSITORY类型的对象数据，print的结果为{}，但是len()的结果为0，且并不在empty中。例如，草图中只有点，没有线，此时sketch.geometry就是这种情形。
			result = True	## 根据长度来判断是否空。

##		result = False
##		try:
##			length = len(obj)  ## 根据长度来判断是否空。
##			if length == 0:  ## 一个REPOSITORY类型的对象数据，print的结果为{}，但是len()的结果为0，且并不在empty中。例如，草图中只有点，没有线，此时sketch.geometry就是这种情形。
##				result = True
##		except:
##			pass

	return result

def is_empty_repository(obj):
	## VER: 2013-07-18, v1.0

	result = False
	if type_of(obj) == 'REPOSITORY':
		if len(obj.keys()) == 0:
			result = True

	return result

def is_faces_model():
	## VER: 2014-11-19, v1.0

	have_cells = False
	for inst in a.instances.values():
		if len(inst.cells) > 0:
			have_cells = True
			break

	result = False
	if have_cells == False:
		for inst in a.instances.values():
			if len(inst.faces) > 0:
				result = True
				break

	return result


def is_inst(p):
	## VER: 2014-08-04, v1.0

	result = False
	if p in a.instances.keys() or p in a.instances.values():
		result = True

	return result

is_instance = is_inst

def is_INT(num):
	## VER: 2014-11-13, v1.0

	if type_of(num) in ['INT','LONT']:
		result = True
	else:
		result = False

	return result

is_int = is_integer = is_INT

##	>>> is_int
##	<function is_INT at 0x756CAEB0>
##	>>>

def is_jishu(num):
	## VER: 2014-09-11, v1.0  奇数

	if type_of(num) == 'INT' and num == int(num/2.0)*2 + 1:
		result = True
	else:
		result = False

	return result

def is_oushu(num):
	## VER: 2014-09-11, v1.0  偶数

	if type_of(num) == 'INT' and num == int(num/2.0)*2:
		result = True
	else:
		result = False

	return result

def is_part(p):
	## VER: 2014-07-31, v1.0

	result = False
	if p in _m.parts.values() or p in _m.parts.keys():
		result = True

	return result


def is_plane(face):
	## VER: 2014-07-15, v1.1

	curvature = get_curvature(face)  ## 确定是否是平面   edge被倒角之后，可能没有radius，但有curvature
	radius = get_radius(face)

	if radius == 'flat':
		result = True
	else:
		result = False

	return result

def is_plane_list(faces):
	## VER: 2012-12-19, v1.0   观察面内的点有无曲率。一个面为平面，但组成该面的线可能有曲线。

	faces = tolist(faces)

	result = True
	curvature = get_curvature(faces[0])
	if curvature not in empty:
		result = False

	if result == True:
		faces1 = random_sub_set(faces,num=4)
		for face in faces1:
			curvature = get_curvature(face)
			if curvature not in empty:
				result = False
				break

	return result

def is_pia(p):
	## VER: 2014-08-04, v1.1

	result = False
	if p in _m.parts.values() or p in _m.parts.keys() or p in a.instances.values() \
		or p in a.instances.keys() or type_of(p) == 'ASSEMBLY':
		result = True

	return result

def is_poi(p):
	## VER: 2014-07-31, v1.0

	result = False
	if p in _m.parts.values() or p in _m.parts.keys() or p in a.instances.values() \
		or p in a.instances.keys():
		result = True

	return result

def is_STR(str1):
	## VER: 2014-11-13, v1.0

	if type_of(str1) == 'STR' and str1 != '':
		result = True
	else:
		result = False

	return result

def is_dof(dof):
	## VER: 2016-09-01, v1.0

	dof = totext(dof).lower()
	result = False
	if dof in ['u1','u2','u3','ur1','ur2','ur3','ux','uy','uz','urx','ury','urz']:
		result = True

	return result

def is_edge_loop(edges,include_line=False):
	## VER: 2016-07-28, v1.4  这里的edge是几何edge

##	>>> is_edge_loop(edges)
##	False
##	>>> is_edge_loop(edges,include_line=True)
##	True
##	>>>

	edges = tolist(edges)
	if edges in empty:
		raise Exception('*** edges are required.')

	result = True

	determined = False
	if len(edges) > 1:
		for edge in edges:
			if len(edge.getVertices()) == 1:  ## 其中一条边是一个完整的circle
				determined = True  ## i.e., result = False
				result = False
				break

	if not determined:
		vertices = edges_to_vertices(edges)

		if len(edges) == len(vertices):
			poi = get_poi(edges[0])
			if len(poi.cells) == 0:
				ext_edges = exterior_edges(poi)
				for vertice in vertices:
					edges1 = tolist(vertice.getEdges())
					edges1 = get_common(edges1,ext_edges)

					if not list1_in_list2(edges1,edges):
						result = False
						break
			else:
				if include_line == False:
					for edge in edges:
						shape1 = edge_shape(edge)
						if shape1 == 'line':
							result = False
							break
		else:
			result = False

##	if len(edges) == 1:
##		e1 = edges[0]
##		if len(e1.getAdjacentEdges()) == 0 and len(e1.getFaces()) > 0:
##			result = True
##	elif len(edges) >=2:
##		vertices = edges_to_vertices(edges)
##		if len(edges) == len(vertices):
##			result = True
##			if include_line == False:
##				for edge in edges:
##					shape1 = edge_shape(edge)
##					if shape1 == 'line':
##						result = False
##						break

	return result

def is_nodes(nodes):
	## VER: 2016-11-17, v1.0

	nodes = tolist(nodes)
	if type_of(nodes[0]) == 'nodes':
		result = True
	else:
		result = False

	return result

def is_none_empty_structure(obj):
	## VER: 2013-07-24, v1.0

	result = False
	if mems_num(obj) > 0 or keys_num(obj) > 0:
		result = True

	return result

def is_feature_edge_node(node):
	## VER: 2016-12-06, v1.1 判断是否为几何边缘线上的点。
	## 该函数需要abaqus 6.14以上版本。

	if type_of(node) != 'nodes':
		return False

	p1 = get_parent(node)
	result = False

	shape = part_shape(p1)[1]
	if '3D_solid' in shape:
		elems = len(node.getElements())
		if elems <=2:
			result = True
		else:
			try:
				nodes1 = node.getNodesByFeatureEdge(5)
			except:
##				print fnln(),'*** Need at least abaqus 6.14 version to get feature edge nodes'
				return result

			if len(nodes1) > 0:
				result = True
			else:
				nodes2 = node.getNodesByFeatureEdge(20)
				if len(nodes2) > 0:
					result = True

	return result

def is_geometry(g1,sketch=None):
	## VER: 2014-10-29, v1.0
	## type_of(g1)得到的是geometry的类型，如regular_line
	## construction line is also a geometry

	result = False
	if is_sketch(g1):
		g1,sketch = sketch,g1

	try:
		if '.geometry' in repr(g1):
			if sketch in empty:
				sketch = get_parent(g1)
			else:
				sketch = check_sketch(sketch)

			if type_of(sketch) == 'sketch' and g1 in sketch.geometry.values():
				result = True
	except:
		pass

	return result

def is_in_line(point1, point2, point3):
	## VER: 2014-10-17, v1.0

	vector1 = vector_of_two_points(point1, point2)
	vector2 = vector_of_two_points(point1, point3)

	if is_parallel_vector(vector1, vector2):
		result = True
	else:
		result = False

	return result


def is_inner_plane(face, printResult=False):
	## VER: 2013-11-12, v1.1

	result = 'unknow'
	curvature = get_curvature(face)
	if curvature not in empty:
		result = False
	else:
		poi = get_poi(face)
		normal = face_normal_by_num(face)
		dir1,dir2,dir3 = normal
		x0,y0,z0 = face.pointOn[0]

##		print fnln(),'normal=',normal
		if normal in xdir:
			if dir1 == 1:
				cells = cell_select(poi,x=x0 + 0.001, printResult=printResult)
			else:
				cells = cell_select(poi,x=x0 - 0.001, printResult=printResult)

			if cells in empty:
				result = False
			else:
				result = True

		elif normal in ydir:
			if dir2 == 1:
				cells = cell_select(poi,y=y0 + 0.001, printResult=printResult)
			else:
				cells = cell_select(poi,y=y0 - 0.001, printResult=printResult)

			if cells in empty:
				result = False
			else:
				result = True

		elif normal in zdir:
			if dir3 == 1:
				cells = cell_select(poi,z=z0 + 0.001, printResult=printResult)
			else:
				cells = cell_select(poi,z=z0 - 0.001, printResult=printResult)

			if cells in empty:
				result = False
			else:
				result = True

	return result

def is_location(tuple1):
	## VER: 2016-05-24, v1.1

##>>> is_location((5,))
##True
##>>>

	result = False
	if type_of(tuple1) == 'TUPLE' and is_numbers(tuple1) and len(tuple1) in [2,3]:
		result = True

	return result

def is_locations(locs):
	## VER: 2017-08-04, v1.0

	result = True
	if type_of(locs) not in ['LIST','TUPLE']:
		result = False
	else:
		for item in locs:
			if is_location(item) == False:
				result = False
				break

	return result

def is_number(num):
	## VER: 2014-09-17, v1.0
	## reference: is_numbers()

	## type_of(1e37) == 'FLOAT'

	if type_of(num) in ['INT','LONG','FLOAT']:
		result = True
	else:
		result = False

	return result

def is_numbers(*values):
	## VER: 2014-07-15, v1.0
	## reference: is_number()

##	>>> is_numbers(5)
##	True
##	>>> is_numbers([3,6])
##	True
##	>>> is_numbers(3,6)
##	True
##	>>>

	values = tolist(values)
	if values not in empty:
		result = True
		for value in values:
			if type_of(value) not in numerics:
				result = False
				break
	else:
		result = False

	return result

def is_obj(obj,repository):
	## VER: 2014-08-25, v1.0

	result = False
	if obj in repository.keys() or obj in repository.values():
		result = True

	return result

def is_objs_sequence(objs):
	## VER: 2012-12-19, v1.0

	result = True
	if type_of(objs) in ['TUPLE','LIST'] and objs not in empty:
		objs1 = randomize(objs)
		objs1 = objs1[:3] + [objs[0],objs[-1]]
		for obj in objs:
			if type_of(obj) in basic_types:
				result = False
				break
	else:
		result = False

	return result

def is_odb_inst(inst):
	## VER: 2014-09-02, v1.0

	if type_of(inst) == 'STR':
		inst = inst.upper()

	result = False
	if inst in oa.instances.keys() or inst in oa.instances.values():
		result = True

	return result

is_odb_instance = is_odb_inst

def is_outer_plane(face, printResult=False):
	## VER: 2013-11-12, v1.1

	result = 'unknow'
	curvature = get_curvature(face)
	if curvature not in empty:
		result = False
	else:
		poi = get_poi(face)
		normal = face_normal_by_num(face)
		x0,y0,z0 = face.pointOn[0]
		dir1,dir2,dir3 = normal

##		print fnln(),'normal=',normal
		if normal in xdir:
			if dir1 == 1:
				cells = cell_select(poi,x=x0 + 0.001, printResult=printResult)
			else:
				cells = cell_select(poi,x=x0 - 0.001, printResult=printResult)

			if cells in empty:
				result = True
			else:
				result = False

		elif normal in ydir:
			if dir2 == 1:
				cells = cell_select(poi,y=y0 + 0.001, printResult=printResult)
			else:
				cells = cell_select(poi,y=y0 - 0.001, printResult=printResult)

			if cells in empty:
				result = True
			else:
				result = False

		elif normal in zdir:
			if dir3 == 1:
				cells = cell_select(poi,z=z0 + 0.001, printResult=printResult)
			else:
				cells = cell_select(poi,z=z0 - 0.001, printResult=printResult)

			if cells in empty:
				result = True
			else:
				result = False

	return result


def is_parallel_vector(vector1,vector2):
	## VER: 2012-12-20, v1.1

	result = False
	if vector1 == vector2:
		result = True
	else:
		x1,y1,z1 = vector1
		x2,y2,z2 = vector2

		if PK(x1,-x2) == 0 and PK(y1,-y2) == 0 and PK(z1,-z2) == 0:
			result = True   ## reversed direction
		elif PK(x1,x2) == 0 and PK(y1,y2) == 0 and PK(z1,z2) == 0:
			result = True  ## same direction

	return result

def is_RP(RP):
	## VER: 2016-10-20, v1.1
	## RP和datum point的feature都有xValue,yValue,zValue

##	>>> is_RP(p1.features['O'])
##	True
##	>>> is_RP(p1.features['Datum pt-1'])
##	False
##	>>> get_RP_objs('frL')
##	[mdb.models['Model-1'].parts['frL'].features['O']]
##	>>>

	result = False
	if type_of(RP) == 'referencePoints':
		result = True
	else:
		if type_of(RP) == 'FEATURE':
			obj = feature_to_obj(RP)
			if type_of(obj) == 'referencePoints':
				result = True

	return result

def is_same_axis(axis1,axis2):
	## VER: 2012-12-20, v1.0

	vector1,center1 = axis1
	vector2,center2 = axis2

	result = False
	if axis1 == axis2:
		result = True
	else:
		vector3 = center2[0] - center1[0], center2[1] - center1[1], center2[2] - center1[2]
		if is_parallel_vector(vector1,vector2) and is_parallel_vector(vector1,vector3):
			result = True

	return result

def is_same_loc(loc1,loc2):
	## VER: 2014-07-11, v1.1

	if is_location(loc1) == False or is_location(loc2) == False:
		raise Exception('*** Two locs are required for comparison')

	same = True
	if PK(loc1[0],loc2[0],err=1e-4) != 0:
		same = False

	if PK(loc1[1],loc2[1],err=1e-4) != 0:
		same = False

	if len(loc1) != len(loc2):
		same = False

	if len(loc2) == 3 and PK(loc1[2],loc2[2],err=1e-4) != 0:
		same = False

	return same

function_labels['is_same_vector'] = 'vector','same','parallel','axis'
def is_same_vector(vector1,vector2):
	## VER: 2017-08-04, v1.0

##	>>> is_same_vector((0,5,0),(0,-1,0))
##	True

	vector1 = positive_vector(vector1)
	vector2 = positive_vector(vector2)

	if vector1 == vector2:
		result = True
	else:
		result = False

	return result

def is_similar_edge(edge1,edge2):
	## VER: 2012-12-10, v1.0

	similar = True
	while True:
		ndir1 = edge_dir(edge1)
		ndir2 = edge_dir(edge2)
##		print 'ndir=',ndir1
		if ndir1 != ndir2:
##			print 'unsimilar ndir'
			similar = False
			break

		length1 = edge_length(edge1)
		length2 = edge_length(edge2)
		if PK(length1,length2) != 0:
##			print 'unequal length'
			similar = False
			break

		space1 = space_of_edges(edge1)
		x1,y1,z1 = space1[0:2],space1[2:4], space1[4:6]

		space2 = space_of_edges(edge2)
		x2,y2,z2 = space2[0:2],space2[2:4], space2[4:6]

		if ndir1 == 'x':
			if space1[0:2] != space2[0:2]:
				similar = False
		elif ndir1 == 'y':
			if space1[2:4] != space2[2:4]:
				similar = False
		elif ndir1 == 'z':
			if space1[4:6] != space2[4:6]:
				similar = False
##				print 'unequal space'
		elif ndir1 == 'circular':
			radius1 = get_radius(edge1)
			radius2 = get_radius(edge2)
			if is_numbers(radius1,radius2) and PK(radius1,radius2) != 0:
				similar = False
		else:
			similar = False ## 包括ndir=slope

		break

	return similar

def is_similar_part(part1,part2):
	## VER: 2012-12-21, v1.0, 判断两个part是否为相似的两个part，只是名字或位置不同。

	part1 = check_part(part1)
	part2 = check_part(part2)

	similar = True
	while True:
		if len(part1.cells) != len(part2.cells):
			similar = False
			break

		if len(part1.faces) != len(part2.faces):
			similar = False
			break

		if len(part1.edges) != len(part2.edges):
			similar = False
			break

		if len(part1.vertices) != len(part2.vertices):
			similar = False
			break

		vol1 = part1.getVolume(part1.cells)
		vol2 = part2.getVolume(part2.cells)
		if PK(vol1,vol2) != 0:
			similar = False
		break

	return similar

def is_string(str1):
	## VER: 2015-04-28, v1.0

	if type_of(str1) == 'STR' and str1 != '':
		result = True
	else:
		result = False

	return result

def is_suppressed(poi,feature=None):
	## VER: 2013-12-15, v1.0

	suppressed = False
	poi = check_pias(poi)

	if type_of(poi) == 'PINSTANCE':
		if feature in empty:
			suppressed = a.features[poi.name].isSuppressed()
		else:
			if feature in a.features.keys():
				name = feature
				feature = a.features[name]

			if feature in a.features.values():
				suppressed = feature.isSuppressed()
			else:
				print '** feature =',repr(feature)
				raise Exception('*** No such feature.')

	elif type_of(poi) == 'PART':
		if feature in poi.features.keys():
			name = feature
			feature = poi.features[name]

		if feature in poi.features.values():
			suppressed = feature.isSuppressed()
		else:
			print '** feature =',repr(feature)
			raise Exception('*** No such feature.')

	return suppressed

def is_vector(vector):
	## VER: 2014-01-16, v1.0

	result = False
	if is_location(vector) == True:
		x,y,z = vector
		if PK(x*x + y*y + z*z,1) == 0:
			result = True

	return result

def len_num(list1,printResults=False):
	## VER: ('VER: 2014-01-08, v1.5')
	## num = -1表示fail to get the len_num
	## note: None < 0

	## Note:
	## dict1 = {1:2, 5:6}
	## then len(dict1) = 2

##	if none == 0:
##		num0 = 0
##	else:
##		num0 = None

##	num = num0
	num0 = 0   ## empty or not element list/array/sequence/tuple
	if type_of(list1) in ['LIST', 'TUPLE', 'DICT']:
		num = len(list1)
	elif type_of(list1) in ['STR','']:
		num = num0
	else:
		try:
			num = len(list1)
		except:
			num = num0

	if num == num0 and printResults == True:
		print fnln_fnln(),'Fail to get the len_num() for',repr(list1),', returned',num0

	return num

def job_info(job1):
	## VER: 2014-06-10, v1.0

	if job1 in mdb.jobs.keys():
		job1 = mdb.jobs[job1]

	if job1 not in mdb.jobs.values():
		raise Exception('*** No such job exist in mdb.')

	info = {}
	info['analysis'] = job1.analysis
	info['description'] = job1.description
##	info['environment'] = job1.environment
	info['inputType'] = job1.inputType
	info['model'] = job1.model
	info['name'] = job1.name
	info['status'] = job1.status
	info['userSubroutine'] = job1.userSubroutine
	info['numCpus'] = job1.numCpus
	info['memory'] = job1.memory

	return info

def job_status(jobname):
	## VER: 2015-01-16, v1.0

	status = None
	if jobname in mdb.jobs.keys():
		status = mdb.jobs[jobname].status
	elif jobname in mdb.jobs.values():
		job1 = jobname
		status = job1.status

	return status

def key_locs(module_type='A'):

	## VER: ('VER: 2012-06-11, v1.1')

	locs = []

	if module_type == 'A':
		module_top_length = 1580		## A frame
		module_top_width = 808
	elif module_type == 'U':
		module_top_length = 1482	   ## U frame
		module_top_width = 992
	elif module_type[0] == 'V':
		module_top_length = 1956
		module_top_width = 992
	elif module_type[0] == 'W':
		module_top_length = 1665
		module_top_width = 992

	L = module_top_length
	W = module_top_width

	locs.append(L/5 - 150)
	locs.append((L-W)/3)
	locs.append(L/5)
	locs.append(L*2/9)
	locs.append(L/4)
	locs.append(L/5 + 150)

	locs.sort()

	return locs

def KP_set(p,loc=None,name=None,x=None,y=None,z=None,point=None,match_RP=False):

	## VER: ('VER: 2012-07-29, v1.9')	## KP要建立set，并建立CSYS来显示出来。但不自动建立RP

	if name in empty:
		name = 'O1'

	if type_of(point) == 'vertices':
		create_set(p,vertices=point,name=name)
		loc = point.pointOn[0]

		create_csys(p,loc=loc,name=name,match_RP=match_RP)
		print ln(),'RPxyz(p)=',RPxyz(p)

	else:
		if loc==x==y==z==None:
			loc=(0,0,0)

		if loc in empty:
			point = vertice_select(p,x,y,z)
			loc = (x,y,z)
		else:
			point = p.vertices.findAt(coordinates=loc, printWarning=False)
			point = tolist(point)

		if point in empty:
			show_loc(p,loc=loc)
##			print '**No vertice at loc=' + repr(loc) + ', marked by cys named **err_loc. Vertice set',name,'was not created.'

		else:
			create_set(p,vertices=point,name=name)
			loc = point[0].pointOn[0]

			create_csys(p,loc=loc,name=name,match_RP=match_RP)
			print ln(),'RPxyz(p)=',RPxyz(p)

	return point

def keys_num(obj):
	## VER: ('VER: 2012-12-27, v1.1')
	## num = -1表示fail to get the keys_num
	## What is key: obj.prop   prop is one key of obj;   dict1[key1]: key1 is also one key of dict1
	## Note: 0 > None

	num = None
	try:
		num = len(obj.keys())		## such as Repository object(_m.parts, etc) and dict type object.
	except:
		pass

	return num

def fn_kph2ms(kph,remark=True):
	## VER: 2012-01-21, v1.1, 转换成m/s，与单位制无关。

	ms = round(kph*1000/3600,3)
##	ms = round(kph*0.28,2)	## m/s     真正的系数应该是：0.277777777777778

	V3 = ms
	V600 = round(V3*0.703,2)

	if remark == True:
		print 'Remark: V3=3秒平均最大阵风速度，V600=10分钟(600秒)平均最大阵风风速。V600=V3*0.703。美国用V3计算基本风压P3，中国用V600计算基本风压P600。'

	print '--->kph=',kph,'km/hr',', 基本风速：V3=',V3,'m/s. V600=',V600,'m/s'
	print ' '

	return V3, V600

def KPxyz(poi,kpset=None, dx=0,dy=0,dz=0):

	## VER: ('VER: 2012-07-29, v3.2')

	global default_plot

	if type_of(kpset) in ['PART','PINSTANCE']:
		kpset,poi = poi,kpset
	elif type_of(poi) == 'STR' and kpset in empty:
		kpset,poi = poi,kpset

	poi = check_pias(poi)

	if kpset in empty:
		kpset = 'O1'

	if kpset not in poi.sets.keys():
		if kpset == 'O1' and type_of(poi) == 'PART':
			point = poi.vertices.findAt(coordinates=(0,0,0), printWarning=False)
			if type_of(point) == 'vertices':
				KP_set(poi,name='O1',point=point)
				return (0,0,0)

		if kpset not in poi.sets.keys():
			raise Exception('******' + poi.name + ' has no setname=' + kpset)

	else:
		vertices = set2objs(poi,kpset)
		if len(vertices) == 0:
			raise Exception('No vertice at point set= ' + kpset + ', it may due to cell delete.')	## ********
		else:
			loc = vertices[0].pointOn[0]

	return loc

def KPx(kpset,poi = '', dx=0, ptype='NA'):
	## VER: 2010-07-22, poi = part or instance, v.2.0

	return KPxyz(kpset,poi,dx=dx)[0]

def KPy(kpset,poi = '', dy=0, ptype='NA'):
	## VER: 2010-07-22, poi = part or instance, v2.0

	return KPxyz(kpset,poi,dy=dy)[1]

def KPz(kpset,poi = '', dz=0, ptype='NA'):
	## VER: 2010-07-22, poi = part or instance, v2.0

	return KPxyz(kpset,poi,dz=dz)[2]

def labels_dict_to_elements(dict1):
	## VER: 2013-06-03, v1.1
	## 可以用于将一个odb的mesh的单元集合映射到目前的模型单元集合。

	if type_of(dict1) != 'DICT':
		raise Exception('**** An elements labels dict is required.')

	elements = []
	for name in dict1.keys():
		inst = real_key(a.instances.keys(),name)
##		inst = None
##		for inst1 in a.instances.keys():
##			if name.lower() == inst1.lower():
##				inst = inst1
##				break

		if inst == None:
			raise Exception('**** Fail to find the inst, name= ' + name)

		inst = a.instances[inst]

		for label in dict1[name]:
			elements.append(inst.elements[label -1])

	return elements

def labels_dict_to_nodes(dict1):
	## VER: 2013-06-03, v1.1
	## 可以用于将一个odb的mesh的单元集合映射到目前的模型单元集合。

	if type_of(dict1) != 'DICT':
		raise Exception('**** An nodes labels dict is required.')

	nodes = []
	for name in dict1.keys():
		inst = real_key(a.instances.keys(),name)

##		inst = None
##		for inst1 in a.instances.keys():
##			if name.lower() == inst1.lower():
##				inst = inst1
##				break

		if inst == None:
			raise Exception('**** Fail to find the inst, name= ' + name)

		inst = a.instances[inst]

		for label in dict1[name]:
			nodes.append(inst.nodes[label -1])

	return nodes


def labels_of_nodes(nodes):

	## VER: ('VER: 2012-03-30, v1.1')

	nodes = tolist(nodes)
	if nodes in empty:
		raise Exception('Nodes are required')

	if type_of(nodes[0]) not in ['nodes','ODBMESHNODE']:
		raise Exception('Nodes are required.')

	labels = []
	for node in nodes:
		label = node.label
		if label not in labels:
			labels.append(label)

	return labels

def labels_of_odb_node_set(name):
	## VER: 2015-12-08, v1.1

	if type_of(name) == 'STR':
		name = name.upper()

	if name not in oa.nodeSets.keys():
		raise Exception('*** Error odb set: ' + repr(name))

	nodes = oa.nodeSets[name].nodes[0]

	labels = []
	for node in nodes:
		labels.append(node.label)

	return labels

def last_feature_name(poi):
	## VER: 2014-10-17, v1.0
	## poi.deleteFeatures(('Datum pt-5', 'Datum axis-2', ))

	poi = check_poi(poi)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	if _len(poi.datums) > 0:
		id = poi.datums.keys()[-1]
		obj = _part(powder).datums[id]
		feature = obj_to_feature(obj)
		name = feature.name

	else:
		raise Exception('*** No datum in ' + poi.name)

	return name


def LBC_plot(idnum=None):
	## VER: 2011-03-09, v1.1

	global load_BC, dg, plot_history

	unlight()
	vpnow = get_vpnow()

	if idnum not in empty and type_of(idnum) != 'INT':
		raise Exception('******Integer is required.')

	run = False
	if 'load_BC' not in globals().keys():
		list_load_BC()
		run = True

	if idnum in empty:
		if run == False:
			list_load_BC()
		print fnln_fnln(),'******Integer is required.'
		return

	faces = load_BC[idnum]['faces']
	seq = list2sequence(faces)
	vpnow.setValues(displayedObject=a)
	plot_history.append(get_traceback())

	leaf = dgm.LeafFromGeometry(faceSeq=seq)
	dg = session.DisplayGroup(leaf=leaf, name='load')
	vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)
	light(dg)

	insts = tuple(load_BC[idnum]['insts'])
	leaf = dgm.LeafFromInstance(instances=insts)
	vpnow.assemblyDisplay.displayGroup.add(leaf=leaf)

	print 'dg of',load_BC[idnum]['name'],'is lighted. Use unlight() to unlight().'

	return

def leaf2dg(leaf,name='_leaf'):
	## VER: 2011-11-10, v1.0

	if 'LEAF' in type_of(leaf):
		dg = session.DisplayGroup(leaf=leaf, name='_leaf')
	else:
		raise Exception('A leaf is required. dgo and dgm has a lot to leaf methods.')

	return dg

def leaf2insts(leaf):
	## VER: 2014-06-04, v1.0

	if type_of(leaf) != 'INSTANCELEAF':
		raise Exception('*** instance leaf is required.')

	insts_id = leaf.instances
	insts = leaf_ids_to_insts(insts_id)   ## insts names list

	return insts

def leaf2sets(leaf):
	## VER: 2014-06-04, v1.0

	if type_of(leaf) != 'SETSLEAF':
		raise Exception('*** set leaf is required.')

	sets = eval(repr(leaf)[18:-1])

	names = {}
	for set in sets:
		poi_name = get_parent(set).name
		set_name = get_repository_key(set,'sets')

		if poi_name not in names:
			names[poi_name] = []
		names[poi_name].append(set_name)

	return names

def leaf_type(leaf):
	## VER: 2011-02-14, v1.0

	type1 = type_of(leaf)
	if 'LEAF' not in type1:
		raise Exception('****** leaf is required, instead of' + type1)

	type2 = repr(leaf.validModules)
	module = repr(leaf.validModules)
	props = leaf.__members__
	if module in ['PART','ASSEMBLY']:
		if 'cellSeq' in props and leaf.cellSeq not in empty:
			type2 = 'cells'
		elif 'faceSeq' in props and leaf.faceSeq not in empty:
			type2 = 'faces'
		elif 'edgeSeq' in props and leaf.edgeSeq not in empty:
			type2 = 'edges'
		elif 'vertexSeq' in props and leaf.vertexSeq not in empty:
			type2 = 'vertices'

	elif module == 'ODB':
		for prop in props:
			value1 = eval('leaf.' + prop)
			if type_of(value1) == 'TUPLE':
				type2 = prop

	return type2

function_labels['leaf_ids_to_insts'] = 'instance','region id', 'instance ID','internal set'
def leaf_ids_to_insts(ids):
	## VER: 2014-04-24, v1.0

##	>>> a.instances.keys()
##	['powder_A1', 'bpunch_A1', 'tpunch_A1', 'die_A1']
##	>>>
##	>>> BC0 = _m.boundaryConditions.values()[0]
##	>>> BC0.region
##	('_PickedSet40', 'Assembly', 4, 1, 1)
##	>>>
##	>>> set1 = a.allInternalSets['_PickedSet40']
##	['cliCommand', 1, 'print_dir', 62106] **Now use prettyPrint() to show these obj.prop :(level= 3 )
##	({'cells': ({'pointsOn': ()}),
##	  'edges': ({'pointsOn': ()}),
##	  'elements': [],
##	  'faces': ({'pointsOn': ()}),
##	  'instances': [3],
##	  'nodes': [],
##	  'referencePoints': (, ),
##	  'vertices': ({'pointsOn': ()})})
##	>>> leaf_ids_to_insts(3)
##	['bpunch_A1']
##	>>>

##	>>> BC1 = _m.boundaryConditions.values()[1]
##	>>> BC1.region
##	('_PickedSet42', 'Assembly', 4, 1, 1)
##	>>> set1 = a.allInternalSets['_PickedSet42']
##	>>> set1.instances
##	[7]
##	>>> leaf_ids_to_insts(7)
##	['die_A1']
##	>>>

	all = {}
	for inst in a.instances.values():
		leaf = dgm.LeafFromInstance(instances=(inst, ))		## print type_of(leaf) = 'INSTANCELEAF'
		id = leaf.instances[0]
		all[id] = inst.name

	insts = []
	ids = tolist(ids)
	for id in ids:
		if id in all.keys():
			insts.append(all[id])

	return insts

def list_contacts():
	## VER: 2014-09-14, v1.7

	global conts, dict_ties, dict_interacts

	conts = {}	## 接触对汇总
	idnum = 0
	part2part = {}
	names = {}  ## 所有接触对的名字及序号
	dict_ties = {}
	dict_interacts = {}
	need_check = []

	for pair in _m.interactions.values():
		name = pair.name
		idnum = idnum + 1
##		try:
		surf_name1 = pair.master[0]
		info = get_surface_info(surf_name1)
		mfaces = info['objs']
		area_m = get_size(mfaces,3)

		master_inst = info['pois']  ## list
		parts = parts_of_insts(master_inst)
		mpart = poi_names(parts)  ## list

		surf_name2 = pair.slave[0]
		info = get_surface_info(surf_name2)
		sfaces = info['objs']
		area_s = get_size(sfaces,3)

		slave_inst = info['pois']  ## list
		parts = parts_of_insts(slave_inst)
		spart = poi_names(parts)

		brief = 'int_' + str(mpart) + '(m)//' + str(spart)
		conts[idnum] = {'name':name, 'mfaces':mfaces, 'msurface':surf_name1,'sfaces':sfaces, 'ssurface':surf_name2, 'brief':brief, 'master':master_inst, 'slave':slave_inst}

		if brief not in part2part.keys():
			part2part[brief] = []
		part2part[brief].append(idnum)

		ratio1 = round(area_m/area_s,4)
		ratio2 = round(area_s/area_m,4)

		if ratio1 >= 1.5:
			ratio1 = str(ratio1) + '**'
			need_check.append(idnum)
		else:
			ratio1 = str(ratio1)

		if ratio2 >= 1.5:
			ratio2 = str(ratio2) + '**'
			need_check.append(idnum)
		else:
			ratio2 = str(ratio2)

		if abs(area_m - area_s) < 1e-6:
			area0 = 'area m:s = 1 : 1'
		elif area_m > area_s:
			area0 = 'area m:s = ' + ratio1 + ' : 1'
		elif area_m < area_s:
			area0 = 'area m:s = 1 : ' + ratio2

		if type_of(mfaces[0]) == 'faces':
			ndir = face_ndir(mfaces[0])
		elif type_of(mfaces[0]) == 'edges':
			ndir = edge_dir(mfaces[0])
		else:
			ndir = 'NA'
		names[idnum] = name.ljust(60) + ' dir=' + ndir + ', ' + area0

##		except:
##			idnum = idnum - 1

	dict_interacts = names
	print 'There are',len(conts),'interactions:'
	for k,v in sort_by_key(names):
		print str(k).rjust(3),':',v
	if part2part not in empty:
		print '---'
		myprint(part2part)

##	raise Exception

	num_interact = len(conts)
	part2part = {}
	names = {}
	for pair in _m.constraints.values():
		name = pair.name
		idnum = idnum + 1
##		try:
		surf_name1 = pair.master[0]
		info = get_surface_info(surf_name1)
		mfaces = info['objs']
		area_m = get_size(mfaces,3)

		master_inst = info['pois']  ## list
		parts = parts_of_insts(master_inst)
		mpart = poi_names(parts)  ## list

		surf_name2 = pair.slave[0]
		info = get_surface_info(surf_name2)
		sfaces = info['objs']
		area_s = get_size(sfaces,3)

		slave_inst = info['pois']  ## list
		parts = parts_of_insts(slave_inst)
		spart = poi_names(parts)

		brief = 'tie_' + str(mpart) + '(m)//' + str(spart)
		conts[idnum] = {'name':name, 'mfaces':mfaces, 'msurface':surf_name1,'sfaces':sfaces, 'ssurface':surf_name2, 'brief':brief, 'master':master_inst, 'slave':slave_inst}

		if brief not in part2part.keys():
			part2part[brief] = []
		part2part[brief].append(idnum)

		ratio1 = round(area_m/area_s,4)
		ratio2 = round(area_s/area_m,4)

		if ratio1 >= 1.5:
			ratio1 = str(ratio1) + '**'
			need_check.append(idnum)
		else:
			ratio1 = str(ratio1)

		if ratio2 >= 1.5:
			ratio2 = str(ratio2) + '**'
			need_check.append(idnum)
		else:
			ratio2 = str(ratio2)

		if abs(area_m - area_s) < 1e-6:
			area0 = 'area m:s = 1 : 1'
		elif area_m > area_s:
			area0 = 'area m:s = ' + ratio1 + ' : 1'
		elif area_m < area_s:
			area0 = 'area m:s = 1 : ' + ratio2

		if type_of(mfaces[0]) == 'faces':
			ndir = face_ndir(mfaces[0])
		elif type_of(mfaces[0]) == 'edges':
			ndir = edge_dir(mfaces[0])
		else:
			ndir = 'NA'
		names[idnum] = name.ljust(60) + ' dir=' + ndir + ', ' + area0

##		except:
##			idnum = idnum - 1

	dict_ties = names
	print 'There are',len(conts) - num_interact,'ties:'
	if len(conts) - num_interact > 0:
		for k,v in sort_by_key(names):
			print str(k).rjust(3),':',v

	if part2part not in empty:
		print '---'
		myprint(part2part)

	print '**Totally',len(conts),'contacts, interacts are collected in global variable dict_interacts, and ties are collected in global variable dict_ties.'
	print '  All detailed info are collected in global variable conts.'
	print '**Run contacts_of_pois(*pois) or myprint(conts) for more detail.'
	if need_check not in empty:
		print '**Please check:',need_check,', e.g., plot(' + str(need_check[0]) + ')'
	print ' '

	return

def xmin_faces(poi, y=None, z=None):

	## VER: ('VER: 2012-06-20, v1.1')

	poi = check_pias(poi)
	faces = faces_of_cut(poi, x=MIN, y=y, z=z)

	return faces

def get_all_treats_and_run_indexs(by_table=False,DOE_method='multiply'):
	## VER: 2013-05-07, v1.1
##	DOE_method = 'multiply'	## DOE_methods: 'multiply','table','DOE'
	## for all runs.

	global DOE_table, levels_list, single_level, run_indexs0, run_indexs

	## table
	DOE_table = []		## 每一个元素就是一个treat
	levels_list = {}

	run_indexs = []

	## treat
	single_level = {}

	if by_table == True:		## please_check('1. DOE_table')
		all_treats = input_treats_list()
	else:
		if provide_levels_list == True:
			levels_list = input_levels_list()
		all_treats = get_all_treats_from_levels_list(DOE_method=DOE_method)

##	myprint(all_treats)
##	raise Exception

	run_indexs = specify_run_indexs()
	run_indexs0 = run_indexs
	indexs_of_treats = range(1,len(all_treats) + 1)

	if all_treats in empty:
		run_indexs = [1]
	else:
		if run_indexs in empty:
			run_indexs = indexs_of_treats
		else:
			list1 = get_common(run_indexs, indexs_of_treats)
			if len(list1) != len(run_indexs):
				run_indexs = [1]

	if len(DOE_table) > 0:
		print ' '
		print fnln(),'**len(DOE_table)=',len(DOE_table),', len(levels_list)=',len(levels_list),', provide_DOE_table=',provide_DOE_table,', run_indexs=',run_indexs,', please confirm.'
		print fnln(),'run_indexs=',run_indexs

	return all_treats, run_indexs

def length_of_insert(p1,sym=None):
	## VER: 2016-09-07, v1.0

	p1 = check_part(p1)

	if sym in empty:
		sym = get_sym_type(p1)

	if sym not in ['xsym','ysym','xysym','full']:
		raise Exception('*** sym should be xsym, ysym, xysym, or full')

	nodes_xmax = node_select(p1,x=MAX,err=0.2)
	nodes_xmin = node_select(p1,x=MIN,err=0.2)
	nodes_ymax = node_select(p1,y=MAX,err=0.2)
	nodes_ymin = node_select(p1,y=MIN,err=0.2)

	if sym == 'full':
		Lx = average_xdist(nodes_xmax,nodes_xmin)
		Ly = average_ydist(nodes_ymax,nodes_ymin)

		Lx = (3*Lx + _xlength(p1))/4
		Ly = (3*Ly + _ylength(p1))/4

	elif sym == 'xysym':
		Lx = 2*average_xloc(nodes_xmax)
		Ly = 2*average_yloc(nodes_ymax)

		Lx = (3*Lx + 2*_xlength(p1))/4
		Ly = (3*Ly + 2*_ylength(p1))/4

	elif sym == 'xsym':
		Lx = 2*average_xloc(nodes_xmax)
		Ly = average_ydist(nodes_ymax,nodes_ymin)

		Lx = (3*Lx + 2*_xlength(p1))/4
		Ly = (3*Ly + _ylength(p1))/4

	elif sym == 'ysym':
		Lx = average_xdist(nodes_xmax,nodes_xmin)
		Ly = 2*average_yloc(nodes_ymax)

		Lx = (3*Lx + _xlength(p1))/4
		Ly = (3*Ly + 2*_ylength(p1))/4

	Lx = round(Lx,3)
	Ly = round(Ly,3)
	Lz = round(_zlength(p1),3)

	print ' '
	print 'Length of insert in x,y,z=',Lx,Ly,Lz

	return

def light(objs,pause=False):
	 ## 'VER: 2016-10-12, v3.2		## plot相应的poi，light相应的objs. 如果只是plot相应的objs，用plot().

	global dg,mdg,sdg
	## For nodes: both _dg and _nodeset will be created. You can light it in displayGroup.

	## If the created _dg is for nodes, you can replace to show only these nodes by: show node label in CAE or show node symbol in ODB. Then you can reselect

##	print '**Tips: make a displayGroup1 of objects, then light(displayGroup1), or use Replace in GUI'
##	print '**Tips: light(faces) to hightlight faces and show their part or instance.'

	print ' '
	if objs in empty:
		print '******No object to light.'
		return

	try:
		if len(objs) == 0:
			print '******No object to light.'
			return
	except:
		pass

##	plot(a)  ## May confuse if current viewport is part display

	try:
		print _m.name
	except:
		refresh()

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	dpo_type = type_of(dpo)
	if dpo_type == 'ASSEMBLY':
		vpnow.setValues(displayedObject=a)
	elif dpo_type == 'PART':
		vpnow.setValues(displayedObject=dpo)

##	replot()
	unlight()   ## 易导致非正常退出。

##	raise Exception

	if objs in session.displayGroups.keys():
		objs = session.displayGroups[objs]

	dpo = vpnow.displayedObject

	if type_of(objs) == 'STR' and objs in a.surfaces.keys():
		objs = a.surfaces[objs]

	obj_type = type_of(objs)

	if is_numbers(objs):
		raise Exception('*** Error objects, should not be numbers.')

##	if is_location(objs):
##		create_csys(dpo,loc=objs)

	if obj_type == 'STR':
		objs = set2objs(objs,p=dpo)

	try:
		if len(objs) > 0:
			obj_type = type_of(objs[0])
	except:
		pass

##	if obj_type not in ['vertices', 'faces','edges','cells','SURFACE', 'nodes', 'elements', 'ODBMESHNODE', 'ODBMESHELEMENT', 'DISPLAYGROUP', 'PART', 'PINSTANCE']:
##		raise Exception('******faces, edges, cells, surface, leaf, or displayGroup object(mdg,sdg,leaf) are required to light.')

##	raise Exception

	if obj_type == 'DISPLAYGROUP':  ## such as: mdg, sdg for cshow()
		dg1 = objs
		if type_of(dg1.root.leaf) == 'GEOMETRYLEAF':
			leaf1 = dg1.root.leaf
			objs_num = 0
			obj_type = 'NA'
			inst_ids = []
			if leaf1.cellSeq not in empty:
				obj_type = 'cells'
				for inst, ids in leaf1.cellSeq:   ## such as: 'faceSeq': ((7, (1378, )), ), here: inst id=7, face index = 1377
					if inst not in inst_ids:
						inst_ids.append(inst)
					objs_num += len(ids)
			elif leaf1.faceSeq not in empty:
				obj_type = 'faces'
				for inst, ids in leaf1.faceSeq:
					if inst not in inst_ids:
						inst_ids.append(inst)
					objs_num += len(ids)
			elif leaf1.edgeeSeq not in empty:
				obj_type = 'edges'
				for inst, ids in leaf1.edgeSeq:
					if inst not in inst_ids:
						inst_ids.append(inst)
					objs_num += len(ids)

			if objs_num > 0:
				print 'Lighted',objs_num,obj_type,'from',len(inst_ids),'insts:',leaf_ids_to_insts(inst_ids)

		highlight(objs)

	elif obj_type.endswith('LEAF'):
		dg = session.DisplayGroup(leaf=leaf, name='_leaf')
		highlight(dg)

	elif obj_type in ['PART', 'PINSTANCE']:
		poi = objs
		if obj_type == 'PART':
			plot(poi)
			print '**',poi.name,'is shown in the viewport.'
			print ' '
			return
		else:
			plot(a)
			leaf = dgm.LeafFromInstance(instances=(poi, ))   ## poi is an instance, not an instance name
			dg = session.DisplayGroup(leaf=leaf, name='_leaf')
			highlight(dg)
			print '**Lighted instance =',poi.name,'. Run unlight() to unlight.'

	elif obj_type == 'SURFACE':
		leaf = dgm.LeafFromMeshSurfaceSets(surfaceSets=(objs, ))
		dg = session.DisplayGroup(leaf=leaf, name='_leaf')
		highlight(dg)

	elif obj_type in ['ODBMESHNODE', 'ODBMESHELEMENT']:
		objs = tolist(objs)
		pois = get_pois(objs)   ##??****
		names = poi_names(pois)
		plot(pois,fitview=False)

		if obj_type == 'ODBMESHNODE':
			label_seq = nodes_to_model_node_labels(objs)
			leaf = dgo.LeafFromModelNodeLabels(nodeLabels=label_seq)  ##
		elif obj_type == 'ODBMESHELEMENT':
			label_seq = elements_to_model_element_labels(objs)
			leaf = dgo.LeafFromModelElemLabels(elementLabels=label_seq)

		dg = session.DisplayGroup(leaf=leaf, name='_dg')
		highlight(dg)

		print "Created global displayGroup variable dg, name='_dg'"
		print '**Lighted',len(objs),obj_type,', pois =',names,'. Run unlight() to unlight.'

	else:
		objs = tolist(objs)
		pois = get_pois(objs)   ;please_check
		names = poi_names(pois)

		plot(pois,fitview=False)
		obj_type = type_of(objs[0])

		if obj_type == 'elemEdges':  ## cannot create the sequence of elemEdges
			nodes = []
			for edge in objs:
				nodes1 = edge.getNodes()
				nodes = nodes + tolist(nodes1)
			nodes = remove_repeated_items(nodes)
			objs = nodes
			obj_type = 'nodes'

		elif obj_type == 'elemFaces':  ## very slow
			surf1 = element_faces_to_surface(faces=objs,name='_temp')

			light(surf1)
			print fnln(),'lighted element faces by surface =',name_of_surface(surf1)
			return
##			nodes = []
##			for face in objs:
##				nodes1 = face.getNodes()
##				nodes = nodes + tolist(nodes1)
##			nodes = remove_repeated_items(nodes)
##			objs = nodes
##			obj_type = 'nodes'
##			for face in objs:
##				highlight(face)
##				return

		seq = list2sequence(objs)   ## 对nodes, elements也适用

		if obj_type == 'faces':
			leaf = dgm.LeafFromGeometry(faceSeq=seq)
		elif obj_type == 'edges':
			leaf = dgm.LeafFromGeometry(edgeSeq=seq)
		elif obj_type == 'cells':
			leaf = dgm.LeafFromGeometry(cellSeq=seq)
		elif obj_type == 'nodes':
			poi = pois[0]
			leaf = dgm.LeafFromMeshNodeLabels(nodeSeq=seq)
			nodeset = create_set(poi,nodes=seq,name='_nodeset',check_name=False)
			print 'Created node set name=_nodeset for these nodes. You can replace and reselect nodes by edit this node set in GUI.'
			if len(seq) == 1:
				print 'node label =',seq[0].label
			print ' '


		elif obj_type == 'elements':
			leaf = dgm.LeafFromMeshElementLabels(elementSeq=seq)
		elif obj_type == 'vertices':
			poi = pois[0]

			create_csys(poi,loc=objs[0])

			ptset = create_set(poi,vertices=seq,name='_ptset')
			name1 = name_of_set(ptset)
			leaf = dgm.LeafFromSets(sets=(ptset,))		## 但LeafFromSets函数可能只适用于nodes, elements
			print ' '
			print 'Created CSYS at vertices[0]. To show all vertices, please manually highlight setname',name1,'in GUI.'
			return

		print '**Lighted',len(objs),obj_type,', pois =',names,'. Run unlight() to unlight.'

		dg = session.DisplayGroup(leaf=leaf, name='_dg')
		print 'Created global variable dg in',type_of(vpnow.displayedObject),'viewport. Usage: plot(dg) or light(dg) + Replace All.'
		print ' '

		unlight()
		highlight(dg)

	if pause == True:
		print "Raised to highlight the " + obj_type + '.'
		print ' '
		raise Exception

	return

def light_enum():
	## VER: 2011-03-10, v1.0

	global seeded_edges

	unlight()

	vpnow = get_vpnow()
	part = vpnow.displayedObject
	if type_of(part) != 'PART':
		print fnln_fnln(),'******Please switch to Part module and select one part to review.'
		return

	if part.name in seeded_edges.keys():
		light(seeded_edges[part.name]['enum'])
	else:
		print fnln_fnln(),'******',part.name,'is not a key of seeded_edges.'

	return

def light_esize():
	## VER: 2011-03-10, v1.0

	global seeded_edges

	unlight()

	vpnow = get_vpnow()
	part = vpnow.displayedObject
	if type_of(part) != 'PART':
		print fnln_fnln(),'******Please switch to Part module and select one part to review.'
		return

	if part.name in seeded_edges.keys():
		light(seeded_edges[part.name]['esize'])
	else:
		print fnln_fnln(),'******',part.name,'is not a key of seeded_edges.'

	return

def text_of_objs_sequence(objs):
	## VER: 2014-07-17, v1.2

	text1 = ''
	if type_of(objs) in ['TUPLE','LIST'] and objs not in empty:
		type1 = type_of(objs[-1])
		type2 = type_of(objs[0])
		num = len(objs)
		start = repr(objs)[0]
		end = repr(objs)[-1]

		if type1 == type2:
			if type1 in ['vertices','edges','faces','cells']:
				poi0 = get_poi(objs[0])
				pointOn = objs[0].pointOn[0]
				text1 = str(num) + type2 + ', p=' + poi0.name + ', pointOn0=' + str(pointOn)
				if type_of(objs[0]) == 'edges':
					dir0 = edge_dir(objs[0])
					text1 = text1 + ', edir= ' + dir0
				elif type_of(objs[0]) == 'faces':
					dir0 = face_ndir(objs[0])
					text1 = text1 + ', ndir= ' + dir0

				if num > 1:
					poi1 = get_poi(objs[-1])
					pointOn = objs[-1].pointOn[0]
					if poi1 != poi0:
						text1 = text1 + ', p1=' + poi.name + ', pointOn1=' + str(pointOn)
					else:
						text1 = text1 + ', pointOn1=' + str(pointOn)
				text1 = start + text1 + end
			elif type1 == 'PART':
				for poi in objs:
					text1 = text1 + ", _m.parts['" + poi.name + "']"
				text1 = text1[2:]
				text1 = start + text1 + end
			elif type1 == 'PINSTANCE':
				for poi in objs:
					text1 = text1 + ", a.instances['" + poi.name + "']"
				text1 = text1[2:]
				text1 = start + text1 + end
			elif type1 not in basic_types:  ## obj type
				text1 = start + str(num) + ' ' + type2 + 's' + end

	if text1 == '':
		text1 = repr(objs)

	return text1

def text_of_sequence(objs):
	## VER: 2012-12-18, v1.8

	if type_of(objs) in ['TUPLE','LIST'] and objs not in empty:
		if is_objs_sequence(objs) == True:
			text1 = text_of_objs_sequence(objs)
		else:
			start = repr(objs)[0]
			end = repr(objs)[-1]
			text1 = start
			for obj in objs:
				text1 = text1 + text_of_objs_sequence(obj) + ','
			text1 = text1[:-1] + end
	else:
		text1 = repr(objs)

	return text1

def this_and_caller(to_print=True,toPrint=None):
	## VER: 2012-08-21, v1.5
	## 结果形式如：** Below is result of ['get_result', 22275] ,  called by ['collect_and_write_results', 5689]

	## VER: .VER:  = {'date':'2012-08-21', 'VER':1.5}		## 得到fnln_fnln()调用语句所在的行号以及caller语句的行号

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

	## 注意当前行所在的行号和所在的函数名就保存在get_traceback[-2:]中

	if toPrint != None:
		to_print = toPrint

	info = get_traceback()
	info = info[:-2]
	if len(info) >= 4:
		info = info[-4:]

	if to_print == False:
		return info
	else:
		if len(info) == 4:
			print '** Below is result of',str(info[-2:]), ',  called by', str(info[:2])

		else:
			print '** Monitor result：Print by' + str(info) + ':'

		return ' '

	return

def line2surface_interact(edges,faces,name=None,prop='Frictionless',sliding=FINITE,step='step1',slave='edges'):
	## VER: ('VER: 2012-07-01, v1.3')	## 默认faces为master，edges为slave。
	## solid model

	global contact_pairs, msfaces_trace, conts, contact_pairs

	## Example:
##	edges = edge_select(rail_A1,z=MAX,y=MIN,edir='x')
##	y0 = space_of_edges(edges)[2]
##	faces = faces_of_cut(frL_A1,z=MIN,y=(y0 - 1,y0 + 1))
##	line2surface_interact(edges=edges,faces=faces)

	msfaces_trace = []

	add_to_process()
	step = check_step(step)

	if type_of(faces) == 'STR':
		inst = insts_by_set(faces)[0]
		faces = set2objs(inst,faces)
	elif type_of(faces) == 'faces':
		faces = [faces]

	if type_of(edges) == 'STR':
		inst = insts_by_set(edges)[0]
		edges = set2objs(inst,edges)
	elif type_of(edges) == 'edges':
		edges = [edges]

	edges = tolist(edges)
	faces = tolist(faces)

	if edges in empty or type_of(edges) != 'LIST':
		raise Exception('edges are required.')

	if type_of(edges[0]) != 'edges':
		raise Exception('edges are required.')

	if faces in empty or type_of(faces) != 'LIST':
		raise Exception('faces are required.')

	if type_of(faces[0]) != 'faces':
		raise Exception('faces are required.')

	if slave == 'edges':
		master_inst = get_poi(faces)
		slave_inst = get_poi(edges)
	else:
		master_inst = get_poi(edges)
		slave_inst = get_poi(faces)

	if prop not in _m.interactionProperties.keys() and len(_m.interactionProperties.keys()) > 0:
		prop1 = _m.interactionProperties.keys()[0]
		print '**Default contact property',prop,'not existed, use',prop1,'instead.'
		prop = prop1

	edges_region = list2region(edges, region_type='surface')
	faces_region = list2region(faces, region_type='surface')

	if slave == 'edges':
		slave_region = edges_region
		master_region = faces_region
	else:
		slave_region = faces_region
		master_region = edges_region

	if name in empty:
		if slave == 'edges':
			name = 'int_' + master_inst.name + '//' + slave_inst.name + '_edges(s)'
		else:
			name = 'int_' + master_inst.name + '//' + slave_inst.name + '_faces(s)'

	seq = get_SN(_m.interactions,3)

	fric = '_hasf_'
	if prop == 'Frictionless':
		fric = '_nof_'

	name = '_' + seq + '_' + name

	_lineno = ''
	info = lineno_and_codes()
	for i in range(len(info)):
		if info[i] == 'line2surface_interact':
			_lineno = str(info[i-1])
			break
	name = name + fric + _lineno

	name = new_key(_m.interactions,name)

	print '---'
	print 'Trying to create line2surface interact: master_inst=',master_inst.name,', slave_inst=',slave_inst.name

	msfaces_trace.append(get_traceback()[-2:] + ['face',objs_num(faces),'edges',objs_num(edges),'slave=',slave])

	mset = name + '(master)'
	sset = name + '(slave)'
	if slave == 'edges':
		create_set(master_inst, objs=faces, name=mset)
		create_set(slave_inst, objs=edges, name=sset)
	else:
		create_set(master_inst, objs=edges, name=mset)
		create_set(slave_inst, objs=faces, name=sset)

##	contact_pairs[-1]['master_set'] = mset
##	contact_pairs[-1]['slave_set'] = sset

	_m.SurfaceToSurfaceContactStd(name=name,
	    createStepName=step, master=master_region, slave=slave_region, sliding=FINITE, 	##注意要使用有限滑移，假如存在大变形的话。
	    interactionProperty=prop, adjustMethod=NONE, smooth=0.2, initialClearance=OMIT, datumAxis=None, clearanceRegion=None)

	print '--->line2surface interact',name,'was created, prop=',prop
	print '**In model: Total ties=',len(_m.constraints), ', total interactions=',len(_m.interactions)
	print ' '
	print 'Calling process of last contact: myprint(msfaces_trace)'
	myprint(msfaces_trace)
	print ' '

	return True

def line2surface_tie(edges,faces,name=None,prop='Friction',sliding=None,tolerance=None,step='step1',slave='edges'):
	## tolerance: nodes from slave surface that will be tied.
	## master=edges, slave=faces
	## prop和sliding是一个无用的参数，只是占位，与line2surface_interact相对应而已。

	## VER: ('VER: 2012-07-01, v1.1')

	global contact_pairs, msfaces_trace, conts, contact_pairs

	## Example:
##	edges = edge_select(rail_A1,z=MAX,y=MIN,edir='x')
##	y0 = space_of_edges(edges)[2]
##	faces = faces_of_cut(frL_A1,z=MIN,y=(y0 - 1,y0 + 1))
##	line2surface_tie(edges=edges,faces=faces)

	if tolerance == None:
		tolerance = clamp_esize

	msfaces_trace = []

	add_to_process()
	step = check_step(step)

	if type_of(faces) == 'STR':
		inst = insts_by_set(faces)[0]
		faces = set2objs(inst,faces)
	elif type_of(faces) == 'faces':
		faces = [faces]

	if type_of(edges) == 'STR':
		inst = insts_by_set(edges)[0]
		edges = set2objs(inst,edges)
	elif type_of(edges) == 'edges':
		edges = [edges]

	edges = tolist(edges)
	faces = tolist(faces)

	if edges in empty or type_of(edges) != 'LIST':
		raise Exception('edges are required.')

	if type_of(edges[0]) != 'edges':
		raise Exception('edges are required.')

	if faces in empty or type_of(faces) != 'LIST':
		raise Exception('faces are required.')

	if type_of(faces[0]) != 'faces':
		raise Exception('faces are required.')

	master_inst = get_poi(edges)
	slave_inst = get_poi(faces)

	edges_region = list2region(edges, region_type='surface')
	faces_region = list2region(faces, region_type='surface')

	if name in empty:
		name = 'tie_' + slave_inst.name + '//' + master_inst.name + '_line(m)'

	seq = get_SN(_m.interactions,3)
	name = '_' + seq + '_' + name

	_lineno = ''
	info = lineno_and_codes()
	for i in range(len(info)):
		if info[i] == 'line2surface_tie':
			_lineno = str(info[i-1])
			break
	name = name + '_' + _lineno

	name = new_key(_m.interactions,name)

	print '---'
	print 'Trying to create line2surface line: line from master_inst=',master_inst.name,', surface from slave_inst=',slave_inst.name

	msfaces_trace.append(get_traceback()[-2:] + ['mfaces',objs_num(faces),'sedges',objs_num(edges)])

	mset = name + '(master)'
	sset = name + '(slave)'
	create_set(master_inst, objs=edges, name=mset)
	create_set(slave_inst, objs=faces, name=sset)

##	contact_pairs[-1]['master_set'] = mset
##	contact_pairs[-1]['slave_set'] = sset

	_m.Tie(name=name, master=edges_region, slave=faces_region,
	    positionToleranceMethod=SPECIFIED, positionTolerance=tolerance, adjust=ON, tieRotations=ON, thickness=ON)

	print '--->line2surface tie',name,'was created'
	print '**In model: Total ties=',len(_m.constraints), ', total interactions=',len(_m.interactions)
	print ' '
	print '最后一个接触对的建立的过程为: myprint(msfaces_trace)'
	myprint(msfaces_trace)
	print ' '

	return True

def line_points(p,dir='x',setname='',x=0,y=0,z=0):
	## VER: 2010-05-04, 参考dir_points()

	dir = dir.lower()

	if setname == '':
		setname = 'p_' + p.name + '_dir' + dir

	if dir == 'x' and x == 0:
		x = ()
	elif dir == 'y' and y == 0:
		y = ()
	elif dir == 'z' and z == 0:
		z = ()

	points = vertice_select(p,x,y,z)
	create_set(p,objs=points,name=setname)

	return

function_labels['list_insert'] = 'list','tuple','insert','append','index','loc'
def list_insert(list1,item,loc=0):
	## VER: 2017-06-08, v1.0
	## default to insert to the first location (index=0)

##	>>> list1 = [1,2,3]
##	>>> list1.append(4)
##	>>> list1
##	[1, 2, 3, 4]
##	>>> list1.insert(0,0)
##	>>> list1
##	[0, 1, 2, 3, 4]
##	>>> list1.insert(0,-1)
##	>>> list1
##	[-1, 0, 1, 2, 3, 4]
##	>>>
##	>>> list1
##	[-1, 0, 1, 2, 3, 4]
##	>>> list1.insert(-1,5)
##	>>> list1
##	[-1, 0, 1, 2, 3, 5, 4]
##	>>>
##	>>> list_insert(list1,-2)
##	[-2, -1, 0, 1, 2, 3, 5, 4]
##	>>> list_insert(list1,6,-1)
##	[-2, -1, 0, 1, 2, 3, 5, 4, 6]
##	>>>

	type0 = type_of(list1)
	if type0 not in ['LIST','TUPLE']:
		raise Exception('*** list or tuple is required.')

	if type0 == 'TUPLE':
		list1 = list(list1)

	if is_integer(loc) == False and is_integer(item):
		item,loc = loc,item

	if len(list1) == 0:
		list1 = [item]
		if type0 == 'TUPLE':
			list1 = (item,)
	else:
		if loc == -1:
			list1.append(item)
		else:
			list1.insert(loc,item)

	if type0 == 'TUPLE':
		list1 = tuple(list1)

	return list1

def list_load_BC():
	## VER: 2011-03-09, v1.1

	global load_BC

	load_BC = {}
	idnum = 0

	print 'List of loads...'
	for load in _m.loads.values():
		name = load.name
		internal_set = load.region[0]
		idnum = idnum + 1
		objs = objs_of_internal_set(internal_set)
		if objs in empty or type_of(objs[0]) != 'faces':
			print idnum,':',name
			continue

		faces = objs
		insts = []
		if len(faces) > 0:
			if get_poi(faces[0]) != get_poi(faces[-1]):
				for face in faces:
					inst = get_poi(face)
					if inst not in insts:
						insts.append(inst)
			else:
				inst = get_poi(faces[0])
				insts.append(inst)

		load_BC[idnum] = {'name':name, 'faces':faces, 'insts':insts}

		faces_num = len(faces)
		area = 0
		if len(faces) > 0:
			seq = list2sequence(faces)
			area = a.getArea(seq)
			area = round(area,5)
		print idnum,':',name,', faces num=',faces_num,', area=', area,

		magnitude = 0
		if type_of(load) == 'PRESSURE':
			for step in _m.steps.keys():
				if step == 'Initial':
					continue
				if name in _m.steps[step].loadStates.keys():
					magnitude =  _m.steps[step].loadStates[name].magnitude
					break

		if magnitude != 0:
			print ', magnitude=',magnitude
		else:
			print

	return

def list_element_type(part):
	## VER: 2012-03-02, v1.0

	part = check_part(part)

	if mesh_status(part) == (True, True):
		for setname in part.sets.keys():
			if type_of_set(part,setname) == 'cells':
				cells = set2objs(part,setname)
				cell = cells[0]

				type1 = ''

				try:
					type1 = part.getElementType(cell,elemShape=HEX)	##六面体单元的具体类型
				except:
					pass

				if type1 == '':
					try:
						type1 = part.getElementType(cell,elemShape=TRI)
					except:
						pass

				if type1 == '':
					try:
						type1 = part.getElementType(cell,elemShape=TET)
					except:
						pass

				if type1 == '':
					try:
						type1 = part.getElementType(cell,elemShape=QUAD)
					except:
						pass

				if type1 == '':
					try:
						type1 = part.getElementType(cell,elemShape=LINE)
					except:
						pass

				if type1 == '':
					try:
						type1 = part.getElementType(cell,elemShape=WEDGE)
					except:
						pass

				if type1 != '':
					print '  For',setname,':'
					print repr(type1)
					print ' '

	return

def list_mats(part=None):
	## VER: 2011-03-07, v1.0

	if type_of(part) == 'PART':
		mats = get_mats(part)
		dpo = part.name
	else:
		mats = get_mats(a)
		dpo = 'assembly'

	newlist = []
	for partname in mats.keys():
		for mat in mats[partname].keys():
			if mat not in newlist:
				newlist.append(mat)
	mats = newlist

	matlib = {}
	for name,mat in _m.materials.items():
		if name not in mats:
			continue
		matlib[name] = {}
		try:
			matlib[name]['K'] = mat.conductivity.table
		except:
			pass

		try:
			matlib[name]['dens'] = mat.density.table
		except:
			pass

		try:
			matlib[name]['E&v'] = mat.elastic.table
		except:
			pass

		try:
			matlib[name]['CTE'] = mat.expansion.table
		except:
			pass

		try:
			matlib[name]['Cp'] = mat.specificHeat.table
		except:
			pass

		try:
			model = mat.hyperelastic.type
			poisson = mat.hyperelastic.poissonRatio
			uniaxial = mat.hyperelastic.uniaxialTestData.table
			matlib[name]['hyperE'] = {'model':model, 'v':poisson, 'uniaxial':uniaxial}
		except:
			pass

	print 'Listing',len(matlib),'materials in',dpo,'...'
	myprint(matlib)
	print ' '

	return

def list_op(list1,operator,num):
	## VER: 2010-12-17, v1.0

	list1 = tolist(list1)
	if list1 not in empty and operator in ['+','-','*','/']:
		if type_of(list1[0]) not in ['FLOAT','INT'] and type_of(num) not in ['FLOAT','INT']:
			raise Exception('******Invalid operation. list1= ' + repr(list1) + ', num= ' + repr(num))

		for i in range(len(list1)):
			if operator == '+':
				list1[i] = list1[i] + num
			elif operator == '-':
				list1[i] = list1[i] - num
			elif operator == '*':
				list1[i] = list1[i]*num
			elif operator == '/':
				list1[i] = list1[i]/num

	return list1

def lineno_and_codes():
	## VER: 2011-05-18, v1.1  左边为行号，右边为该行语句所要调用的函数，就像所见的一样。

	info = get_traceback()
	info = info[1:-3]

	for i in range(len(info)):
		if type_of(info[i]) == 'STR':
			info[i] = info[i]

	info.insert(0,'lineno_and_codes -->')

	return info

def list1_in_list2(list1,list2):
	## VER: 2016-07-29, v1.0

	list1 = tolist(list1)
	list2 = tolist(list2)
	result = True
	for item in list1:
		if item not in list2:
			result = False
			break

	return result

function_labels['list2csv'] = 'excel','file','write','result','open','csv'
def list2csv(filename,list1,mode='ab'):
	## VER: 2017-06-23, v1.0, comma seperated values(csv)
	## wb:以二进制写模式打开, rb:以二进制写模式打开,ab:以二进制追加模式打开,rb+: 以二进制读写模式打开, wb+:以二进制读写模式打开
	## list1中的每一个元素，就是一行数据

	## examples:
	## list2csv('test1.csv','')
	## list2csv('test1.csv',['a',5]
	## list2csv('test1.csv',[1,2,3,4])
	## list2csv('test1',[1,(1,2),3])  ## 没问题，第二个元素为(1,2)

	import csv
	if type_of(filename) != 'STR':
		raise Exception('*** filename is required.')
	loc = filename.rfind('.')
	if loc == -1:
		filename = filename + '.csv'
	elif filename[loc:].lower() != '.csv':
		raise Exception('*** should be .csv file.')

	mode = mode.lower()
	list1 = tolist(list1)
	if list1 in empty:
		list1 = []
	if type_of(list1) != 'LIST':
		raise Exception('*** data list is required. blank for blank line')

	with open(filename, mode) as csvfile: ## 文件必须保持关闭状态，否则无法打开
		if mode in ['wb','ab']:
			writer = csv.writer(csvfile,dialect='excel')
			writer.writerow(list1)

	return

function_labels['csv2list'] = 'excel','file','write','result','open','csv'
def csv2list(filename):
	## VER: 2017-06-23, v1.0, comma seperated values(csv)
	## wb:以二进制写模式打开, rb:以二进制写模式打开,ab:以二进制追加模式打开,rb+: 以二进制读写模式打开, wb+:以二进制读写模式打开
	## 在只读状态下，csv文件可以被打开着。

	## examples:
	## list2csv('test1.csv','')
	## list2csv('test1.csv',['a',5]
	## list2csv('test1.csv',[1,2,3,4])

##	>>> csv2list('test1.csv')
##	[[], ['a', '5'], ['1', '2', '3', '4']]
##	>>>

	import csv
	if type_of(filename) != 'STR':
		raise Exception('*** filename is required.')
	loc = filename.rfind('.')
	if loc == -1:
		filename = filename + '.csv'
	elif filename[loc:].lower() != '.csv':
		raise Exception('*** should be .csv file.')

	list1 = []
	with open(filename, 'rb') as csvfile: ## 文件必须保持关闭状态，否则无法打开
		reader  = csv.reader (csvfile,dialect='excel')
		for row in reader:
			list1.append(row)

	return list1

function_labels['list_to_txt_lines'] = 'print','write','list','tuple', 'file','txt'
def list_to_txt_lines(list1,filename='_list1.txt'):
	## VER: 2017-08-14, v1.2 多行输出, 每一个元素就占一行。输出到工作目录下的results子目录
	## reference: list_to_txt_line() 单行输出
	## reference: line_print()

##	line_print(file1,'res =',res)

##	>>> make_dir('results')
##	'Z:/A0283-Assembly analysis-Oscar/new1/results'

##	>>> list1 = ['var1',5,'var2=',6]
##	>>> list_to_txt_lines('_test1.txt',list1)
##	var1
##	5
##	var2=
##	6

	if type_of(list1) == 'STR':
		list1,filename = filename,list1

	dir1 = make_dir('results')
	loc = filename.find('.')
	if loc == -1:
		filename = filename + '.txt'

	path = 	dir1 + '/' + filename
	file1 = open(path,'w')

	type0 = type_of(list1)
	if type0 not in ['LIST','TUPLE','DICT']:
		raise Exception('*** a tuple or list is required.')

##	file1 = open(filename,'w')
	if type0 in ['LIST','TUPLE']:
		for i in range(len(list1)):
			item = list1[i]
			if type_of(item) not in ['LIST','TUPLE']:
				print >> file1, item
			else:
				for item1 in item:
					print >>file1, item1,'   ',
				print >> file1

	elif type0 == 'DICT':
		for key in list1.keys():
			print >> file1, key, '   ',list1[key], '   '

	file1.close()

	print fnln_fnln(),type0,'has been printed to file',path

	return path

def list2region(objs=None,poi=None,faces=None,cells=None,edges=None,vertices=None, referencePoints=None,
	elements=None, nodes=None, region_type='set', side_num=None,surface_name='',info=''):
	## VER: ('VER: 2016-04-11, v3.0')   for BC application, region_type should be set
	## another kind of set like region: region = tolist(objs)  (can use for material assignment).
	## region type == set or surface  (such as wire edge for shell part for rigid body definition)
	## create_set()或create_surface()更不易出错。

####		region0 = list2region(cells0)  ## error
##		region0 = create_set(p,objs=cells0,setname=mat_old)
##		p.sectionAssignments[i].setValues(region=region0)  ##对原有材料重新定义


	type1 = type_of(objs)
	if type1 in ['PART','PINSTANCE','ODBINSTANCE']:
		objs,poi = poi,objs

##	if referencePoints not in empty:
##		region = regionToolset.Region(referencePoints=totuple(referencePoints))

	objs = get_real_input(objs, faces, cells, edges, vertices, referencePoints, elements, nodes)

	if type_of(objs) == 'STR' and objs in a.sets.keys():
		objs = a.sets[objs]

	if type_of(objs) in ['SET','REGION']:
		return objs

	sequence = list2sequence(objs)

	if type_of(side_num) == 'STR':
		side_num = side_num.lower()
		if side_num == 'magenta':
			side_num = 1
		elif side_num == 'yellow':
			side_num = 2
		else:
			raise Exception('*** side_num should be 1(magenta) or 2(yellow)')

	obj_type = type_of(objs[0])
	if type_of(side_num) == 'INT':
		region_type = 'surface'
	elif type_of(surface_name) == 'STR':
		region_type = 'surface'

	if obj_type != 'elements':
		if obj_type == 'faces':
			poi = get_poi(objs[0])
			if region_type == 'surface':
				region = create_surface(faces=sequence,info=info)

			else:
				region = eval('Region(faces = sequence)')			## set-like region (used for boundary condition, material sectionAssignment)

		elif obj_type == 'edges':
			if region_type == 'surface':
				region = create_surface(edges=sequence,info=info)

			else:
				region = eval('Region(edges = sequence)')

		else:
##			print obj_type
			region = eval('Region(' + obj_type + '=sequence)')

	else:
		if region_type == 'surface':
			raise Exception('*** Please use create_surface() or elements_to_surface() instead.')
		elif region_type == 'set':
			sequence = list2sequence(objs=objs,poi=poi)
			region = eval('Region(elements = sequence)')			## set-like region (used for boundary condition, material sectionAssignment)

	print '--->** region created, obj_type=',obj_type,', region_type=',region_type,', please check.'

	return region

def list2sequence(objs=None,poi=None,faces=None,cells=None,edges=None,vertices=None, elements=None, nodes=None, use_for='',post=False):
	## VER: ('VER: 2015-06-28,v3.6')		## poi为part or instance.
	## poi不能为assembly?

	## array就是sequence
	## 对于一条edge, (edge,)也是sequence形式，不过这不是geomSequence。
	## 本函数得到的是该edge的geomSequence，其结果如:plate.edges.findAt(((3.75, 0.0, 1.5),),)。该结果中含有位置信息（用作findAt的参数），所以称为geomSequence

	## Example:
##	print 'type_of(poi)=',type_of(poi)  ## PINSTANCE, or ASSEMBLY is OK
##	seq = list2sequence(objs,poi)
##

##	nodes1 = _inst('plate_A1').nodes[:]
##	nodes2 = _inst('green_A1').nodes[:]
##	region = a.Set(nodes=nodes1+nodes2, name='all_nodes')   ## sequence1 + sequence2 = sequence3

	if is_poi(objs):
		objs,poi = poi,objs
		poi = check_poi(poi)

	type1 = type_of(objs)
	if type1 in ['PART','PINSTANCE','ODBINSTANCE']:
		objs,poi = poi,objs

	objs = get_real_input(objs,cells,faces,edges,vertices,elements, nodes)
	if objs in empty:
		raise Exception('******Empty objs.' )

	if type_of(objs) == 'SEQUENCE':   ## poi.cells is array, but poi.cells[:] is sequence
		return objs
	elif 'ARRAY' in type_of(objs):    ## please_check
		return objs[:]
	else:
		objs = tolist(objs)
		poi0 = None
		if is_poi(poi):
			poi0 = check_poi(poi)
		else:
			poi1 = get_poi(objs[0])
			poi2 = get_poi(objs[-1])
			if poi1 == poi2:
				poi0 = poi1

		if poi0 not in empty:
			poi = poi0
			type1 = type_of(objs[0])
			if type1 == 'cells' and len(objs) == len(poi0.cells):
				return poi0.cells[:]
			elif type1 == 'faces' and len(objs) == len(poi0.faces):
				return poi0.faces[:]
			elif type1 == 'edges' and len(objs) == len(poi0.edges):
				return poi0.edges[:]
			elif type1 == 'vertices' and len(objs) == len(poi0.vertices):
				return poi0.vertices[:]
			elif type1 == 'elements' and len(objs) == len(poi0.elements):
				return poi0.elements[:]
			elif type1 == 'nodes' and len(objs) == len(poi0.nodes):
				return poi0.nodes[:]

	if use_for == 'load_BC' and objs[0].instanceName == None:
		raise Exception('Part instance is needed for sequence conversion for load_BC.')   ##******

	num0 = len(objs)

	pois = get_pois(objs)
	if len(pois) > 1:
		poi = None
	elif len(pois) == 1:
		poi = pois[0]

	obj_type = type_of(objs[0])

	if obj_type == 'referencePoints':
		sequence = totuple(objs)
		return sequence

	elif obj_type == 'ODBMESHNODE':
		sequence = odb_nodes_to_sequence(nodes=objs, inst=poi)
		return sequence

	if obj_type == 'elemEdges':
##		>>> full_set = _part(powder).elemEdges
##		>>> full_set
##		mdb.models['Model-1'].parts['powder'].elemEdges
##		>>> print full_set    ##好奇怪
##		{}
##		>>> len(full_set)
##		3600
##		>>>

		raise Exception('*** can not create the sequence of elemEdges.')

	sequence = 'NA'

	if poi not in empty:
		full_set = eval('poi.' + obj_type)
		if len(objs) == len(full_set) and objs[-1] == full_set[-1] and objs[0] == full_set[0]:
			sequence = full_set[:]
			return sequence

		if 'REPOSITORY' in type_of(full_set).upper():
			full_set = full_set.values()

		num = len(full_set)
		if num == len(objs):
			sequence = full_set[:]
		else:
			sequence = []
			for obj in objs:
				please_check
				if 'index' in obj.__members__:
					index1 = obj.index
					seq1 = full_set[index1:index1 + 1]
				else:
					index1 = get_index(obj)
					if type_of(index1) == 'INT':
						seq1 = full_set[index1:index1 + 1]
					else:
						raise Exception('*** Fail to get the index.')

##				try:
##					index1 = obj.index
##					seq1 = full_set[index1:index1 + 1]
##				except:
##					try:
##						index1 = obj.label		## 对于element, node
##						seq1 = full_set[index1 - 1:index1]
##					except:
##						index1 = get_repository_key(obj)
####						print 'index1=',index1
##						if type_of(index1) == 'INT':
##							seq1 = full_set[index1:index1 + 1]
####							print seq1
##						else:
##							raise Exception('*** Fail to get the index.')

				if sequence == []:
					sequence = seq1
				else:
					sequence = sequence + seq1

##		print sequence
##		raise Exception
	else:
		seq_dict = {}
		for obj in objs:
			p = get_poi(obj)
			if p.name not in seq_dict.keys():
				seq_dict[p.name] = []

			full_set = eval('p.' + obj_type)

			please_check
			if 'index' in obj.__members__:
				index1 = obj.index
				seq1 = full_set[index1:index1 + 1]
			else:
				index1 = get_index(obj)
				if type_of(index1) == 'INT':
					seq1 = full_set[index1:index1 + 1]
				else:
					raise Exception('*** Fail to get the index.')

##			try:
##				index1 = obj.index
##				seq1 = full_set[index1:index1 + 1]
##			except:
##				index1 = obj.label		## 对于element, node
##				seq1 = full_set[index1 - 1:index1]

			if seq1 not in seq_dict[p.name]:
				seq_dict[p.name].append(seq1)

		for poi_name in seq_dict.keys():
			sum1 = seq_dict[poi_name][0]
			for item in seq_dict[poi_name][1:]:
				sum1 = sum1 + item

			seq_dict[poi_name] = sum1

		poi_num = len(seq_dict.keys())

		sequence = 'NA'
		if seq_dict not in empty:
			if post == False:
				name0 = seq_dict.keys()[0]
				sequence = seq_dict[name0]
				for k,v in seq_dict.items():
					if k != name0:
						sequence = sequence + v

	if sequence == 'NA':
		raise Exception('Fail to get the sequence from '+ obj_type + ' list')

##	num1 = len(sequence)
##	if num0 != num1:
##		raise Exception('*** Error: element num is change from ' + str(num0) + ' to ' + str(num1) + ' after list2sequence()')

	return sequence

_sequence = list2sequence

def loc_at(poi,vertices=None, x=None,y=None,z=None,nx=None,ny=None,nz=None,dir=None,axis=None,
	index=None,pointOn=True,nearby=5e-3,groupX=None,groupY=None,groupZ=None):
	## VER: 2016-01-13, v1.5
	## 注意: groupX, groupY, groupZ不做partition操作来找位置。partition可能在x,y,z为数值时进行。

##	>>> locs_of_poi('powder',x=MAX,groupY=MID)
##	2 vertices selected.
##	['locs_of_poi', 31416, 'vertice_select', 68481] *** No vertice selected.
##	[]
##	>>>

##	>>> loc_at('powder',y=MID,groupX=MIN)
##
##	['locs_of_poi', 31389, 'batch_divide', 4542] Performing batch divide for ['powder_temp'] in y , offsets= [26.78]
##	--->Performed partition for powder_temp , divide#= 1 , y = 26.78
##	3 vertices selected.
##	1 vertices selected.
##	(0.0, 26.78, 0.0)
##	>>>

	locs = locs_of_poi(poi,vertices=vertices, x=x, y=y, z=z, nx=nx, ny=ny, nz=nz, dir=dir, axis=axis, index=index, pointOn=pointOn,
		nearby=nearby, groupX=groupX, groupY=groupY,groupZ=groupZ)

	if len(locs) > 1:
		raise Exception('*** Multiple locs are found')
	loc1 = locs[0]

	return loc1

def loc_dict_of_sketch_vertices(sketch, vertices):
	## VER: 2014-03-31, v1.1
	## sketch的vertice没有id属性。

	sketch = check_sketch(sketch)

	dict1 = {}
	for vertice in vertices:
##		print 'vertice=',repr(vertice)   ## mdb.models['Model-1'].sketches['s_die'].vertices.findAt((0.0, 6.13),)
##		print type_of(vertice)
##		prettyPrint(vertice, 2)
##		stop1()
		id = id_of_sketch_vertice(vertice)
		x1,y1 = vertice.coords
		x1,y1 = round6(x1,y1)
		dict1[id] = (x1,y1)

##	stop1()

	return dict1

def loc_of_feature_point(feature,p=None):
	## VER: 2016-05-25, v1.1. note: type_of(datumpoint) = 'FEATURE', not = 'DATUMPOINT'

	## Example:
	##>>> pt3 = carbide1.features['Datum pt-3']
	##>>> pt3
	##mdb.models['Model-1'].parts['carbide1'].features['Datum pt-3']
	##>>> type_of(pt3)
	##'FEATURE'
	##>>> loc_of_feature_point(pt3)
	##(10.0, 0.0, 0.0)

	##>>> csys = a.features['RP_csys']
	##>>> csys
	##mdb.models['Model-1'].rootAssembly.features['RP_csys']
	##>>> loc_of_feature_point(csys)
	##(0.0, 0.0, 0.0)

	if is_pia(feature):
		feature,p = p,feature

	if type_of(feature) == 'STR':
		p = check_pia(p)
		if feature in p.features.keys():
			feature = p.features[feature]

	if type_of(feature) != 'FEATURE':
		raise Exception('**** One feature point, such as datum point, cys, is required.')

	if 'xValue' in feature.__members__:
		x = feature.xValue
		y = feature.yValue
		z = feature.zValue
		loc = (x,y,z)
	else:
		raise Exception('*** No loc available for this feature.')

##	poa = get_poa(feature)
##	id = feature.id
##	print fnln(),'poa=',poa.name
##	print fnln(),'id=',id
##	loc = poa.datums[id-1].pointOn

	return loc

def loc_of_odb_node(node_label,inst=None,step=-1,frame=-1):
	## VER: ('VER: 2015-11-20, v1.3')
	## Correct.

	## Odb label is stored with index = label - 1, such as:
##	>>> nodes = oa.instances.values()[0].nodes
##	>>> nodes[720].label
##	721

##	>>> loc_of_odb_node(720)
##	(7.66653251647949, 0.0233727134764194, -0.245483040809631)

	if inst in empty:
		inst = inst = oa.instances.keys()[0]

	inst = check_odb_inst(inst)

	if type_of(node_label) == 'ODBMESHNODE':
		node_label = node_label.label

	if type_of(node_label) != 'INT':
		raise Exception('node_label is required.')

	variables0 = odb_variables()
	if 'COORD' in variables0.keys():
		x = xydata_of_nodes(nodes=node_label,inst=inst,step=step,frame=frame,variable='COOR1')
		y = xydata_of_nodes(nodes=node_label,inst=inst,step=step,frame=frame,variable='COOR2')
		z = xydata_of_nodes(nodes=node_label,inst=inst,step=step,frame=frame,variable='COOR3')
		loc = (x,y,z)

	else:
		node = get_odb_nodes_by_labels(inst, node_label)[0]
		x,y,z = totuple(node.coordinates)   ## Error! Only the coordinate of frame 0 (original)
		x = round(x, 6)
		y = round(y, 6)
		z = round(z, 6)
		loc = (x, y, z)

	return loc

def loc_unselect(base,list2):
	## VER: 2015-04-20, v1.0
	## reference: unselect()

	if base in empty:
		return []
	elif list2 in empty:
		return base

	base = totable(base)
	list2 = totable(list2)
##	print ' '
##	print fnln(),'list2=',list2
##	print fnln(),'base=',base

##	base = round_locs(base)
	list2 = round_locs(list2)

	base1 = []
	for item in base:
		item1 = round_loc(item)
		if item1 in list2:
			continue

##		print item,'not in',list2
		if item1 not in base1:
##			print item,'not in',base1
			base1.append(item)

	return base1

def local2global(local_dict,*variables):
	## 2012-01-14, v1.2

	variables = tolist(variables)

	if variables not in empty:
		for var in variables:
			var1 = var
			if type_of(var) != 'STR':
				try:
					var1 = var.name
				except:
					raise Exception('******Name of object is required, not object itself. line=5312, local2global()')

			globals()[var1] = local_dict[var1]
			add2my_globals(var1)

	return

def locals2globals(keys0,locals1,save_var=False):
	## VER: 2017-07-25, v1.9

	global myglobals

	dict1 = {}

	if type_of(keys0) == 'DICT' and type_of(locals1) == 'LIST':
		keys0,locals1 = locals1, keys0

	if type_of(keys0) != 'LIST':
		raise Exception('******keys0 should store the keys only.')

	if type_of(locals1) != 'DICT':
		raise Exception('******locals1 should be locals().')

	if 'inp_file_title' not in myglobals.keys() and 'inp_file_title' in locals1.keys():
		globals()['inp_file_title'] = locals1['inp_file_title']
		myglobals['inp_file_title'] = locals1['inp_file_title']

	locals1 = sort_by_key(locals1)
	caller_code = get_caller_code()
##	print fnln(),get_caller_code()

	for key1,value1 in locals1:
		type1 = type_of(value1)
		if type1 in ['INT','STR','FLOAT','LIST','TUPLE','DICT','','None','BOOL']:   ##???****
			if key1 not in keys0 and key1 not in caller_code and key1 != 'keys0':
				globals()[key1] = value1
				dict1[key1] = value1

				if save_var == True:   ## save to model description and .vars file.
					if inp_file_title not in myglobals.keys():
						myglobals[inp_file_title] = {}
					myglobals[inp_file_title][key1] = value1

					add2my_globals(key1)
					write_global_variables(inp_file_title + '.vars', key1)

					if type_of(value1) == 'STR':
						text = key1 + ' = ' + repr(value1)
					else:
						text = key1 + ' = ' + str(value1)
					add_model_description(text)

	return dict1

def lockV():
	## 2011-01-07, v1.1

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	esets = display.displayGroup.root.leaf.elementSets
	leaf = dgo.LeafFromElementSets(elementSets=esets)
	print 'esets=',esets

	display.contourOptions.setValues(maxAutoCompute=ON,minAutoCompute=ON)
	vmax = display.contourOptions.autoMaxValue
	vmin = display.contourOptions.autoMinValue
	display.contourOptions.setValues(maxAutoCompute=OFF, minAutoCompute=OFF, maxValue=vmax, minValue=vmin)

##	display.displayGroup.replace(leaf=leaf)
##	replot()

	return

def pointOns_of_geometry(sketch,curves=None,regular_only=True):
	## VER: 2015-04-19, v1.1
	## pointOn of construction line will be included.
	## 可以收集整个sketch的pointOn，间接地获得新生成的geometry。

	sketch = check_sketch(sketch)
	if curves not in empty:
		curves = tolist(curves)
	else:
		curves = sketch.geometry.values()

	locs = []
	for curve in curves:
		if curve.getSize() < 0:
			continue

		loc = curve.pointOn
		if loc not in locs:
			locs.append(loc)

	return locs

def vertice_locs_of_geometry(sketch=None, geometry=None):
	## VER: 2015-04-20, v1.2, 也可能包括construction line
	## point is a location
	## a construction line will return []
	## arc center will not included.
	## reference: pointOns_of_geometry()

	## Example:
	## vertice_locs_of_geometry(sketch=sketch,geometry=line2)

	if type_of(geometry) in ['sketch','STR']:
		geometry,sketch = sketch,geometry
	sketch = check_sketch(sketch)

	if is_number(geometry):
		if geometry in sketch.geometry.keys():
			geometry = sketch.geometry[geometry]
		else:
			raise Exception('*** No such geometry with id =' + str(curve))

	elif geometry in empty:   ## 只提供一个参数
		geometry = all_regular_geometry(sketch)

	geometry = tolist(geometry)

	if geometry in empty:
		raise Exception('*** geometry is required.')

	locs = []
	for curve in geometry:
		vertices = curve.getVertices()[:2]    ## center of arc will not included.
		for vertice in vertices:
			loc = vertice.coords
			if loc not in locs:
				locs.append(vertice.coords)

	return locs

def points_at_geometry_x(sketch=None,geometry=None,y=None):
	## VER: 2015-10-16, v1.2

	if geometry in empty:   ## 只提供一个参数
		try:
			sketch = check_sketch(sketch)
			geometry = all_regular_geometry(sketch)
		except:
			geometry = sketch
			sketch = get_parent(geometry)
			if sketch not in _m.sketches.values():
				raise Exception('*** Fail to get the sketch.')

	else:	##提供两个参数
		if type_of(geometry) in ['sketch','STR']:
			geometry,sketch = sketch,geometry
		sketch = check_sketch(sketch)

	geometry = tolist(geometry)

	if geometry in empty:
		raise Exception('*** geometry is required.')

	if y not in empty:
		y = real_xy_sketch(sketch,y=y,Yonly=True)

	locs = []
	for curve in geometry:
		vertices = curve.getVertices()[:2]  ## center of arc will not included.
		for vertice in vertices:
			loc = vertice.coords
			if loc not in locs:
				if type_of(y) in numerics:
					x1,y1 = loc
					if PK(y1,y) == 0:
						locs.append(vertice.coords)
				else:
					locs.append(vertice.coords)

	print fnln(),'locs=',locs
	if locs in empty:
		raise Exception('*** No loc was found')
	locs = sort_tuple_type_elements(locs,index=0)

	return locs

def points_at_geometry_y(sketch=None,geometry=None,x=None):
	## VER: 2015-09-28, v1.2

	if geometry in empty:   ## 只提供一个参数
		try:
			sketch = check_sketch(sketch)
			geometry = all_regular_geometry(sketch)
		except:
			geometry = sketch
			sketch = get_parent(geometry)
			if sketch not in _m.sketches.values():
				raise Exception('*** Fail to get the sketch.')

	else:	##提供两个参数
		if type_of(geometry) in ['sketch','STR']:
			geometry,sketch = sketch,geometry
		sketch = check_sketch(sketch)

	geometry = tolist(geometry)

	if geometry in empty:
		raise Exception('*** geometry is required.')

	if x not in empty:
		x = real_xy_sketch(sketch,x=x,Xonly=True)

##	print 'x=',x

	locs = []
	for curve in geometry:
##		print curve.getVertices()
		vertices = curve.getVertices()[:2]  ## center of arc will not included.
		for vertice in vertices:
			loc = vertice.coords
##			print 'loc=',loc
			if loc not in locs:
				if type_of(x) in numerics:
					x1,y1 = loc
##					print 'x1,x=',(x1,x)
##					print 'PK(x1,x)=',PK(x1,x)
					if abs(x1-x) < 1e-4:   ## 不能用PK(x1,x)
##					if PK(x1,x) == 0:
						locs.append(vertice.coords)
				else:
					locs.append(vertice.coords)

##	print 'locs=',locs
##	raise Exception
	if locs in empty:
		raise Exception('*** locs in empty')

	locs = sort_tuple_type_elements(locs,index=1)

	return locs

def locs_of_arc_nodes(labels=(),part=None,cae_nodes=None,from_odb=False,axis1='x',axis2='y',err=0.1,expand=True,step=-1,frame=-1):
	## VER: 2015-12-09, v1.2, 至少给出两个点

	## Example: nodes = get_arc_nodes(labels=[3833,3617,2671],from_odb=True)
##	>>> nodes[0].coordinates
##	(-0.00724466051906347, 2.65596532821655, 0.888877630233765)
##	>>>

	if axis1 == 1:
		axis1 = 'x'
	elif axis1 == 2:
		axis1 = 'y'
	elif axis1 == 3:
		axis1 = 'z'
	axis1.lower()
	if axis1 not in ['x','y','z']:
		raise Exception('*** axis1 should be x,y or z')

	if axis2 == 1:
		axis2 = 'x'
	elif axis2 == 2:
		axis2 = 'y'
	elif axis2 == 3:
		axis2 = 'z'
	axis2.lower()
	if axis2 not in ['x','y','z']:
		raise Exception('*** axis2 should be x,y or z')

	plane = axis1 + axis2
	if 'x' not in plane:
		axis3 = 'x'
	elif 'y' not in plane:
		axis3 = 'y'
	elif 'z' not in plane:
		axis3 = 'z'

	if cae_nodes not in empty:
		if type_of(cae_nodes) in ['LIST','TUPLE'] and type_of(cae_nodes[0]) == 'nodes':
			nodes = cae_nodes
		elif type_of(cae_nodes) == 'STR':
			if part in empty:
				raise Exception('*** part should be provided for node set name.')
			nodes = set2objs(setname=cae_nodes,p=part)
		else:
			raise Exception('*** Either nodes list or node setname is required.')

		part = get_parent(nodes[0])

	elif labels not in empty:
		if is_numbers(labels) == False:
			raise Exception('*** node labels are required.')

		if len(labels) <2:
			raise Exception('*** At least two node labels are required.')

		if part in empty:
			if from_odb == True or len(_m.parts) == 0:
				import_part_from_odb(step=step,frame=frame)

			if len(_m.parts) == 0:
				raise Exception('*** No part in the model')

			part = _m.parts.keys()[0]

		part = check_part(part)

		if len(part.nodes) == 0:
			raise Exception('*** No nodes in the part.')

		nodes = []
		for label in labels:
			nodes.append(part.nodes[label-1])

	if expand == True:
		space = objs_space(nodes)
		nodes2 = node_select(part,space=space,err=err)
		set1 = create_set(part,nodes=nodes2,name='nodes_arc')

		print fnln(),'created arc nodes set,name=',name_of_set(set1)
		light(nodes2)

	else:
		nodes2 = nodes

	locx = []
	locy = []
	locz = []
	for node in nodes2:
		x,y,z = node.coordinates
		locx.append(x)
		locy.append(y)
		locz.append(z)

	if axis1 == 'x':
		coordx = locx
	elif axis1 == 'y':
		coordx = locy
	elif axis1 == 'z':
		coordx = locz

	if axis2 == 'x':
		coordy = locx
	elif axis2 == 'y':
		coordy = locy
	elif axis2 == 'z':
		coordy = locz

	locs = []
	for i in range(len(coordx)):
		locs.append((coordx[i],coordy[i]))

	return locs

def locs_of_edge(edge, pars=(0,1)):
	## VER: 2014-07-14, v1.2
	### such as: pars=[0, 1], pars=(0,0.1,0.2,0.5,1.0)

	if type_of(edge) != 'edges':
		raise Exception('*** an edge is required.')

	try:
		curvature = edge.getCurvature(point=edge.pointOn[0])
		shape = 'curve'
	except:
		shape = 'line'

	poi = get_poi(edge)
	locs = []
	vertices = edge.getVertices()

	start_loc = poi.vertices[vertices[0]].pointOn[0]
	if len(vertices) == 2:
		end_loc = poi.vertices[vertices[1]].pointOn[0]
	else:
		end_loc = start_loc   # a circle has only one vertice

	pars = tolist(pars)

	if shape == 'line':
		loc1,loc2 = end_locs_of_edge(edge)
		x1,y1,z1 = loc1
		x2,y2,z2 = loc2

		for par in pars:
			x = x1 + (x2-x1)*par
			y = y1 + (y2-y1)*par
			z = z1 + (z2-z1)*par

##			x = round(x,7)
##			y = round(y,7)
##			z = round(z,7)

			loc = (x,y,z)
			loc = round_loc(loc,7)

			locs.append(loc)

	else:
		for par in pars:
			if par == 0:
				locs.append(start_loc)
			elif par == 1:
				locs.append(end_loc)
			else:
				curvature = edge.getCurvature(parameter=par)  ## not applicable for a straight line
				loc = curvature['evaluationPoint']
				loc = round_loc(loc,7)
##				x,y,z = loc
##				x = round(x,7)
##				y = round(y,7)
##				z = round(z,7)
##				loc = (x,y,z)

				locs.append(loc)

	return locs

def locs_of_edges(edges):
	## VER: 2015-11-16, v1.2

	edges = tolist(edges)

	locs = []
	for edge in edges:
		locs0 = end_locs_of_edge(edge)
		for loc in locs0:
			if loc not in locs:
				locs.append(loc)

	return locs

##def locs_of_edges(edges):
##	## VER: 2014-07-14, v1.1
##
##	edges = tolist(edges)
##	vertices = edges_to_vertices(edges)
##
##	single_points = []
##	for vertice in vertices:
##		if len(vertice.getEdges()) == 1:
##			single_points.append(vertice)
##
##	if len(single_points) == 1:  ## circle
##		pt0 = single_points[0]
##	elif len(single_points) == 2:    # 2: opened lines
##		pt0 = single_points[0]
##	elif len(single_points) == 0:   ## 0: closed lines,
##		pt0 = vertices[0]
##	else:
##		raise Exception('*** please specify the start point.')
##
####	print fnln(),'single_points=',single_points
##
##	pars = myrange(0,1,0.01)
##	locs = []
##	if len(edges) == 1:
##		locs = locs_of_edge(edges[0],pars=pars)
##	else:
##		dict1 = {}
##		for edge in edges:
##			id = edge.index
##			locs_id = locs_of_edge(edge,pars=pars)
##			dict1[id] = locs_id
##
##		poi = get_poi(edges)
##		pt0_id = pt0.index
##
##		edge0_id = pt0.getEdges()[0]
##		edge0 = poi.edges[edge0_id]
##
##		indexs = connect_edges(edges,pt0, edge0)
####		print 'len(indexs)=',len(indexs)
####		print 'indexs=',indexs
##
##		locs = dict1[edge0_id]
##
##		indexs = indexs[1:]
##		for index in indexs:
##			locs1 = dict1[index]
##			if is_same_loc(locs[-1],locs1[0]):
##				locs = locs + locs1[1:]
##			elif is_same_loc(locs[-1],locs1[-1]):
##				locs1.reverse()
##				locs = locs + locs1[1:]
##			else:
##				print 'locs[-1]=',locs[-1]
##				print 'edge index=',index
##				print locs1[0]
##				print locs1[-1]
##				raise Exception('*** Not connected locs.')
##
##	print fnln(), len(locs),'locs are found for',len(edges),'connected edges.'
##
##	return locs

def locs_of_face(face,minimum=4):
	## VER: ('VER: 2014-07-15, v1.5')
	## 收集该面及该面上的线的pointOn位置

	## refer to: coords_of_objs()

	locs = []
	locs.append(face.pointOn[0])

	poi = get_poi(face)
	for index1 in face.getEdges():
		edge = poi.edges[index1]
		locs1 = locs_of_edge(edge,0.2)
		locs = locs + locs1

	for index1 in face.getEdges():
		edge = poi.edges[index1]
		locs1 = locs_of_edge(edge,0.8)
		locs = locs + locs1

	if len(locs) < 4:
		for index1 in face.getVertices():
			loc = poi.vertices[index1].pointOn[0]
			if loc not in locs:
				locs.append(loc)
			if len(locs) >= minimum:
				break

	return locs

def locs_poi_to_sketch(locs,ndir='y'):
	## VER: 2012-11-26, v1.0

	if type_of(locs) == 'STR':
		locs,ndir = ndir,locs

	ndir = ndir.lower()
	if len(locs) == 3 and type_of(locs[0]) in numerics:
		locs = [locs]

	locs_2D = []
	if ndir == 'x':
		for loc in locs:
			x3,y3,z3 = loc
			y2,z2 = y3,z3
			locs_2D.append([y2,z2])
	elif ndir == 'y':
		for loc in locs:
			x3,y3,z3 = loc
			x2,z2 = x3,-z3
			locs_2D.append([x2,z2])
	elif ndir == 'z':
		for loc in locs:
			x3,y3,z3 = loc
			x2,y2 = x3,y3
			locs_2D.append([x2,y2])

	return locs_2D

def locs_sketch_to_poi(locs,ndir='y',offset=0):
	## VER: 2012-11-26, v1.0	offset为sketch的offset

	if type_of(locs) == 'STR':
		locs,ndir = ndir,locs

	ndir = ndir.lower()
	if len(locs) == 2 and type_of(locs[0]) in numerics:
		locs = [locs]

	locs_3D = []
	if ndir == 'x':
		for loc in locs:
			y2,z2 = loc
			y3,z3 = y2,z2
			locs_3D.append([offset,y3,z3])
	elif ndir == 'y':
		for loc in locs:
			x2,z2 = loc
			x3,z3 = x2,-z2
			locs_3D.append([x3,offset,z3])
	elif ndir == 'z':
		for loc in locs:
			x2,y2 = loc
			x3,y3 = x2,y2
			locs_3D.append([x3,y3,offset])

	return locs_3D


def long_edges_of_faces(part=None,faces=None,x=None,y=None,z=None,minimum=None):
	## VER: 2014-09-11, v1.4

	if is_part(faces):
		part,faces = faces,part

	if is_poi(part):
		part = check_part(part)

	if type_of(part) == 'PART' and (x,y,z) != (None,None,None):
		faces = faces_of_cut(part,x=x,y=y,z=z,exterior=None)
	else:
		faces = tolist(faces)

	if faces in empty:
		raise Exception('*** faces are required.')

	if minimum in empty:
		minimum = 3
##		x1,x2,y1,y2,z1,z2 = objs_space(faces)
##		list1 = _sort(x2-x1,y2-y1,z2-z1)
##		minimum = 0.3*list1[1]

	long_edges = []
	for face in faces:
		edges = edges_of_face(face,in_out='exterior',long_short='long',minimum=minimum)
		if len(edges) > 0:
			long_edges = long_edges + edges[0:1]

	print '--->',len(long_edges),'long edges are selected from the cross-section faces.'
	print ' '

	return long_edges

def long_short_edges_of_face(face,ratio=2.5,short_min=1.3,long_min=4,area_min=5):
	## VER: 2012-12-10, v1.5，注意与faces_to_edges不同，本函数主要用于mesh时，寻找长边和短边。

	if type_of(face) != 'faces':
		raise Exception('****** A face is required.')

	poi = get_poi(face)
	ids = face.getEdges()

	long_edges = []
	short_edges = []

##	print len(ids)
	if len(ids) == 4:
		area = get_area(face)
		if area < area_min:
			return [],[]

		Ldict = {}
		for id in ids:
			edge = poi.edges[id]
			length = edge_length(edge)
			if length < short_min:
				return [],[]
			Ldict[id] = length

		list1 = sort_by_value(Ldict)  ## 逆序
		edge1,edge2,edge3,edge4 = list1
		if PK(edge1[1],edge2[1]) != 0 or PK(edge3[1],edge4[1]) != 0:
			return [],[]	## 无效。例如梯形。

		longer = edge1[1]
		shorter = edge3[1]

		ndict = {}
		for id in ids:
			edge = poi.edges[id]
			num = len(edge.getFaces())
			ndict[id] = num

		nums = ndict.values()
		min_num = min(nums);	min_status = nums.count(min_num)
		max_num = max(nums); max_status = nums.count(max_num)
		if min_status == 3 and max_status == 1:  ## 有三条边均只是两个面的交界线。
			for id in ndict.keys():
				if ndict[id] == 3:  ## inner edge
					short_edges = [poi.edges[id]]   ## 至少是短边，也可能同时算入长边。
					if id == edge3[0] or id == edge4[0]:  ## 短边
						short_edges = [poi.edges[edge3[0]], poi.edges[edge4[0]]]
						if longer >= 0.75*long_min or longer >= ratio*shorter:
							long_edges = [poi.edges[edge1[0]], poi.edges[edge2[0]]]

		elif nums == [2,2,2,2]:
			long_edges = [poi.edges[edge1[0]], poi.edges[edge2[0]]]
			short_edges = [poi.edges[edge3[0]], poi.edges[edge4[0]]]

		else:
			if longer < long_min or longer < ratio*shorter:
				return [],[]   ## 无效

			long_edges = [poi.edges[edge1[0]], poi.edges[edge2[0]]]
			short_edges = [poi.edges[edge3[0]], poi.edges[edge4[0]]]

	elif len(ids) >= 5:
		area = get_area(face)
		if area < area_min:
			return [],[]

		Ldict = {}
		for id in ids:
			edge = poi.edges[id]
			length = edge_length(edge)
			Ldict[id] = length

		list1 = sort_by_value(Ldict)  ## 逆序
		edge1,edge2 = list1[0],list1[1]
		length = edge1[1]
		edge1 = poi.edges[edge1[0]]
		edge2 = poi.edges[edge2[0]]
		if is_similar_edge(edge1,edge2) == True and length > long_min:		## 最长的两条边相似
			long_edges = [edge1,edge2]

	return long_edges,short_edges

def long_short_edges_of_faces(part=None,faces=None,x=None,y=None,z=None,ratio=2.5,short_min=1.3,long_min=4,area_min=5):
	## VER: 2012-12-10, v1.3
	## 可能会出错。标准. 不如单独运行long_edges_of_faces(), short_edges_of_faces()

	print 'Usage: long_short_edges_of_faces(part=None,faces=None,x=None,y=None,z=None,ratio=2.5,short_min=1.3,long_min=4,area_min=5)'
	print ' '

	if type_of(part) == 'LIST' and part not in empty:
		if type_of(part[0]) == 'faces':
			part,faces = faces,part

	if type_of(part) == 'PART' and (x,y,z) != (None,None,None):
		faces = faces_of_cut(part,x=x,y=y,z=z,exterior=None)
	else:
		faces = tolist(faces)

	long_edges = []
	short_edges = []

	for face in faces:
		longs,shorts = long_short_edges_of_face(face,ratio=ratio,short_min=short_min,long_min=long_min,area_min=area_min)
		for edge in longs:
			if edge not in long_edges:
				long_edges.append(edge)

		for edge in shorts:
			if edge not in short_edges:
				short_edges.append(edge)

	print len(long_edges),'long edges and',len(short_edges),'short edges are found.'

	return long_edges, short_edges

function_labels['main_vars'] = 'result','variables','odb','fieldVariables'
def main_vars():
	## VER: 2014-11-29, v1.0
	## is different from the field output request variables
	## reference: find_odb_variables(),odb_variables()

##	'CE', 'CEEQ',  'CENER', 'CF', 'CM', 'CNAREA', 'CNORMF', 'COORD',
##	'COPEN', 'CPRESS',  'CSHEAR1', 'CSHEAR2' 'CSHEARF',  'CSTATUS', 'DMENER',  'EE',
##  'EVOL',  'IVOL', 'IE','LE', 'NE', 'NT11', 'NT12', 'PE', 'PEEQ', 'PEMAG', 'PENER', 'PEQC',
##	 'RF', 'RM', 'S', 'SENER', 'TEMP', 'TF', 'THE', 'TM', 'U', 'UR'
##  'V', 'BF', 'GRAV', 'P'

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	list1 = display.fieldVariables.variableList  ## for this step only

	vars = []
	for item in list1:
		vars.append(item[0])

	return vars

function_labels['make_dir'] = 'folder','directory'
def make_dir(dirname):
	## VER: 2015-07-17, v1.0

	## 可以连续创建多级子目录，例如：
##	>>> make_dir('Part/part1')  ## 如果在当前目录下没有Part子目录，就创建Part子目录。如果在Part子目录下没有part1子目录，就在Part子目录下创建part1子目录。
##	'Part/part1'

##	>>> make_dir('results')  ## 在当前工作目录下生成子目录result
##	'Z:/A0283-Assembly analysis-Oscar/new1/results'

	dirname = real_dir(dirname)
	if not os.path.isdir(dirname):
		os.makedirs(dirname)

	if not os.path.isdir(dirname):
		result = ''
		print '*** Fail to create the new dir:',dirname

	else:
		result = dirname
		if '/' not in result:
			result = search_dir(result)

	return result

function_labels['map_data'] = 'lambda','mapping', 'dict'
def map_data(data,list1,list2):
	## VER: 2017-08-09, v1.0

##	>>> map_data(ndir,(0,1,2),('x','y','z'))
##	'x'

	if type_of(list1) not in ['LIST','TUPLE'] or type_of(list2) not in ['LIST','TUPLE']:
		raise Exception('*** list1 and list2 should be list or tuple.')

	for i in range(len(list1)):
		if data == list1[i]:
			data = list2[i]
			break

	return data

def mapped_seed(setname,p1='',dx=0, dy=0, dz =0, size=5,num=1):
	## VER: 2010-02-22

	inst = insts_by_set(setname)
	part_ofset = _m.parts[inst[0].partName]
	if p1 == '':
		p1 = [part_ofset]

	num1 = len(set2objs(setname,part_ofset))

	parts_name = []
	for p in p1:
		parts_name.append(p.name)
	print 'Mapped seeding for',num1,'edges for',parts_name,'......'
	for p in p1:
		for i in range(num1):
			loc = KPxyz(setname,part_ofset,i)
			loc = (loc[0]+dx,loc[1]+dy,loc[2]+dz)

			seed_edge(p,loc=loc,esize=size,enum=num)

	return

function_labels['mapping'] = 'sort','lambda','tuples','dict','list','mapping','loop'
def mapping(tuples,index=0,sort=None,abs=None,factor=1,offset=0):
	## VER: 2016-12-19, v1.0

##	map(lambda edge: (round(edge_length(edge),4),edge), edges)  ## 获得一个列表:[(length1,edge1),(length2,edge2),...]
##  lambda edge: 相当于函数句柄，其中edge是参数。lambda是函数名。但其调用方式不是lambda(参数)
##	lambda函数的格式为: map(lambda 参数: 返回的元素, 参数列表)  ## ★★★

##	>>> list1 = [1,3,3]
##	>>> lambda x:x,list1
##	(<function <lambda> at 0x000000001C2EE668>, [1, 3, 3])
##	>>> map(lambda x:x,list1)
##	[1, 3, 3]
##	>>> map(lambda x:is_number(x),list1)
##	[True, True, True]
##	>>>

##	>>> insts = instances_of_BC('die')
##	>>> names = map(lambda x:x.name, insts)  ## insts是一个列表   (lambda元素:进行操作）
##	>>> names
##	['die_A1']
##	>>>

##	>>> am1
##	mdb.models['Model-1'].amplitudes['top_move']
##	>>> am1.data
##	((0.0, 0.0), (0.1, -4.0), (0.5, -25.0), (1.0, -45.4))
##	>>> mapping(am1.data,index=0)
##	[0.0, 0.1, 0.5, 1.0]
##	>>> mapping(am1.data,index=1)
##	[0.0, -4.0, -25.0, -45.4]
##	>>>
##	>>> mapping(am1.data,index=1,sort=True)
##	[-45.4, -25.0, -4.0, 0.0]
##	>>>

	if type_of(tuples) == 'DICT':
		tuples = tuples.items()

	try:
		tuples[0]
	except:
		raise Exception('*** a list of tuples is required.')

	if abs == True:
		list1 = map(lambda item:abs(factor*item[index]), tuples)  ## lambda相当于函数名，item相当于参数，返回值为abs(factor*item[index])
	else:
		if is_number(factor) and factor != 1:
			list1 = map(lambda item:factor*item[index]+offset, tuples)
		else:
			if is_number(offset) and offset != 0:
				list1 = map(lambda item:item[index] + offset, tuples)
			else:
				list1 = map(lambda item:item[index], tuples)

	if sort in ['increase','ascend','+',True]:
		list1 = sorted(list1)
	elif sort in ['decrease','descend','-']:
		list1 = sorted(list1)
		list1.reverse()

	return list1

def mark_loc(part,x='',y='',z=''):
	## VER: 2010-06-29

	if x != '':
		loc = x
		dir = 'x'
	elif y != '':
		loc = y
		dir = 'y'
	elif z != '':
		loc = z
		dir = 'z'

	x1,x2,y1,y2,z1,z2 = poi_space(part)
	ext = 10
	err1 = 1e-5

	if dir == 'x':
		create_block(part,(loc,loc + err1),(y1-ext,y2+ext),(z1-ext,z2+ext))
	elif dir == 'y':
		create_block(part,(x1-ext,x2+ext),(loc,loc + err1),(z1-ext,z2+ext))
	elif dir == 'z':
		create_block(part,(x1-ext,x2+ext),(y1-ext,y2+ext),(loc,loc + err1))

	return

def mat2section(mat):
	## VER: 2014-11-25, v1.0

	if mat not in _m.materials.keys():
		raise Exception('*** material not existed.')

	sections = []
	for sec in _m.sections.keys():
		section = _m.sections[sec]
		if section.material == mat:
			sections.append(sec)     ## collect all the sections of mat

	if sections in empty:
		sec_name = check_name(_m.sections.keys(),mat + '_sec')
		_m.HomogeneousSolidSection(name=sec_name, material=mat, thickness=1)
	elif len(sections) == 1:
		sec_name = sections[0]
	else:
		raise Exception('*** There are more than one section for mat '+ mat)

	return sec_name

def mat_deform():
	## VER: 2010-09-06, v1.0

	vpnow = get_vpnow()
	vpnow.odbDisplay.display.setValues(plotState=(DEFORMED, ))

	vpnow.enableMultipleColors()
##	vpnow.setColor(initialColor='#BDBDBD')
	cmap=vpnow.colorMappings['Material']
	vpnow.setColor(colorMapping=cmap)
	vpnow.disableMultipleColors()

	vpnow.odbDisplay.commonOptions.setValues(visibleEdges=EXTERIOR)

	animate()

	return

def mat_view():
	## 2011-03-15, v1.0

	vpnow = get_vpnow()
	vpnow.enableMultipleColors()
	vpnow.setColor(initialColor='#BDBDBD')
	cmap=vpnow.colorMappings['Material']
	vpnow.setColor(colorMapping=cmap)
	vpnow.disableMultipleColors()
	vpnow.odbDisplay.commonOptions.setValues(visibleEdges=FEATURE)

	return

def same_axis_direction(vector,dir1):
	## VER: 2014-12-22, v1.1，用于bias_seed或者建立surface
	## vector是一个向量，例如：vector= (-0.0, -1.0, 0.0)
	## vector= (-0.0, -1.0, 0.0)与side=-y是match的。

##	>>> same_axis_direction((0.0, -1.0, 0.0), '-y')
##	True

	if type_of(vector) == 'STR':
		vector, dir1 = dir1, vector

	dir1 = dir1.lower()
	if dir1[-1] not in ['x','y','z']:
		raise Exception('*** Error direction, should be in x, y, or z.')

	sign = index = None
	if '+' in dir1:
		sign = 1
	elif '-' in dir1:
		sign = -1

	if 'x' in dir1:
		index = 0
	elif 'y' in dir1:
		index = 1
	elif 'z' in dir1:
		index = 2

	if sign in empty or index in empty:
		raise Exception('*** incorrect axis dir info, should be such as +x')

	if type_of(vector) == 'edges':
		vector = edge_to_vector(vector)
	elif type_of(vector) == 'DATUMAXIS':
		vector = vector.direction

	if is_vector(vector) == False:
		raise Exception('*** A vector, straight edge, or datum axis is required.')

	please_check
	if sign*vector[index] > 0:    ## sign与vector[index]同号。
		matched = True
	else:
		matched = False

	return matched

function_labels['mats_of_poi'] = 'material','part','instance','poi'
def mats_of_poi(poi):
	## VER: 2015-03-19, v1.0
	## reference: get_mats()

##	>>> mats_of_poi('powder')
##	['H10pow']
##	>>>

	poi = check_poi(poi)
	mats0 = get_mats(poi)

	if mats0 not in empty:
		mats = mats0.values()[0].keys()
	else:
		mats = []

	return mats

def max_ofset(part,setname,dir1):
	## VER: 2010-01-25

	if dir1 == 'x':
		index1 = 0
	elif dir1 == 'y':
		index1 = 1
	elif dir1 == 'z':
		index1 == 2

	v0 = KPxyz(setname,part,0)[index1]
	locs = set2pointOns(part,setname)
	num1 = len(locs)
	for i in range(num1)[1:]:
		v1 = KPxyz(setname,part,i)[index1]
		if v0 < v1:
			v0 = v1

	return v0

function_labels['meet_element_face_dir'] = 'element surface','element face','ndir'
def meet_element_face_dir(face,nx=None,ny=None,nz=None):
	## VER: 2016-11-30, v1.0

	if type_of(face) != 'elemFaces':
		raise Exception('*** An element face is required.')

	elem = face.getElements()[0]

	center = element_center(elem)
	nodes1 = face.getNodes()
	normal = normal_vector_of_three_points_plane(nodes1[0],nodes1[1],nodes1[2],center)

	vector = vector_in_01(normal)

	xmeet = ymeet = zmeet = True
	if nx not in empty and nx != vector[0]:
		xmeet = False
	if ny not in empty and ny != vector[1]:
		ymeet = False
	if nz not in empty and nz != vector[2]:
		zmeet = False

	if xmeet and ymeet and zmeet:
		result = True
	else:
		result = False

	return result

def meet_search_range(candidate_range=(),search_range=(),include_ends=False,mark_select=True,err=1e-3):
	## VER: ('VER: 2014-09-09, v3.1')
	## 实际上，mark_select参数没用。少用mark_select参数，默认为True；多用ndir。
	## 对于edge_select, include_ends的缺省值为True

##>>> meet_search_range(11.2005, 11.201)   ## Error
##True
##>>>

	## candidate_range is the candidate range

	## search_range: search range, candidate_range: obj range
	## 特殊情形：candidate_range vs. search_range:
	##        1. 	! 		       vs. 		()
	##        2. 	! 		       vs. 		|
	##        3. 	{} 	       vs. 		|
	##        4. 	{} 	       vs. 		()
	## keyword: mark_select = True时，碰上就选择
	## 假设!代表candidate_range为一个数, |为search range为一个数。
	## 假设{}代表candidate_range为一个范围，()代表search range为一个范围。

	candidate_range=eval(repr(candidate_range))
	search_range=eval(repr(search_range))

	if type_of(candidate_range) in ['FLOAT','INT']:
		candidate_range = (candidate_range,candidate_range)

	if type_of(search_range) in ['FLOAT','INT']:
		search_range = (search_range,search_range)

	list1 = [candidate_range[0],candidate_range[1],search_range[0],search_range[1]]
	list1.sort()

	if PK(candidate_range[0],candidate_range[1]) == 0:
		candidate = 'point'
	else:
		candidate = 'range'

##	print fnln(),'candidate=',candidate
##	print fnln(),'candidate_range=',candidate_range

	if PK(search_range[0],search_range[1]) == 0:
		search = 'point'
	else:
		search = 'range'

##	print fnln(),'search=',search
##	print fnln(),'search_range=',search_range

	list2 = []
	for item in list1:
		if item not in list2:
			list2.append(item)

	data_num = len(list2)
##	print fnln(),'list2=',list2

	cross = cross_of_ranges(candidate_range,search_range)  ## have err par
##	print fnln(),'cross=',cross

	match1 = False
	meet_type = 'NA'

	if cross['length'] > 0:
		match1 = True
		meet_type = 'crossed:{ [} ]'
	elif cross['length'] == 0:  ## 交集只有一个点。
		if candidate == 'point' and search == 'point':  ##重合：!/|  situation 2
			match1 = True
			meet_type = '!/|'
		elif candidate == 'range' and search == 'range': ## 两个球相切，不选择。(不管是face, cell, edge，都不会选择)(不选擦边球)
			match1 = False
			meet_type = '{}()'

		elif candidate == 'point' and search == 'range':   ## ! vs. (), situation 1
			## data_num要么为3，要么为2
			if data_num == 3:   ## 囊括其中 ( ! ) point inside search range
				match1 = True
				meet_type = 'include_obj:( ! )'
			elif data_num == 2 and include_ends == True:   ##贴着边缘: !/()
##			elif data_num == 2: ##贴着边缘: !/()
				match1 = True	;please_check   ## for face select: match1 is False, for edge_select: match1 should be True
				meet_type = '!/()'
		elif candidate == 'range' and search == 'point':  ## {} vs. |, situation 3
			## data_num要么为3，要么为2
			if data_num == 3:  ## allow mark select (使得命令变得简单灵活，包括对于shell模型)  ## 切入其中：{ | }   (cut through)
				if mark_select == True:
					match1 = True
					meet_type = 'cut_into_obj:{ | }'		;please_check
				else:
					match1 = False
					meet_type = 'cut_into_obj:{ | }'		;please_check
			elif data_num == 2:  ## 不选擦边的球。这种类型的mark_select不要

				##>>> meet_search_range((39.999, 40.0), 40)   其中，(39.999, 40.0)是由于几何位置不够精确造成的。
				##['meet_search_range', 282] candidate= range
				##['meet_search_range', 290] search= point
				##['cross_of_ranges', 223] lenght= 0.0
				##['meet_search_range', 302] cross= {'touch': True, 'length': 0, 'range': [40.0, 40]}
				##True
				##>>>

				mid = (candidate_range[0] + candidate_range[1])/2
				please_check
				if abs(mid - search_range[0]) < err:   ## 1um   ## 有时候, candidate range非常窄，可能是几何上的读取误差或制图误差所致。
					match1 = True
				else:
					match1 = False

			## 不选择{}[], {}|

	else:  ## cross['length'] < 0
		if search == 'point' and abs(candidate_range[0] - candidate_range[1]) < 1e-3:
			mid = (candidate_range[0] + candidate_range[1])/2
##			print 'mid=',mid

			changing
			if abs(mid - search_range[0]) < 1e-4:   ## 0.1um   ## 有时候, candidate range非常窄，可能是几何上的读取误差或制图误差所致。
				print 'err=',err
				print abs(mid - search_range[0])
				match1 = True
			else:
				match1 = False

		##>>> meet_search_range(39.999, 40)
		##['meet_search_range', 303] cross= {'touch': False, 'length': -0.001, 'range': [39.999, 40]}
		##mid= 39.999
		##True
		##>>>

	return match1

def mems_num(obj):
	## VER: ('VER: 2012-12-27, v1.1')
	## num = 0表示fail to get the mems_num
	## Note: 0 > None

	num = None
	try:
		num = len(obj.__members__)		## Repository object has no members, but has keys, such as: _m.parts
	except:
		pass

	return num

def merge_edges(part,edges=None):
	## VER: 2014-12-23, v1.2
	## 此函数会使得get_part_space()出现错误，要当心。

	## ignore_vertices()比merge_edges()好。
##	vertices = vertice_select(powder_part, y=0)
##	ignore_vertices(powder_part,vertices=vertices[0])

##	edges = edge_select(powder,ny=-1)
##	merge_edges(powder,edges=edges)   ## sometimes will fail to merge.

	part = check_part(part)

	if edges in empty:
		edges = part.edges

	if type_of(edges) == 'STR' and edges in part.sets.keys():
		edges = set2objs(part,edges)

	edges = totuple(edges)

	if len(edges) <= 1:
		raise Exception('*** muliple edges are required.')

	edges_y2 = edge_select(part,y=MAX)
	if have_common(edges_y2, edges):
		raise Exception('*** Straight lines at ymax cannot be merged, otherwise, may lead to error in part_space.')

	edges_y1 = edge_select(part,y=MIN)
	if have_common(edges_y1, edges):
		raise Exception('*** Straight lines at ymin cannot be merged, otherwise, may lead to error in part_space.')

	edges_x1 = edge_select(part,x=MIN)
	if have_common(edges_x1, edges):
		raise Exception('*** Straight lines at xmin cannot be merged, otherwise, may lead to error in part_space.')

	edges_x2 = edge_select(part,x=MAX)
	if have_common(edges_x2, edges):
		raise Exception('*** Edges at xmax cannot be merged, otherwise, may lead to error in part_space.')

	part.MergeEdges(edgeList=edges,extendSelection=False)
	part.checkGeometry()
	part.regenerate()

	return

def merge_instances(insts=(),partname='part1',parts=(),boundary='keep'):
	## VER: 2016-07-04, v3.2, 如果boundary='merge'，也只是merge instance直接的界面，至于某个instance内部的边界线不被merge
	## 几个instance分别有自己的RP时，合并之后，RP会消失。几个instance分别有自己的O1时，合并之后O1不再只对应一个点，而是会对应多个点。

	## 注意：wire part不能被move和merge。只能移动其sketch

	## 合并后加入是保持边界，材料就还存在，例如:
##	set_mat('base',mat='Steel')
##	set_mat('carbide',mat='H10F')
##	merge_instances(parts=('base','carbide'),partname='ring')
##	>>> mats_of_poi('ring')
##	['Steel', 'H10F']
##	>>>

	global default_plot, _m, a

	if type_of(partname) in ['TUPLE','LIST'] and type_of(insts) == 'STR':
		insts,partname = partname,insts

	if insts not in empty:
		insts = tolist(insts)
		if type_of(insts[0]) != 'STR':
			raise Exception('*** an insts name list is required.')

		insts = real_insts(insts)
	elif parts not in empty:
		insts = []
		for part in parts:
			insts0 = insts_of_parts(part)
			if insts0 in empty:
				name = new_instance(part)
				insts0 = [a.instances[name]]
			insts = insts + insts0

	if insts in empty:
		raise Exception('instances are required for merge')

	insts = totuple(insts)
	names = poi_names(insts)
	if len(names) < 2:
		raise Exception('******At least 2 instances are required for merge.')

	partnames = []
	for inst in insts:
		name = inst.partName
		if name not in partnames:
			partnames.append(name)

##	if partname in partnames:   ## 保留主人的RP和O1
##		part = _m.parts[partname]
##		RP_loc = RPxyz(partname)
##		O1_loc = ()
##		if 'O1' in part.sets.keys():
####			point = set2objs(part,'O1')[0]
####			O1_loc = point.pointOn[0]
##			O1_loc = set2pointOns(part,'O1')[0]

	if boundary == 'keep':
		intersect = ON
	else:
		intersect = OFF

	temp_name = new_key(_m.parts.keys(),partname)

	print '   '
	print fnln(),'Merging geometry instances...'

	a.InstanceFromBooleanMerge(name=temp_name, instances=insts,
	    keepIntersections=intersect, originalInstances=DELETE, domain=GEOMETRY)

	print fnln(),'instances merged to create new part:',temp_name

	a.regenerate()

	del a.features[temp_name + '-1']		## delete instance
	if partname != temp_name:		## Existed part
		rename(_m.parts[temp_name], partname)

##	if partname in partnames:   ## RP和O1最重要，csys不重要。
##		part = _m.parts[partname]
##		create_RP(partname,loc=RP_loc)

	a.regenerate()
	update_part(partname)
	default_plot = _m.parts.values()[0]

	return partname

function_labels['mesh_lam'] = 'PV','module','suntech','lamination','glass','cell'
def mesh_lam(esize=None,glass_enum=1, glass_edge_esize=2,cell_esize=None):

	## VER: ('VER: 2012-07-31, v2.1')

	if esize in empty:
		esize = lam_esize

	## lam
	lams = find_mdb_parts('lam')
	for lam in lams:
		if glass_enum > 1:
			seed_edge(lam,z=_zmax(lam) - _nearby, enum=glass_enum)  ## glass thickness

		seed_edge(lam,x=_xmax(lam) - _nearby, esize=glass_edge_esize)
		seed_edge(lam,y=_ymax(lam) - _nearby, esize=glass_edge_esize)

		if _ylength(lam) > 1000:	## 1米以上，为全模型
			seed_edge(lam,y=_ymin(lam) + _nearby, esize=glass_edge_esize)

		if _xlength(lam) > 500:
			seed_edge(lam,x=_xmin(lam) + _nearby, esize=glass_edge_esize)

		mesh_part(lam,esize=esize)

	## cell
	cell_parts = find_mdb_parts('cell')
	if cell_parts not in empty:
		if cell_esize in empty:
			cell_esize = cell_length/20
		mesh_part(cell_parts,esize=cell_esize)		;please_check

	return

def mesh_part(parts=(),exclude=(),esize=2, etype=None, global_default=False,force_mesh=True,antype='',solver=''):
	## VER: 2017-03-29, v2.7

	global default_plot

	if antype in empty:  ## Dynamic, Explicit的antype为stress
		antype = get_antype()

	if solver in empty: ## Dynamic, Explicit的solver为explicit
		solver = get_solver()

	etype_default = 'C3D8'		## if C3D8R cannot mesh, consider use C3D20R instead of TET mesh.
	if antype == 'thermal':
		etype_default = 'DC3D8'

	if etype in empty:
		if antype == 'stress':
			etype = eval(etype_default + 'R')
		elif antype == 'thermal_stress':
			etype = eval(etype_default + 'RT')
		elif antype == 'thermal':
			etype = eval(etype_default)

	etype_default = eval(etype_default)

	parts = real_parts(parts)
	if parts in empty:
		parts = _m.parts.values()

	exclude = real_parts(exclude)
	if exclude != []:
		parts = unselect(parts,exclude)

##	if esize in empty:
##		esize = lam_esize

	part_names = poi_names(parts)
	for part1 in part_names:
		print ' '
		print 'Before meshing part',part1,':'
		stats = mesh_status(part1)
		if stats[1] == True:
##			query = GUI_inputs([(part1 + ' has been meshed, delete the mesh and mesh again?','yes')])
			query = message_box('The part ' + part1 + ' has been meshed, delete the mesh and mesh again?',title='mesh insert',buttons='yes,no')
			if query.lower() == 'yes':
				_part(part1).deleteMesh()
			else:
				print fnln_fnln(),'******' + part1 + ' has been meshed, cannot mesh again.'
				return

		part = _m.parts[part1]
		esize_modified = False
		esize1 = esize
##		if esize in empty or esize == 'default':
		if global_default == True:
			esize0 = part.getPartSeeds(attribute=DEFAULT_SIZE)
			if esize1 > esize0:
				esize1 = esize0		##取小(在global_default=True的情况下)
				esize_modified = True

		print part1,': Global seeding esize=',esize1
		if esize_modified == True:
			print fnln_fnln(),'******未提供esize for',part1,'，软件自动设esize=',esize1,'，小于lam_esize=',lam_esize,'，前面的seeding语句可能无效。'

		part.seedPart(deviationFactor=0.1, size=esize1)

		print fnln(),'antype=',antype
		print fnln(),'etype_default=',etype_default

		if etype != etype_default:
			print fnln(),'chnge etype =',etype
			set_element_type(part,etype=etype,meshed=False,antype=antype,solver=solver)	## Will not change the default etype if failed.
		part.generateMesh()    ;please_check('先设etype，然后mesh') ## if set_element_type failed, will use default etype

		region = part.getUnmeshedRegions()
		if region != None:
			cells0 = region.cells   ## unmeshed region for 3D model
			faces0 = region.faces   ## unmeshed region for 2D model
			edges0 = region.edges   ## unmeshed region for 1D model

			unmesh_objs = []
			if cells0 not in empty:
				print '**** There are cells unmeshed.'
				unmesh_objs = cells0
			elif faces0 not in empty:
				print '**** There are faces unmeshed.'
				unmesh_objs = faces0
			elif edges0 not in empty:
				print '**** There are edges unmeshed.'
				unmesh_objs = edges0

			if force_mesh == True and unmesh_objs not in empty:
				mesh_region(part, objs = unmesh_objs)

##		stats = mesh_status(part)
##		if stats[1] == False:   ## example: stats=(True,False)
##			print ' '
##			print '** mesh_status =',stats
##			raise Exception('******Meshing failed for ' + part1)

	try:
		a.regenerate()
	except:
		pass

	if len(part_names) > 1:
		print '--->Generated mesh for',len(part_names),'parts:',part_names
		print ' '

	if len(parts) == 1:
		default_plot = parts[0]
	else:
		default_plot = _m.parts.values()[0]

	return

def mesh_region(part,objs=None,faces=None,cells=None,edges=None,order=1, esize=None,
	seed_override=OFF,sweep=None,try_twice=False):
	## VER: 2016-08-26, v1.7
	## choose_element_type(),set_element_shape(),seed_edges(),mesh_region()

##	seed_edges('powder',edges=_part('powder').edges,esize=0.5,min_num=4)
##	mesh_region(powder,sweep=True)	;changing1

	## edge类型的part不需要设置单元类型。例如：
##	mesh_region(tpunch,esize=0.1)
##	mesh_region(bpunch,esize=0.1)
##	mesh_region(corepin,esize=0.1)
##	mesh_region(die,esize=0.1)

##	cells = get_unmeshed_region(anvil)
##	if cells not in empty:
##		set_element_shape(anvil,cells=cells,eshape='TET')
##		mesh_region(anvil,cells=cells)
##
##		cells1 = get_unmeshed_region(anvil)
##		if cells1 not in empty:
##			choose_element_type(anvil,cells=cells1,order=2)
##			mesh_region(anvil,cells=cells)


	part = check_part(part)

	objs = get_real_input(objs,faces,cells,edges)
	if objs in empty:
		if len(part.cells) > 0:
			objs = part.cells
		elif len(part.faces) > 0:
			objs = part.faces
		elif len(part.edges) > 0:
			objs = part.edges

	region = list2sequence(objs)

	status = mesh_status(part)
	if sweep == True and status[0] == False:
		set_element_shape(part, technique=SWEEP)

	if status[0] == False:  ## have no any mesh in the part
		choose_element_type(part,order=order)	;please_check
		seed_part(part, esize=esize)

	if seed_override == OFF:
		part.generateMesh(regions=region)
	else:
		part.generateMesh(regions=region,seedConstraintOverride=ON)  ## 有时有此option可以保证网格划分进行下去。

	part.regenerate()

	cells = get_unmeshed_region(part)
	if cells not in empty and try_twice == True:
		set_element_shape(part,cells=cells, eshape='TET')
		mesh_region(part,cells=cells)    ## mesh again
		part.regenerate()
	a.regenerate()   ## cannot obmit

	return

def mesh_status(poi=None,objs=None,cells=None,faces=None,edges=None):
	## VER: ('2013-06-12, v1.2')

	if poi not in empty:
		poi = check_pias(poi)

	objs = get_real_input(objs,cells,faces,edges)
	objs = real_objs(objs)

	if poi in empty and objs in empty:
		raise Exception('**** part, instance or geometry objs are required.')

	if objs in empty:
		if len(poi.cells) > 0:
			objs = poi.cells
		elif len(poi.faces) > 0:
			objs = poi.faces
		elif len(poi.edges) > 0:
			objs = poi.edges
		else:
			raise Exception('**** empty objs.')

##	print 'type_of(poi)=',type_of(poi)
	seq = list2sequence(objs,poi)

	if type_of(poi) == 'PINSTANCE':
		poi = a

##	print 'type_of(poi)=',type_of(poi)
	stats = poi.getMeshStats(seq)

	obj_num = len(objs)
	meshed_num = stats.numMeshedRegions

	meshed = False
	all_meshed = False
	if meshed_num > 0:
		meshed = True
	if meshed_num == obj_num:
		all_meshed = True

	print '**Mesh status: meshed=',meshed,', all_meshed=',all_meshed
	print ' '

	return (meshed,all_meshed)

def merge_and_clear_sketch_objs(sketch,tolerance=1e-3):
	## VER: 2013-11-19, v1.1
	## 本函数将改变sketch的物理地址，将导致原有sketch变量的引用失效。故使用方法为:
	## powder_sketch = merge_and_clear_sketch_objs(powder_sketch)

	sketch = check_sketch(sketch)
	num_v0 = len(sketch.vertices)
	num_g0 = len(sketch.geometry)
	name = sketch.name

	curves = geometry_select(sketch, type='construction')
	del_sketch_objs(sketch,curves)

	del_sketch_objs(sketch,sketch.vertices.values())

	part1 = sketch_to_wire(sketch)
	sketch1 = wirepart_to_sketch(part1)
	del_parts(part1)

	del _m.sketches[sketch.name]
	_m.sketches.changeKey(fromName=sketch1,toName=name)  ## 改变sketch的物理地址，将导致原有sketch变量的引用失效。
	sketch = _m.sketches[name]

	sketch.mergeVertices(value=tolerance, vertexList=sketch.vertices.values())
##	sketch.removeGapsAndOverlaps(tolerance=tolerance, geomList=sketch.geometry.values())
	sketch.removeGapsAndOverlaps(tolerance=tolerance, geomList=all_regular_geometry(sketch))

	num_v1 = len(sketch.vertices)
	num_g1 = len(sketch.geometry)

	show_sketch(sketch)

	print ln(),num_v0 - num_v1,'vertices are deleted,',num_g0 - num_g1,'curves are deleted.'

	return sketch

def merge_lists(list1,list2):
	## VER: 2014-05-27

	if type_of(list1) == 'LIST' and type_of(list2) == 'LIST':
		newlist = list1
		for item in list2:
			if item not in newlist:
				newlist.append(item)
		results = newlist

	else:
		raise Exception('*** two lists are required.')

	return results

def mesh_2D(part,esize=None):
	## 2015-04-01, v1.1
	## for 2D, you even donot need to choose the element type (for stress analysis).
	## 没有涉及单元类型的选择。则单元形状为QUAD

	## example: mesh_2D(wire,esize=esize)

	## 最简单的mesh(不涉及单元类型选择，默认单元类型)。以下是GUI的操作结果
##	p = mdb.models['Model-1'].parts['base']
##	p.seedPart(size=1.0, deviationFactor=0.1, minSizeFactor=0.1)
##	p = mdb.models['Model-1'].parts['base']
##	p.generateMesh()

	part = check_part(part)
	if esize in empty:
		esize = get_part_seed(part)

	choose_element_type(part)
	part.seedPart(size=esize, deviationFactor=0.1, minSizeFactor=0.1)
	part.generateMesh()
	part.regenerate()

	return esize

def mesh_cohesive(material,setname=None,cells=None, parts=None):

	## VER: ('VER: 2012-08-24, v1.0')	## region一般用于instance, 不用于part. mesh part时所说的region就是cells.

	if type_of(material) != 'STR':
		raise Exception('Material name is required.')

	if setname in empty and cells in empty:
		setname = material

	partnames = []
	if setname not in empty:
		parts = real_parts(parts)
		if parts in empty:
			parts = parts_by_set(setname)

		if parts in empty:
			raise Exception('No parts with setname=',setname)

		for part in parts:
			default = part.getPartSeeds(DEFAULT_SIZE)
			assigned = part.getPartSeeds(SIZE)
			if assigned == 0:
				print '**Global esize for',part.name,'has not been defined yet.'
				part.seedPart(size=default, deviationFactor=0.1)

			cells = set2objs(setname,part)	## list
			sequence = list2sequence(cells,poi=part)
			region = list2region(cells,poi=part, region_type='set')

			part.deleteMesh(regions=cells)	## (regions=cells 或 equence均可, 但不能regions=region)
##			part.deleteMesh(regions=region)	## Error

			part.setMeshControls(regions=cells, technique=SWEEP, algorithm=ADVANCING_FRONT)	## mesh control  (regions=cells 或 equence均可, 但不能regions=region)
##			part.setMeshControls(regions=region, technique=SWEEP, algorithm=ADVANCING_FRONT)	## Error

			elemType1 = mesh.ElemType(elemCode=COH3D8, elemLibrary=STANDARD, viscosity=1e-05)
			elemType2 = mesh.ElemType(elemCode=COH3D6, elemLibrary=STANDARD)
			elemType3 = mesh.ElemType(elemCode=UNKNOWN_TET, elemLibrary=STANDARD)
			part.setElementType(regions=cells, elemTypes=(elemType1, elemType2, elemType3))	## element type (只能regions=cells or region, 不能regions=sequence)
##			part.setElementType(regions=sequence, elemTypes=(elemType1, elemType2, elemType3))	## Error

			part.generateMesh(regions=cells)		## (regions=cells 或 equence均可, 但不能regions=region)
##			part.generateMesh(regions=region)	## Error

			part.regenerate()
			partnames.append(part.name)

	elif cells not in empty:
		cells = tolist(cells)
		part = get_poi(cells)
		if type_of(part) != 'PART':
			raise Exception('Cells should be come from part')

		part.deleteMesh(regions=cells)
		part.setMeshControls(regions=cells, technique=SWEEP, algorithm=ADVANCING_FRONT)	## mesh control

		elemType1 = mesh.ElemType(elemCode=COH3D8, elemLibrary=STANDARD, viscosity=1e-05)
		elemType2 = mesh.ElemType(elemCode=COH3D6, elemLibrary=STANDARD)
		elemType3 = mesh.ElemType(elemCode=UNKNOWN_TET, elemLibrary=STANDARD)
		part.setElementType(regions=cells, elemTypes=(elemType1, elemType2, elemType3))	## element type

		part.generateMesh(regions=cells)
		part.regenerate()
		partnames.append(part.name)

	print '--->Meshed cohesive elements for material=',material,', parts=',partnames

	return

def mesh_data(poi=None):
	## VER: 2013-07-24, v1.2

	global stats

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	if type_of(poi) == 'PART':
		dpo = poi

	type1 = type_of(dpo)
	if type1 == 'PART':
		part = dpo
		objs = get_real_input(part.cells, part.faces, part.edges)
		if objs in empty:
			raise Exception('*** No geometry entities was found.')

		stats = dpo.getMeshStats(objs)
		meshed_num = stats.numMeshedRegions
		cell_num = len(objs)

		meshed = False
		all_meshed = False
		if meshed_num > 0:
			meshed = True
		if meshed_num == cell_num:
			all_meshed = True
		esize = get_part_esize(part)

		print 'Mesh status: meshed=',meshed,', all_meshed=',all_meshed
		print 'Global esize: default=',esize[0],', assigned=',esize[1]
	else:
		stats = a.getMeshStats(tuple(a.instances.values()))

	print '**六面体单元数为',stats.numHexElems,
	if stats.numTetElems > 0:
		print ', 四面体单元数为',stats.numTetElems,
	print ', 节点总数为',stats.numNodes

	return


def mesh_3D_TET_disp_exp(cells,esize=None):
	## VER: 2014-05-05, v1.0, 3D

	if cells in _m.parts.values():
		part = cells
		cells = part.cells
	elif cells in _m.parts.keys():
		part = _m.parts[cells]
		cells = part.cells

	cells = tolist(cells)

	part = get_parent(cells[0])

	if esize in empty:
		esize = get_part_seed(part)

	region = totuple(cells)
	part.setMeshControls(regions=region, elemShape=TET, technique=FREE)
	elemType1 = mesh.ElemType(elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT)
	elemType2 = mesh.ElemType(elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT)
	elemType3 = mesh.ElemType(elemCode=C3D10M, elemLibrary=EXPLICIT)
	part.setElementType(regions=region, elemTypes=(elemType1, elemType2, elemType3))
	part.seedPart(size=esize, deviationFactor=0.1, minSizeFactor=0.1)
	part.generateMesh(regions=list2sequence(region))

	return

def mesh_3D_TET_disp_std(cells=None,esize=None):
	## VER: 2014-08-08, v1.1, 3D

	if is_part(cells):
		part = check_part(cells)
		cells = part.cells

##	if cells in _m.parts.values():
##		part = cells
##		cells = part.cells
##	elif cells in _m.parts.keys():
##		part = _m.parts[cells]
##		cells = part.cells

	cells = tolist(cells)

	part = get_parent(cells[0])

	if esize in empty:
		esize = get_part_seed(part)

	region = totuple(cells)
	part.setMeshControls(regions=region, elemShape=TET, technique=FREE)
	elemType1 = mesh.ElemType(elemCode=C3D20R, elemLibrary=STANDARD)
	elemType2 = mesh.ElemType(elemCode=C3D15, elemLibrary=STANDARD)
	elemType3 = mesh.ElemType(elemCode=C3D10M, elemLibrary=STANDARD)
	part.setElementType(regions=region, elemTypes=(elemType1, elemType2, elemType3))

	seed = part.getPartSeeds(SIZE)
	if seed == 0:  ## not apply global seed yet.
		if esize in empty:
			esize = part.getPartSeeds(DEFAULT_SIZE)

		part.seedPart(size=esize, deviationFactor=0.1, minSizeFactor=0.1)  ## cannot ignore for the first mesh region

	part.generateMesh(regions=list2sequence(cells))
##	part.generateMesh(regions=pickedRegions, seedConstraintOverride=ON)

	return

def mesh_frame(frm,esize=None,lip_esize=2,support_option=None):
	## VER: ('VER: 2012-12-21, v3.9')

	global seeding_seq

	if support_option in empty:
		support_option = globals()['support_option']

	frm = check_part(frm)
	if esize in empty:
		esize = lam_esize

	dir1 = get_beam_dir(frm)
##	seed_circular_edges(frm,quarter_seed=4)
	seed_circular_edges(frm,quarter_seed=2) 			;please_check

	partname = frm.name

	globals()['lip_esize'] = lip_esize

##	seed_edge(frm,z=_zmin(frm) + _nearby,enum=flange_thick_enum)  ## flange is 3 layer

	if dir1 == 'y':
		faces = faces_of_cut(frm,y=KPy(frm))
##		seed_edges_of_faces(faces,enum_short=2,esize_long=frame_H_esize)    ## 整个截面
		long,short = long_short_edges_of_faces(faces)
		seed_edges(frm,edges=long,esize=frame_H_esize)
		seed_edges(frm,edges=short,enum=2)

		if _module_type in ['R3','R4','R5']:
			edges = edges_of_cut(frL,y=MIN,inplane=True)
			edges = edge_select(frL,edges=edges,x=[_xmax(frL,z=MAX),MAX],z=[_zmin(frL,x=MIN), _zmin(frL,x=MIN) + flange_thick])
			del_edges_seed(edges)
			seed_edges(frL,edges=edges,esize=frame_H_esize)

		if has_mid_hole == True and frm.name in ['frm','frL']:
			edges = edges_of_cut(frm,z=MIN,y=1.2*ehole_D,edir='x')
			seed_edges(frm,edges=edges,esize=frame_H_esize)

			if 'long_edge+' in support_option:
				edges = edges_of_cut(frm,z=MIN,y=[_ymax(rail_A1), _ymax(rail_A1) + 10],edir='x')
				seed_edges(frm,edges=edges,esize=frame_H_esize)

##		edges = edges_of_cut(frm,y=0,z=bot_lip_top)
##		seed_edges(frm,edges,esize=lip_esize)
##
##		edges = edges_of_cut(frm,y=0,z=frame_top)
##		seed_edges(frm,edges,esize=lip_esize)
##
##		seed_edge(frm,y=0,z=frame_top - top_lip_thick - top_adhesive_thick - _nearby,enum=2)

		if _module_type[0] != 'R':
##			if (has_mount_clamp == True or has_rail == True) and 'long_edge+' in support_option:
			if 'long_edge+' in support_option:
				if find_mdb_insts('clamp') not in empty:
					edges = edges_of_cut(frm,y=_yspace(clamp_A1), z=MIN, edir='y')
					seed_edges(frm,edges=edges,esize=clamp_esize)			;please_check
				elif find_mdb_insts('rail') not in empty:
					edges = edges_of_cut(frm,y=_yspace(rail_A1), z=MIN, edir='y')
					seed_edges(frm,edges=edges,esize=clamp_esize)			;please_check

		if frm.name in ['frm','frL']:
##			seed_edge(frm,y=0,x=_xmax(frm) - _nearby,esize=1)
			seed_edge(frm,y=0,x=_xmax(frm,z=MAX) - _nearby,enum=outer_wall_enum)	;please_check
			seed_edge(frm,y=0,x=_xmax(frm,z=MAX) - legs_span + _nearby,enum=inner_wall_enum)	;please_check

		if partname in part_holes.keys():
			for hole in part_holes[partname]:
				edges = edges_of_cut(frm,z=MIN,y=hole['center'][1],edir='x')
				seed_edges(frm,edges=edges,esize=frame_H_esize)

	elif dir1 == 'x':
		faces = faces_of_cut(frm,x=KPx(frm))
##		seed_edges_of_faces(faces,enum_short=2,esize_long=frame_H_esize)

		long,short = long_short_edges_of_faces(faces)
		seed_edges(frm,edges=long,esize=frame_H_esize)
		seed_edges(frm,edges=short,enum=2)

##		edges = edges_of_cut(frm,x=0,z=bot_lip_top)
##		seed_edges(frm,edges,esize=lip_esize)
##
##		edges = edges_of_cut(frm,x=0,z=frame_top)
##		seed_edges(frm,edges,esize=lip_esize)
##
##		seed_edge(frm,x=0,z=frame_top - top_lip_thick - top_adhesive_thick - _nearby,enum=2)

		if (has_mount_clamp == True or has_rail == True) and 'short_edge+' in support_option:
##			xspace = (_xmax(frm) - clamp2corner - 20, _xmax(frm) - clamp2corner + 20)
			edges = edges_of_cut(frm,x=_xspace(clamp_A1), z=MIN, edir='x')
			seed_edges(frm,edges=edges,esize=clamp_esize)			;please_check

		if frm.name in ['frm','frS']:
##			seed_edge(frm,x=0,y=_ymax(frm) - _nearby,esize=1)
			seed_edge(frm,x=0,y=_ymax(frm,z=MAX) - _nearby,enum=outer_wall_enum)	;please_check
			seed_edge(frm,x=0,y=_ymax(frm,z=MAX) - legs_span + _nearby,enum=inner_wall_enum)	;please_check

##		if partname in part_holes.keys():
##			for hole in part_holes[partname]:
##				edges = edge_select(frm,z=MIN,x=hole['center'][0] + 2*hole['D'])
##				seed_edges(frm,edges=edges,esize=3)

	mesh_part(frm,esize=esize)
##	set_element_type(frm,setname='Silic',etype='hybrid')
##	set_element_type(frm,setname='Silic2',etype='hybrid',hyper_elastic=True)   ##??******

	print '--->',frm.name,'is meshed, dir=',dir1
	print ' '

	return

def meshing(p,region1,method):
	## VER: 2010-01-01

	if method == 'sweep':
		p.setMeshControls(regions=region1, technique=SWEEP)
	elif method == 'mapped':
		p.setMeshControls(algorithm=ADVANCING_FRONT, allowMapped=True, regions=region1, technique=SWEEP)
	p.generateMesh(regions = region1)

function_labels['message_box'] = 'windows','info','GUI','ctypes','dll'
def message_box(message='your info',info='',title='window title',buttons='YES|NO|CANCEL'):
	## VER: 2017-06-30, v1.1
	## 本程序对内核文件和GUI文件均适用
	## 可做中断调试。点击OK之后，程序才会继续运行。

##	reply1 = message_box('',buttons='yes,no')
##	message_box(reply1)

##	>>> message_box(info=5,buttons='yes,no')
##	'yes'
##	>>>

	if info not in empty:
		message = info

	MB_OK = 0  ## 单键OK
	MB_OKCANCEL = 1
	## 2: abort, retry, ignore, 共三键
	MB_YESNOCANCEL = 3
	MB_YESNO = 4

	IDOK = 1   ## 单键OK; OK|Cancel中的OK
	IDCANCEL = 2  ## yes|no|cancel中的cancel; OK|Cancel中的cancel
	IDABORT = 3  ##abort|retry|ignore中的abort;
	IDRETRY = 4 ##abort|retry|ignore中的retry
	IDIGNORE = 5 ##abort|retry|ignore中的ignore
	IDYES = 6  ## yes|no|cancel中的yes; yes|no中的yes
	IDNO = 7  ## yes|no|cancel中的no; yes|no中的no

	MB = 0
	if type_of(buttons) == 'STR':
		buttons = buttons.lower()
		newlist = []
		if 'no' in buttons:
			newlist.append('yes')
		elif 'yes' in buttons:
			newlist.append('yes')
		elif 'ok' in buttons:
			newlist.append('ok')
		elif 'abort' in buttons or 'retry' in buttons or 'ignore' in buttons:
			newlist = ['abort','retry','ignore']

		if 'no' in buttons:
			newlist.append('no')

		if 'cancel' in buttons:
			newlist.append('cancel')

		if newlist == ['yes']:
			MB = 0
		elif newlist == ['ok','cancel']:
			MB = 1
		elif newlist == ['yes','no','cancel']:
			MB = 3
		elif newlist == ['yes','no']:
			MB = 4

	elif buttons in [0,1,2,3,4]:
		MB = buttons

	import ctypes
	user32 = ctypes.windll.LoadLibrary('user32.dll')  ##  # 加载动态链接库
	if type_of(message) != 'STR':
		message = str(message)
	reply = user32.MessageBoxA(0, message, title, MB)

	if reply in [1,3,6]:  ## abort是第一个键，按yes来处理
		reply = 'yes'
	elif reply in [4,7]: ## retry是第二个键，按no来处理
		reply = 'no'
	elif reply in [2,5]:
		reply = 'cancel'  ## 包括直接点击X关闭消息窗口

	return reply

pop_info = message_box

def mid_divide(p,*dir1):
	## 2010-08-13, v1.2

	if dir1 == ():
		dir1 = ['x','y','z']
	elif type_of(dir1[0]) == 'LIST':
		dir1 = dir1[0]

	x1,x2,y1,y2,z1,z2 = poi_space(p)

	if 'x' in dir1 or 'X' in dir1:
		divide(p,x=(x1+x2)/2)

	if 'y' in dir1 or 'Y' in dir1:
		divide(p,y=(y1+y2)/2)

	if 'z' in dir1 or 'Z' in dir1:
		divide(p,z=(z1+z2)/2)

	for axis in dir1:
		dir_points(p,axis)

	print '--->Performed block half divide for',p.name,'in',dir1
	print '--->Created dir_points sets for',p.name,', dirs=',dir1

	return

def mid_of_edge(edge):
	## VER: 2014-01-15, v1.0
	## edge should be straight edge

	if type_of(edge) != 'edges':
		raise Exception('*** an edge is required.')

	poi = get_parent(edge)
	ids = edge.getVertices()

	x1,y1,z1 = poi.vertices[ids[0]].pointOn[0]
	x2,y2,z2 = poi.vertices[ids[-1]].pointOn[0]

	return (x1+x2)/2, (y1+y2)/2, (z1+z2)/2

def mids_of_poi(poi):
	## VER: 2012-10-30, v1.0

	poi = check_pias(poi)
	x1,x2,y1,y2,z1,z2 = poi_space(poi)

	return (x1+x2)/2,(y1+y2)/2,(z1+z2)/2

def min_ofset(part,setname,dir1):
	## VER: 2010-01-25

	if dir1 == 'x':
		index1 = 0
	elif dir1 == 'y':
		index1 = 1
	elif dir1 == 'z':
		index1 == 2

	v0 = KPxyz(setname,part,0)[index1]
	locs = set2pointOns(part,setname)
	num1 = len(locs)
	for i in range(num1)[1:]:
		v1 = KPxyz(setname,part,i)[index1]
		if v0 > v1:
			v0 = v1

	return v0

def minmax_of_step_value(step=None,frame=-1,main_var=None,sub_var=None):
	## VER: 2014-08-06, v1.1. This result may be quite different from the viewport result.
	## by read through odb method. integration point value
	## reference: minmax_value_of_viewport(), also can get the info of label and element.

	if step in empty:
		step = get_step_frame_time()[0][0]

	step = check_odb_step(step)
##	print 'step=',step

	if main_var in empty or sub_var in empty:
		main_var,sub_var = get_main_sub_var()

	sub_var = modify_string(sub_var,' ')
	sub_var = modify_string(sub_var,'.')

	print fnln(),main_var,sub_var
	values = step.frames[frame].fieldOutputs[main_var].values  ## array by element

	found = False

	for mem in values[0].__members__:
##		print mem.lower(),'--', sub_var.lower()
		if mem.lower() == sub_var.lower():
			sub_var = mem
			found = True
			break

	if found == False:
		raise Exception('*** Cannot find the sub_var')

	list1 = []
	print fnln(),'sub_var =',sub_var

	for value in values:
		v1 = eval('value.' + sub_var)
		list1.append(v1)

	list1.sort()

	min_label = ''
	max_label = ''
	for value in values:
		v1 = eval('value.' + sub_var)
		if PK(v1,list1[0]) == 0:
			min_label = value.elementLabel
		elif PK(v1,list1[-1]) == 0:
			max_label = value.elementLabel

		if min_label not in empty and max_label not in empty:
			break

	print 'min_label=',min_label,', max_label=',max_label

	results = (smart_round(list1[0]),min_label), (smart_round(list1[-1]),max_label)

	return results

def minmax_of_curve(curve):
	## VER: 2014-07-31, v1.1

	if curve in session.curves.keys():
		curve = session.curves[curve]

	if type_of(curve) != 'XYCURVE':
		raise Exception('*** an xycurve is required.')

	data = curve.data.data
	min0 = None
	max0 = None
	for time,value in data:
		if min0 == None:
			min0 = value

		min0 = min(min0,value)
		max0 = max(max0,value)

	min0 = smart_round(min0)
	max0 = smart_round(max0)

	return min0,max0

def start_end_of_curve(curve):
	## VER: 2017-06-12, v1.1

	if curve in session.curves.keys():
		curve = session.curves[curve]

	if type_of(curve) != 'XYCURVE':
		raise Exception('*** an xycurve is required.')

	data = curve.data.data
	start = data[0][0]
	end = data[-1][0]

##	print fnln(),'before: start_end=',(start,end)
	start = smart_round(start)
	end = smart_round(end)
##	print fnln(),'after: start_end=',(start,end)

	return start,end


def minmax_of_XYPLOT(viewport):
	## VER: 2014-02-17, v1.0

	viewport_type, viewport = check_viewport(viewport)
	dpo = viewport.displayedObject

	if viewport_type != 'XYPLOT':
		raise Exception('*** XYPLOT is required.')

	if len(dpo.curves) == 0:
		raise Exception('*** No curve in the viewport.')

	mins = []
	maxs = []

	for curve in dpo.curves.values():
		data = curve.data.data
##		print type_of(data)   ## tuple
##		print len(data)   ## 15872
##		>>> 1e-30 > None
##		True
##		>>>
		min0 = None
		max0 = None
		for time,value in data:
			if min0 == None:
				min0 = value

			min0 = min(min0,value)
			max0 = max(max0,value)
##		data = sort_tuple_type_elements(data,index=1)   ## very slow
		mins.append(min0)
		maxs.append(max0)

	min0 = smart_round(min(mins))
	max0 = smart_round(max(maxs))

	return min0,max0

def minmax_value_of_step():
	## VER: 2014-02-21, v1.0
	## keep current frame

	step, frame, time = get_step_frame_time()

	session.viewports[session.currentViewportName].odbDisplay.setFrame(step=step[0], frame=-1)
	min0, max0 = minmax_value_of_viewport()

	session.viewports[session.currentViewportName].odbDisplay.setFrame(step=step[0], frame=frame[0])

	return min0,max0

def minmax_value_of_frame():
	## VER: 2014-06-27, v1.1
	## keep current frame

	min0, max0 = minmax_value_of_viewport()

	return min0,max0

def minmax_value_of_viewport():
	## 2014-02-21, v1.0
	## get the minmax value and location of current frame, not the last frame

	vpnow = get_vpnow()
	value_loc = vpnow.getPrimVarMinMaxLoc()
##	prettyPrint(value_loc)
##	raise Exception

	if value_loc != None:
		max_inst = value_loc['maxPartInstanceName']
		try:
			max_label = value_loc['maxElementLabel']	## based on element integration point, such as stress
		except:
			max_label = value_loc['maxNodeLabel']		## based on nodal result, such as displacement

		max_value = value_loc['maxValue']
		max_value = smart_round(max_value)

		min_inst = value_loc['minPartInstanceName']
		try:
			min_label = value_loc['minElementLabel']
		except:
			min_label = value_loc['minNodeLabel']

		min_value = value_loc['minValue']
		min_value = smart_round(min_value)

		results = (min_inst,min_label,min_value),(max_inst,max_label,max_value)

	else:  ## plot_state = UNDEFORMED
		results = ()

	return results

def mirror_geometry(sketch,geometry=None,mirror_line=None,x=None,y=None,copy=False):
	## VER: 2014-03-11, v1.0

	sketch = check_sketch(sketch)
	if geometry in empty:
		geometry = all_regular_geometry(sketch)

	geometry = tolist(geometry)
	newlist = []
	for curve in geometry:
		if type_of_geometry(curve) == 'regular':
			newlist.append(curve)
	geometry = totuple(newlist)

	x,y = real_xy_sketch(sketch,x=x,y=y)

	if type_of(x) in numerics:
		mirror_line = create_construction(sketch,x=x)
	elif type_of(y) in numerics:
		mirror_line = create_construction(sketch,y=y)

	if shape_of_geometry(mirror_line) != 'line':
		raise Exception('*** a line or construction line is required.')

	if copy == True:
		sketch.copyMirror(mirrorLine=mirror_line, objectList=geometry)
	else:
		sketch.mirror(mirrorLine=mirror_line, objectList=geometry)

	return

def mirror_mat_set(p1,p2,mat,setname='',dir1='x'):
	## VER: 2010-04-12

	dir1 = dir1.lower()

	points = set2pointOns(p1,setname)
	list1 = []
	for point in points:
		if dir1 == 'x':
			point1 = (-point[0],point[1],point[2])
		elif dir1 == 'y':
			point1 = (point[0],-point[1],point[2])
		elif dir1 == 'z':
			point1 == (point[0],point[1],-point[2])

		list1.append(p2.cells.findAt(point1,), printWarning=False)

	set_mat(p2,cells=list1,mat=mat,subset=setname)
##	print '--->Set',setname,'mirrored in',dir1, 'new setname=',newset_name)

	return list1

def mirror_part(part,mirror_axis=None,mirror_plane=None, mirror_x=None,mirror_y=None,mirror_z=None):
	## VER: 2013-01-09, v1.0, part进行翻转，是rotate_part的特殊形式。

	## Example: mirror_part('upper punch', mirror_axis='y', mirror_y=35)

	part = check_part(part)
	partname = part.name

	part1 = copy_part(part,partname + '_mirror', mirror_axis=mirror_axis, mirror_plane=mirror_plane, mirror_x=mirror_x, mirror_y=mirror_y, mirror_z=mirror_z)
	del_parts(part)

	_m.parts.changeKey(fromName=part1, toName=partname)
	update_part(partname)

	print '--->',partname,'is rotated by mirror, mirror_axis=',mirror_axis

	return

def mirror_set(p1,setname,p2,mirror_axis='x',mirror_plane=None,mat=''):
	## 2013-01-09, v1.5

	if type_of(mirror_axis) == 'STR':
		mirror_axis = mirror_axis.lower()
	if type_of(mirror_plane) == 'STR':
		mirror_plane = mirror_plane.lower()

	if mirror_plane == XZPLANE or mirror_plane == 'xoz' or mirror_plane == 'zox':
		mirror_axis = 'y'
	elif mirror_plane == XYPLANE or mirror_plane == 'xoy':
		mirror_axis = 'z'
	elif mirror_plane == YZPLANE or mirror_plane == 'yoz':
		mirror_axis = 'x'

	if mirror_axis not in ['x','y','z']:
		raise Exception('Error mirror_axis, should be x, y, or z')

	type1 = type_of_set(p1,setname)
	pts1 = set2pointOns(p1,setname)

	objs = []
	for point in pts1:
		if mirror_axis == 'x':
			pt2 = (-point[0],point[1],point[2])
		elif mirror_axis == 'y':
			pt2 = (point[0],-point[1],point[2])
		elif mirror_axis == 'z':
			pt2 == (point[0],point[1],-point[2])

		expression = 'p2.' + type1 + '.findAt(coordinates = pt2, printWarning=False)'
		try:
			obj1 = eval(expression)
		except:
			pass

		if obj1 != None:
			objs.append(obj1)

	if len(objs) > 0:
		create_set(p2, objs=objs, name=setname,check_name=False)

		if mat != '' and type1 == 'cells':
			set_mat(p2,cells=objs,mat=mat,subset=setname)

		print '--->Mirrored setname',setname,'in',mirror_axis,'from',p1.name,'to',p2.name

	else:
		print 'Mirror set failed. line=2989, mirror_set()'

	return

def mirror_sketch(sketch,line=None,new_sketch=None,x=None,y=None,dx=0,dy=0):
	## VER: 2013-11-18, v1.0

	global _m, a

	sketch = check_sketch(sketch)

	replace = False
	if new_sketch in empty:
		new_sketch = new_key(_m.sketches.keys(),sketch.name)
		old_name = sketch.name
		replace = True

	if x not in empty or y not in empty:
		lines = geometry_select(sketch,shape='line',x=x, y=y)
		if lines in empty:
			raise Exception('*** No mirror line was found.')
		else:
			line = lines[0]

	if type_of(line) != 'regular_line':
		raise Exception('*** One regular line is required for geometry mirror.')

	s1 = create_base_sketch(new_sketch, return_sketch=True)
##	s1 = _m.sketches[new_sketch]

	pointOn = line.pointOn
	s1.retrieveSketch(sketch=sketch)
	line1 = s1.geometry.findAt(pointOn)

	s1.mirror(mirrorLine=line1, objectList = all_regular_geometry(s1))

	if dx != 0 or dy != 0:
		s1.move(vector=(dx, dy), objectList=all_regular_geometry(s1))

	if replace == True:
		del _m.sketches[old_name]
		_m.sketches.changeKey(fromName=new_sketch, toName=old_name)

	return

def model_backup():
	## VER: 2011-04-12, v1.0

	global p_features, a_features

	p_features = {}
	for partname in _m.parts.keys():
		feature = _m.parts[partname].features.keys()
		p_features[partname] = feature

	a_features = [a.instances.keys(),a.features.keys()]

	print ' '
	print '--->**model backuped into global p_features, a_features'

	return

def model_change(name='model_change',active=False,step='step2',cells=None,region=None,del_setting=True):
	## VER: 2014-11-20, v1.0  Currently faces model not supported?
	## 注意：model change之后，后处理时，观察节点的coordiantes时，仍然会把degrade之后的节点的坐标一起显示。
	## 所以，需要建立final_cells的集合，并只观察该集合。

##		remove_cells = unselect(_inst(compound_A1).cells,final_cells)
##		model_change(cells=remove_cells,step='remove',active=False)


	step = check_step(step)
	name = new_key(_m.interactions.keys(),name)

	if cells not in empty:
		region = list2region(cells)

	if type_of(region) in ['SET','REGION']:
		_m.ModelChange(name=name, createStepName=step, region=region, activeInStep=active, includeStrain=False)
	else:
		raise Exception('*** a set like region of cells is required.')

	if del_setting == True:
		for key in _m.loads.keys():
			_load(key).deactivate(step)

		for key in _m.boundaryConditions.keys():
			try:
				_BC(key).deactivate(step)
			except:
				pass

		for key in _m.interactions.keys():
			_int(key).deactivate(step)

	get_current_model()

	print '--->Created interaction model_change, the rigidity of the region will be zero.'

	return name

def model_restore():
	## VER: 2011-04-12, v1.0

	if 'p_features' in globals().keys() and 'a_features' in globals().keys():
		for partname in _m.parts.keys():
			if partname not in p_features.keys():
##				del _m.parts[partname]
				del_parts(partname)
			else:
				del_features(poa=partname,backup=p_features[partname])

		del_features(poa=a,backup=a_features[1])

		insts = unselect(a.instances.keys(),a_features[0])
		del_insts(insts)

		del globals()['p_features']
		del globals()['a_features']

		print '--->**model restored.'
		print ' '

	return

def model_shape():
	## VER: 2014-12-24, v1.0

##	>>> model_shape()
##	AXISYMMETRIC
##	>>>

	shapes = []
	for inst in a.instances.keys():
		shape1 = part_shape(inst)[0]
		if shape1 not in shapes:
			shapes.append(shape1)

	if len(shapes) > 1:
		raise Exception('*** There are more than part shape: 3D, 2D planar, or axisymmetric.')

	if shapes in empty:
		shape = None
	else:
		shape = shapes[0]

	return shape

def model_space():
	## 2014-04-28, v1.4

	i = 0
	for inst in a.instances.values():
		i = i + 1
		x1,x2,y1,y2,z1,z2 = poi_space(inst)
		if i == 1:
			x_min = x1;	x_max = x2
			y_min = y1; y_max = y2
			z_min = z1; z_max = z2

		else:
			x_min = min(x_min,x1)
			x_max = max(x_max,x2)
			y_min = min(y_min,y1)
			y_max = max(y_max,y2)
			z_min = min(z_min,z1)
			z_max = max(z_max,z2)

	space = (x_min, x_max, y_min, y_max, z_min, z_max)
##	size = (int(x_max - x_min), int(y_max - y_min), int(z_max - z_min))

	return space

def model_summary():
	## VER: 2014-06-10, v1.7

##	refresh()

##	vpnow = get_vpnow()
##	leaf = dgm.Leaf(leafType=DEFAULT_MODEL)
##	vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)

##	vpnow.assemblyDisplay.setValues(optimizationTasks=OFF, geometricRestrictions=OFF, stopConditions=OFF)
##	vpnow.assemblyDisplay.meshOptions.setValues(meshTechnique=OFF)
##	vpnow.enableMultipleColors()
##	vpnow.setColor(initialColor='#BDBDBD')
##	cmap=vpnow.colorMappings['Part instance']
##	vpnow.setColor(colorMapping=cmap)
##	vpnow.disableMultipleColors()

##	vpnow.view.setValues(session.views['Front'])


	screen()
	print '*** If error occurs, please run screen() to print back to screen.'
	print ' '

	get_cae_file_title()
	sys.stdout = open('_sum_' + cae_file_title + '.txt','w')

	for model_name in mdb.models.keys():
		vpnow = get_vpnow()
		a = mdb.models[model_name].rootAssembly
		vpnow.setValues(displayedObject=a)
		get_current_model()

		print ' '
		print '====================================='
		print '===================================== Begin to show info of new model'

		print 'Model name:', _m.name
		print 'Model desciption:'
		print _m.description
		print ' '

		parts = sorted(_m.parts.keys())
		print '----------------'
		print 'There are',len(parts), 'parts in the model.'
		for part in parts:
			print part,':',part_shape_and_type(part)

##		raise Exception

		if len(_m.parts) == 0:
			return

##		print 'Part volume:',
##		for i in range(len(parts)):
##			end1 = ''
##			if i < len(parts) -1:
##				end1 = ','
##			part = parts[i]
##			part1 = _m.parts[part]
##			volume = int(round(get_volume(p=part1)))
##
####			print part_shape(part1)
####			if '3D' in part_shape(part1):
####				volume = int(round(get_volume(p=part1)))
####			else:
####				volume = 0
##			print part + '= ' + str(volume) + end1,
##		print

##		raise Exception

		print 'Part weight:',
		for i in range(len(parts)):
			end1 = ''
			if i < len(parts) -1:
				end1 = ','
			part = parts[i]
			part1 = _m.parts[part]
			mass = get_mass(part1,print_result=False)
			print part + '= ' + str(mass) + end1,
		print


		print ' '
		print 'Cells num:',
		for i in range(len(parts)):
			end1 = ''
			if i < len(parts) -1:
				end1 = ','
			part = parts[i]
			part1 = _m.parts[part]
			print part + '= ' + str(len(part1.cells)) + end1,
		print ' '

		print 'faces num:',
		for i in range(len(parts)):
			end1 = ''
			if i < len(parts) -1:
				end1 = ','
			part = parts[i]
			part1 = _m.parts[part]
			print part + '= ' + str(len(part1.faces)) + end1,
		print ' '

		print 'element num:',
		for i in range(len(parts)):
			end1 = ''
			if i < len(parts) -1:
				end1 = ','
			part = parts[i]
			part1 = _m.parts[part]
			print part + '= ' + str(len(part1.elements)) + end1,
		print ' '

		dict1 = get_mats(a)
		mats = []
		for inst in dict1.keys():
			for mat in dict1[inst].keys():
				if mat not in mats:
					mats.append(mat)
		mats = sorted(mats)

		print ' '
		print len(mats),'mats:',mats
		for mat in mats:
			if get_attrib(_m.materials,mat) == 'unknow':
				print '*** Error in matrial name',mat
				continue
			else:
				doc = _m.materials[mat].description
				if doc in empty:
					doc = 'NA'
				print mat,': description =',doc

		print ' '
		print 'Material assignment for instances:'
		for inst in dict1.keys():
			print inst.ljust(8),':',sorted(dict1[inst].keys())

		for mat in mats:
			show_mat_props(mat)

		print '--'
		print len(a.instances),'instances:', sorted(a.instances.keys())
		print '--'
		print_steps()
		print ' '
		print_contacts()

		print ' '
		print 'Assembly sets and their set_types:'
		for setname in a.sets.keys():
			print setname,':',type_of_set(a,setname)

		print ' '
		print 'Assembly surfaces:'
		for surface_name in a.surfaces.keys():
			print surface_name,':',get_surface_side(surface_name)
	##	print a.surfaces.keys()

		print ' '
		print 'Amplitudes for loads and BCs:'
		prettyPrint(_m.amplitudes,4)

		print ' '
		print '----------loads'
		myloads = {}
		if len(_m.loads.values()) == 0:
			print 'NA'
		else:
			i = 0
			for load in _m.loads.values():
				i += 1
				if i > 1:
					print ' '

				info = get_load_info(load)
				print 'Load name:',info['action_name']
				print 'Load type:',info['action_type']
				print 'Description:', load.__doc__
##				myprint(info)

				print '   surface name:',info['region_name'], ', insts=',info['pois'], ', obj_type=',info['obj_type']

				load_insts = info['pois']

				j = 0
				keyname = None
				for step in _m.steps.values()[1:]:  ## Initial step没有status这个属性
					if load.name in step.loadStates.keys():
						load_obj = step.loadStates[load.name]
						if 'status' in load_obj.__members__:
		##					print load_obj.status
							if load_obj.status not in [NOT_YET_ACTIVE,PROPAGATED]:
								j += 1
								if j >= 2:
									print '****'
								step_num = get_sequence_index(_m.steps.keys(),step.name)
								print '---in step '+ str(step_num) + ', name=',step.name,', action=',load_obj.status

								keyname = load.name + '(' + repr(type(load_obj))[7:-7] + ')'
								value = 'In step ' + str(step_num) + '(' + step.name + '), ' + repr(load_obj.status)
								if keyname not in myloads.keys():
									myloads[keyname] = [value]
								else:
									myloads[keyname].append(value)

								if load_obj.status != DEACTIVATED:
									prettyPrint(load_obj,2)

				if keyname not in empty:
					myloads[keyname].append(load_insts)

		print ' '
		print '--------BCs:'
		if _m.boundaryConditions.values() in empty:
			print 'NA'
		else:
			i = 0
			for BC in _m.boundaryConditions.values():
				i += 1
				if i > 1:
					print ' '

				info = get_BC_info(BC)
				print 'BC name:',info['action_name']
				print 'BC type:',info['action_type']
				print 'Description:', BC.__doc__
				print '   surface name:',info['region_name'], ', insts=',info['pois'], ', obj_type=',info['obj_type']

				j = 0
				for step in _m.steps.values():
					if BC.name in step.boundaryConditionStates.keys():
						BC_obj = step.boundaryConditionStates[BC.name]
						if 'status' in BC_obj.__members__:
		##					print BC_obj.status
							if BC_obj.status not in [NOT_YET_ACTIVE,PROPAGATED]:
								if 'typeNameState' in BC_obj.__members__ and BC_obj.typeNameState == UNCHANGED:
									continue

								j += 1
								if j >= 2:
									print '****'
								step_num = get_sequence_index(_m.steps.keys(),step.name)
								print '---in step '+ str(step_num) + ', name=',step.name,', action=',BC_obj.status
								if BC_obj.status != DEACTIVATED:
									settings = {}
									for prop in BC_obj.__members__:
										if prop.endswith('State') and BC_obj.__getattribute__(prop) != UNSET:
											loc = prop.find('State')
											dof = prop[:loc]
											settings[dof] = BC_obj.__getattribute__(dof)
									print '** settings =',settings

	##								prettyPrint(BC_obj,2)

		print ' '
		print '-----------prefields:'
		if _m.predefinedFields.values() in empty:
			print 'NA'
		else:
			i = 0
			for prefield in _m.predefinedFields.values():
				i += 1
				if i > 1:
					print ' '
				print 'prefield name:',prefield.name
				print 'Description:', prefield.__doc__
				j = 0
				for step in _m.steps.values():
					if prefield.name in step.predefinedFieldStates.keys():
						field_obj = step.predefinedFieldStates[prefield.name]
						if 'status' in field_obj.__members__:
		##					print field_obj.status
							if field_obj.status not in [NOT_YET_ACTIVE,PROPAGATED,COMPUTED]:
								j += 1
								if j >= 2:
									print '****'
								step_num = get_sequence_index(_m.steps.keys(),step.name)
								print '---in step '+ str(step_num) + ', name=',step.name,', action=',field_obj.status
								if field_obj.status != DEACTIVATED:
									prettyPrint(field_obj,2)

		print ' '
		print 'meshing:'
		print 'for whole assembly:'
		meshed = False
		meshobj = a.getMeshStats(tuple(a.instances.values()))
		for attrib in meshobj.__members__:
			num = get_attrib(meshobj,attrib)
			if num > 0:
				print attrib,':',num
				meshed = True
		if meshed == False:
			print '** Model not meshing yet'

		print '--'
		print 'for individual parts:'
		for part in _m.parts.values():
			print '--partname:',part.name
			print 'geometry mesh technique:',get_mesh_control(part)
			print 'Global seed=',get_part_seed(part)

			seeded = False
			num_seeds = {}
			size_seeds = {}
			for edge in part.edges:
				method = part.getEdgeSeeds(edge,EDGE_SEEDING_METHOD)
				if method not in empty:
	##				print 'method=',method
					seeded = True
					if 'NUMBER' in totext(method):
						enum = part.getEdgeSeeds(edge,NUMBER)
						if enum not in num_seeds.keys():
							num_seeds[enum] = [edge.index]
						else:
							num_seeds[enum].append(edge.index)
					elif 'SIZE' in totext(method):
						esize = part.getEdgeSeeds(edge,AVERAGE_SIZE)
						if esize not in size_seeds.keys():
							size_seeds[esize] = [edge.index]
						else:
							size_seeds[esize].append(edge.index)

			if num_seeds not in empty:
				print 'num_seeds =',num_seeds

			if size_seeds not in empty:
				print 'size_seeds =',size_seeds

			if seeded == False:
				print 'No edge seed for this part.'

			meshobj = part.getMeshStats()
			meshed = False
			for attrib in meshobj.__members__:
				num = get_attrib(meshobj,attrib)
				if num > 0:
					meshed = True
					print attrib,':',num
			if meshed == False:
				print 'Not meshed yet.'

			print ' '


		proc_types = []
		outputs = {}
##		print fnln(),'here'
##		raise Exception
		for step in _m.steps.values()[1:]:
			type1 = step.procedureType
			if type1 not in proc_types:
				proc_types.append(type1)

			for key in step.fieldOutputRequestStates.keys():
##				print fnln(),'key=',key
				try:
					state1 = step.fieldOutputRequestStates[key]   ## maybe inactive or deactive, so to be non-available
					vars = state1.variables
					if vars not in outputs.values():
						outputs[key] = vars
				except:
					pass

		print ' '
		print '** Overall info:'
		print 'Model name:', _m.name
		print '--Model desciption:'
		print _m.description
		print 'Model type:', _m.modelType
		print 'Absolute temperature:', _m.absoluteZero
		print len(_m.parts),'parts:',_m.parts.keys()
		print '--Part shape and part type:'
		for part in _m.parts.keys():
			print part,':', part_shape(part),',', part_type(part)
		print '--'
		print len(a.instances),'instances:',a.instances.keys()
		print len(mats),'materials:',mats
		print len(_m.steps),'steps:',_m.steps.keys()
		print '    procedure types=',proc_types
		print '    field outputs:  ',outputs
		print len(_m.interactions),'interactions:',_m.interactions.keys()
		for contact in _m.interactions.keys():
			info = get_interact_surface(contact)
			if 'master' in info.keys():
				print '   ', contact,': master=',info['master'],', slave=',info['slave']
			elif 'surface' in info.keys():
				print '   ', contact,': inst=',info['insts']

		print len(_m.constraints),'constraints:',_m.constraints.keys()
		for contact in _m.constraints.keys():
			info = get_constraint_info(contact)
			if 'master' in info.keys():
				print '   ', contact,': master=',info['master'],', slave=',info['slave']
			elif 'surface' in info.keys():
				print '   ', contact,': inst=',info['insts']

		print len(a.sets),'assembly sets:',a.sets.keys()
		print len(a.surfaces),'assembly surface:',a.surfaces.keys()
		print len(_m.amplitudes),'amplitudes:',_m.amplitudes.keys()

		print len(_m.loads),'loads:',_m.loads.keys()
		for load1 in myloads.keys():
			print '    ', load1,':', myloads[load1]

		print len(_m.boundaryConditions),'boundary conditions:',_m.boundaryConditions.keys()
		for BC1 in _m.boundaryConditions.keys():
			info = get_BC_info(BC1)
			print '   ',BC1,', type=',info['action_type'], ', obj_type=',info['obj_type'], ', insts=',info['pois']

		print len(_m.predefinedFields),'predefined fields:',_m.predefinedFields.keys()

		print ' '
		print 'Related jobs:'
		jobs = related_jobs(_m.name)
		for job1 in jobs:
			print '------'
			print "inp file (?):", job1 + '.inp'
			info = job_info(job1)
			myprint(info)
		if jobs in empty:
			print 'No jobs created for model name:',_m.name

	sys.stdout = screen_output		## 如果中途出错，则在命令行中运行此命令，因为screen已经是全局变量。

	print 'model_summary() results are saved in','_sum_' + cae_file_title + '.txt',', User parameters are saved in model description.'
	print ' '

	return

def modify_acceleration_BC(BCname,a1=None,a2=None,a3=None,ar1=None,ar2=None,ar3=None,amplitude=None,freq=None,step='step1'):

	## VER: ('VER: 2012-05-24, v1.0')

	step = check_step(step)
	if freq in empty:
		if a1 not in empty:
			_m.boundaryConditions[BCname].setValuesInStep(stepName=step, a1=a1)
		elif a2 not in empty:
			_m.boundaryConditions[BCname].setValuesInStep(stepName=step, a2=a2)
		elif a3 not in empty:
			_m.boundaryConditions[BCname].setValuesInStep(stepName=step, a3=a3)
		elif ar1 not in empty:
			_m.boundaryConditions[BCname].setValuesInStep(stepName=step, ar1=ar1)
		elif ar2 not in empty:
			_m.boundaryConditions[BCname].setValuesInStep(stepName=step, ar2=ar2)
		elif ar3 not in empty:
			_m.boundaryConditions[BCname].setValuesInStep(stepName=step, ar3=ar3)

	elif amplitude not in empty and freq not in empty:
		T4 = 1.0/freq/4
		_m.PeriodicAmplitude(name='Amp-1', timeSpan=STEP, 		## 正弦曲线
		    frequency=freq, start=0.0, a_0=0.0, data=((T4, amplitude), (2*T4, 0.0), (3*T4, -amplitude), (4*T4, 0.0)))

		_m.boundaryConditions[BCname].setValuesInStep(stepName=step, amplitude='Amp-1')

	print '--->Applied acceleration BC: a1=',a1,', a2=',a2,', a3=', a3, ', ar1=',ar1, ', ar2=', ar2, ', ar3=', ar3, ', amplitude=',amplitude,'step=',step

	return

def modify_string(name,str1,str2=''):
	## VER: ('VER: 2014-04-11, v1.7')   ##假如str2缺省，则相当于删除str1
	## Phython用"\\"来表示一个反斜杠字符'\'，而'\'并不是\本身(转义)。
	## 一个目录名在windows下为：'E:\jyq\pao\49AC', python中表示为：'E:\\jyq\\pao\\49AC'，因为'E:\jyq\pao\49AC\'会出现语法错误，而'E:\\jyq\\pao\\49AC\\'不会
	## raw string: r'E:\jyq\pao\49AC'等效于'E:\\jyq\\pao\\49AC',但r'E:\jyq\pao\49AC\'的写法就会出现语法错误，即最后两个字符\'其实代表一个字符，这样字符串出现没有结束符的错误。

	if str1 == '':
		return name

	if str1 == ' ' and str2 == '':
		name = name.strip()   ##可删除两头的缩进符、换行符、及两头的空白串。

	if str1 in name:
		while True:
			loc = name.find(str1)
			if loc != -1:
##				name = name[:loc] + str2 + name[loc + len(str1) + 1:]
				name = name[:loc] + str2 + name[loc + len(str1):]
			else:
				break
		result = name
	else:
		result = name

	return result


def module_summary():
	## VER: ('VER: 2012-08-17, v1.7')

	print ' '
	print '===============****** Print Modules Summary by module_summary() ******================='
	print 'model mass=',get_mass()
	print 'module_mass=',module_mass
	print 'frame_mass=',frame_mass
	print '--'
	print 'module_top_length=',module_top_length
	print 'module_top_width=',module_top_width
	print 'frame_height =',frame_height
	print '--'

	dict1 = get_mats(a)
	mats = []
	for inst in dict1.keys():
		for mat in dict1[inst].keys():
			if mat not in mats:
				mats.append(mat)

	print len(mats),'mats:',sorted(mats)
	for inst in dict1.keys():
		print inst.ljust(8),':',sorted(dict1[inst].keys())
	print '--'

	parts = sorted(_m.parts.keys())
	print len(_m.parts),'parts:', parts
	if part_holes not in empty:
		myprint(part_holes)

	print 'sets of parts:'
	for part in _m.parts.values():
		print '   **Partname:',part.name
		print part.sets.keys()

	print ' '
	print 'Cells num:',
	for i in range(len(parts)):
		end1 = ''
		if i < len(parts) -1:
			end1 = ','
		part = parts[i]
		part1 = _m.parts[part]
		print part + '= ' + str(len(part1.cells)) + end1,
	print

	print 'Part volume:',
	for i in range(len(parts)):
		end1 = ''
		if i < len(parts) -1:
			end1 = ','
		part = parts[i]
		part1 = _m.parts[part]
		volume = int(round(get_volume(p=part1)))
		print part + '= ' + str(volume) + end1,
	print

	print '--'
	print len(a.instances),'instances:', sorted(a.instances.keys())
	if 'clamp2corner' in globals().keys():
		print 'Assembly: clamp2corner=',clamp2corner
	print '--'
	print 'steps =',_m.steps.keys()
	print len(_m.interactions),'interactions:',sorted(_m.interactions.keys())
	print '--'
	print len(_m.constraints),'constraints:',sorted(_m.constraints.keys())
	print '--'
	print len(_m.loads),'loads:', sorted(_m.loads.keys())
	print len(_m.boundaryConditions),'BCs:',sorted(_m.boundaryConditions.keys())
	myprint(BCs)
	myprint(BC_status)

	print '--'
	stats = a.getMeshStats(tuple(a.instances.values()))
	print stats.numHexElems,'elements:',
	for i in range(len(parts)):
		end1 = ''
		if i < len(parts) -1:
			end1 = ','
		part = parts[i]
		part1 = _m.parts[part]
		elem_num = part1.getMeshStats().numHexElems

		print part + '= ' + str(elem_num) + end1,

##	if has_frame == True:
##		print ' '
##		print '--'
##		print 'Collecting nodes in line:'
##		## frL
##		nodex1 = node_select(frL,y=MIN,z=MIN)
##		nodey1 = node_select(frL,x=_xmax(frL,z=MAX),z=MAX)
##		nodez1 = node_select(frL,x=_xmax(frL,z=MAX),y=MIN)
##
##		## frS
##		nodex2 = node_select(frS,y=_ymax(frS,z=MAX),z=MAX)
##		nodey2 = node_select(frS,x=MIN,z=MIN)
##		nodez2 = node_select(frS,x=MIN,y=_ymax(frS,z=MAX))
##
##		## lam
##		nodex3 = node_select(lam,y=MIN,z=MIN)
##		nodey3 = node_select(lam,x=MAX,z=MIN)
##
##		print 'frL: nodex,nodey,nodez=',(len(nodex1),len(nodey1),len(nodez1))
##		print 'frS: nodex,nodey,nodez=',(len(nodex2),len(nodey2),len(nodez2))
##		print 'lam: nodex,nodey,nodez=',(len(nodex3),len(nodey3))
##
##		print ' '
##		print '**Please highlight the seeds by highlight the seeded edge sets in GUI.'
##		print '  Or check the function mesh_frame()'

	print
	print '--'
	print 'Seedings:'
	for part in parts:
		list1 = []
		part1 = _m.parts[part]
		for setname in part1.sets.keys():
			if '_seed' in setname:
				list1.append(setname)
		list1.sort()
		if list1 == []:
			list1 = 'No seeding was found.'
		print part.ljust(6),':',list1

	print ' '

	return

function_labels['small_mouth_of_insert'] = 'open','radius','diameter','sintering','fix','hole'
def small_mouth_of_insert(insert,axis='z'):
	## VER: 2016-11-15, v1.1

##	>>> small_mouth_of_insert(p1)
##	MIN

##	face_nodes = nodes_by_face(p1,z=MIN,nz=-1,angle=5)	## 获得底面的所有节点
##	edge_nodes = get_edge_nodes(face_nodes)	## 获得底面的外围及内孔的节点。

	p1 = check_poi(insert)

	face_nodes = nodes_by_face(p1,z=MIN,nz=-1,angle=5)
	nodes1 = node_select(p1,nodes=face_nodes,Gx=MID,err=1)  ## 0.5
	nodes1 = nodes_sort_byy(nodes1)

	gaps_zmin = []
	for i in range(len(nodes1)-1):
		dist = get_distance(nodes1[i],nodes1[i+1])
		gaps_zmin.append(dist)
	gap_zmin = max(gaps_zmin)

	face_nodes = nodes_by_face(p1,z=MAX,nz=1)
	nodes1 = node_select(p1,nodes=face_nodes,Gx=MID,err=1)
	nodes1 = nodes_sort_byy(nodes1)

	gaps_zmax = []
	for i in range(len(nodes1)-1):
		dist = get_distance(nodes1[i],nodes1[i+1])
		gaps_zmax.append(dist)
	gap_zmax = max(gaps_zmax)

	if gap_zmax > 1.1*gap_zmin:
		open = MAX
	elif gap_zmin > 1.1*gap_zmax:
		open = MIN
	else:
		print fnln(),'opens are almost the same: top =',gap_zmax,', bot =',gap_zmin
		open = MAX

	if open == MAX:
		small = MIN
	elif open == MIN:
		small = MAX

	return small

def move_clamp(clamp,clamp2corner=None,support_option=None):

	## VER: ('VER: 2012-07-18, v1.0')

	clamp = check_part(clamp)		## 临时变量，move_part之后需要用partname
	partname = clamp.name

	if support_option in empty:
		support_option = globals()['support_option']

	support_option = totext(support_option)
	support_option = modify_string(support_option,' ')		## 去掉空格

	if clamp2corner in empty:
		clamp2corner = globals()['clamp2corner']

	if has_frame == True:
		if 'long_edge' in support_option:
			move_part(clamp,x1=_xmax(clamp,z=MAX) - clamp_thick, x2=_xmax(frL),
				y1=clamp_length/2,y2 = _ymax(frL) - clamp2corner, z1 = _zmax(clamp) - clamp_thick, z2 = _zmax(frL))
			new_instance(partname)

		elif 'short_edge' in support_option:
			move_part(partname,x1=MID, x2=_xmax(frS) - clamp2corner,y1=_ymax(clamp,z=MAX) - clamp_thick,y2 = _ymax(frS),
				z1 = _zmax(clamp) - clamp_thick, z2 = _zmax(frS))
			new_instance(partname)

	elif has_frame == False:  ## Diamond
		if 'long_edge' in support_option:
			move_part(clamp,x1=_xmin(clamp) + clamp_depth, x2=_xmax(lam), y1=MID, y2=_ymax(lam) - clamp2corner, z1=_zmin(clamp) + clamp_thick + rubber_thick, z2=_zmin(lam,x=MAX))
			new_instance(partname)

		elif 'short_edge' in support_option:
			move_part(clamp,x1=MID,x2=_xmax(lam) - clamp2corner,y1=_ymin(clamp) + clamp_depth,y2=_ymax(lam), z1=_zmin(clamp) + clamp_thick + rubber_thick, z2=_zmin(lam,y=MAX))
			new_instance(partname)

	return partname

def move_RP(p,loc=None,x=None,y=None,z=None,dx=None,dy=None,dz=None,KP=None,gohome=False):

	## VER: ('VER: 2012-07-27, v1.8')	## 设置直角坐标系的原点，用于grow or del. CAE中显示的是RP位置。

	global local_csys

	p = check_part(p)
##	if type_of(p) != 'PART':
##		raise Exception('******part is needed for move_RP()')

	loc = tolist(loc)
	if loc not in empty:
		x,y,z=loc

	if loc==x==y==z==dx==dy==dz==KP==None:
		print fnln_fnln(),'Move csys to home position.'
		gohome = True

	if gohome == True:
		if 'O1' not in p.sets.keys():
			now = (0,0,0)
			if type_of(point_at(p,loc=(0,0,0))) == 'vertices':
				KP_set(p,loc=(0,0,0),name='O1')

		else:
			now = KPxyz(p,'O1')

	elif KP not in empty and KP in p.sets.keys():
		now = KPxyz(p,KP)
	else:
		now = tolist(local_csys[p.name])
		if x not in empty or y not in empty or z not in empty:	## 有绝对位置信息
			if x not in empty:
				now[0] = real_xyz(p,x=x, Xonly=True)

			if dx not in empty:
				now[0] = now[0] + dx

			if x in empty and dx in empty:	## 未提供x的位置信息，表示为绝对0位置。？？？？
				now[0] = 0

			if y not in empty:
				now[1] = real_xyz(p,y=y,Yonly=True)

			if dy not in empty:
				now[1] = now[1] + dy

			if y in empty and dy in empty:	## 未提供y的位置信息，表示为绝对0位置。？？？？
				now[1] = 0

			if z not in empty:
				now[2] = real_xyz(p,z=z,Zonly=True)

			if dz not in empty:
				now[2] = now[2] + dz

			if z in empty and dz in empty:	## 未提供x的位置信息，表示为绝对0位置。？？？？
				now[2] = 0

		else:
			if dx not in empty:
				now[0] = now[0] + dx
			if dy not in empty:
				now[1] = now[1] + dy
			if dz not in empty:
				now[2] = now[2] + dz

	local_csys[p.name] = tolist(now)
	print '--->**Relative active csys is moved to',now

##	try:
##		del p.features['RP']
##	except:
##		pass

	RPs = get_RP_objs(p)
	for RP1 in RPs:
		del p.features[RP1.name]

	print fnln(),'now=',now
	print fnln(),'p.name=',p.name
	p.ReferencePoint(point=tuple(now))

	return now

def move_geometry(sketch,geometry=None,dx=0,dy=0, x1=None, x2=None, y1=None,y2=None,loc1=(),loc2=()):
	## VER: 2014-07-15, v1.3
	## 移动之后，会把倒角的地方的半径显示在sketch上，很好。
	## 对于wire part, 无法move_sketch和move_part，只能move_geometry

	sketch = check_sketch(sketch)
	name = sketch.name

	print fnln_fnln(),'y1=',y1,', y2=',y2
	if is_location(loc1):
		x1,y1 = loc1
	if is_location(loc2):
		x2,y2 = loc2

	if x1 not in empty:
		x1 = real_xy_sketch(sketch,x=x1,Xonly=True)

	if x2 not in empty:
		x2 = real_xy_sketch(sketch,x=x2,Xonly=True)

	if y1 not in empty:
		y1 = real_xy_sketch(sketch,y=y1,Yonly=True)

	if y2 not in empty:
		y2 = real_xy_sketch(sketch,y=y2,Yonly=True)

	if type_of(x1) in numerics and type_of(x2) in numerics:
		dx = x2 - x1

	print fnln_fnln(),'y1=',y1,', y2=',y2
##	raise Exception

	if type_of(y1) in numerics and type_of(y2) in numerics:
		dy = y2 - y1

	print fnln_fnln(),'dy=',dy
	if geometry in empty:
		geometry = all_regular_geometry(sketch)

	geometry = totuple(geometry)
	num = len(geometry)

	if dx != 0 or dy != 0:
		sketch.move(vector=(dx,dy), objectList=geometry)

		print '--->Moved',num,'geometry in',sketch.name

	show_sketch(sketch)

##	s1 = _m.ConstrainedSketch(name='__edit__', objectToCopy=sketch)
##	g, v, d, c = s1.geometry, s1.vertices, s1.dimensions, s1.constraints
##
##	curves = []
##	for curve in geometry:
##		curves.append(s1.geometry[curve.id])
##	curves = totuple(curves)
##
##	s1.setPrimaryObject(option = STANDALONE)
##	s1.move(vector=(dx, dy), objectList = curves)
##	_m.sketches.changeKey(fromName='__edit__', toName=name)   # save changes to the sketch
##	s1.unsetPrimaryObject()

	return

def move_instances(insts,dx=0,dy=0,dz=0,x1=None,x2=None,y1=None,y2=None,z1=None,z2=None):
	## VER: 2015-05-04, v1.1

	## reference: new_instance()

	## Example:
##	rotate_instances(insts='crack_A1',angle_y=-45)
##	move_instances('crack_A1',y1=MIN,y2=_ymin('anvil_A1'))
##	move_instances('inter',x1=MID,x2=0)

	insts = real_insts(insts)
	if insts in empty:
		raise Exception('*** No instance to move.')

	names = poi_names(insts)

	x1,y1,z1 = real_xyz(insts[0],x1,y1,z1)
	x2,y2,z2 = real_xyz(insts[0],x2,y2,z2)

	if is_numbers(x1,x2):
		dx = x2 - x1

	if is_numbers(y1,y2):
		dy = y2 - y1

	if is_numbers(z1,z2):
		dz = z2 - z1

	a.translate(instanceList=totuple(names), vector=(dx,dy,dz))

	print '---> instances',names,'is translated, dx,dy,dz=',(dx,dy,dz)

	a.regenerate()

	return

def move_items(list1,start=None,item_num=1,toLoc=1,start_value=None,to_value=None):
	## VER: 2011-06-02, v1.0

	list1 = tolist(list1)

	if start_value != None:
		for i in range(len(list1)):
			item1 = list1[i]
			if type_of(start_value) == 'STR':
				if type_of(item1) == 'STR' and start_value in item1:
					start = i
					break
			elif item1 == start_value:
				start = i
				break

	if to_value != None:
		for i in range(len(list1)):
			item1 = list1[i]
			if type_of(to_value) == 'STR':
				if type_of(item1) == 'STR' and to_value in item1:
					toLoc = i
					break
			elif item1 == to_value:
				toLoc = i
				break

##	print 'start=',start,', toLoc=',toLoc
	sub_list = list1[start:start+item_num]
	list2 = list1[:start] + list1[start + item_num:]
	list21 = list2[:toLoc]
	list22 = list2[toLoc:]

	list1 = list21 + sub_list + list22

	return list1

def move_part(part,dx=0, dy=0, dz=0, from_loc=(), to_loc=(), x1=None,x2=None,y1=None,y2=None,z1=None,z2=None,csys_KP=None):
	## VER: 2016-05-25, v4.0

	global a,_m

	get_current_model()

	if is_part(part):
		part = check_part(part)
	else:
		raise Exception('*** a part is needed to be move.')

	partname = part.name

	if dx in empty:
		dx = 0
	if dy in empty:
		dy = 0
	if dz in empty:
		dz = 0

	x1,y1,z1 = real_xyz(part,x1,y1,z1)
	x2,y2,z2 = real_xyz(part,x2,y2,z2)

	if is_numbers(x1,x2):
		dx = x2 - x1

	if is_numbers(y1,y2):
		dy = y2 - y1

	if is_numbers(z1,z2):
		dz = z2 - z1

	for inst in a.instances.keys():
		if a.instances[inst].partName == partname:
			a.regenerate()
			del a.features[inst]
			a.regenerate()

	get_current_model()

	tempA1 = partname + '-1'
	tempA2 = partname + '-2'

	tempA1 = new_key(a.instances.keys(),tempA1)
	tempA2 = new_key(a.instances.keys() + [tempA1], tempA2)

##	print fnln(), 'tempA1=',tempA1
##	print fnln(), 'tempA2=',tempA2
##	print fnln(),'type_of(part)=',type_of(part)
	a.Instance(name=tempA1, part=part, dependent=ON)
	a.Instance(name=tempA2, part=part, dependent=ON)
##	raise Exception

##	print '(dx, dy, dz)=', (dx, dy, dz)
	a.translate(instanceList=(tempA1, tempA2), vector=(dx, dy, dz))
	merge_instances(partname=partname,insts=(tempA1,tempA2))
	part = _m.parts[partname]

	print 'Part',partname,'was moved. dx,dy,dz=',str([dx,dy,dz])

	if partname in part_holes.keys():
		for i in range(len(part_holes[partname])):
			x0,y0,z0 = part_holes[partname][i]['center']
			part_holes[partname][i]['center'] = [x0+dx,y0+dy,z0+dz]

	if 'temp' not in partname:
		default_plot = partname
	else:
		default_plot = None

	update_part(partname)

	if 'O' in _part(partname).features.keys():
		loc = loc_of_feature_point(p=partname, feature='O')
		space = poi_space(partname)
		if within_space(space,loc) == False:
			_part(partname).deleteFeatures(('O',))

	return partname

def move_sketch_in_ndir(sketch,offset,ndir=None):
	## VER: 2012-11-29, v1.0  只能移动simple sketch

	global _m, a

	if ndir not in ['x','y','z']:
		sketch = check_sketch(sketch,dict_sketch=True)
		ndir = sketch['ndir']
		name = sketch['name']
		sketch = sketch['sketch']
	else:
		sketch = check_sketch(sketch)
		name = sketch.name

	sketch2 = create_base_sketch(name,ndir=ndir,offset=offset,return_sketch=True)
	sketch2_name = sketch2.name

	if is_empty(sketch.geometry) == False:
		wirepart = sketch_to_wirepart1(sketch)
		part1 = _m.parts[wirepart]

		part1.projectEdgesOntoSketch(sketch=sketch2,edges=totuple(part1.edges),constrainToBackground=False)	;please_check
##		del _m.parts[wirepart]
		del_parts(wirepart)

	del _m.sketches[name]
	_m.sketches.changeKey(fromName=sketch2_name, toName=name)
##	sketch2['name'] = name
##	sketch2['sketch'] = _m.sketches[name]

	print 'sketch',name,'is moved in ndir=',ndir,', offset=',offset

	return sketch2

def move_sketch(sketch,dH=0,dV=0,x1=None,x2=None,y1=None,y2=None,move_construction=False,part_method=True):
	## VER: 2013-11-06, v1.1
	## 移动之后，会把倒角的地方的半径显示在sketch上，很好。
	## 参考move_geometry(). 对于wire part, 无法move_sketch和move_part，只能move_geometry

	global _m, a

	sketch = check_sketch(sketch)
	name = sketch.name

	if x1 not in empty:
		x1 = real_xy_sketch(sketch,x=x1,Xonly=True)

	if x2 not in empty:
		x2 = real_xy_sketch(sketch,x=x2,Xonly=True)

	if y1 not in empty:
		y1 = real_xy_sketch(sketch,y=y1,Yonly=True)

	if y2 not in empty:
		y2 = real_xy_sketch(sketch,y=y2,Yonly=True)

	if type_of(x1) in numerics and type_of(x2) in numerics:
		dH = x2 - x1

	if type_of(y1) in numerics and type_of(y2) in numerics:
		dV = y2 - y1

	if part_method == True:
		part1 = sketch_to_wire(sketch)
		move_part(part1,dx=dH, dy=dV)

		name1 = wirepart_to_sketch(part1)
		s1 = _m.sketches[name1]

		del _m.sketches[name]
		del_parts(part1)

		_m.sketches.changeKey(fromName=name1, toName=name)

		show_sketch(name)

	else:
		move_geometry(sketch,geometry=sketch.geometry,dx=dH,dy=dV)  ## 可能会使模型无法计算。

	return name


def mplot(matname=None,poi=None):
	## VER: 2011-11-17, v1.5, material plot

	global dg

	unlight()

	if type_of(matname) in ['PART','PINSTANCE']:
		matname,poi = poi,matname

	vpnow = get_vpnow()
	module = vpnow.displayedObject
	view_type = type_of(module)

	if matname in empty:
		mats = get_mats()
		print 'Material sections in',module.name,':'
		myprint(mats)
		print 'Usage: mplot(matname), mplot(matname,poi), mplot()'
		print '可以用light(matname)来高亮某种材料.'
		print
		return

	elif type_of(matname) != 'STR':
		print fnln_fnln(),'******Material name is required.'
		mplot()
		return

	## get the correct matname
##	print 'view_type=',view_type
	if view_type in ['ASSEMBLY','PART']:
		if matname.upper() not in [mat.upper() for mat in _m.materials.keys()]:
			print fnln_fnln(),'******No such material name= ' + matname
			mplot()
			return
		else:
			for mat in _m.materials.keys():
				if matname.upper() == mat.upper() and matname != mat:
					matname = mat
					print 'Material=',matname
					break

	elif view_type == 'ODB':
		if matname.upper() not in vpnow.odbDisplay.materialAssignments.keys():
			print fnln_fnln(),'******No such material name= ' + matname
			mplot()
			return
		elif poi not in empty and type_of(poi) != 'STR':
			print fnln_fnln(),'******Instance name is required.'
			return
		else:
			matname = matname.upper()

	mats = get_mats(poi)
##	print 'mats=',mats
	print 'plotted matname=',matname
	if view_type == 'ODB':
		if matname in mats.keys():
			esets = mats[matname]
			esets = tuple(esets)
			leaf = dgo.LeafFromElementSets(elementSets=esets)

	else:
		if poi not in empty:
			plot(poi)

		num = 0
		if mats not in empty:
			seq = None
			for pname in mats.keys():
				if matname in mats[pname].keys():   ##有这种材料
					if view_type == 'PART':
						poi = _m.parts[pname]
					elif view_type == 'ASSEMBLY':
						poi = module.instances[pname]

					setnames = mats[pname][matname]   ##InternalSets, name
					for setname in setnames:
						if view_type != 'PART':
							setname1 = pname + '.' + setname
						else:
							setname1 = setname
						cells_seq = module.allInternalSets[setname1].cells
						num = num + 1
						if num == 1:
							seq = cells_seq
						else:
							seq = seq + cells_seq

			if seq != None:
				leaf = dgm.LeafFromGeometry(cellSeq=seq)
			else:
				print fnln_fnln(),'****** No such material in',vpnow.displayedObject.name
				return

			type2 = type_of(poi)
			if type2 == 'PINSTANCE':
				vpnow.setValues(displayedObject=a)
				plot_history.append(get_traceback())
			elif type2 == 'PART':
				vpnow.setValues(displayedObject=poi)
				plot_history.append(get_traceback())

	dg = session.DisplayGroup(leaf=leaf, name='_leaf')
	print 'Created global variable dg in',type_of(vpnow.displayedObject),'viewport. Usage: plot(dg) or light(dg) + Replace All按钮.'
	print ' '
	plot(leaf)

	return

def fn_mph2ms(mph):
	## VER: 2010-11-16, v1.1，转换成m/s

	ms = round(mph*0.45,2)		## m/s
	kph = round(mph*1.6,2)		## kph

	V3 = ms
	V600 = round(V3*0.703,2)

	print 'Remark: V3=3秒平均最大阵风速度，V600=10分钟(600秒)平均最大阵风风速。V600=V3*0.703。美国用V3计算基本风压P3，中国用V600计算基本风压P600。'
	print '--->mph=',mph,'mile/hr',', 基本风速：V3=',kph,'kph =',V3,'m/s. V600=',V600,'m/s'
	print ' '

	return V3,V600

def ms_reverse(base_type):
	## VER: 2011-11-18, v1.0   与接触对相关。

	if type_of(base_type) != 'STR':
		raise Exception('string "master" or "slave" is required.')

	if base_type[0] == 'm':
		result = 's'
	elif base_type[0] == 's':
		result = 'm'
	else:
		raise Exception('string "master" or "slave" is required.')

	return result

def my_walk(path=None):
	## VER: 2015-07-07, v1.1
	## 会列出当前目录及其所有的子目录的文件。有时仅仅需要当前目录。
	## Reference: search_file(),search_dir()

##	>>> dict1 = my_walk()
##	>>> min(dict1.keys())
##	'E:/FEM/A0241_Cap_Eugene'  ## 获取最短的路径，也就是当前目录，而不是子目录
##	>>>

	## 路径的判断
##	>>> dir1 = 'E:/FEM/A0241_Cap_Eugene/py'
##	>>> os.path.isdir(dir1)
##	True
##	>>> os.path.isdir(dir1+'/')  ##路径后面带或不带'/'都是正确的
##	True
##	>>>

	## 创建新文件夹:带创建的文件夹名字以'/'结尾也是正确的。
##	>>> dir1
##	'E:/FEM/A0241_Cap_Eugene/py'
##	>>> os.makedirs(dir1+'/test1/')  ##成功
##	>>> os.makedirs(dir1+'/test2')  ##成功
##	>>>

	## Example:
	##>>> num, dict1 = my_walk('T:\\Transfer\\steven')
	##>>> myprint(dict1)
	##
	##['<module>', 1, 'myprint', 24731] Results of ['myprint','dict1'] :
	##T:\Transfer\steven\New Folder = {'sub_dirs': [], 'files': ['A105a.jnl']}
	##T:\Transfer\steven\test4 = {'sub_dirs': [], 'files': []}
	##T:\Transfer\steven\test5 = {'sub_dirs': [], 'files': ['flat.odb']}
	##T:\Transfer\steven\Test6 = {'sub_dirs': [], 'files': []}
	##T:\Transfer\steven\test3 = {'sub_dirs': ['sub1'], 'files': []}
	##T:\Transfer\steven\test3\sub1\sub2 = {'sub_dirs': [], 'files': ['A105a.inp']}
	##T:\Transfer\steven\test3\sub1 = {'sub_dirs': ['sub2'], 'files': []}
	##--
	##T:\Transfer\steven = {'sub_dirs': ['New Folder', 'test3', 'test4', 'test5', 'Test6'], 'files': ['A105a-6.8-2.cae', 'A105a-6.8-2.jnl', 'A105a-upgrade.log', 'A105a.cae', 'A105a.jnl', 'A105b-version updated.cae', 'A105b-version updated.jnl', 'abaqus_v6.env', 'billesrempl1-h11n-pcup30-1.inp']}
	##--
	##Printed dictionay by item(key : value) per line.
	##
	##>>>

	if path in empty:
		path = get_work_dir()

	path = real_dir(path)
	if os.path.isdir(path) == False:
		raise Exception('**** path not exists')

	list1 = os.walk(path)
	dict1 = {}
	files_num = 0
	for current_folder,sub_dirs,files in list1:
		folder1 = real_dir(current_folder)
		dict1[folder1] = {}
		dict1[folder1]['sub_dirs'] = sub_dirs
		dict1[folder1]['files'] = files
		files_num = files_num + len(files)

	## 如果files_num == 0，则为空目录。

	return dict1
##	return files_num, dict1

def myprint(obj,level=1):
	## VER: 2014-04-10, v2.5
	## 10.23 myprint()函数运行后不会使密度结果消失。

	## Example:
##	>>> dict1 = read_density_and_element_labels('uread.py')
##	>>> myprint(dict1)
##	5.62 : [1, 2, 3, 4, 5, 6, 7, 8]
##	5.64 : [12, 14, 16, 18, 19]
##	5.66 : [22, 26, 27, 29]
##
##	>>>

	type1 = type_of(obj)

	num = 0
	try:
		num = len(obj)
	except:
		pass

##	trace1 = get_traceback(instance_list=True)
##	print caller_fnln(),'Results of',get_caller_code(),':'

	if num > 100:
		print 'type_of(obj)=',type_of(obj)
		print fnln_fnln(),'there are more than 100 items. obj=',repr(obj)[0:200] + '......'
		return

	if obj in empty:
		if obj == '':
			obj = "''"
		print 'obj=',obj
		return

	if type1 in ['LIST','TUPLE']:
		for item in obj:
			value1 = item
			if value1 == '':
				value1 = "''"
			print value1
##		print 'Printed',type1,"by 'print item' per line."
		print 'This is a',type1
		print

	elif type1 in ['DICT']:
		n = 0
		blank_before = False
		items = sort_by_key(obj)
		for k,v in items:
##		for k,v in obj.items():
			n = n + 1
			value1 = v
			if value1 == '':
				value1 == "''"
			value1 = repr(value1)
			value1 = use_poi_var_name(value1)
			if len(value1) > 110 and n > 1 and blank_before == False:
				print '--'
			print k,':',value1
			if len(value1) > 110:
				print '--'
				blank_before = True
			else:
				blank_before = False

##		print 'Printed dictionay by item(key : value) per line.'
##		print 'This is a dictionary'
		print ' '

	elif type1 in ['INT','FLOAT','STR'] or obj in empty:
		print 'obj=',obj

	elif type1 in ['VETEXARRAY','EDGEARRAY','FACEARRAY','CELLARRAY']:
		type2 = type1[:-5].lower()
		print '--This is an array of',type2,', type_of(obj)=',type_of(obj),', len(obj)=',len(obj)
		if len(obj) > 0:
			print '***It can be use as a normal list of',type2
			print ' '
		if len(obj) <= 10:
			print '--list of detailed',type2,'element in this array:'
			for item in obj:
				print item
			print ' '
		print '--pointsOn of array:'
		print obj.pointsOn
		print ' '
		print '--Methods of array:'
		print obj.__methods__
		print ' '

	else:
		print "****properties and values shown by prettyPrint(obj," + str(level) + ")..."
		try:
			prettyPrint(obj,level)
		except:
			print 'Cannot performed prettyPrint(). Please try dir()'

		print '  '
		print "****methods..."

		meth = []
		try:
			meth = obj.__methods__
		except:
			pass

		if len(meth) > 0:
			print '---'
			for i in range(len(meth)):
				if meth[i][0] <= 'Z':
					if i <= len(meth) - 2 and meth[i+1][0] <='Z':
						print meth[i] + '(), ',
					else:
						print meth[i] + '()'
				else:
					break

			print '---'
			for i in range(len(meth)):
				if meth[i][0] >= 'a':
					if i <= len(meth) - 2:
						print meth[i] + '(), ',
					else:
						print meth[i] + '()'
		else:
			meth = dir(obj)
			newlist = []
			for item in meth:
				prop = eval('obj.' + item)
				type1 = type_of(prop)
				if 'METHOD' not in type1 or item[:2] == '__':
					continue
				newlist.append(item)
			meth = newlist

			if meth in empty:
				print 'This object has no method.'
			else:
				print '---'
				for i in range(len(meth)):
					if meth[i][0] <= 'Z':
						if i <= len(meth) - 2 and meth[i+1][0] <='Z':
							print meth[i] + '(), ',
						else:
							print meth[i] + '()'
					else:
						break

				print '---'
				for i in range(len(meth)):
					if meth[i][0] >= 'a':
						if i <= len(meth) - 2:
							print meth[i] + '(), ',
						else:
							print meth[i] + '()'

		print ' '
		type1 = str(type(obj))[7:-2]
		print '**** type_of(obj)=',type1,', upper()=',type_of(obj)
		print ' '

	return

def myrange(start,end,inc=1):
	## VER: 2015-05-08, 2.0

	## Example:
##	CTEs = myrange(0.14, 0.24, 0.001)	## for deltaT = 1
##	>>> myrange(0,20,2)
##	[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

	if type_of(start) not in ['FLOAT','INT']:
		raise Exception('Error parameter start=',start)

	if type_of(end) not in ['FLOAT','INT']:
		raise Exception('Error parameter end=',end)

	if type_of(inc) not in ['FLOAT','INT']:
		raise Exception('Error parameter inc=',inc)

	if inc == 0:
		raise Exception('parameter inc cannot be zero.')

	list1 = []
	if type_of(inc) == 'INT':
		list1 = range(start,end + inc, inc)
	else:
		now = start
		if inc > 0:
			while PK(now,end) in ['<',0]:
				now = round(now,8)
				list1.append(now)
				now = now + inc
		elif inc < 0:
			while PK(now,end) in ['>',0]:
				now = round(now,8)
				list1.append(now)
				now = now + inc

	return list1

def ndir_of_datum_plane(datum_plane):
	## VER: 2014-01-14, v1.1, for tilted plane, get the most dir

	if type_of(datum_plane) != 'DATUMPLANE':
		raise Exception('*** datum plane is required.')

	x,y,z = datum_plane.normal
	x,y,z = round6(x,y,z)

	dict1 = {'x':x, 'y':y, 'z':z}

	list1 = sort_by_value(dict1)   ## accending

	dir1,dir2,dir3 = list1

	## find most normal direction
	if PK(abs(dir1[1]),abs(dir3[1])) == '>':
		if dir1[1] > 0:
			ndir = '+' + dir1[0]
		else:
			ndir = '-' + dir1[0]
	else:
		if dir3[1] > 0:
			ndir = '+' + dir3[0]
		else:
			ndir = '-' + dir3[0]

	return ndir

def get_sketch_ndir(sketch):
	## VER: 2013-05-18, v1.0
	## reference: ndir_of_sketch(), 不过该函数仅适用于命令窗口。

	sketch = check_sketch(sketch)

	if len(sketch.geometry) == 0:
		return None

	part = sketch_to_wirepart1(sketch)

	x1,x2,y1,y2,z1,z2 = poi_space(part)
##	print (x1,x2,y1,y2,z1,z2)

	PKx = PK(x1,x2)
	PKy = PK(y1,y2)
	PKz = PK(z1,z2)

	if PKx == 0 and PKy != 0 and PKz != 0:
		ndir = 'x'
	elif PKx !=0 and PKy == 0 and PKz != 0:
		ndir = 'y'
	elif PKx != 0 and PKy != 0 and PKz == 0:
		ndir = 'z'
	else:
		raise Exception('*** Fail to get ndir of the sketch.')

	del_parts(part)
	sketch.setPrimaryObject(option=STANDALONE)
	sketch.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	return ndir

def nearby_of_edge_end(edge,vertice):
	## VER: 2016-06-20, v1.0
	## To get a nearby loc close to one end of the edge.
	## 类似于MAX1,MIN1的效果

	if type_of(vertice) == 'edges':
		edge,vertice = vertice,edge

	vertices = edges_to_vertices(edge)
	if vertice not in vertices:
		raise Exception('*** vertice not the end of the edge.')

	loc0 = vertice.pointOn[0]
	loc1 = locs_of_edge(edge,0.99)[0]
	loc2 = locs_of_edge(edge,0.01)[0]
	dist1 = round(get_distance(loc0,loc1),6)
	dist2 = round(get_distance(loc0,loc2),6)

	if dist1 <= dist2:
		nearby = loc1
	else:
		nearby = loc2

	return nearby

def new_geometry_of_sketch(sketch,ids0=()):
	## VER: 2015-04-20, v1.0
	## reference: new_points_of_sketch()
	## return ids

	sketch = check_sketch(sketch)
	if ids0 in empty:
		ids0 = sketch.geometry.keys()

	ids1 = []
	for curve in sketch.geometry.values():
		if curve.getSize() > 0:  ## regular
			id = curve.id
			if id not in ids0:
				ids1.append(id)

##	print fnln(),'--->There are',len(ids1),'new geometry'

	return ids1

function_labels['new_instance'] = 'assembly','part','move'
def new_instance(part,inst_name='',name='', dx=0, dy=0, dz=0, x1=None, x2=None, y1=None, y2=None, z1=None, z2=None, ref_inst=None,fix=False, vector=None,plota=True):
	## VER: 2016-10-24, v3.1

	global _m, a

	global _divide_num, insts_space, default_plot
	_divide_num = 0

	part = check_part(part)

	if type_of(name) == 'STR':
		inst_name = name

	if vector in empty:
		x1,y1,z1 = real_xyz(part,x1,y1,z1)
		x2,y2,z2 = real_xyz(part,x2,y2,z2)

		if x1 != None and x2 != None:
			dx = x2 - x1

		if y1 != None and y2 != None:
			dy = y2 - y1

		if z1 != None and z2 != None:
			dz = z2 - z1

		if ref_inst not in empty:
			ref_inst = check_inst(ref_inst)
			dx1,dy1,dz1 = ref_inst.getTranslation()
			dx += dx1
			dy += dy1
			dz += dz1

	else:
		dx, dy, dz = vector

	if inst_name in empty:
		inst_name = part.name + '_A1'
		inst_name = new_key(a.instances,inst_name,new_inst=True)

##	print fnln_fnln(),'inst_name=',inst_name
	try:
		a.Instance(dependent=ON, name=inst_name, part=part)
	except:
		shape1 = model_shape()
		shape2 = part_shape(part)[0]
		if shape1 not in empty and shape1 != shape2:
			raise Exception('*** Error part shape for ' + part.name + ', it should be ' + repr(shape1))

	a.translate(instanceList=(inst_name, ), vector=(dx,dy,dz))

	if '_temp' not in inst_name:
		print fnln_fnln(),'--->New instance of',part.name,'created, name =',inst_name
		print ' '

	new_inst = a.instances[inst_name]

	if fix == True:
		insts_space[inst_name] = poi_space(new_inst)

##	globals()[text2varname(inst_name,poi_type='instance')] = a.instances[inst_name]

	a.regenerate()
	if plota == True:
		plot(a)

	return inst_name

def blank_part(partname,pshape='3D', ptype='deformable',show_RP=True):
	## VER: 2014-03-06, v2.0
	## a shell part is always deformable in part type, but it can be constrained as rigid body.

	global  default_plot, local_csys, _m, a

	## Example:
	## blank_part(partname='carbide',pshape='2D')   ## wire是2维时，需要blank_part是二维的。

	partname = new_key(partname,new_part=True)

	pshape, ptype = real_pshape_and_ptype(pshape = pshape, ptype = ptype)
	_m.Part(name=partname, dimensionality=pshape,  type=ptype)  ## 生成一个空白part，没有任何实体。

	_divide_num = 0
	local_csys[partname] = [0,0,0]

	update_part(partname)

	if 'temp' not in partname:
		default_plot = _m.parts[partname]

	if show_RP == True:
		create_RP(partname,(0,0,0))		## 此时还没有O1

	return partname

function_labels['bias_cut'] = 'delete','part','bias_cut','instance'
def bias_cut(part,cut_sides=(),sides=None,side=None,x=None,y=None,z=None, datum_plane=None, point1=None,point2=None,point3=None,
	pass_point1=None, pass_point2=None, pass_point3=None, parallel='', edge1=None, edge2=None, offset_x=None,offset_y=None,offset_z=None,
	angle_with_X=None,angle_with_Y=None,angle_with_Z=None):
	## VER: 2017-07-28, v3.2

	## 也可以通过divide()，然后remove faces来实现。界面下操作。因为有时候，通过bias_cut可能对特殊曲面失灵。
	## cut_dir3 = '+'表示拇指方向朝我时，切除的是dir3的正向一侧； False时表示切除的是dir3的负向一侧。
	## 拇指方向为旋转轴的正方向。顺着四指方向的角度为正，否则为负角。
	## 知道thumb_axis=z, fingle_angle_from_Y, 知道dir3=x
	## 也就是说，thum_axis和angle_with_Y组成了切削平面，dir3相当于切削平面的法向。
	## angle_with_Y:表示夹角中的非斜边为Y轴，即与Y轴的夹角。

##	bias_cut(ring,cut_sides=['+x','+y'],point1=locs[2],angle_with_X=45,offset_x=-0.5)  ## 2D axissymmetric

	## >>> bias_cut(p1,z=0,side='+')  ## 保留xoy平面，并且把+z方向切除（法线向外部分不见了）

	## 对二维模型也使用。例如：
##	bias_cut('nib',cut_sides=['+x','-y'],point1=(nib_R, 1.09,0), angle_with_Y=15)
##	bias_cut(nib,cut_sides='bot_right',point1=(nib_diameter/2,_ymin(nib) + cut_height), angle_with_Y = 15)  ## Nib chamfer
##	bias_cut(nib,x=0.5,cut_sides='-x')


##	bias_cut(anvil,cut_sides=['+x','+y'], pass_point1 = (land_width/2, total_H,0), angle_with_Y=45)
##	bias_cut(anvil,cut_sides=['-z','+y'], pass_point1 = (0, total_H,-land_width/2), angle_with_Z=45)

##	blank_part('stamp')
##	cylinder_grow(stamp,ndir='z',OD=stamp_D,L=stamp_L)
##	bias_cut(stamp,cut_sides='+x',x=cut2cut/2)
##	bias_cut(stamp,cut_sides='-x',x=-cut2cut/2)

	if is_instance(part):
		raise Exception('*** Please use cut_instance() instead.')

	if part == 'this':
		dpo = get_dpo()
		if type_of(dpo) != 'PART':
			raise Exception('*** a part name or a part display is required.')
		part = dpo

	part = check_part(part)

	vol0 = 0
	area0 = 0
	if len(part.cells)>0:
		vol0 = round(get_volume(part))
	else:
		area0 = round(get_area(part))

	if len(part.edges) == 0:  ## empty part
		return

	if side not in empty and sides in empty:
		sides = side

	if sides not in empty and cut_sides in empty:
		cut_sides = sides

	x,y,z = real_xyz(part,x,y,z)
	if cut_sides in ['+','-']:
		if is_number(x) and y in empty and z in empty:
			cut_sides = cut_sides + 'x'
		elif is_number(y) and x in empty and z in empty:
			cut_sides = cut_sides + 'y'
		elif is_number(z) and x in empty and y in empty:
			cut_sides = cut_sides + 'z'

	if pass_point1 not in empty:
		point1 = pass_point1
	if pass_point2 not in empty:
		point2 = pass_point2
	if pass_point3 not in empty:
		point3 = pass_point3

##	print point1,point2,point3

	pt_num = len(remove_empty([point1, point2, point3]))
	if pt_num == 1:
		point1 = get_real_input(point1, point2, point3)
	elif pt_num == 2:
		if point1 in empty or point2 in empty:
			raise Exception('*** point1 and point2 are requird.')

	if type_of(point1) == 'vertices':
		point1 = point1.pointOn[0]
	elif type_of(point1) == 'DATUMPOINT':
		point1 = point1.pointOn

##	print fnln(),'point1=',point1
##	stop1()

	if is_location(point1) and len(point1) == 2 and len(part.cells) == 0:
		point1 = point1[0],point1[1],0

	if type_of(point2) == 'vertices':
		point2 = point2.pointOn[0]
	elif type_of(point2) == 'DATUMPOINT':
		point2 = point2.pointOn

	if is_location(point2) and len(point2) == 2 and len(part.cells) == 0:
		point2 = point2[0],point2[1],0

	if type_of(point3) == 'vertices':
		point3 = point3.pointOn[0]
	elif type_of(point3) == 'DATUMPOINT':
		point3 = point3.pointOn

	if is_location(point3) and len(point3) == 2 and len(part.cells) == 0:
		point3 = point3[0],point3[1],0

	if is_location(point1) and point2 in empty and point3 in empty:
		x1,y1,z1 = point1
		if is_number(offset_x):
			x1 = x1 + offset_x
		if is_number(offset_y):
			y1 = y1 + offset_y
		if is_number(offset_z):
			z1 = z1 + offset_z
		point1 = (x1,y1,z1)

##	print point1,point2,point3

	if type_of(cut_sides) == 'STR':
		cut_sides = cut_sides.lower()
		if cut_sides == 'bot_right':
			cut_sides = ['+x','-y']
		elif cut_sides == 'top_right':
			cut_sides = ['+x','+y']
		elif cut_sides == 'top_left':
			cut_sides = ['-x','+y']
		elif cut_sides == 'bot_left':
			cut_sides = ['-x','-y']
		elif cut_sides == 'top':
			cut_sides = ['+y']
		elif cut_sides == 'bot':
			cut_sides = ['-y']
		elif cut_sides == 'right':
			cut_sides = ['+x']
		elif cut_sides == 'left':
			cut_sides = ['-x']

	cut_sides = tolist(cut_sides)
	if cut_sides not in empty:
		for i in range(len(cut_sides)):
			side = cut_sides[i]
			side = side.lower()
			if side[-1] not in ['x','y','z']:
				raise Exception("*** cut_sides are required, such as: cut_sides=['+x','-y']")

			if len(side) == 1:
				cut_sides[i] = '+' + side

	print 'cut_sides=',cut_sides

	if datum_plane in empty:
		if is_empties(x,y,z) == False:
			x,y,z = real_xyz(part,x,y,z)
			if type_of(x) in numerics:
				datum_plane = create_datum_plane_by_offset(part,x=x)
			elif type_of(y) in numerics:
				datum_plane = create_datum_plane_by_offset(part,y=y)
			elif type_of(z) in numerics:
				datum_plane = create_datum_plane_by_offset(part,z=z)

		elif is_empties(edge1,edge2) == False:
			if type_of(edge1) in ['edges','DATUMAXIS']:
				if type_of(edge2) in ['edges','DATUMAXIS']:
					datum_plane = create_datum_plane_by_2axis(part, axis1=edge1, axis2=edge2)
				else:
					if is_location(point1) == True:
						datum_plane = create_datum_plane_by_point_and_axis(part, point=point1, axis=edge1)
					else:
						raise Exception('*** point1 or edge2 is required.')

		elif is_empties(point1,point2,point3) == False:  ## provide point and parallel
			if pt_num == 3:
				datum_plane = create_datum_plane_by_3points(part,point1=point1,point2=point2, point3=point3)
##				print point1,point2,point3

			elif pt_num == 2:
				if parallel in empty:
					list1 = ['x','y','z']
					for i in range(len(cut_sides)):
						list1.remove(cut_sides[i][-1])
					if list1 not in empty:
						parallel = list1[0]

				if parallel not in ['x','y','z']:
					raise Exception('*** please provide parallel axis: x, y, or z')

				if parallel == 'x':
					point3 = point1[0] + 100, point1[1], point1[2]
				elif parallel == 'y':
					point3 = point1[0], point1[1] + 100, point1[2]
				elif parallel == 'z':
					point3 = point1[0], point1[1], point1[2] + 100

				axis1 = create_datum_axis_by_2points(part,start=point1,end=point2)
				axis2 = create_datum_axis_by_2points(part,start=point1,end=point3)
				angle0 = get_intersect_angle(obj1 = axis1, obj2 = axis2)
				angle0 = angle0[0]
				if angle0 == 0:
					raise Exception('*** please provide another parallel direction.')

				datum_plane = create_datum_plane_by_3points(part,point1=point1,point2=point2, point3=point3)

			elif pt_num == 1:
				if len(cut_sides) == 1:
					if cut_sides[0][-1] == 'x':
						datum_plane = create_datum_plane_by_offset(part,x=point1[0])
					elif cut_sides[0][-1] == 'y':
						datum_plane = create_datum_plane_by_offset(part,y=point1[1])
					elif cut_sides[0][-1] == 'z':
						datum_plane = create_datum_plane_by_offset(part,z=point1[2])

				else:
					if len(cut_sides) != 2:
						raise Exception("*** cut_sides are required, such as: cut_sides=['+x','-y']")

					if parallel in empty:
						list1 = ['x','y','z']
						for i in range(len(cut_sides)):
							list1.remove(cut_sides[i][-1])
						if list1 not in empty:
							parallel = list1[0]

					angle = get_angle_of_cut_sides(cut_sides, angle_with_X, angle_with_Y,angle_with_Z)
					print fnln_fnln(), 'cut_sides=',cut_sides
					print fnln_fnln(), 'angle=',angle

					cut_sides2 = copy.deepcopy(cut_sides)
					if type_of(angle_with_Y) in numerics:
						cut_sides2 = unselect(cut_sides,['+y','-y'])
					elif type_of(angle_with_X) in numerics:
						cut_sides2 = unselect(cut_sides,['+x','-x'])
					elif type_of(angle_with_Z) in numerics:
						cut_sides2 = unselect(cut_sides,['+z','-z'])

					print fnln_fnln(),'parallel=',parallel
					print fnln_fnln(),'point1=',point1

					if is_location(point1) == False:
						raise Exception('*** point1 location is required.')

					if parallel not in ['x','y','z']:
						raise Exception('*** parallel is required, x, y, or z')

					if parallel == 'x':
						point2 = point1[0] + 100, point1[1], point1[2]
					elif parallel == 'y':
						point2 = point1[0], point1[1] + 100, point1[2]
					elif parallel == 'z':
						point2 = point1[0], point1[1], point1[2] + 100

					datum_axis = create_datum_axis_by_2points(part,start=point1,end=point2)
					if parallel == 'z':    ## cutting plane is rotated from yoz plane
						if type_of(angle_with_Y) in numerics:
							datum_plane0 = create_datum_plane_by_offset(part,ndir='x',offset=point1[0])
						elif type_of(angle_with_X) in numerics:
							datum_plane0 = create_datum_plane_by_offset(part,ndir='y',offset=point1[1])

					elif parallel == 'y':
						if type_of(angle_with_Z) in numerics:
							datum_plane0 = create_datum_plane_by_offset(part,ndir='x',offset=point1[0])
						elif type_of(angle_with_X) in numerics:   ## xoy plane
							datum_plane0 = create_datum_plane_by_offset(part,ndir='z',offset=point1[2])

					elif parallel == 'x':   ## cutting plane is rotated from xoy plane
						if type_of(angle_with_Z) in numerics:
							datum_plane0 = create_datum_plane_by_offset(part,ndir='y',offset=point1[1])
						elif type_of(angle_with_Y) in numerics:
							datum_plane0 = create_datum_plane_by_offset(part,ndir='z',offset=point1[2])

					datum_plane = rotate_plane_to_datum_plane(face=datum_plane0, edge=datum_axis, angle=angle)

	if type_of(datum_plane) != 'DATUMPLANE':
		raise Exception('*** A datum plane is required.')

	normal_sides = normal_sides_of_datum_plane(datum_plane)
	if have_common(normal_sides, cut_sides):
		flip = ON
	else:
		flip = OFF

	right_edge = right_edge_of_datum_plane(part,datum_plane)
	s = datum_plane_to_blank_sketch(datum_plane,right_edge=right_edge)

##	print fnln_fnln(),'Most ndir side of datum_plane:',ndir_of_datum_plane(datum_plane)
##	print fnln_fnln(),'normal_sides =',normal_sides
##	print fnln_fnln(),'cut_sides=',cut_sides

	s.rectangle(point1=(border_x - 100, border_y - 100), point2=(100 - border_x, 100 - border_y))
	part.CutExtrude(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=SIDE1,
	    sketchOrientation=RIGHT, sketch=s, flipExtrudeDirection=flip)

	del _m.sketches[s.name]

	get_current_model()

	vol1 = 0
	area1 = 0
	if len(part.cells)>0:
		vol1 = round(get_volume(part))
	else:
		area1 = round(get_area(part))

	if vol0 != vol1 or area0 != area1:
		cutted = True
	else:
		cutted = False

	return cutted

def normal_datum_plane_of_edge(edge,point=None):
	## VER: 2014-07-10, v1.0

	if point in empty:
		point = edges_to_vertices(edge)[0]

	if type_of(edge) != 'edges':
		raise Exception('*** an edge is required.')

	poi = get_poi(edge)

	loc0 = point
	ptype = type_of(point)
	if ptype == 'vertices':
		loc0 = point.pointOn[0]
	elif ptype == 'referencePoints':
		loc0 = RPxyz(point)
	elif ptype == 'DATUMPOINT':
		loc0 = point.pointOn
	elif is_location(point):
		poi.DatumPointByCoordinate(coords=loc0)
		point = poi.datums.values()[-1]

	if is_location(loc0) == False:
		raise Exception('*** a point location at the edge is required.')

	x0,y0,z0 = loc0
	vector = tangent_vector_of_edge(edge,loc0)
	x1,y1,z1 = vector
	x1 = x0 + x1
	y1 = y0 + y1
	z1 = z0 + z1

	normal = create_datum_axis_by_2points(poi, start=(x0,y0,z0), end=(x1,y1,z1))
	poi.DatumPlaneByPointNormal(point=point, normal=normal)
	plane = poi.datums.values()[-1]

	return plane

def circle_radius_by_3points(loc1,mid,loc2,ndir='z',inst=None,step=-1,frame=-1):
	## VER: 2015-11-20, v1.0

	if type_of(loc1) == 'INT':
		loc1 = loc_of_odb_node(loc1,inst=inst,step=step,frame=frame)

	if type_of(loc2) == 'INT':
		loc2 = loc_of_odb_node(loc2,inst=inst,step=step,frame=frame)

	if type_of(mid) == 'INT':
		mid = loc_of_odb_node(mid,inst=inst,step=step,frame=frame)

	if is_location(loc1) == False:
		raise Exception('*** loc1 should be location')

	if is_location(mid) == False:
		raise Exception('*** loc1 should be location')

	if is_location(mid) == False:
		raise Exception('*** loc1 should be location')

	x01,y01,z01 = loc1
	x02,y02,z02 = loc2
	x0m,y0m,z0m = mid

	if ndir == 'z':
		loc1 = (x01,y01,0)
		loc2 = (x02,y02,0)
		mid = (x0m,y0m,0)

		## 垂直平分线的向量
		n1 = normal_vector_of_three_points_plane(loc1,mid,(x0m,y0m,1))
		n2 = normal_vector_of_three_points_plane(loc2,mid,(x0m,y0m,1))

		nx1,ny1,nz1 = n1
		nx2,ny2,nz2 = n2

		## 斜率
		K1 = ny1/nx1
		K2 = ny2/nx2

		##中点
		x1,y1,z1 = (x01 + x0m)/2, (y01 + y0m)/2, 0
		x2,y2,z2 = (x02 + x0m)/2, (y02 + y0m)/2, 0

		## 垂直平分线的交点为圆心
		x0 = 1/(K1-K2)*(y2 - y1 + K1*x1 - K2*x2)
		y0 = K1*(x0 - x1) + y1
		z0 = 0
		center = (x0,y0,z0)

		## 获取半径
		R1 = get_distance(center,loc1)
		R2 = get_distance(center,loc2)
		Rm = get_distance(center,mid)

		R = smart_round((R1+R2+Rm)/3)

	return R

def normal_vector_of_element(elem):
	## VER: 2016-12-07, v1.0

##	>>> vector1 = normal_vector_of_element(e1)
##	>>> vector1
##	(0.00305503, -0.00596975, 0.99997751)
##	>>> vector2 = normal_vector_of_element(e2)
##	>>> vector2
##	(0.86297808, 0.50513872, 0.01018411)
##	>>> vector_angle(vector1=vector1,vector2=vector2,absolute=False)
##	['vector_angle', 77815] angle = 89deg26'
##	89.438
##	>>>
##	>>> is_location(vector1)
##	True
##	>>>

	if type_of(elem) != 'elements':
		raise Exception('*** an exterior element is required.')

	if is_exterior_element(elem) == False:
		raise Exception('*** an exterior element is required.')

	faces = exterior_faces_of_elements(elem)
	if len(faces) > 1:
		print('*** This is an corner/edge element')
		return None

	center = element_center(elem)
	nodes = faces[0].getNodes()
	vector = normal_vector_of_three_points_plane(nodes[0],nodes[1],nodes[2],reference=center)

	return vector

def normal_vector_of_three_points_plane(loc1,loc2,loc3,reference=()):
	## VER: 2015-05-29,v1.1

##	直线方程:过点(x0,y0,z0)，且向量为n={m,n,p}，则直线方程(equation)为:
##		(x-x0)/m = (y-y0)/n = (z-z0)/p
#	若直线向量为n=(Nx,Ny,Nz),则有:
#		y-y0 = Ny/Nz(z-z0)   斜率K=Ny/Nz   so, y-y0 = K(z-z0)
#		x-x0 = Nx/Nz(z-z0)   斜率K=Nx/Nz   so, x-x0 = K(z-z0)
#		y-y0 = Ny/Nx(x-x0)   斜率K=Ny/Nx   so, y-y0 = K(x-x0)

##	平面的点法式方程(平面方程): 过点(x0,y0,z0)，且法线向量为n={A,B,C}，方程为:
##		A(x-x0) + B(y-y0) + C(z-z0) = 0

	## nodes at plane: n1,n2,n3
##	>>> ndir_of_three_points_plane(n1,n2,n3,n4)
##	(0, 0, 1.0)
##	>>> ndir_of_three_points_plane(n2,n3,n1,n4)
##	(0, 0, 1.0)
##	>>>

	if type_of(loc1) == 'nodes':
		loc1 = loc1.coordinates
	elif type_of(loc1) == 'vertices':
		loc1 = loc1.pointOn[0]

	if is_location(loc1) == False:
		raise Exception('*** loc1 is required.')

	if type_of(loc2) == 'nodes':
		loc2 = loc2.coordinates
	elif type_of(loc2) == 'vertices':
		loc2 = loc2.pointOn[0]

	if is_location(loc2) == False:
		raise Exception('*** loc2 is required.')

	if type_of(loc3) == 'nodes':
		loc3 = loc3.coordinates
	elif type_of(loc3) == 'vertices':
		loc3 = loc3.pointOn[0]

	if is_location(loc3) == False:
		raise Exception('*** loc3 is required.')

	if type_of(reference) == 'nodes':
		reference = reference.coordinates
	elif type_of(reference) == 'vertices':
		reference = reference.pointOn[0]

	x1,y1,z1 = loc1
	x2,y2,z2 = loc2
	x3,y3,z3 = loc3

	## 叉积
	ax,ay,az = x2-x1,y2-y1,z2-z1
	bx,by,bz = x3-x1,y3-y1,z3-z1
	coeff_i = ay*bz - az*by
	coeff_j = az*bx - ax*bz
	coeff_k = ax*by - ay*bx

	vector = coeff_i,coeff_j,coeff_k
	vector = normalized_vector(vector)

	if is_location(reference):
		x0,y0,z0 = reference
		xc,yc,zc = (x1+x2+x3)/3,(y1+y2+y3)/3,(z1+z2+z3)/3

		vector1 = (xc-x0,yc-y0,zc-z0)
		vector1 = normalized_vector(vector1)
		sign = vector[0]*vector1[0] + vector[1]*vector1[1] + vector[2]*vector1[2]  ## 内积

		if sign < -1e-6:
			vector = -coeff_i,-coeff_j,-coeff_k

	return vector  ## normalized vector

def normalized_vector(vector):
	## VER: 2016-11-21, v1.1

##	>>> normalized_vector((0,-1,0))
##	(0, -1.0, 0)

##	>>> normalized_vector((5,0,0))
##	(1.0, 0, 0)
##	>>> normalized_vector((5,5,0))
##	(0.7071068, 0.7071068, 0)
##	>>> normalized_vector((5,5,1))
##	(0.70014, 0.70014, 0.140028)
##	>>>

	if is_location(vector):
		if len(vector) == 3:
			coeff_i,coeff_j,coeff_k = vector
		elif len(vector) == 2:
			coeff_i,coeff_j = vector; 	coeff_k = 0

		length = sqrt(vector[0]*vector[0] + vector[1]*vector[1] + vector[2]*vector[2])
		vector = coeff_i/length, coeff_j/length, coeff_k/length
		vector = round_loc(vector,num=8)   ## 不要round，角度可能会有误差
	else:
		raise Exception('*** a location type vector is required.')

##	if vector == (0,-1,0):
##		vector = (0,1,0)
##	elif vector == (-1,0,0):
##		vector = (1,0,0)

	return vector

def normal_sides_of_datum_plane(datum_plane):
	## VER: 2014-01-13, v1.0

	## results such as: ['-x', '+y', '+z']

	if type_of(datum_plane) != 'DATUMPLANE':
		raise Exception('*** datum plane is required.')

	x0,y0,z0 = datum_plane.normal
	normal_sides = []
	if x0 > 0:
		normal_sides.append('+x')
	elif x0 < 0:
		normal_sides.append('-x')
	else:
		normal_sides.append('x')   ## parallel to x

	if y0 > 0:
		normal_sides.append('+y')
	elif y0 < 0:
		normal_sides.append('-y')
	else:
		normal_sides.append('y')   ## parallel to y

	if z0 > 0:
		normal_sides.append('+z')
	elif z0 < 0:
		normal_sides.append('-z')
	else:
		normal_sides.append('z')	## parallel to z

	return normal_sides


def bias_cut_sketch(sketch,x=None,y=None,side='+',connect=False):
	## VER: 2013-11-03, v1.2
	## for example: bias_cut_sketch('s_pressed',x=punch_D/2,side='+')

	sketch = check_sketch(sketch)
	curves = []

	if x in empty and y in empty:
		raise Exception('*** x or y is required.')

	if x not in empty:

		x = real_xy_sketch(sketch,x=x,Xonly=True)
		divide_geometry(sketch,x=x)

		for curve in all_regular_geometry(sketch):
			sign = PK(curve.pointOn[0],x)
			if side == '+' and sign == '>':
				curves.append(curve)
			elif side == '-' and sign == '<':
				curves.append(curve)

	elif y not in empty:
		y = real_xy_sketch(sketch,y=y,Yonly=True)
		divide_geometry(sketch,y=y)

		for curve in all_regular_geometry(sketch):
			sign = PK(curve.pointOn[1],y)
			if side == '+' and sign == '>':
				curves.append(curve)
			elif side == '-' and sign == '<':
				curves.append(curve)

	if curves not in empty:
		del_sketch_objs(sketch,objs=curves)

	if connect == True:
		if x not in empty:
##			print fnln_fnln(),'-----',type_of(sketch)
			locs = points_at_geometry_y(sketch=sketch,x=x)
		else:
			locs = points_at_geometry_x(sketch=sketch,y=y)

		if len(locs) > 1:
			connect_points(sketch,locs)

	return


def bias_seed_edges(part,edges,ratio=2,enum=3,single_dir=True, dense_dir='', flip=None):
	## VER: 2015-10-08, v1.2
	## (在粉末压制方向上不要使用bias_seed，否则可能会使网格变形很大。) (即只bias加密die附近的区域）
	## 对于单条edge，鼠标点击那一端会被加密。但是，这不会反馈到脚本。

	part = check_part(part)
	if type_of(edges) == 'STR':
		edges = set2objs(part,edges)
	edges = tolist(edges)
	sequence = list2sequence(part,edges=edges)
	print 'sequence=',sequence
	print type_of(sequence)

	if single_dir == False:
		bias = DOUBLE
	else:
		bias = SINGLE

	if bias == DOUBLE:
		if flip == False:
			part.seedEdgeByBias(biasMethod=bias, endEdges=sequence,ratio=ratio,number=enum + 1, constraint=FINER)   ## dense at ends
		else:
			part.seedEdgeByBias(biasMethod=bias, centerEdges=sequence,ratio=ratio,number=enum + 1, constraint=FINER)  ## dense at center

		return

	else:
		if dense_dir in empty:
			if flip == False:
				part.seedEdgeByBias(biasMethod=bias, end1Edges=sequence,ratio=ratio,number=enum + 1, constraint=FINER)
			else:
				part.seedEdgeByBias(biasMethod=bias, end2Edges=sequence,ratio=ratio,number=enum + 1, constraint=FINER)

			if bias == DOUBLE:
				return

		else:
			dense_dir = dense_dir.lower()

			if dense_dir[0] not in ['+','-']:
				dense_dir = '+' + dense_dir
			if dense_dir not in ['+x','-x','+y','-y','+z','-z']:
				raise Exception('*** Error vector direction, should be +x, -x, +y, -y, +z, or -z.')

	##		print fnln(),'dense_dir=',dense_dir
	##		print fnln(),'edges=',edges

			if dense_dir[0] == '+':
				for edge in edges:
					seq = obj2sequence(edge)
					dir1 = edge_dir_ends(edge,axis=dense_dir[1])
					if dir1 == REVERSE:
						part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
					else:
						part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
			elif dense_dir[0] == '-':
				for edge in edges:
					seq = obj2sequence(edge)
					dir1 = edge_dir_ends(edge,axis=dense_dir[1])
					print fnln(),'dir1=',dir1
					if dir1 == FORWARD:
						part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
					else:
						part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)

	##			stop1()
	##		elif dense_dir == '+y':
	##			for edge in edges:
	##				seq = obj2sequence(edge)
	##				dir1 = edge_dir_ends(edge,axis='y')
	##				if dir1 == FORWARD:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
	##				else:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
	##		elif dense_dir == '-y':
	##			for edge in edges:
	##				seq = obj2sequence(edge)
	##				dir1 = edge_dir_ends(edge,axis='y')
	##				if dir1 == REVERSE:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
	##				else:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
	##		elif dense_dir == '+z':
	##			for edge in edges:
	##				seq = obj2sequence(edge)
	##				dir1 = edge_dir_ends(edge,axis='z')
	##				if dir1 == FORWARD:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
	##				else:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
	##		elif dense_dir == '-z':
	##			for edge in edges:
	##				seq = obj2sequence(edge)
	##				dir1 = edge_dir_ends(edge,axis='z')
	##				if dir1 == REVERSE:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)
	##				else:
	##					part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=seq,ratio=ratio,number=enum + 1, constraint=FINER)


	return

def bit2KB(size):
	## VER: 2012-05-24, v1.0

	if type_of(size) not in numerics:
		raise Exception('**** file size is required.')

	KB = round(size/1024,1)

	return KB

def bit2MB(size):
	## VER: 2012-05-24, v1.0

	if type_of(size) not in numerics:
		raise Exception('**** file size is required.')

	MB = round(size/(1024*1024),1)

	return MB

def num2dir(num):
	## 2010-05-08

	dir = 'error_axis'
	if num == 0:
		dir = 'x'
	elif num == 1:
		dir = 'y'
	elif num == 2:
		dir = 'z'

	return dir

def new_points_of_sketch(sketch,locs0=()):
	## VER: 2015-04-20, v1.0
	## reference: new_geometry_of_sketch()

	sketch = check_sketch(sketch)

	if len(locs0) > 0:
		if is_location(locs0):
			locs0 = totable(locs0)

		if is_location(locs0[0]) == False:
			raise Exception('*** a tuple of locations is required.')

##	print fnln(),'locs0=',locs0
	locs1 = locs_of_sketch_vertices(sketch)
##	print fnln(),'locs0=',locs0
##	print fnln(),'locs1=',locs1

	locs1 = loc_unselect(locs1, locs0)
##	print fnln(),'locs1=',locs1

##	print fnln(),'--->There are', len(locs1),'new vertices.'

	return locs1

function_labels['var_print'] = 'var','print','txt','data','variable','output','data','write','file','line'
def var_print(file1,str1,space=None,value=None):
	## VER: 2017-08-15, v1.0
	## space: 字符串space的宽度，用于进行str1.ljust(space)处理，即固定宽度输出。（非等号输出形式）
	## space=value=None时，为等号输出形式，即：变量名=值

##	>>> vol1 = 'abcd'
##	>>> var_print('_test.txt',vol1)     ## vol1 = 'abcd'
##	>>> vol1 = 999
##	>>> var_print('_test.txt',vol1)     ## vol1 = 999
##	>>> var_print('_test.txt',vol1,5)	## vol1  999

	if type_of(file1) not in ['STR','FILE']:
		raise Exception('*** file name is required.')

	code = get_caller_code()
	loc = code.find(',')
	if loc == -1:
		return
	else:
		code = code[loc+1:]

	loc = code.find(',')
	if loc == -1:
		loc = code.rfind(')')
		var = code[:loc].strip()
	else:
		var = code[:loc].strip()
	if var[0] in ["'",'"']:
		var = var[1:-1]

	if space == value == None:  ## 等号输出形式
		if type_of(str1) == 'STR':
			line_print(file1,var,'=',repr(str1))
		else:
			line_print(file1,var,'=',str1)

	elif type_of(space) == 'INT':  ## 非等号输出，即格式化输出形式
		if space > 0:
			if value != None:
				line_print(file1,str1.ljust(space),value)
			else:
				line_print(file1,var.ljust(space),str1)

	return

def var_to_refinement_position(main_var='',sub_var=''):
	## VER: 2014-03-24, v1.0

	vars = odb_variables()

	if main_var in empty:
		raise Exception('*** main var is required.')
	elif main_var not in vars.keys():
		raise Exception('*** main_var is not in the main_var list.')

	position = vars[main_var]['position']

	if sub_var in empty:
		if vars[main_var]['components'] in empty and vars[main_var]['invariants'] in empty:
			refinement = None
		else:
			raise Exception('*** sub_var is required.')
	else:
		if sub_var in vars[main_var]['components']:
			refinement = (COMPONENT,sub_var)
		elif sub_var in vars[main_var]['invariants']:
			refinement = (INVARIANT,sub_var)
		else:
			print fnln(),'sub_var=',sub_var
			raise Exception('*** Incorrect sub_var=' + sub_var)

	vpnow = get_vpnow()
	plot_state = vpnow.odbDisplay.display.plotState[0]

	results = {'main':main_var, 'position':position, 'refinement':refinement,'plot_state':plot_state}

	return results

def nodal_values_vs_time(*labels):
	## VER: 2014-12-16, v1.4
	## Example: nodal_values_vs_time('compound_A1',[2, 53])  ## to get the coordinates
	## 读取速度很快，即使odb文件很大。

##odb = session.odbs['E:/FEM/A0229/AA_A0229_HPHT_anvil_crack_A_final.odb']
##xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
##    'U', NODAL, ((COMPONENT, 'U2'), )), ), nodeLabels=(('BLANK_A1', ('10', '100', )), ))

	## Example: nodal_values_vs_time(12163, 6520)

##	>>> nodal_values_vs_time(('ANVIL_A1',15419),('BLANK_A1',801))
##	['nodal_values_vs_time', 102] main= U
##	['nodal_values_vs_time', 103] refinement= (COMPONENT, 'U2')
##	['nodal_values_vs_time', 104] position= NODAL
##	['nodal_values_vs_time', 105] nodes= (('BLANK_A1', ('801',)), ('ANVIL_A1', ('15419',)))
##	>>>

##	>>> nodal_values_vs_time('BLANK_A1',[10,100])
##	['nodal_values_vs_time', 102] main= U
##	['nodal_values_vs_time', 103] refinement= (COMPONENT, 'U2')
##	['nodal_values_vs_time', 104] position= NODAL
##	['nodal_values_vs_time', 105] nodes= (('BLANK_A1', ('10', '100')),)
##	>>>

	plot_state = get_plot_state()
	if plot_state != CONTOURS_ON_DEF:
		raise Exception('*** a contour viewport is required.')

	setting = current_variable_setting()
	main = setting['main']
	sub = setting['sub']
	position = setting['position']
	refinement = setting['refinement']
	variable = setting['variable']

	if position != NODAL:
		raise Exception('*** value position not at nodal, please use contour_values_vs_time() or element_values_vs_time() instead.')

	axis2_title = main
	if sub not in empty:
		axis2_title = main + ', ' + sub

	labels = tolist(labels)	##

	nodes = []
	if len(labels) > 0:
		if is_numbers(labels):
			insts = objs_of_dg()
			if len(insts) == 1 and insts[0] in oa.instances.keys():
				inst=insts[0]
				for number in labels:
					nodes.append([inst,number])
			else:
				raise Exception('*** There are more than one instances displayed, please specify the instance name with nodes label.')
		else:
			if len(labels) == 2:
				if type_of(labels[0]) == 'STR' and is_numbers(labels[1]):
					labels = ((labels[0],labels[1]),)

			for label0 in labels:
				if _len(label0) == 2:
					inst,label = label0
					if is_STR(inst):
						inst = inst.upper()

					if inst in oa.instances.keys():
						if is_INT(label):
							nodes.append((inst,str(label)))
						elif type_of(label) in ['TUPLE','LIST']:
							for num in label:
								if is_INT(num):
									nodes.append((inst,str(num)))

	if nodes not in empty:
		nodes = totable(nodes)

##	print fnln(),nodes

	nodes1 = {}
	for node in nodes:
		inst,label = node
		if inst not in nodes1.keys():
			nodes1[inst] = []
		label = tolist(label)
		nodes1[inst] = nodes1[inst] + label

##	print fnln(),nodes1

	for inst in nodes1.keys():
		nodes1[inst] = totuple(nodes1[inst])

	nodes = tuple(nodes1.items())
	print fnln(),'nodes=',nodes

##	xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((main, position, (refinement, )), ), nodeLabels=nodes)
	xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=variable, nodeLabels=nodes)

	xyp = check_xyplot('xyplot-1')
	chartName = xyp.charts.keys()[0]
	chart = xyp.charts[chartName]
	curveList = session.curveSet(xyData=xyList)
	chart.setValues(curvesToPlot=curveList)

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=xyp)

## GUI:
##>>> chart = session.charts.values()[-1]
##>>> axis_data = chart.axes2[0].axisData

	chart = get_current_chart()
	update_axis2(chart,axis2_title)
	refresh()

	save_image()

	return

function_labels['node_coords_to_profile'] = 'flatness','straightness','insert','coords','angle','xyplot','xydata','file'
def node_coords_to_profile(nodes,axis='xy',filename='_coords_nodes.txt',sort=True,left=None,right=None,factor=1,relative=True):
	## VER: 2017-06-12, v1.2, left: 左侧第几个点(default=0)，right:右侧第几个点(default=-1)

##	node_coords_to_profile(nodes1,axis='xy',factor=-1)	## 曲线倒个，最小变最大，最大变最小。

##	nodes = set2objs(p1,'side1')
##	nodes1 = node_select(p1,nodes=nodes,z=MID,err=0.1)
##	>>> node_coords_to_profile(nodes1,axis='yx',filename='_side1')
##	--->Coordinates of nodes has been written to Z:/A0282 new triangle verify/sinter/results/_side1.txt
##	TUPLE has been printed to file Z:/A0282 new triangle verify/sinter/results/_list1.txt
##	values: min= 6.33581 , max= 6.358394 , gap= 0.022584
##	>>>

	coords = cae_coords_of_nodes(nodes=nodes,axis=axis,filename='',sort=sort,factor=factor)
	coords = rotate_profile(coords,left=left,right=right,relative=relative,filename=filename)

	return coords

function_labels['node_line'] = 'PV','suntech','thick line','sketch','drawing','pen','frame'
def node_line(part,edir=None,ndir=None, x=None,y=None,z=None,dx=0,dy=0,dz=0,thx=None,thy=None,thz=None,mat=None,addRP=True):
	## VER: ('VER: 2012-09-06, v1.1') 相当于画粗线条thick line
	## edir就是粗线条的edge dir

	global line_thick

	part = check_part(part)

	if [x,y,z].count(None) == 2:
		if x not in empty:
			edir = 'x'
		elif y not in empty:
			edir = 'y'
		elif z not in empty:
			edir = 'z'

	if (thx,thy,thz) == (None,None,None):
		if type_of(ndir) == 'STR' and ndir[-1] in ['x','y','z']:
			if ndir in ['x','y','z']:
				ndir = '+' + ndir

			if ndir == '+x':
				thx = line_thick
			elif ndir == '-x':
				thx = -line_thick
			elif ndir == '+y':
				thy = line_thick
			elif ndir == '-y':
				thy = -line_thick
			elif ndir == '+z':
				thz = line_thick
			elif ndir == '-z':
				thz = -line_thick

	if [thx,thy,thz].count(None) != 2:
		raise Exception('one of thx, thy, or thz is required.')

	if thx not in empty:
		x = (0, thx)
		line_thick = abs(thx)
	elif thy not in empty:
		y = (0, thy)
		line_thick = abs(thy)
	elif thz not in empty:
		z = (0, thz)
		line_thick = abs(thz)

	x1,x2,y1,y2,z1,z2 = real_space(part,x,y,z,dx=dx,dy=dy,dz=dz,addRP=addRP)

	print 'edir=',edir
	print 'line_thick=',line_thick

	if edir == 'x':
		if thy not in empty:
			near_y = (y1 + y2)/2
			near_z = z1
		elif thz not in empty:
			near_z = (z1 + z2)/2
			near_y = y1

		face = part.faces.findAt((x2 + _nearby, near_y, near_z), printWarning=False)
		if type_of(face) == 'faces':
			info = rect_face_info(face)
			if info['isRect'] == True and info['width_dir'] == 'x':
				near_x = x2 + info['width']
				edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
				if type_of(edge) == 'edges':
					x2 = near_x
		else:
			face = part.faces.findAt((x2 + line_thick + _nearby, near_y, near_z), printWarning=False)
			if type_of(face) == 'faces':
				info = rect_face_info(face)
				if info['isRect'] == True and info['width_dir'] == 'x':
					near_x = x2 + line_thick + info['width']
					edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
					if type_of(edge) == 'edges':
						x2 = near_x

		face = part.faces.findAt((x1 - _nearby, near_y, near_z), printWarning=False)
		if type_of(face) == 'faces':
			info = rect_face_info(face)
			if info['isRect'] == True and info['width_dir'] == 'x':
				near_x = x1 - info['width']
				edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
				if type_of(edge) == 'edges':
					x1 = near_x
		else:
			face = part.faces.findAt((x1 - line_thick - _nearby, near_y, near_z), printWarning=False)
			if type_of(face) == 'faces':
				info = rect_face_info(face)
				if info['isRect'] == True and info['width_dir'] == 'x':
					near_x = x1 - line_thick - info['width']
					edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
					if type_of(edge) == 'edges':
						x1 = near_x

	elif edir == 'y':
		if thx not in empty:
			near_x = (x1 + x2)/2
			near_z = z1
		elif thz not in empty:
			near_z = (z1 + z2)/2
			near_x = x1

		face = part.faces.findAt((near_x, y2 + _nearby, near_z), printWarning=False)
		if type_of(face) == 'faces':
			info = rect_face_info(face)
			if info['isRect'] == True and info['width_dir'] == 'y':
				near_y = y2 + info['width']
				edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
				if type_of(edge) == 'edges':
					y2 = near_y
		else:
			face = part.faces.findAt((near_x, y2 + line_thick + _nearby, near_z), printWarning=False)
			if type_of(face) == 'faces':
				info = rect_face_info(face)
				if info['isRect'] == True and info['width_dir'] == 'y':
					near_y = y2 + line_thick + info['width']
					edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
					if type_of(edge) == 'edges':
						y2 = near_y

		face = part.faces.findAt((near_x, y1 - _nearby, near_z), printWarning=False)
		if type_of(face) == 'faces':
			info = rect_face_info(face)
			if info['isRect'] == True and info['width_dir'] == 'y':
				near_y = y1 - info['width']
				edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
				if type_of(edge) == 'edges':
					y1 = near_y
		else:
			face = part.faces.findAt((near_x, y1 - line_thick - _nearby, near_z), printWarning=False)
			if type_of(face) == 'faces':
				info = rect_face_info(face)
				if info['isRect'] == True and info['width_dir'] == 'y':
					near_y = y1 - line_thick - info['width']
					edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
					if type_of(edge) == 'edges':
						y1 = near_y

	elif edir == 'z':
		if thx not in empty:
			near_x = (x1 + x2)/2
			near_y = y1
		elif thy not in empty:
			near_y = (y1 + y2)/2
			near_x = x1

		face = part.faces.findAt((near_x, near_y, z2 + _nearby), printWarning=False)
		if type_of(face) == 'faces':
			info = rect_face_info(face)
			if info['isRect'] == True and info['width_dir'] == 'z':
				near_z = z2 + info['width']
				edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
				if type_of(edge) == 'edges':
					z2 = near_z
		else:
			face = part.faces.findAt((near_x, near_y, z2 + line_thick + _nearby), printWarning=False)
			if type_of(face) == 'faces':
				info = rect_face_info(face)
				if info['isRect'] == True and info['width_dir'] == 'z':
					near_z = z2 + line_thick + info['width']
					edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
					if type_of(edge) == 'edges':
						z2 = near_z

		face = part.faces.findAt((near_x, near_y, z1 - _nearby), printWarning=False)
		if type_of(face) == 'faces':
			info = rect_face_info(face)
			if info['isRect'] == True and info['width_dir'] == 'z':
				near_z = z1 - info['width']
				edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
				if type_of(edge) == 'edges':
					z1 = near_z
		else:
			face = part.faces.findAt((near_x, near_y, z1 - line_thick - _nearby), printWarning=False)
			if type_of(face) == 'faces':
				info = rect_face_info(face)
				if info['isRect'] == True and info['width_dir'] == 'z':
					near_z = z1 - line_thick - info['width']
					edge = part.edges.findAt((near_x,near_y,near_z),printWarning = False)
					if type_of(edge) == 'edges':
						z1 = near_z

	x = x1,x2
	y = y1,y2
	z = z1,z2
	print fnln_fnln(),'x,y,z=',x,y,z

	create_block(part,x=x,y=y,z=z,mat=mat,addRP=False)

	return

def node_region_contact(mnodes,snodes,action='interact',prop='Frictionless',step='step1'):
	## VER: 2013-06-04, v1.0

	action = action.lower()
	if action == 'interaction':
		action = 'interact'

	if type_of(mnodes) == 'DICT':
		mnodes = labels_dict_to_nodes(mnodes)

	if type_of(snodes) == 'DICT':
		snodes = labels_dict_to_nodes(snodes)

	mregion = list2region(mnodes, region_type='set')
	sregion = list2region(snodes, region_type='set')

	master_inst = get_poi(mnodes[0]).name
	slave_inst = get_poi(snodes[0]).name

	caller_lineno = str(fnln_fnln()[1])
	if action == 'interact':
		seq = get_SN(_m.interactions,3)
		act = '_int_'

		if prop == 'Frictionless':
			fric = '_nof_'
		else:
			fric = '_hasf_'

	elif action == 'tie':
		seq = get_SN(_m.constraints)
		act = '_tie_'
		fric = '_'

	name = master_inst + '//' + slave_inst + '(s)'
	name = '_' + seq + act + name + fric + caller_lineno

	if action == 'interact':
		name = new_key(_m.interactions,name)
		raise Exception

	elif action == 'tie':
		name = new_key(_m.constraints,name)
		_m.Tie(name=name, master=mregion, slave=sregion, positionToleranceMethod=COMPUTED, adjust=ON, tieRotations=ON, thickness=ON)

	return name

def node_select(p,x=(),y=(),z=(), poiRefX=(), poiRefY=(),poiRefZ=(), PRx=None,PRy=None,PRz=None, space=(),
	elements=None, edges=None, faces=None, GRx=None,GRy=None,GRz=None, Gx=None,Gy=None,Gz=None,nodes=None,
	groupX=None, groupY=None, groupZ=None, groupRefX=None, groupRefY=None, groupRefZ=None, endX=None,
	endY=None,endZ=None,include_mid_points=False, exterior=True,err=0.1):
	## nodes 的再次选择，在CAE界面上：方法-建立这些nodes的set，然后tools-set-Edit该set，这些节点将被点亮。此时按住Ctrl键+鼠标左键框选去除部分高亮的节点。或按Shift键+鼠标左键增加新的节点。

	## VER: ('VER: 2016-11-15, v3.0')
	## 选择nodes之后，可以用light(nodes)高亮。
	## You can display only node by: show node label in CAE or show node symbol in odb. Then you can reselect the nodes in GUI and replace.

	## nodex1 = node_select(p1,x=0,err=0.3,y=(MID,MAX),groupY=(MID,MIN))  ## 此时groupY相当于在Y方向上进行二次筛选,相当于group 范围内的Y。而第一个y为整个part内

	## nodes3 = node_select(p1,nodes=nodes,endX=MIN)  ## will only select one node with x=min

##	>>> nodes3 = node_select(p,x=MAX)
##	---> 961 nodes are selected by box_select().
##	---> 9 nodes are selected by node_select().
##	>>> nodes2 = box_select(p.nodes,x=MAX)
##	---> 961 nodes are selected by box_select().
##	>>>

##	nodes = node_select('green',z=0,err=0.2)   ## middle of green part in height

##	nodes = node_select(anvil_A1,x=0,z=0,exterior=False) + node_select(blank_A1,x=0,z=0,y=(MIN1,MAX),exterior=False)
##	apply_disp_fix('fix_center',nodes=nodes, Ux=0,Uz=0,step='step1',deactive_step='step4')

	## Example:
	## nodes = node_select1(powder,y=MAX)
	##
	## nodes = node_select(powder3,x=(MIN1,MAX1),y=(MID,MIN))
	## 虽然给了一个很宽的范围，但是因为只选外部节点，所以没关系。x=(MIN1,MAX1)保证获得的face都是一侧的。

	## Example:
##	nodes = node_select(powder)  将选择powder的所有外围节点。

##	>>> nodes = node_select(powder,poiRefX=(MAX,-0.5))  ## 选择一个 ] 型的节点区域，且为外围节点。
##	>>> nodes = node_select('green',z=MIN)

	if Gx not in empty:
		groupX = Gx
	if Gy not in empty:
		groupY = Gy
	if Gz not in empty:
		groupZ = Gz

	if GRx not in empty:
		groupRefX = GRx
	if GRy not in empty:
		groupRefY = GRy
	if GRz not in empty:
		groupRefZ = GRz

	if PRx not in empty:
		poiRefX = PRx
	if PRy not in empty:
		poiRefY = PRy
	if PRz not in empty:
		poiRefZ = PRz

	thens = (groupX, groupY, groupZ, groupRefX, groupRefY, groupRefZ)
	if thens != (None,None,None,None,None,None):
		have_then = True
	else:
		have_then = False

	p = check_poi(p)
	x,y,z = real_xyz(p,x,y,z,space=space,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ)
	x1,x2,y1,y2,z1,z2 = tospace(x,y,z)
	x10,x20,y10,y20,z10,z20 = poi_space(p)

	x0,y0,z0 = x,y,z
	if type_of(x0) in numerics:
		if abs(x0 - x10) < 1e-3:
			x0 = MIN
		elif abs(x0 - x20) < 1e-3:
			x0 = MAX

	if type_of(z0) in numerics:
		if abs(z0 - z10) < 1e-3:
			z0 = MIN
		elif abs(z0 - z20) < 1e-3:
			z0 = MAX

	if type_of(y0) in numerics:
		if abs(y0 - y10) < 1e-3:
			y0 = MIN
		elif abs(y0 - y20) < 1e-3:
			y0 = MAX

	if edges not in empty:
		nodes1 = []
		for edge in edges:
			nodes0 = edge.getNodes()
			if nodes0 not in empty:
				nodes0 = tolist(nodes0)
				nodes1 = nodes1 + nodes0

		if nodes1 not in empty:
			nodes1 = remove_repeated_items(nodes1)
			nodes = nodes1

	if faces not in empty:
		nodes1 = []
		for face in faces:
			nodes0 = face.getNodes()
			if nodes0 not in empty:
				nodes0 = tolist(nodes0)
				nodes1 = nodes1 + nodes0

		if nodes1 not in empty:
			nodes1 = remove_repeated_items(nodes1)
			nodes = nodes1

	if nodes in empty:
		nodes = p.nodes

	nodes = tolist(nodes)
	selected = False
	if err > 0:
		nodes = box_select(nodes,x=(x1,x2),y=(y1,y2),z=(z1,z2),err=err)
		selected = True

##	light(nodes)
##	raise Exception

	if exterior == True:
		nodes = exterior_nodes(nodes)

	if selected == False:
		mynodes = []
		for node in nodes:   ## 检查时，针对某个节点，看能否选上该节点。
			ptCoords = node.coordinates
	##		print ptCoords
			if meet_search_range(ptCoords[0],(x1,x2),include_ends=True):
				if meet_search_range(ptCoords[1],(y1,y2),include_ends=True):
					if meet_search_range(ptCoords[2],(z1,z2),include_ends=True):
	##					print 'meet'
						if node not in mynodes:
							mynodes.append(node)

	else:
		mynodes = nodes

	if mynodes in empty:
		print fnln(),'*** No node selected. Please try box_select() instead.'

	mynodes0 = mynodes
	mynodes1 = []
##	print fnln(), len(mynodes)

	if mynodes not in empty and have_then: ## Try1 for groupX,groupY,groupZ
		space = objs_space(mynodes)
		if groupX not in empty:
			groupX = real_xyz_in_space(space,x=groupX)
			mynodes1 = node_select(p=p, nodes=mynodes, x=groupX,err=err)
		elif groupY not in empty:
			groupY = real_xyz_in_space(space,y=groupY)
			mynodes1 = node_select(p=p, nodes=mynodes, y=groupY,err=err)
		elif groupZ not in empty:
			groupZ = real_xyz_in_space(space, z=groupZ)
			mynodes1 = node_select(p=p, nodes=mynodes, z=groupZ,err=err)

		elif groupRefX not in empty:
			groupX = real_xyz_in_space(space,ref_x=groupRefX)
			mynodes1 = node_select(p=p, nodes=mynodes, x=groupX,err=err)
		elif groupRefY not in empty:
			groupY = real_xyz_in_space(space,ref_y=groupRefY)
			mynodes1 = node_select(p=p, nodes=mynodes, y=groupY,err=err)
		elif groupRefZ not in empty:
			groupZ = real_xyz_in_space(space, ref_z=groupRefZ)
			mynodes1 = node_select(p=p, nodes=mynodes, z=groupZ,err=err)

		changing
		if mynodes1 not in empty:  ## successfuly refined, mynodes0 will be updated.
			mynodes0 = mynodes1

		## Fail to update, Try2 for groupX,groupY,groupZ, change them to endX, endY, endZ
		else:
			if groupX in [MIN,MAX] and endX in empty:
				endX = groupX
				endY = None
				endZ = None
			elif groupY in [MIN,MAX] and endY in empty:
				endY = groupY
				endX = None
				endZ = None
			elif groupZ in [MIN,MAX] and endZ in empty:
				endZ = groupZ
				endX = None
				endY = None

	mynodes = mynodes0
	if mynodes0 not in empty and len(mynodes0) > 1 and (endX not in empty or endY not in empty or endZ not in empty):
		if endX == MIN:
			dict1 = nodes_dict_byx(mynodes0)
			loc = min(dict1.keys())
			mynodes2 = dict1[loc]
		elif endX == MAX:
			dict1 = nodes_dict_byx(mynodes0)
			loc = max(dict1.keys())
			mynodes2 = dict1[loc]

		elif endY == MIN:
			dict1 = nodes_dict_byy(mynodes0)
			loc = min(dict1.keys())
			mynodes2 = dict1[loc]
		elif endY == MAX:
			dict1 = nodes_dict_byy(mynodes0)
			loc = max(dict1.keys())
			mynodes2 = dict1[loc]

		elif endZ == MIN:
			dict1 = nodes_dict_byz(mynodes0)
			loc = min(dict1.keys())
			mynodes2 = dict1[loc]
		elif endZ == MAX:
			dict1 = nodes_dict_byz(mynodes0)
			loc = max(dict1.keys())
			mynodes2 = dict1[loc]
		else:
			raise Exception('*** Incorrect input of endX, endY, or endZ, should be MIN or MAX')

		mynodes = mynodes2

	if len(mynodes) == 0:
		print fnln_fnln(),'*** No node selected.'
	else:
		print fnln_fnln(),len(mynodes),'nodes are selected by node_select().'

	return mynodes

def edir_of_vector(vector):
	## VER: 2014-01-16, v1.2, for tilted axis, get the most dir

	if type_of(vector) == 'DATUMAXIS':
		x,y,z = vector.direction
	elif is_vector(vector) == True:
		x,y,z = vector
	else:
		raise Exception('*** a datum axis or a vector, such as normal of face, is required.')

	x,y,z = round6(x,y,z)

	dict1 = {'x':x, 'y':y, 'z':z}

	list1 = sort_by_value(dict1)   ## accending

	dir1,dir2,dir3 = list1

	## find most normal direction
	if PK(abs(dir1[1]),abs(dir3[1])) == '>':
		edir = '-' + dir1[0]
	else:
		if dir3[1] > 0:
			edir = '+' + dir3[0]
		else:
			edir = '-' + dir3[0]

	return edir

def elem_edge_facing(edge):
	## VER: 2014-10-19, v1.1

	if type_of(edge) != 'elemEdges':
		raise Exception('*** an element edge is required.')

	if len(edge.getElements()) > 1:
		raise Exception('*** exterior element edge is required.')

	poi = get_parent(edge)
	nodes = edge.getNodes()
	node1,node2 = nodes

	element = edge.getElements()[0]
	nodes1 = element.getNodes()
	nodes1 = unselect(nodes1, nodes)

	node = None
	for nd in nodes1:
		if is_in_line(node1, node2, nd) == False:
			node = nd
			break

	dirs = None
	if node not in empty:
		dirs = get_project_dirs(poi, point=node, point2=node1, point3 = node2)

	return dirs

function_labels['element_center'] = 'centroid','normal vector'
def element_center(elem):
	## VER: 2015-05-20, v1.0

	if type_of(elem) != 'elements':
		raise Exception('*** An element is required.')

	nodes = elem.getNodes()
	x = 0
	y = 0
	z = 0
	for node in nodes:
		x1,y1,z1 = node.coordinates
		x = x + x1
		y = y + y1
		z = z + z1

	x = x/len(nodes)
	y = y/len(nodes)
	z = z/len(nodes)

	return x,y,z

def element_edge_select(poi, elements=None, edges=None, nx=None, ny=None, nz=None):
	## VER: 2014-10-20, v1.2

	poi = check_poi(poi)

	if _len(poi.elemEdges) == 0:
		return []

	if '3D' in part_shape(poi)[1]:
		raise Exception('*** only 2D model applicable.')

	if elements == edges == None:
		elements = poi.elements

	if elements not in empty:
		elements = tolist(elements)

		newlist = []
		for elem in elements:
			edges1 = exterior_edges_of_element(elem)
			newlist = newlist + edges1

		newlist = remove_repeated_items(newlist)
		edges = newlist

	edges = tolist(edges)

	if (nx,ny,nz) != (None,None,None):
		newlist = []
		for edge in edges:
			dirs = elem_edge_facing(edge)  ## no regenerate
##			print dirs
			nx1,ny1,nz1 = dirs
			if nx != None and nx1 != nx:
				continue
			if ny != None and ny1 != ny:
				continue
			if nz != None and nz1 != nz:
				continue
			newlist.append(edge)
		edges = newlist

	print '--->',len(edges),'exterior edges are selected, (nx,ny,nz)=',(nx,ny,nz)

	return edges

def element_all_face_nums(elem,select_sym=False):
	## VER: 2015-10-09, v1.0
	## reference: get_an_element_face()
	## 一维线性单元和3D模型中的shell部件用sideN, 其他二维和三维单元用faceN

	## Used for create_surface() from elements

##	>>> element_all_face_nums(elems[0])
##	['face1', 'face4']
##	>>>

	if type_of(elem) != 'elements':
		raise Exception('** An element is required.')

	edges0 = elem.getElemEdges()
	faces0 = elem.getElemFaces()

	faceN = []
	sideN = []

	if len(faces0) == 1:		## 2D model
		for i in range(len(edges0)):
			edge = edges0[i]
			faces1 = edge.getElemFaces()
			if len(faces1) == 1:
##				if i+1 == len(edges0) and select_sym == False:   ## 轴对称单元的轴对称边的face num=4(即单元有多少条边)
##					continue

				faceN.append('face'+str(i+1))

				ff0 = faces1[0]
				face = ff0.face   	## 对于2D模型，如果一个单元的面积不为0，则其裸露边的face num恒为FACE1
									## 对于3D模型，如果一个单元的体积不为0，则其裸露面的face num恒为FACE1
				if face not in sideN:
					sideN.append(face)

	elif len(faces0) > 1:   ## 3D model
		for i in range(len(faces0)):
			face = faces0[i]
			if len(face.getElements()) == 1:
				num = totext(face.face).lower()
				faceN.append(num)

	results = faceN
	if faceN in empty:
		results = ()

	return results

function_labels['element_face_select'] = 'surface','facenum'
def element_face_select(poi,elements=None,x=(),y=(),z=(),poiRefX=(), poiRefY=(),poiRefZ=(), space=(),
	nx=0,ny=0,nz=0,angle=10,err=1,err0=None):
	## VER: 2016-11-12, v1.0
	## reference: elements = seq.getByBoundingBox()   ## seq is a sequence of elements, such as _part(powder).elements[:]
	## 无法建立element faces的displayGroup，因此无法直接highlight()他们，一次只能highlight一个elementFace

	## element faces无法建立sequence?
##	>>> p1.elements[1]
##	mdb.models['Model-1'].parts['green_part'].elements[1]
##	>>> p1.elements[1:3]
##	mdb.models['Model-1'].parts['green_part'].elements[1:3]
##	>>> p1.elemFaces[1]
##	mdb.models['Model-1'].parts['green_part'].elemFaces[1]
##	>>> p1.elemFaces[1:3]
##	TypeError: Integer Expected as dictionary Type
##	>>>

##	>>> faces = element_face_select('odb_pocket',nx=1)
##	['element_face_select', 83] 390 element faces are found.
##	>>>
##	>>> surf1 = element_faces_to_surface(faces,name='s_pocket_OD')
##	--->Created element surface, name= s_pocket_OD , element faces= ['face4', 'face6']
##	>>>

##	faces = element_face_select('odb_pocket',y=MID,nx=1)

	poi = check_poi(poi)

	if elements in empty:
		elements = poi.elements[:]
	else:
		elements = tolist(elements)

##	print fnln(),'x,y,z=',x,y,z
##	x0,y0,z0 = x,y,z   ## 如果在real_xyz之前，指定了x,y,或z的具体值，那么需要进行精细化选择
##	if is_number(err0) == False:
##		err0 = 0.1		;please_check
##
##	refine = False
##	if is_number(x0):
##		x0 = x0-err0,x0+err0
##		refine = True
##
##	if is_number(y0):
##		y0 = y0-err0,y0+err0
##		refine = True
##
##	if is_number(z0):
##		z0 = z0-err0,z0+err0
##		refine = True

	if x == MID or y == MID or z == MID:
		err = max(err,2)

	x,y,z = real_xyz(poi,x,y,z,space=space,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ)
##	print fnln(),'x,y,z=',x,y,z

	if is_number(x):
		x = x-err,x+err
	if is_number(y):
		y = y-err,y+err
	if is_number(z):   ## such as z=MAX
		z = z-err,z+err

##	print fnln(),'err=',err
##	print fnln(),'so, x,y,z=',x,y,z
##	print fnln(),'angle=',angle

##	print fnln(),'x,y,z=',x,y,z

	if (nx,ny,nz) == (0,0,0):
		raise Exception('*** nx,ny,or nz is required.')

##	print fnln(),poiRefZ

	myelements = []
	if x in empty and y in empty and z in empty:
		myelements = elements
	else:
		myelements = element_select(poi,x=x,y=y,z=z,elements=elements)

	if myelements not in empty:
		myelements = exterior_elements(poi,myelements)

##	light(myelements)
##	raise Exception

##	nodes = []
##	elems = []
##	faces1 = []
##	if myelements not in empty:
##		shape = get_element_shape(myelements[0])
	faces1 = get_an_element_face(myelements,nx=nx,ny=ny,nz=nz,angle_err=angle)

	faces = []
	for face in faces1:
		faces2 = face.getElemFacesByFaceAngle(angle)
		faces = faces + tolist(faces2)
	faces = remove_repeated_items(faces)
##	if faces not in empty:
##		face0 = faces[0]
##		faces = face0.getElemFacesByFaceAngle(angle)
##		print fnln(),len(faces),'element faces are found.'
##	else:
##		print '*** No element face was found.'

	return faces

function_labels['element_faces_of_node'] = 'element surface','element face'
def element_faces_of_node(node,nodes=None,nx=None,ny=None,nz=None):
	## VER: 2016-11-30, v1.0

	if type_of(node) != 'nodes':
		raise Exception('*** One node is required.')

	faces = node.getElemFaces()
	newlist = []
	for face in faces:
		if len(face.getElements()) == 1:
			newlist.append(face)
	faces = newlist

	if (nx,ny,nz) != (None,None,None):
		newlist = []
		for face in faces:
			if meet_element_face_dir(face,nx=nx,ny=ny,nz=nz):
				newlist.append(face)
		faces = newlist

	return faces

def element_faces_to_nodes(faces):
	## VER: 2016-01-08, v1.0

##	elems = element_select('powder_A1',y=MAX)
##	faces = get_an_element_face(elems,ny=1)
##	nodes = element_faces_to_nodes(faces)
##	create_nodal_surface('powder_A1', nodes=nodes)

	faces = tolist(faces)
	if type_of(faces[0]) not in ['elemEdges','elemFaces']:
		raise Exception('*** element faces are required.')

	nodes = []
	for face in faces:
		nodes1 = face.getNodes()
		nodes1 = tolist(nodes1)
		nodes = nodes + nodes1

	nodes = remove_repeated_items(nodes)

	return nodes

function_labels['element_faces_to_surface'] = 'facenum'
def element_faces_to_surface(faces,name='surf',results='surface',printinfo=True):
	## VER: 2016-12-02, v1.3

##	>>> faces = element_face_select('odb_pocket',nx=1)
##	['element_face_select', 83] 390 element faces are found.
##	>>>
##	>>> surf1 = element_faces_to_surface(faces,name='s_pocket_OD')
##	--->Created element surface, name= s_pocket_OD , element faces= ['face4', 'face6']
##	>>>

##	>>> faces = element_face_select('odb_pocket',y=MIN,ny=-1)
##	---> 780 elements selected by element_select()
##	['element_face_select', 83] 780 element faces are found.
##	>>> surf1 = element_faces_to_surface(faces,name='s_pocket_bot')
##	--->Created element surface, name= s_pocket_bot , element faces= ['face3', 'face4', 'face5', 'face6']

	if type_of(faces) == 'STR':
		faces,name = name,faces

	faces = tolist(faces)
	if type_of(faces[0]) != 'elemFaces':
		raise Exception('*** element faces are required.')

	poi = get_poi(faces)
	if type_of(poi) == 'PINSTANCE':
		poi = a
	name = new_key(poi.surfaces.keys(),name)

	dict1 = {}
	for face1 in faces:
		if len(face1.getElements()) == 1:
			elem = face1.getElements()[0]
			facenum = face1.face
			facenum = totext(facenum).lower()

			if facenum not in dict1.keys():
				dict1[facenum] = []
			if elem not in dict1[facenum]:
				dict1[facenum].append(elem)

	for facenum in dict1.keys():
		elems = dict1[facenum]
		seq = list2sequence(elems)
		dict1[facenum] = seq

	if dict1 in empty:
		raise Exception('*** Empty element faces.')

	sides = []
	seqs = ''
	list1 = sort(dict1.keys())
	for i in range(len(list1)):
		facenum = list1[i]
		sides.append(facenum)
		seq = dict1[facenum]
		exec('seq' + str(i) + ' = seq')
		seqs = seqs + facenum + 'Elements= seq' + str(i) + ','

	exec('poi.Surface(' + seqs + 'name=name)')

	if sides not in empty:
		surface = poi.surfaces[name]
		if printinfo == True:
			print '--->Created element surface, name=',name,', element faces=',sides
	else:
		raise Exception('*** Fail to create the surface')

	if results == 'surface':
		res = surface
	else:
		res = (surface,dict1)

	return res

def element_ids_in_odb(inst):
	## VER: 2014-12-17, v1.0, id is not the label

	## Below method is wrong!!!
##	for element in oa.instances[set1].elements:
##		id = element.label
##		ids.append(id)

	step_name,frame,time1 = current_step_frame_time()
	stress = odb.steps[step_name].frames[frame].fieldOutputs['S'].values   ## integration point

	if inst in oa.instances.values():
		inst = inst.name

	if type_of(inst) == 'STR':
		inst = inst.upper()

	if inst not in oa.instances.keys():
		raise Exception('*** Error instance name.')

	ids = []
	num = len(oa.instances[inst].elements)
	for id in xrange(len(stress)):
		inst1 = stress[id].instance.name
		if inst1 == inst:
			ids.append(id)

		if len(ids) == num:
			break

	return ids

def elements_to_surface(elements,name='surf-1',select_sym=False,face='',fine_angle=30,axis='',rough_angle=70,by_fine=True):
	## VER: 2016-04-14, v1.3
	## reference: create_surface()

##	>>> elems = element_select('p1',x=MAX,nx=1)
##	['element_select', 49039] poiRefX= (10.680254, 9.180254)
##	---> 1600 elements selected by element_select()
##	>>> elements_to_surface(elems,axis='x')
##	['elements_to_surface', 243] ['face4', 'face5', 'face6', 'face3']
##	['elements_to_surface', 244] str1= p.Surface(face4Elements=face4,face5Elements=face5,face6Elements=face6,face3Elements=face3,name=name)
##	p.Surface(face4Elements=face4,face5Elements=face5,face6Elements=face6,face3Elements=face3,name=name)
##	surface name= surf-2
##
##	mdb.models['Model-1'].parts['p1'].surfaces['surf-2']
##	>>>

	## Example: 在界面框选一些单元，包含内部单元也没关系，生成set，然后如下：
##	>>> elems = set2objs('set2')
##	>>> elements_to_surface(elems)
##	p.Surface(face1Elements=face1,face2Elements=face2,name=name)
##	'surf-3'
##	>>>

	elements = tolist(elements)
	if elements in empty:
		raise Exception('*** No elements to create surface.')

	p = get_parent(elements[0])
	if type_of(p) == 'PINSTANCE':
		p = a

	name = new_key(p.surfaces.keys(),name)

	if type_of(elements) == 'DICT':
		dict2 = elements
	elif axis in ['x','y','z']:
		dict2 = elements_dict_by_face(elements,fine_angle=fine_angle,axis=axis,rough_angle=rough_angle,by_fine=by_fine)
	else:
		dict1 = {}
		for element in elements:
			faces = element_all_face_nums(element,select_sym=select_sym)
			if faces not in empty:
				for face0 in faces:
					if face0 not in dict1.keys():
						dict1[face0] = []
					dict1[face0].append(element)

		dict2 = {}
		for key in dict1.keys():
			seq = list2sequence(dict1[key])
			dict2[key] = seq

		if dict2 in empty:
			raise Exception('*** No external element surface')

	if 'face1' in dict2.keys():
		face1 = dict2['face1']
	if 'face2' in dict2.keys():
		face2 = dict2['face2']
	if 'face3' in dict2.keys():
		face3 = dict2['face3']
	if 'face4' in dict2.keys():
		face4 = dict2['face4']
	if 'face5' in dict2.keys():
		face5 = dict2['face5']
	if 'face6' in dict2.keys():
		face6 = dict2['face6']
	if 'face7' in dict2.keys():
		face7 = dict2['face7']
	if 'face8' in dict2.keys():
		face8 = dict2['face8']

	str1 = 'p.Surface('
	if face in empty:
		for key in dict2.keys():
			if key != 'total':
				str1 = str1 + key + 'Elements=' + key + ','
	else:
		if face in dict2.keys():
			str1 = str1 + face + 'Elements=' + face + ','
		else:
			raise Exception('***'+face+' do not in the faces list.')

	str1 = str1 + 'name=name)'
	print fnln(),dict2.keys()
	print fnln(),'str1=',str1

	exec(str1)

	print str1
	print 'surface name=',name
	print ' '

	return p.surfaces[name]

def elems_by_face(poi,elements=None,x=(),y=(),z=(),poiRefX=(), poiRefY=(),poiRefZ=(), space=(),
	nx=0,ny=0,nz=0,angle=10,err=1):
	## VER: 2015-06-17, v1.6

##	>>> elems = elems_by_face('p1',nz=-1,z=MIN)
##	---> 6248 elements selected by elems_nodes_by_face()
##	---> 6394 nodes selected by elems_nodes_by_face()

##	elems = elems_by_face(p1,x=0,y=0,z=MAX,angle=5,nz=1)  ## x=0,y=0,用于确定种子单元，随后根据angle获得其他相邻面。

	poi = check_poi(poi)
	elems,nodes = elems_nodes_by_face(poi=poi,elements=elements,x=x,y=y,z=z,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ,
		space=space,nx=nx,ny=ny,nz=nz,angle=angle,err=err)

	return elems

function_labels['node_select_by_feature_angle'] = 'feature edge','hole','fix','insert','angle'
def node_select_by_feature_angle(p1,axis='z',end=MIN):
	## VER: 2017-06-06, v1.0
	## feature: edge

	## nodes = node_select_by_feature_angle(p1)

	p1 = check_poi(p1)
	axis = axis.lower()

	nodes = []
	if axis == 'z':
		nodes = nodes_by_face(p1,zend=end,angle=10)
	elif axis == 'y':
		nodes = nodes_by_face(p1,yend=end,angle=10)
	elif axis == 'x':
		nodes = nodes_by_face(p1,xend=end,angle=10)

	if len(nodes) == 0:
		raise Exception('*** Fail to get the end face nodes.')

	nodes1 = []
	if axis == 'z':
		nodes1 = node_select(p1,nodes=nodes,y=MID,err=0.2,groupX=(MID,MAX))
		nodes1 = nodes_sort_byx(nodes1)
		nodes1 = nodes1[:-4]
	elif axis == 'y':
		nodes1 = node_select(p1,nodes=nodes,z=MID,err=0.2,groupX=(MID,MAX))
		nodes1 = nodes_sort_byx(nodes1)
		nodes1 = nodes1[:-4]
	elif axis == 'x':
		nodes1 = node_select(p1,nodes=nodes,z=MID,err=0.2,groupY=(MID,MAX))
		nodes1 = nodes_sort_byy(nodes1)
		nodes1 = nodes1[:-4]

	if len(nodes1) == 0:
		raise Exception('*** Fail to get the center line nodes.')

	nodes2 = []
	for node in nodes1:
		nodes2 = node.getNodesByFeatureEdge(20)  ## angle=20
		if len(nodes2) > 2:
			break

	if len(nodes2) == 0:
		raise Exception('*** Fail to get the hole nodes')

	return nodes2

def nodes_by_face(poi,elements=None,x=(),y=(),z=(),poiRefX=(), poiRefY=(),poiRefZ=(), space=(), PRx=None,PRy=None,PRz=None,
	nx=0,ny=0,nz=0,angle=40,err=1,err0=None,xend=None,yend=None,zend=None):
	## VER: 2017-06-06, v2.1
	## 对3D模型可用，用于2D模型时需检查
	## 如果是imported deformed part,可以直接在GUI下选择节点建立set，然后set2objs()获得nodes
	## angle太小的话，很可能漏选。

	## nodes = nodes_by_face(p1,zend=MAX,angle=1)
	## nodes = nodes_by_face(p1,y=MIN,x=(MINp,0.5),ny=-1,z=_zmid(p1)+2)  ## 选择外表面局部的节点
	## nodes5 = nodes_by_face(p1,z=MIN,nz=-1,angle=1)  ## angle太大可能选择的面过多
	## nodes = nodes_by_face('p1',x=MAX,nx=1)  ## USM insert, 3D, OK
	## nodes = nodes_by_face('powder_A1',nx=1,x=MAX)   ## 2D button, right

	## Example:
##	elems = element_select('powder_A1',y=MAX)   ## 2D model
##	faces = get_an_element_face(elems,ny=1)
##
##	nodes = nodes_by_face('powder_A1',y=MAX,ny=1)
##	create_nodal_surface('powder_A1', nodes=nodes)

##	>>> nodes = nodes_by_face('p1',nz=-1,z=MIN)
##	---> 6248 elements selected by elems_nodes_by_face()
##	---> 6394 nodes selected by elems_nodes_by_face()

	if PRx not in empty:
		poiRefX = PRx
	if PRy not in empty:
		poiRefY = PRy
	if PRz not in empty:
		poiRefZ = PRz

	if xend == MAX:
		x=MAX; nx=1
	elif xend == MIN:
		x=MIN; nx=-1

	if yend == MAX:
		y=MAX; ny=1
	elif yend == MIN:
		y=MIN; ny=-1

	if zend == MAX:
		z=MAX; nz=1
	elif zend == MIN:
		z=MIN; nz=-1

	elems,nodes = elems_nodes_by_face(poi=poi,elements=elements,x=x,y=y,z=z,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ,
		space=space,nx=nx,ny=ny,nz=nz,angle=angle,err=err,err0=err0)

	if xend == MAX:
		nodes = node_select(poi,nodes=nodes,x=(MID,MAX))
	elif xend == MIN:
		nodes = node_select(poi,nodes=nodes,x=(MID,MIN))
	elif yend == MAX:
		nodes = node_select(poi,nodes=nodes,y=(MID,MAX))
	elif yend == MIN:
		nodes = node_select(poi,nodes=nodes,y=(MID,MIN))
	elif zend == MAX:
		nodes = node_select(poi,nodes=nodes,z=(MID,MAX))
	elif zend == MIN:
		nodes = node_select(poi,nodes=nodes,z=(MID,MIN))

	return nodes

def elem_label_to_index(poi):
	## VER: 2015-06-18, v1.0

	## Odb node label is stored with index = label - 1, such as:
##	>>> nodes = oa.instances.values()[0].nodes
##	>>> nodes[720].label
##	721

	poi = check_poi(poi)
	if len(poi.elements) == 0:
		raise Exception('*** No element in the poi.')

	dict1 = {}
	for element in poi.elements:
		label = element.label
		index = get_index(element)
		dict1[label] = index

	return dict1

def element_select(poi,elements=None,x=(),y=(),z=(),poiRefX=(), poiRefY=(),poiRefZ=(), space=(), mark_select=True,
	nx=None,ny=None,nz=None,exterior=None,angle_err=20,err=1,fine_angle=30,axis='',rough_angle=70,by_fine=True):
	## VER: 2016-04-14, v2.4, 2D powder compaction: land<0.1, so, err should <0.1
	## reference: elements = seq.getByBoundingBox()   ## seq is a sequence of elements, such as _part(powder).elements[:]

	## elems = element_select('powder_A1',ny=-1)  ## 2D powder compaction button model, select the bottom dome side nodes.

##	Compare below two methods, method1 is better than method2
##	1)
##	nodes = nodes_by_face('green_A1',nz=-1,z=MIN)
##	elems = nodes_to_elements(nodes)
##	elements_to_surface(elems,name='surf-a',axis='z')
##	2)
##	elems = element_select('green_A1',z=MIN,nz=-1)
##	elements_to_surface(elems,name='surf-a',axis='z')

	## Example:
##	>>> elems = element_select('p1',y=MIN,ny=-1)
##	---> 1500 elements selected by element_select()

##	>>> elems = element_select('powder_A1',x=(die_R/2,MAX),poiRefY=(MAX, -_ylength('powder')/5))
##	---> 265 elements selected by element_select()
##	>>> create_surface(elements=elems)
##	p.Surface(face2Elements=face2,face3Elements=face3,name=name)
##	surface name= surf_powder2
##
##	mdb.models['Model-1'].rootAssembly.surfaces['surf_powder2']

	poi = check_poi(poi)

	if elements in empty:
		elements = poi.elements[:]
	else:
		elements = tolist(elements)

	if x in ['MIN',MIN]:
		x=(_xmin(poi)-1, _xmin(poi) + err)
	elif x in ['MAX',MAX]:
		x=(_xmax(poi)+1, _xmax(poi)-err)

	if poiRefX not in empty:
		if poiRefX[0] in ['MIN',MIN]:
			x=(_xmin(poi)-1,_xmin(poi) + poiRefX[1])
			poiRefX = ()
		elif poiRefX[0] in ['MAX',MAX]:
			x=(_xmax(poi)+1, _xmax(poi) + poiRefX[1])
			poiRefX = ()


	if y in ['MIN',MIN]:
		y=(_ymin(poi)-1,_ymin(poi) + err)
	elif y in ['MAX',MAX]:
		y=(_ymax(poi)+1,_ymax(poi) - err)

	if poiRefY not in empty:
		if poiRefY[0] in ['MIN',MIN]:
			y=(_ymin(poi)-1,_ymin(poi) + poiRefY[1])
			poiRefY = ()
		elif poiRefY[0] in ['MAX',MAX]:
			y=(_ymax(poi)+1, _ymax(poi) + poiRefY[1])
			poiRefY = ()

	if z in ['MIN',MIN]:
		z=(_zmin(poi)-1,_zmin(poi) + err)
	elif z in ['MAX',MAX]:
		z=(_zmax(poi)+1, _zmax(poi) - err)

##	print fnln(),'z=',z

	if poiRefZ not in empty:
		if poiRefZ[0] in ['MIN',MIN]:
			z=(_zmin(poi)-1,_zmin(poi) + poiRefZ[1])
			poiRefZ = ()
		elif poiRefZ[0] in ['MAX',MAX]:
			z=(_zmax(poi)+1, _zmax(poi) + poiRefZ[1])
			poiRefZ = ()

	myelements = []
##	print fnln(),'poiRefX=',x
	x,y,z = real_xyz(poi,x,y,z,space=space,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ)
	x1,x2,y1,y2,z1,z2 = tospace(x,y,z)
##	print fnln(),'z=',z
##	print fnln(),'x1,x2,y1,y2,z1,z2=',(x1,x2,y1,y2,z1,z2)

##	print fnln(),_xmax(poi) + 1
##	print fnln(),(x1,x2,y1,y2,z1,z2)
##	raise Exception

##	## 对于单元选择，需要把范围略为放宽，因为单元的节点可能会超限。
##	x1 = x1 - err
##	x2 = x2 + err
##	y1 = y1 - err
##	y2 = y2 + err
##	z1 = z1 - err
##	z2 = z2 + err

##	print fnln(),'x,y,z=',x,y,z
##	print len(elements)
##	print (x1,x2,y1,y2,z1,z2)

	if x in empty and y in empty and z in empty:
		myelements = elements
	else:
		seq = list2sequence(elements)
		myelements = seq.getByBoundingBox(xMin=x1,xMax=x2,yMin=y1,yMax=y2,zMin=z1,zMax=z2)
		## 完全在框中的单元才会被选中, 所以类似y=MAX这种设置往往无效。

		if len(myelements) == 0:
			myelements = []
			for elem in elements:
				x01,x02,y01,y02,z01,z02 = space_of_element(elem)
				if not meet_search_range((x01,x02),(x1,x2),mark_select=mark_select):  ## 实际是mark_select参数在meet_search_range()函数中没有用上，是一个闲置参数。
					continue
				if not meet_search_range((y01,y02),(y1,y2),mark_select=mark_select):
					continue
				if not meet_search_range((z01,z02),(z1,z2),mark_select=mark_select):
					continue

				myelements.append(elem)

##	print len(myelements)
##	print 'exterior=',exterior

	if (nx,ny,nz)!= (0,0,0):  ## select external elements
		exterior = True

	if exterior == True and myelements not in empty:
		myelements = exterior_elements(poi,myelements)

##	light(myelements)
##	raise Exception

	if (nx,ny,nz)!= (None,None,None):  ## select external elements
		## refer to nodes_by_face(), such as: nodes = nodes_by_face('powder_A1',y=MAX,ny=1)
		shape = get_element_shape(myelements[0])
		print fnln(),'shape=',shape

		if shape == '3D':
			if nx in [1,-1]:
				dict1 = elements_dict_by_face(myelements,fine_angle=fine_angle,axis='x',rough_angle=rough_angle,by_fine=by_fine)
				elems1 = dict1['total']
			elif ny in [1,-1]:
				dict1 = elements_dict_by_face(myelements,fine_angle=fine_angle,axis='y',rough_angle=rough_angle,by_fine=by_fine)
				elems1 = dict1['total']
			elif nz in [1,-1]:
				dict1 = elements_dict_by_face(myelements,fine_angle=fine_angle,axis='z',rough_angle=rough_angle,by_fine=by_fine)
				elems1 = dict1['total']
			else:
				raise Exception('*** Error nx,ny,nz')

			faces = get_an_element_face(elems1,nx=nx,ny=ny,nz=nz)  ## Sometimes with error, because some element not in the perfect angle
			elems = faces[0].getElementsByFaceAngle(angle_err)
			elems = tolist(elems)
		elif shape == '2D':
			elems = []
			for element in myelements:
				faces1 = get_an_element_face(element,nx=nx,ny=ny,nz=nz)
				if faces1 not in empty:
					elems.append(element)

		else:
			elems = []

		myelements = elems

	myelements = tolist(myelements)
	print '--->',len(myelements),'elements selected by element_select()'

	return myelements

elem_select = element_select

def choose_element_types():
	## VER: 2015-04-03, v1.0

	parts = parts_of_insts(a.instances.keys())
	for part in parts:
		choose_element_type(part)

	return

def choose_element_type(part, objs=None, cells=None, faces=None, edges=None,
	order=1, hybrid=False,reduced=True,hour_glass='default',incompatible=False,modified=False,improved_surface=False,
	dispersion=False,convection=False):
	## VER: 2016-10-30, v2.0
	## reference: set_element_shape(), set_element_type

	## 一个模型中允许有多个procedure type，
##	例如：job A0215 PDC simulation中，step1=coupled_temp_disp,然后model change时必须采用general_static，而不能有温度自由度，因为这与温度无关，否则不收敛。
##	create_coupled_temp_displacement_step('cooling', period=250,response='transient')
##	create_general_static_step('remove', period=5)	;changing

##>>> get_element_type('compound',order=1)
##(ElemType(elemCode=C3D8, elemLibrary=STANDARD), ElemType(elemCode=C3D6, elemLibrary=STANDARD), ElemType(elemCode=C3D4, elemLibrary=STANDARD))
##>>>

##	cells = get_unmeshed_region(anvil)
##	if cells not in empty:
##		set_element_shape(anvil,cells=cells,eshape='TET')
##		mesh_region(anvil,cells=cells)
##
##		cells1 = get_unmeshed_region(anvil)
##		if cells1 not in empty:
##			choose_element_type(anvil,cells=cells1,order=2)
##			mesh_region(anvil,cells=cells)


	part = check_part(part)

	solver = get_solver()
	antype = get_antype()

	if len(_m.steps) == 1:
		raise Exception('*** No analysis step yet.')

	hour_glass = hour_glass.lower()
	if hour_glass == 'default':
		hour_glass = DEFAULT
	elif 'enhance' in hour_glass:	##sever deformation. Hour_glass is applicable for reduced == True
		hour_glass = ENHANCED

	if order not in [1,2]:
		raise Exception('*** element order should be 1 or 2')

	if len(part.cells) > 0:
		obj_type = 'cells'
	elif len(part.faces) > 0:
		obj_type = 'faces'
	elif len(part.edges) > 0:
		obj_type = 'edges'

##	raise Exception

	objs = get_real_input(objs,faces,cells,edges)
	if objs in empty:
		objs = body_obj(part)

	objs = tolist(objs)
	obj_type = type_of(objs[0])

	print fnln(),'(solver, antype, obj_type, order)=', (solver, antype, obj_type, order)

	region = list2region(objs,region_type='set')

	elemType1 = None
	elemType2 = None
	elemType3 = None

	elem1 = None
	elem2 = None
	elem3 = None

	if solver == 'implicit':
		if antype == 'stress':
			if obj_type == 'cells':   ## 3D stress
				if order == 1:
					elem1 = 'C3D8'
					if reduced == True and incompatible == True:
						raise Exception('*** cannot both reduced and incompatible.')

					if reduced == True:
						elem1 = elem1 + 'R'
					elif incompatible == True:
						elem1 = elem1 + 'I'

					if hybrid == True:
						elem1 = elem1 + 'H'

					elem2 = 'C3D6'
					if hybrid == True:
						elem2 = 'C3D6H'

					elem3 = 'C3D4'
					if hybrid == True:
						elem3 = 'C3D4H'

				elif order == 2:
					elem1 = 'C3D20'
					if reduced == True:
						elem1 = elem1 + 'R'
					if hybrid == True:
						elem1 = elem1 + 'H'

					elem2 = 'C3D15'
					if hybrid == True:
						elem2 = 'C3D15H'

					elem3 = 'C3D10'
					if improved_surface == False:
						if modified == True:
							elem3 = elem1 + 'M'
						if hybrid == True:
							elem3 = elem1 + 'H'
					else:
						elem3 = elem1 + 'I'

			elif obj_type == 'faces':  ## No elem3
				if 'axisym' in part_shape(part)[1]:  ## No second order    axisymmetric shell
					elem1 = 'CAX4'   ## axisymmetric

					if reduced == True and incompatible == True:
						raise Exception('*** cannot both reduced and incompatible.')

					if reduced == True:
						elem1 = elem1 + 'R'
					elif incompatible == True:
						elem1 = elem1 + 'I'

					if hybrid == True:
						elem1 = elem1 + 'H'

					elem2 = 'CAX3'
					if hybrid == True:
						elem2 = elem2 + 'H'

					if reduced == True:
						elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=STANDARD,
						    kinematicSplit=AVERAGE_STRAIN, hourglassControl=hour_glass)

				elif part_type(part) == DISCRETE_RIGID_SURFACE:  ## No second order
					elem1 = 'R3D4'
					elem2 = 'R3D3'

				elif part_type(part) == ANALYTIC_RIGID_SURFACE:
					raise Exception('*** Element type cannot assign to analytical rigid surface. No mesh needed.')

				elif part_shape(part)[0] == TWO_D_PLANAR:
					elem1 = 'CPS4'
					if reduced == True:
						elem1 = 'CPS4R'

					if reduced == True:
						elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=STANDARD,
						    secondOrderAccuracy=OFF, hourglassControl=hour_glass,
						    distortionControl=DEFAULT)

					elem2 = 'CPS3'

				else:   ## 3D planar
					elem1 = 'S4'   ## Quard

					if reduced == True:
						elem1 = elem1 + 'R'   ## default

					elem2 = 'S3'   ## Tri

					if reduced == True:
						elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=STANDARD, hourglassControl=hour_glass)

		elif antype == 'thermal_stress':
			if obj_type == 'cells':
				if order == 1:
					elem1 = 'C3D8'
					if reduced == True:
						elem1 = elem1 + 'R'
					if hybrid == True:
						elem1 = elem1 + 'H'
					elem1 = elem1 + 'T'

					elem2 = 'C3D6T'
					elem3 = 'C3D4T'

				elif order == 2:
					elem1 = 'C3D20'
					if reduced == True:
						elem1 = elem1 + 'R'
					if hybrid == True:
						elem1 = elem1 + 'H'
					elem1 = elem1 + 'T'

					elem2 = 'UNKNOWN_WEDGE'   ## No wedge element shape.

					elem3 = 'C3D10MT'
					if hybrid == True:
						elem3 = 'C3D10MHT'

			elif obj_type == 'faces':  ## wire draw: 由standard转到explicit时，用的单元类型一样，不需要改变。
				if order == 1:
					elem1 = 'CAX4'
					if reduced == True:
						elem1 = elem1 + 'R'
					if hybrid == True:
						elem1 = elem1 + 'H'
					elem1 = elem1 + 'T'

					elem2 = 'CAX3T'

				elif order == 2:
					elem1 = 'CAX8'
					if reduced == True:
						elem1 = elem1 + 'R'
					if hybrid == True:
						elem1 = elem1 + 'H'
					elem1 = elem1 + 'T'

					elem2 = 'CAX6MT'
					if hybrid == True:
						elem2 = 'CAX6MHT'


			if reduced == True and order == 1:
				elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=STANDARD,
				    kinematicSplit=AVERAGE_STRAIN, hourglassControl=hour_glass)

		elif antype == 'thermal':
			if obj_type == 'cells':
				if order == 1:
					elem1 = 'DC3D8'
					if convection == True:
						elem1 = 'DCC3D8'
					elif dispersion == True:
						elem1 = 'DCC3D8D'

					elem2 = 'DC3D6'
					elem3 = 'DC3D4'

				elif order == 2:
					elem1 = 'DC3D20'
					elem2 = 'DC3D15'
					elem3 = 'DC3D10'

	elif solver == 'explicit':
		if antype == 'stress':
			if obj_type == 'cells':
				if order == 1:
					elem1 = 'C3D8'
					if reduced == True:
						elem1 = 'C3D8R'
					elif incompatible == True:
						elem1 = 'C3D8I'

					elem2 = 'C3D6'
					elem3 = 'C3D4'

				elif order == 2:
					elem1 = 'UNKNOWN_HEX'
					elem2 = 'UNKNOWN_WEDGE'
					elem3 == 'C3D10M'   ## No hex and wedge elements.

				if reduced == True and order == 1:
					elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=EXPLICIT,
					    kinematicSplit=AVERAGE_STRAIN, hourglassControl=hour_glass)

			elif obj_type == 'faces':
				if 'axisym' in part_shape(part)[1]:   ## For exmaple: powder compaction modelling.
					## only order = 1 is available.

					if len(part.faces) > 0:    ## wire draw: 由standard转到explicit时，用的单元类型一样，不需要改变。
						elem1 = 'CAX4R'
						elem2 = 'CAX3'
						reduced = True

						elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=EXPLICIT, hourglassControl=hour_glass)
	##					elemType1 = mesh.ElemType(elemCode=CAX4R, elemLibrary=EXPLICIT,  secondOrderAccuracy=OFF, hourglassControl=ENHANCED, distortionControl=ON,  lengthRatio=0.100000001490116)

					elif len(part.edges) > 0:   ## tpunch, bpunch wires
						elemType1 = mesh.ElemType(elemCode=RAX2, elemLibrary=EXPLICIT)  ## 隐式也是RAX2

				elif part_type(part) == DISCRETE_RIGID_SURFACE:  ## No second order
					elem1 = 'R3D4'
					elem2 = 'R3D3'

				elif part_type(part) == ANALYTIC_RIGID_SURFACE:
					raise Exception('*** Element type cannot assign to analytical rigid surface. No mesh needed.')

			elif obj_type == 'edges':
				if part_type(part) == DISCRETE_RIGID_SURFACE:
					if 'axisym' in part_shape(part)[1]:
						elem1 = 'RAX2'
					else:
						elem1 = 'R2D2'   ## planar

				else:
					if 'axisym' in part_shape(part)[1]:
						elem1 = 'SAX1'
					else:
						elem1 = 'B21'	## Planar. Beam: B21, Truss: T2D2

##					elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=EXPLICIT, hourglassControl=hour_glass)

		elif antype == 'thermal_stress':
			if obj_type == 'cells':
				if order == 1:
					elem1 = 'C3D8T'
					if reduced == True:
						elem1 == 'C3D8RT'

					elem2 = 'C3D6T'
					elem3 = 'C3D4T'

				elif order == 2:
					elem1 = 'UNKNOWN_HEX'
					elem2 = 'UNKNOWN_WEDGE'
					elem3 = 'C3D10MT'   ## No hex and wedge elements

			elif obj_type == 'faces':
				if 'axisym' in part_shape(part)[1]:   ## For exmaple: powder compaction modelling.
					## only order = 1 is available.

					if len(part.faces) > 0:    ## wire draw: 由standard转到explicit时，用的单元类型一样，不需要改变。
						elem1 = 'CAX4RT'
						elem2 = 'CAX3T'
						reduced = True

						elemType1 = mesh.ElemType(elemCode=eval(elem1), elemLibrary=EXPLICIT, hourglassControl=hour_glass)
	##					elemType1 = mesh.ElemType(elemCode=CAX4R, elemLibrary=EXPLICIT,  secondOrderAccuracy=OFF, hourglassControl=ENHANCED, distortionControl=ON,  lengthRatio=0.100000001490116)

					elif len(part.edges) > 0:   ## tpunch, bpunch wires
						elemType1 = mesh.ElemType(elemCode=RAX2, elemLibrary=EXPLICIT)  ## 隐式也是RAX2


	if elem1 not in empty:
		elem1 = eval(elem1)

	if elem2 not in empty:
		elem2 = eval(elem2)

	if elem3 not in empty:
		elem3 = eval(elem3)

	if solver == 'implicit':
		library = STANDARD
	else:
		library = EXPLICIT

	print fnln(),'library=',library
##	raise Exception

	if (elem1,elem2,elem3) == (None,None,None):
		raise Exception('*** Fail to get the element types.')

	print fnln(),'elem1=',elem1
	print fnln(),'elem2=',elem2
	print fnln(),'elem3=',elem3
##	raise Exception

	if elemType1 in empty and 'SYMBOL' in type_of(elem1):
		elemType1 = mesh.ElemType(elemCode=elem1, elemLibrary=library)

	if elemType2 in empty and 'SYMBOL' in type_of(elem2):
		elemType2 = mesh.ElemType(elemCode=elem2, elemLibrary=library)

	if elemType3 in empty and 'SYMBOL' in type_of(elem3):
		elemType3 = mesh.ElemType(elemCode=elem3, elemLibrary=library)

##	print fnln(),'elemType1=',elemType1
##	print fnln(),'elemType2=',elemType2
##	print fnln(),'elemType3=',elemType3
	print fnln(),'obj_type=',obj_type
	if obj_type == 'cells':
		if (elemType1 not in empty) and (elemType2 not in empty) and (elemType3 not in empty):
			part.setElementType(regions=region, elemTypes=(elemType1, elemType2, elemType3))
	elif obj_type == 'faces':
		if (elemType1 not in empty) and (elemType2 not in empty):  ## shell
			part.setElementType(regions=region, elemTypes=(elemType1, elemType2))
	elif obj_type == 'edges':
		if elemType1 not in empty:  ## wire
			part.setElementType(regions=region, elemTypes=(elemType1, ))

	part.regenerate()
	a.regenerate()

	return elemType1, elemType2, elemType3

function_labels['element_surface_of_nodes'] = 'element surface','element face'
def element_surface_of_nodes(nodes,nx=None,ny=None,nz=None):
	## VER: 2016-12-02, v1.2
	## reference: create_surface_of_nodes()。不过，element_surface_of_nodes()更快更灵活。

##	>>> surf1 = element_surface_of_nodes(v1)
##	['element_surface_of_nodes', 145] trying angle= 2
##	['element_surface_of_nodes', 145] trying angle= 5
##	['element_surface_of_nodes', 145] trying angle= 10
##	['element_surface_of_nodes', 145] trying angle= 15
##	['element_surface_of_nodes', 145] trying angle= 20
##	['element_surface_of_nodes', 145] trying angle= 25
##	--->Created element surface, name= surf4
##	['element_surface_of_nodes', 181] Matched nodes in 100.0 %, angle= 25
##	>>> light(surf1)

	nodes = tolist(nodes)
	poi = get_poi(nodes)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	num = len(nodes)
	if num <=2:
		raise Exception('*** need enough nodes to create a surface.')

	seeds = []
	num0 = 20
	for i in range(num0):
		index = int(float(i)/num0*num)
		node = nodes[index]
		seeds.append(node)

	seed_face = None
	for node in seeds:
		faces1 = element_faces_of_node(node,nx=nx,ny=ny,nz=nz)
		if len(faces1) > 0:
			nodes1 = element_faces_to_nodes(faces1)
			if list1_in_list2(nodes1,nodes):
				seed_face = faces1[0]
				break

	if seed_face == None:
		raise Exception('*** Fail to find the seed face.')

	ratios = []
	surf = None
	angle = None
	for angle0 in [2,5,10,15,20,25,30,35,40,45]:
		print fnln(),'trying angle=',angle0
		faces2 = seed_face.getElemFacesByFaceAngle(angle0)	;please_check
		surf2 = element_faces_to_surface(faces=faces2,printinfo=False)
		ratio = round(len(surf2.nodes)/float(num)*100,1)

		ratios.append([angle0,ratio])
		if ratio == 100.0:
			surf = surf2
			angle = angle0
			print '--->Created element surface, name=',name_of_surface(surf2)
		else:
			del poi.surfaces[name_of_surface(surf2)]

		if ratio >= 100:
			break

	if surf == None:
		if len(ratios) == 1:
			angle = 1
		else:
			angle1 = ratios[-2][0]
			angle2 = ratios[-1][0]
			angle = round((angle1 + angle2)/2.0,1)

		faces2 = seed_face.getElemFacesByFaceAngle(angle)	;please_check
		surf = element_faces_to_surface(faces=faces2)
		ratio = round(len(surf.nodes)/float(num)*100,1)

		if ratio < 100:
			del poi.surfaces[name_of_surface(surf)]

			angle = round((angle + ratios[-1][0])/2.0,1)
			faces2 = seed_face.getElemFacesByFaceAngle(angle)	;please_check
			surf = element_faces_to_surface(faces=faces2)
			ratio = round(len(surf.nodes)/float(num)*100,1)

	print fnln(),'Matched nodes in',ratio,'%, angle=',angle

	return surf

def element_values_vs_time(*labels):
	## VER: 2014-12-16, v1.2
	## Example: nodal_values_vs_time('compound_A1',[2, 53])  ## to get the coordinates

##odb = session.odbs['E:/FEM/A0229/AA_A0229_HPHT_anvil_crack_A_final.odb']
##xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
##    'U', NODAL, ((COMPONENT, 'U2'), )), ), nodeLabels=(('BLANK_A1', ('10', '100', )), ))

	## Example:
##	element_values_vs_time('anvil_A1',16766)
##	element_values_vs_time('anvil_A1',[16766,16767,16768])
##	element_values_vs_time('anvil_A1',(16766,16767,16768))
##	element_values_vs_time((16766,16767,16768))
##	element_values_vs_time([16766,16767,16768])
##	element_values_vs_time(16766,16767)

	plot_state = get_plot_state()
	if plot_state != CONTOURS_ON_DEF:
		raise Exception('*** a contour viewport is required.')

	setting = current_variable_setting()
	main = setting['main']
	sub = setting['sub']
	position = setting['position']
	refinement = setting['refinement']
	variable = setting['variable']

	if position == NODAL:
		raise Exception('*** Error: value position is at nodal, please use contour_values_vs_time() or nodal_values_vs_time() instead.')

	axis2_title = main
	if sub not in empty:
		axis2_title = main + ', ' + sub

	labels = tolist(labels)	##

	elements = []
	if len(labels) > 0:
		if is_numbers(labels):
			insts = objs_of_dg()
			if len(insts) == 1 and insts[0] in oa.instances.keys():
				inst=insts[0]
				for number in labels:
					elements.append([inst,number])
			else:
				raise Exception('*** There are more than one instances displayed, please specify the instance name with element label.')
		else:
			if len(labels) == 2:
				if type_of(labels[0]) == 'STR' and is_numbers(labels[1]):
					labels = ((labels[0],labels[1]),)
	##			else:
	##				raise Exception('*** Error labels format, shouldb be (inst1,label1),(inst2,label2),...')

		for label0 in labels:
			if _len(label0) == 2:
				inst,label = label0
				if is_STR(inst):
					inst = inst.upper()

				if inst in oa.instances.keys():
					if is_INT(label):
						elements.append((inst,str(label)))
					elif type_of(label) in ['TUPLE','LIST']:
						for num in label:
							if is_INT(num):
								elements.append((inst,str(num)))

	if elements not in empty:
		elements = totable(elements)

##	print fnln(),elements

	elements1 = {}
	for element in elements:
		inst,label = element
		if inst not in elements1.keys():
			elements1[inst] = []
		label = tolist(label)
		elements1[inst] = elements1[inst] + label

##	print fnln(),elements1

	for inst in elements1.keys():
		elements1[inst] = totuple(elements1[inst])

	elements = tuple(elements1.items())
	print fnln(),'elements=',elements

##	setting = current_variable_setting()
##	main = setting['main']
##	refinement = setting['refinement']
##	position = setting['position']

##	print fnln(),'main=',main
##	print fnln(),'refinement=',refinement
##	print fnln(),'position=',position

##	if refinement not in empty:
##		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=position, variable=((main, position, (refinement, )), ), elementLabels=elements)
##	else:
##		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=position, variable=((main, position), ), elementLabels=elements)

	xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=position, variable=variable, elementLabels=elements)

	xyp = check_xyplot('xyplot-1')
	chartName = xyp.charts.keys()[0]
	chart = xyp.charts[chartName]
	curveList = session.curveSet(xyData=xyList)
	chart.setValues(curvesToPlot=curveList)

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=xyp)

## GUI:
##>>> chart = session.charts.values()[-1]
##>>> axis_data = chart.axes2[0].axisData

	chart = get_current_chart()
	update_axis2(chart,axis2_title)
	refresh()

	save_image()

	return

def elements_labels_of_faces(faces):
	## VER: 2013-06-03, v1.0

	elements = elements_of_faces(faces)
	labels = elements_to_labels_dict(elements)

	return labels


def odb_node_set_dims(setname,step_name,frame=-1):
	## VER: 2015-06-11, v1.1

	## Example:
##	odb_node_set_dims(setname='SET-A1',step_name='uppressing')

	if setname not in oa.nodeSets.keys():
		raise Exception('*** Node set is required.')

	set1 = oa.nodeSets[setname]
	if len(set1.instances) > 1:
		raise Exception('*** More than one instance in the set')

	inst = set1.instances[0].name

	nodes = oa.nodeSets[setname].nodes[0]
	x0,y0,z0 = nodes[0].coordinates   ## 得到的是base distance，即变形前的坐标尺寸。
	x1=x2=x0
	y1=y2=y0
	z1=z2=z0

	for node in nodes:
		x,y,z = node.coordinates

		x1 = min(x1,x)
		x2 = max(x2,x)

		y1 = min(y1,y)
		y2 = max(y2,y)

		z1 = min(z1,z)
		z2 = max(z2,z)

	xdim = smart_round(x2-x1)
	ydim = smart_round(y2-y1)
	zdim = smart_round(z2-z1)

	title1 = odb_file_title

	labels = labels_of_odb_node_set(setname)
	partname = import_part_from_odb(odb_file_title,inst_name=inst,step_name=step_name,frame=frame)
	p = _m.parts[partname]

	nodes1 = []
	for label in labels:
		nodes1.append(p.nodes[label-1])  ## label is greater than index

	create_set(p,nodes=nodes1,name=setname)

	x11,x12,y11,y12,z11,z12 = objs_space(nodes1)
	xdim1 = smart_round(x12-x11)
	ydim1 = smart_round(y12-y11)
	zdim1 = smart_round(z12-z11)

	results = (xdim,ydim,zdim),(xdim1,ydim1,zdim1)

	open_odb(title1)

	return results

def nodes_dict_byx(nodes,poi=None,reverse=False):
	## VER: ('VER: 2016-04-05, v1.')

	if type_of(nodes) == 'STR':
		if poi not in empty:
			nodes = set2objs(nodes,poi)
		else:
			raise Exception('Part or instance name is needed.')

	nodes = tolist(nodes)
	num = len(nodes)
	dict1 = {}

	if num == 0:
		raise Exception('*** Empty nodes')

	for i in range(num):
		loc1 = nodes[i].coordinates[0]
		loc2 = smart_round(loc1,2)
		if loc2 not in dict1.keys():
			dict1[loc2] = []
		dict1[loc2].append(nodes[i])

	return dict1

def nodes_dict_byy(nodes,poi=None,reverse=False):
	## VER: ('VER: 2016-04-05, v1.')

	if type_of(nodes) == 'STR':
		if poi not in empty:
			nodes = set2objs(nodes,poi)
		else:
			raise Exception('Part or instance name is needed.')

	nodes = tolist(nodes)
	num = len(nodes)
	dict1 = {}

	if num == 0:
		raise Exception('*** Empty nodes')

	for i in range(num):
		loc1 = nodes[i].coordinates[1]
		loc2 = smart_round(loc1,2)
		if loc2 not in dict1.keys():
			dict1[loc2] = []
		dict1[loc2].append(nodes[i])

	return dict1

def nodes_dict_byz(nodes,poi=None,reverse=False):
	## VER: ('VER: 2016-04-05, v1.')

	if type_of(nodes) == 'STR':
		if poi not in empty:
			nodes = set2objs(nodes,poi)
		else:
			raise Exception('Part or instance name is needed.')

	nodes = tolist(nodes)
	num = len(nodes)
	dict1 = {}

	if num == 0:
		raise Exception('*** Empty nodes')

	for i in range(num):
		loc1 = nodes[i].coordinates[2]
		loc2 = smart_round(loc1,2)
		if loc2 not in dict1.keys():
			dict1[loc2] = []
		dict1[loc2].append(nodes[i])

	return dict1

def nodes_labels_of_faces(faces):
	## VER: 2013-06-02, v1.0

	nodes = nodes_of_faces(faces)
	labels = nodes_to_labels_dict(nodes)

	return labels

def nodes_of_faces(faces,poi=None):
	## VER: 2013-05-31, v1.0
	## 注意，node和element的label比起index大1.
	## 例如，mdb.models['Model-1'].parts['anvil'].nodes[24]，起label为25。

	if type_of(faces) == 'STR':
		faces = set2objs(faces,p=poi)

	nodes = []
	faces = tolist(faces)
	for face in faces:
		nodes0 = list(face.getNodes())
		nodes = nodes + nodes0

	return nodes

def nodes_of_odb_path(path):
	## VER: 2016-03-02, v1.1

##	>>> path.expression
##	(('GREEN_A1', (933, '7539:7531:-1', 955, '9549:9541:-1', 1119)),)

##	>>> nodes = nodes_of_odb_path('nodes_ymax')
##	>>> nodes[0]
##	session.openOdb(r'D:/JYQ/A0256-USM insert/D1_A0256_USM_insert_rough1_4hr.odb').rootAssembly.instances['GREEN_A1'].nodes[932]
##	>>> type_of(nodes[0])
##	'ODBMESHNODE'
##	>>>

##	>>> radius_of_fit_nodes(nodes)
##	35.376

	if path in session.paths.keys():
		path = session.paths[path]

	if path not in session.paths.values():
		raise Exception('*** node path is required.')

	if path.type != NODE_LIST:
		raise Exception('*** node path is required.')

	expression = path.expression
	nodes = []
	for item in expression:
##		print item   ## ('GREEN_A1', (933, '7539:7531:-1', 955, '9549:9541:-1', 1119))
		name = item[0]
		labels = item[1]

		inst = oa.instances[name]
		for express in labels:
			if is_number(express):
				label = express
				node = inst.nodes[label - 1]
				nodes.append(node)
			else:
##				print fnln(),express

				loc1 = express.find(':')
				loc2 = express.rfind(':')
				start = eval(express[:loc1])
				end = eval(express[loc1+1:loc2])
				inc = eval(express[loc2+1:])
				node_labels = myrange(start,end,inc)
				for label in node_labels:
					node = inst.nodes[label - 1]
					nodes.append(node)

	print fnln(),len(nodes),'nodes are found in the odb node path'

	return nodes

def nodes_region_of_faces(faces,poi=None):
	## VER: 2013-05-31, v1.0

	nodes = nodes_of_faces(faces=faces,poi=poi)

	if nodes not in empty:
		region = list2region(nodes, region_type='set')
	else:
		raise Exception('**** Cannot get nodes of unmeshed faces.')

	return region

def nodes_sequence_of_faces(faces,poi=None):
	## VER: 2013-05-31, v1.0

	nodes = nodes_of_faces(faces=faces,poi=poi)

	if nodes not in empty:
		seq = list2sequence(nodes)
	else:
		raise Exception('**** Cannot get nodes of unmeshed faces.')

	return seq

def nodes_sort_byx(nodes,poi=None,reverse=False,absolute=False):
	## VER: ('VER: 2016-05-03, v1.2')

##	## coordinates属性对于odb node也是适用的。例如:
##	>>> nodes[0].coordinates
##	array([-0.00327158952131867, -3.23005747795105, -13.7365942001343], 'f')
##	>>> x,y,z = nodes[0].coordinates
##	>>> x,y,z
##	(-0.0032715895, -3.2300575, -13.736594)
##	>>> type_of(nodes[0])
##	'ODBMESHNODE'
##	>>>
##	>>> loc = nodes[0].coordinates
##	>>> loc[0]
##	-0.0032715895
##	>>>

	if type_of(nodes) == 'STR':
		if poi not in empty:
			nodes = set2objs(nodes,poi)   ## reference: odb_node_set_to_nodes()
		else:
			raise Exception('Part or instance name is needed.')

	nodes = tolist(nodes)
	num = len(nodes)
	for i in range(num - 1):
		loc1 = nodes[i].coordinates[0]
		if absolute == True:
			loc1 = abs(loc1)

		for j in range(i + 1,num):
			loc2 = nodes[j].coordinates[0]
			if absolute == True:
				loc2 = abs(loc2)

			if loc2 < loc1:  ## sequence: from small to big
				node = nodes[i]
				nodes[i] = nodes[j]
				nodes[j] = node
				loc1 = loc2

	if reverse == True:
		nodes.reverse()

	return nodes

def nodes_sort_byy(nodes,poi=None,reverse=False,absolute=False):
	## VER: ('VER: 2016-05-03, v1.1')

	if type_of(nodes) == 'STR':
		if poi not in empty:
			nodes = set2objs(nodes,poi)
		else:
			raise Exception('Part or instance name is needed.' )

	nodes = tolist(nodes)
	num = len(nodes)
	for i in range(num - 1):
		loc1 = nodes[i].coordinates[1]
		if absolute == True:
			loc1 = abs(loc1)

		for j in range(i + 1,num):
			loc2 = nodes[j].coordinates[1]
			if absolute == True:
				loc2 = abs(loc2)

			if loc2 < loc1:
				node = nodes[i]
				nodes[i] = nodes[j]
				nodes[j] = node
				loc1 = loc2

	if reverse == True:
		nodes.reverse()

	return nodes

def nodes_sort_byz(nodes,poi=None,reverse=False,absolute=False):
	## VER: ('VER: 2016-05-03, v1.1')

	if type_of(nodes) == 'STR':
		if poi not in empty:
			nodes = set2objs(nodes,poi)
		else:
			raise Exception('Part or instance name is needed.')

	nodes = tolist(nodes)
	num = len(nodes)
	for i in range(num - 1):
		loc1 = nodes[i].coordinates[2]
		if absolute == True:
			loc1 = abs(loc1)

		for j in range(i + 1,num):
			loc2 = nodes[j].coordinates[2]
			if absolute == True:
				loc2 = abs(loc2)

			if loc2 < loc1:
				node = nodes[i]
				nodes[i] = nodes[j]
				nodes[j] = node
				loc1 = loc2

	if reverse == True:
		nodes.reverse()

	return nodes

def nodes_to_elements(nodes,inside=False):
	## VER: 2015-05-31, v1.2，运行非常慢, if too much nodes

	nodes = tolist(nodes)
	if nodes in empty:
		raise Exception('*** nodes are required.')

	elems = []
	for node in nodes:
		elems0 = tolist(node.getElements())
		elems = elems + elems0

	newlist = []
	for elem in elems:
		if elem not in newlist:
			newlist.append(elem)
	elems = newlist

	return elems

def nodes_to_labels_dict(nodes):
	## VER: 2013-05-31, v1.0

	nodes = tolist(nodes)
	if nodes[0].instanceName == None:
		raise Exception('**** nodes from instance is required.')

	dict1 = {}
	for node in nodes:
		inst = node.instanceName
		label = node.label

		if inst not in dict1.keys():
			dict1[inst] = [label]
		else:
			dict1[inst].append(label)

	for inst in dict1.keys():
		dict1[inst] = totuple(dict1[inst])

	return dict1

def nodes_to_model_node_labels(nodes):
	## VER: ('VER: 2015-06-23, v1.1')

	nodes = tolist(nodes)

	dict1 = {}
	for node in nodes:
		inst = node.instanceName
		label = node.label
		if inst not in dict1.keys():
			dict1[inst] = [label]
		else:
			dict1[inst].append(label)

	for key in dict1.keys():
		dict1[key] = totuple(dict1[key])

	items = totuple(dict1.items())

	return items

def noplot(*setname):
	## VER: 2011-05-20, v1.1

	vpnow = get_vpnow()
	leaf = get_leaf_of_odb_sets(setname)
	vpnow.odbDisplay.displayGroup.remove(leaf=leaf)

	return

def num2char(num):
	## VER: 2010-05-20

	char0 = str(num)
	if num > 9:
		if num == 10: char0 = 'A'
		if num == 11: char0 = 'B'
		if num == 12: char0 = 'C'
		if num == 13: char0 = 'D'
		if num == 14: char0 = 'E'
		if num == 15: char0 = 'F'
		if num == 16: char0 = 'G'
		if num == 17: char0 = 'H'
		if num == 18: char0 = 'I'
		if num == 19: char0 = 'J'

	return char0

def obj2sequence(obj):
	## VER: 2015-06-17, v1.1
	## Example: seq = obj2sequence(edge)

	poi = get_parent(obj)
	obj_type = type_of(obj)
##	id = obj.index
	id = get_index(obj)

	if obj_type == 'cells':
		sequence = poi.cells[id:id+1]
	elif obj_type == 'faces':
		sequence = poi.faces[id:id+1]
	elif obj_type == 'edges':
		sequence = poi.edges[id:id+1]
	elif obj_type == 'vertices':
		sequence = poi.vertices[id:id+1]
	elif obj_type == 'elements':
		sequence = poi.elements[id:id+1]
	elif obj_type == 'nodes':
		sequence = poi.nodes[id:id+1]
	else:
		sequence = None

	return sequence

def obj_at(p,objtype,point):
	## VER: 2010-02-04

##	obj = eval('p.'+objtype + '.findAt((point,))')
##	obj = eval('p.'+objtype + '.findAt(point,)')
	obj = eval('p.'+objtype + '.findAt(coordinates = point, printWarning=False)')	## 字典类型的对象数据，可以用于实体操作(如extend face cutting)
##	obj = eval('p.'+objtype + '.findAt(point)')
##	print 'point=',point 	##
##	print objtype[:-1], '= ',obj
##	print type_of(obj)

	return obj

def obj_space(obj,p=None):
	## VER: 2011-03-17, v1.6

	if type_of(obj) in ['PART','PINSTANCE']:
		obj,p = p,obj

	type1 = type_of(obj)
	if type1 in ['LIST','TUPLE','DICT','STR','INT','FLOAT']:
		raise Exception("Not one object, it's type = " + type1)

	if p in empty:
		p = get_poi(obj)

	by_edge = False
	if type_of(obj) == 'edges' and edge_dir(obj) in bending_dirs:
		x_min,x_max,y_min,y_max,z_min,z_max = curve_space(obj)
		return x_min, x_max, y_min, y_max, z_min, z_max

	elif type_of(obj) == 'faces':
		edges = faces_to_edges(obj)
		for edge in edges:
			if edge_dir(edge) in bending_dirs:	## please check
				by_edge = True		;please_check
				break

		if by_edge == True:
			i = 0
			for edge in edges:
				i = i + 1
				if edge_dir(edge) in bending_dirs:
					x1,x2,y1,y2,z1,z2 = curve_space(edge)
				else:
					p1 = p.vertices[edge.getVertices()[0]].pointOn[0]
					p2 = p.vertices[edge.getVertices()[1]].pointOn[0]
					x1,x2,y1,y2,z1,z2 = space_of_points(p1,p2)

				if i == 1:
					x_min,x_max,y_min,y_max,z_min,z_max = x1,x2,y1,y2,z1,z2

				else:
					x_min = min(x_min,x1)
					x_max = max(x_max,x2)
					y_min = min(y_min,y1)
					y_max = max(y_max,y2)
					z_min = min(z_min,z1)
					z_max = max(z_max,z2)

			x_min,x_max,y_min,y_max,z_min,z_max = check_values(x_min,x_max,y_min,y_max,z_min,z_max)

			return x_min, x_max, y_min, y_max, z_min, z_max

	ptsList = []
	i = 0
	for index1 in obj.getVertices():   ##get obj 顶点的index
		loc = p.vertices[index1].pointOn[0]
		i = i + 1
		if i == 1:
			x_min = x_max = loc[0]
			y_min = y_max = loc[1]
			z_min = z_max = loc[2]
		else:
			x_min = min(x_min,loc[0])
			x_max = max(x_max,loc[0])
			y_min = min(y_min,loc[1])
			y_max = max(y_max,loc[1])
			z_min = min(z_min,loc[2])
			z_max = max(z_max,loc[2])

	x_min,x_max,y_min,y_max,z_min,z_max = check_values(x_min,x_max,y_min,y_max,z_min,z_max)

	return x_min, x_max, y_min, y_max, z_min, z_max

def obj_select(p, objectType, xRange, yRange, zRange):
	"""In the partObject p, search objects (vertice,edge, face, cell, node, element) within the given region"""
	## VER: 2009-12-17
	TOLERANCE_GLOBAL = 1.0E-6
	INFINITE_RANGE = [-1.0E6, 1.0E6]
	tolerance = TOLERANCE_GLOBAL
	objectType = objectType.upper()
	x = 0; y = 1; z = 2
	err = 1e-8

	#Convert into list type
	search_range = [xRange, yRange, zRange]
	for i in range(len(search_range)):
		search_range[i] = list(search_range[i])
		if len(search_range[i]) == 0:
			search_range[i] = INFINITE_RANGE
		else:
			if search_range[i][0] == None:
				search_range[i][0] = INFINITE_RANGE[0]
			if search_range[i][1] == None:
				search_range[i][1] = INFINITE_RANGE[1]
			if search_range[i][0] == search_range[i][1]:
				search_range[i][0] = search_range[i][0] - tolerance
				search_range[i][1] = search_range[i][1] + tolerance
		if search_range[i][0] > search_range[i][1]:
			search_range[i][0], search_range[i][1] = search_range[i][1], search_range[i][0]

	myObjects = []

	#Find out the nodes within the given region
	if objectType == 'NODE':
		for node in p.nodes:
			ptCoords = node.coordinates
			if (ptCoords[0] < search_range[0][0] or ptCoords[0]>search_range[0][1]):
				continue
			if (ptCoords[1] < search_range[1][0] or ptCoords[1]>search_range[1][1]):
				continue
			if (ptCoords[2] < search_range[2][0] or ptCoords[2]>search_range[2][1]):
				continue
			myObjects.append(node)

	#Find out the faces within the given region
	if objectType == 'ELEMENT':
		for element in p.elements:
			ptsList = []
			flag = 1
			#Get the nodes on the elements
			for index in element.connectivity:
				ptsList.append(p.nodes[index].coordinates)
			for ptCoords in ptsList:
				if (ptCoords[0] < search_range[0][0] or ptCoords[0]>search_range[0][1]):
					flag = 0
					break
				if (ptCoords[1] < search_range[1][0] or ptCoords[1]>search_range[1][1]):
					flag = 0
					break
				if (ptCoords[2] < search_range[2][0] or ptCoords[2]>search_range[2][1]):
					flag = 0
					break
			if flag == 1:
				myObjects.append(element)

	if myObjects == []:
		print fnln_fnln(),"******Empty selection of",objectType,'. line=2681, obj_select()'
		error_record('obj_select()')
	else:
		print len(myObjects),objectType,'selected.'

	return myObjects

def obj_to_feature(obj):
	## VER: 2014-06-26, v1.0
	## reference: ids_to_feature_names()，可知最后一个feature的name (id是最后一个)

##>>> obj = feature_to_obj(anvil,'RP')
##>>> obj
##mdb.models['Model-1'].parts['anvil'].referencePoints[6]
##>>> feature = obj_to_feature(obj)
##>>> feature
##mdb.models['Model-1'].parts['anvil'].features['RP']
##>>>

##>>> id = _part(powder).datums.keys()[-1]
##>>> _part(powder).datums[id]
##mdb.models['Model-1'].parts['powder'].datums[30]
##>>> type_of(_part(powder).datums[id])
##'DATUMPOINT'
##>>> obj = _part(powder).datums[id]
##>>> prettyPrint(obj)   ## obj do not have name
##({'pointOn': 'tuple object'})
##>>> feature = obj_to_feature(obj)
##>>> feature
##mdb.models['Model-1'].parts['powder'].features['Datum pt-6']
##>>> feature.name    ## feature has a name
##'Datum pt-6'
##>>>

	obj0 = obj
	obj = repr(obj)
	if obj[-1] != ']':
		raise Exception('*** obj is required, such as referencePoint, datum point, etc.')

	loc = obj.rfind('[')
	index = obj[loc + 1:-1]
	if index.isdigit():
		index = eval(index)
	else:
		print fnln(),'index=',index
		raise Exception('*** obj is required, such as referencePoint, datum point, etc.')

	poa = get_parent(obj0)
	feature = None
	for name in poa.features.keys():
		feature = poa.features[name]
		id = feature.id
		if id == index:
			break

	if feature == None:
		raise Exception('*** fail to get the feature operation.')

	return feature


def objs2construction(sketch,objs):
	## VER: 2013-05-22, v1.0

	## Example
##	curve = select_lines_in_sketch('_punch',H=MIN,type='regular')
##	objs2construction('_punch',objs=curve)

	sketch = check_sketch(sketch)

	objs = totuple(objs)
	sketch.setAsConstruction(objectList=objs)

	return

def objs2index(objs):
	## VER: 2011-10-17, v1.0

	objs = tolist(objs)

	ids = []
	for obj in objs:
		id1 = obj.index
		if id1 not in ids:
			ids.append(id1)

	return ids

def objs_num(objs):
	## VER: 2013-01-10, v1.0

	if type_of(objs) == 'STR':
		result = objs
	else:
		result = len_num(objs)

	return result

def remove_hide_suppress_insts(insts=None):
	## VER: 2014-04-30, v1.0

	if insts in empty:
		insts = a.instances.keys()

	insts = tolist(insts)
	if type_of(insts[0]) == 'PINSTANCE':
		insts = poi_names(insts)

	hide_insts = get_hiden_insts()
	suppr_insts = get_suppressed_insts()
	insts = unselect(insts, hide_insts)
	insts = unselect(insts, suppr_insts)

	return insts

def objs_of_material(part,mat):
	## VER: 2014-11-25, v1.0

##	>>> cells = objs_of_material(compound,'H11N')
##	['objs_of_material', 14] sections of  H11N are: ['H11N_sec']
##	>>>

	part = check_part(part)
	if mat not in _m.materials.keys():
##		raise Exception('*** mat not existed.')
		print fnln(),'*** mat not existed.'
		return []

	sections = []
	for sec in _m.sections.keys():
		section = _m.sections[sec]
		if section.material == mat:
			sections.append(sec)     ## collect all the sections of mat

	print fnln(),'sections of ',mat,'are:',sections

	objs = []
	for section in part.sectionAssignments:   ## a list
		sectionName = section.sectionName
##		print sectionName
		if sectionName in sections:
			setname = section.region[0]
##			print 'setname =',setname
			objs1 = set2objs(part,setname)
			if objs1 not in empty:
				objs = objs + objs1

	return objs

_mat = objs_of_material

def objs_of_mdb_leaf(leaf):
	## VER: 2014-04-29, v1.1, note: one leaf just as one book leaf, but current dg can consists of many leafs.

	print fnln(),fnln(),'leaf.validModules=',leaf.validModules

	if leaf.validModules == ALL:
		vpnow = get_vpnow()
		if type_of(vpnow.displayedObject) == 'PART':
			objs = [vpnow.displayedObject]
		elif type_of(vpnow.displayedObject) == 'ASSEMBLY':
			objs = remove_hide_suppress_insts()
		else:
			raise Exception('*** A part or assembly leaf is required.')

	else:
		dpo = get_dpo()

		objs = []
		for member in leaf.__members__:
			if member != 'validModules':
				type1 = member
				objs0 = get_attrib(leaf,member)
				if objs0 not in empty:
					objs = objs0
					if member.endswith('Seq'):
	##				if len(leaf.__members__) > 2:   ## include such as: faceSeq, cellSeq, edgeSeq, vertexSeq
						objs = ()

					if type_of(objs) == 'TUPLE':
						objs = list(objs)
					else:
						objs = totext(objs)
						if objs == 'DEFAULT_MODEL':
							if totext(leaf.validModules) == 'PART':
								objs = [dpo.name]
							else:
								objs = a.instances.keys()
						objs = tolist(objs)
					break

		if type_of(dpo) == 'ASSEMBLY':
			objs = remove_hide_suppress_insts(objs)

##		a.regenerate()
##		hide_insts = get_hiden_insts()
##		suppr_insts = get_suppressed_insts()
##		objs = unselect(objs,hide_insts)
##		objs = unselect(objs,suppr_insts)

	if objs not in empty:
		objs = sorted(objs)

	return objs

def objs_of_odb_leaf(leaf):
	## VER: 2014-04-28, v1.0, note: one leaf just as one book leaf, but current dg can consists of many leafs.

	## pick nodes at odb viewport and create dg:
##	>>> objs_of_odb_leaf(dg.root.leaf)
##	[('GREEN_A1', 21, ('[#0:29 #4000010 #0:4 #40000000 #0:200 #7fc00 #0:62', ' #1ff0 ]'))]
##	>>>

	if totext(leaf.validModules) != 'ODB':
		raise Exception('*** An odb leaf is required.')

	objs = []
	for member in leaf.__members__:
		if member != 'validModules':
			type1 = member
			objs0 = get_attrib(leaf,member)
			if objs0 not in empty:
				objs = objs0
				if len(leaf.__members__) > 2:   ## include such as: faceSeq, cellSeq, edgeSeq, vertexSeq
					objs = ()

				if type_of(objs) == 'TUPLE':
					objs = list(objs)
				else:
					objs = totext(objs)
					if objs == 'DEFAULT_MODEL':
						objs = oa.instances.keys()
					objs = tolist(objs)
				break

	if objs not in empty:
		objs = sorted(objs)

	return objs

def objs_span(objs,poi=None):
	## VER: 2016-09-13, v1.0
	## 可以用来获得烧结后的part的节点的翘曲。事先需要选择节点并建立set

	x1,x2,y1,y2,z1,z2 = objs_space(objs=objs,poi=poi)
	spanx = round(x2-x1,3)
	spany = round(y2-y1,3)
	spanz = round(z2-z1,3)

	return spanx,spany,spanz

function_labels['objs_xmin'] = 'objs','loc','vertice'
def objs_xmin(objs):
	## VER: 2017-10-25, v1.0
	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	return x1

function_labels['objs_xmax'] = 'objs','loc','vertice'
def objs_xmax(objs):
	## VER: 2017-10-25, v1.0
	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	return x2

function_labels['objs_ymin'] = 'objs','loc','vertice'
def objs_ymin(objs):
	## VER: 2017-10-25, v1.0
	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	return y1

function_labels['objs_ymax'] = 'objs','loc','vertice'
def objs_ymax(objs):
	## VER: 2017-10-25, v1.0
	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	return y2

function_labels['objs_zmin'] = 'objs','loc','vertice'
def objs_zmin(objs):
	## VER: 2017-10-25, v1.0
	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	return z1

function_labels['objs_zmax'] = 'objs','loc','vertice'
def objs_zmax(objs):
	## VER: 2017-10-25, v1.0
	x1,x2,y1,y2,z1,z2 = objs_space(objs)
	return z2

def objs_space(objs,poi=None):
	## VER: 2014-12-10, v2.5
	## 利用bounding box来获取范围。

	if type_of(objs) in ['PART','PINSTANCE','ASSEMBLY']:
		objs,poi = poi, objs

	if type_of(objs) == 'STR':
		objs = set2objs(objs,poi=poi)

	objs = tolist(objs)   ## single obj will also turn to be a list.
	if poi in empty:
		poi = get_poi(objs[0])   ## only applicable for one poi

	if type_of(objs[0]) == 'cells':
		indexs = []
		cells = objs
		for cell in cells:
			indexs0 = tolist(cell.getFaces())
			indexs = merge_lists(indexs, indexs0)

		faces = []
		for index in indexs:
			face = poi.faces[index]
			if face not in faces:
				if len(face.getCells()) == 1:  ## Exterior only
					faces.append(face)
		objs = faces

	elif type_of(objs[0]) == 'edges':   ## 如果全都是直线，则可根据点的范围来确定。
		shapes = []
		for edge in objs:
			shape1 = edge_shape(edge)
			if shape1 not in shapes:
				shapes.append(shape1)
		if len(shapes) == 1 and shapes[0] == 'line':
			vertices = edges_to_vertices(objs)
			objs = vertices
##	elif type_of(objs[0]) == 'nodes':
##		element = objs[0].getElements()[0]
##		if repr((element.type)).startswith('C3D8'):
##			nodes = []
##			for obj in objs:
##				if len(obj.getElemEdges()) <= 5:
##					nodes.append(obj)
##			objs = nodes

	data_type = type_of(objs[0])
##	print fnln(),'data_type=',data_type

	type0 = type_of(objs[0])
	seq0 = list2sequence(objs)
	x10,x20,y10,y20,z10,z20 = space_of_sequence(seq0)  ## 很可能是错误的。BoundingBox的方法不准。
	space0 = x10,x20,y10,y20,z10,z20
	space = x10,x20,y10,y20,z10,z20

	xranges = [x10,x20]
	yranges = [y10,y20]
	zranges = [z10,z20]

##	print fnln(),'space0=',space0

	float_x = max(get_float_num(x10), get_float_num(x20))
	float_y = max(get_float_num(y10), get_float_num(y20))
	float_z = max(get_float_num(z10), get_float_num(z20))

	if float_x >= 5 or float_y >= 5 or float_z >= 5:
		objs1 = None
		if type0 == 'faces':
			type1 = 'edges'

			indexs = []
			for face in objs:
				indexs0 = tolist(face.getEdges())
				indexs = merge_lists(indexs, indexs0)

			edges = []
			for index in indexs:
				edge = poi.edges[index]
				if edge not in edges:
					edges.append(edge)
			objs1 = edges

		elif type0 == 'edges':
			type1 = 'vertices'

			indexs = []
			for edge in objs:
				indexs0 = tolist(edge.getVertices())
				indexs = merge_lists(indexs, indexs0)

			vertices = []
			for index in indexs:
				vertice = poi.vertices[index]
				if vertice not in vertices:
					vertices.append(vertice)
			objs1 = vertices

		if objs1 not in empty:
			seq1 = list2sequence(objs1)
			space1 = space_of_sequence(seq1)
			x11,x21,y11,y21,z11,z21 = space1

			## 简单枚举,收集
			xranges = xranges + [x11,x21]
			yranges = yranges + [y11,y21]
			zranges = zranges + [z11,z21]

			xranges = remove_repeated_items(xranges)
			yranges = remove_repeated_items(yranges)
			zranges = remove_repeated_items(zranges)

			xranges = sort(xranges)
			yranges = sort(yranges)
			zranges = sort(zranges)

			xranges = correct_range(xranges)
			yranges = correct_range(yranges)
			zranges = correct_range(zranges)

			space1 = xranges + yranges + zranges

##			print fnln(),'space1=',space1
##			x12,x22,y12,y22,z12,z22 = check_space(space0,space1)
##			print ' '
##			print fnln(),'space1=',space1

			f1,f2,f3,f4,f5,f6 = space0
			x1,x2,x3,x4,x5,x6 = space1

			## symmetric
			if PK(f1,-f2) == 0:  ## 优先取对称的。
				x1,x2 = f1,f2

			if PK(f3,-f4) == 0:
				x3,x4 = f3,f4

			if PK(f5,-f6) == 0:
				x5,x6 = f5,f6

			space = x1,x2,x3,x4,x5,x6

	## 下面考察x,y,z,z相互之间的对称关系。
	x1,x2,x3,x4,x5,x6 = space

	if PK(-x1,x2) == 0 and PK(-x5,x6) == 0:
		if abs(x2 - x6) < 2e-4:
			num2 = get_float_num(x2)
			num6 = get_float_num(x6)
			if num2 > num6:
				x1,x2 = -x6,x6
			elif num2 < num6:
				x5,x6 = -x2,x2

	if PK(-x1,x2) == 0 and PK(-x3,x4) == 0:
		if abs(x2 - x4) < 2e-4:
			num2 = get_float_num(x2)
			num4 = get_float_num(x4)
			if num2 > num4:
				x1,x2 = -x4,x4
			elif num2 < num4:
				x3,x4 = -x2,x2

	if PK(-x5,x6) == 0 and PK(-x3,x4) == 0:
		if abs(x6 - x4) < 2e-4:
			num6 = get_float_num(x6)
			num4 = get_float_num(x4)
			if num6 > num4:
				x5,x6 = -x4,x4
			elif num6 < num4:
				x3,x4 = -x5,x6

	return x1,x2,x3,x4,x5,x6

function_labels['odb_to_part'] = 'odb','part','import','deformed','postprocessing','flatness'
def odb_to_part(step_name=None,step_id=None,step_num=None,frame=-1):
	## VER: 2017-06-20, v1.1

	refresh()
	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) != 'ODB':
		raise Exception('*** an odb is required in the viewport')

	path = odb.path
	for path1 in session.odbs.keys():
		if path1 != path:
			session.odbs[path1].close()

	insts = []
	names = []
	for inst in oa.instances.values():
		if inst.type == DEFORMABLE_BODY:
			insts.append(inst)
			names.append(inst.name)

	print fnln(),'deformed instances=',names
	if len(insts) != 1:
		dict1 = {}
		for inst in insts:
			nodes_num = max(len(inst.elements[0].connectivity),len(inst.elements[50].connectivity),len(inst.elements[-1].connectivity))
			if nodes_num not in dict1.keys():
				dict1[nodes_num] = []
			dict1[nodes_num].append(inst)
		max_num = max(dict1.keys())
		if len(dict1[max_num]) == 1:
			insts = dict1[max_num]

	if len(insts) != 1:
		raise Exception('*** Need only one deformed instance in the odb. Maybe this is an compaction odb?')

	inst = insts[0]

	if (step_name,step_id,step_num) == (None,None,None):
		step_id = -1

	step = check_odb_step(step_num=step_num,step_id=step_id,step_name=step_name)
	step_num = step.number
	step_id = step.number - 1		## num从1开始，id从0开始，所以num=id+1
	step_name = step.name

	frame_ids = range(len(step.frames))
	if frame < 0:
		frame_id = frame_ids[frame]
	else:
		frame_id = frame

	p = _m.PartFromOdb(name=odb.analysisTitle, instance=inst.name, odb=odb, shape=DEFORMED, step=step_id, frame=frame_id)
	vpnow.setValues(displayedObject=p)

	refresh()
	del_pick_sets()
	get_p1()

	return p.name


def odb_variables(variable='',main='',sub=''):
	## VER: 2015-07-07, v1.3

##	>>> variables = odb_variables()
##	>>> 'COOR1' in variables.keys()
##	False
##	>>> 'COOR' in variables.keys()
##	False
##	>>> 'COORd' in variables.keys()
##	False
##	>>> 'COORD' in variables.keys()
##	True
##	>>>

##>>> _print(contour.fieldVariables.variableList)
##('tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object', 'tuple object')
##>>>

## 下面：3.40282346638529 = 3.402823
##	>>> vpnow = get_vpnow()
##	>>> display = vpnow.odbDisplay
##	>>> display.fieldVariables.variableList
##	(('AC YIELD', 'Active yield flag', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('AC YIELD1', 'Active yield flag for PEQC1', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('AC YIELD2', 'Active yield flag for PEQC2', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('AC YIELD3', 'Active yield flag for PEQC3', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('AC YIELD4', 'Active yield flag for PEQC4', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CENER', 'Creep dissipation energy density', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('CF', 'Point loads', 1, 'at nodes', 4, 'vector', 0, (('Magnitude', 10),), (('CF1', 0), ('CF2', 1), ('CF3', 2)), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CNORMF', 'Contact Normal Force Vector', 4, 'at surface nodes', 4, 'vector', 0, (('Magnitude', 10),),
##		(('CNF1', 0), ('CNF2', 1), ('CNF3', 2)), (), 0, 0, -3.402823e+38, 3.402823e+38),

	please_check
##	('COORD', 'Coordinates', 1, 'at nodes', 4, 'vector', 0, (('Magnitude', 10),), (('COOR1', 0), ('COOR2', 1), ('COOR3', 2)), (), 0, 0, -3.402e+38, 3.402e+38),
##	('COPEN', 'Contact opening ', 4, 'at surface nodes', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CPRESS', 'Contact pressure', 4, 'at surface nodes', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CSHEAR1', 'Frictional shear stress', 4, 'at surface nodes', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CSHEAR2', 'Frictional shear stress', 4, 'at surface nodes', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CSHEARF', 'Contact Shear Force Vector', 4, 'at surface nodes', 4, 'vector', 0, (('Magnitude', 10),),
##		(('CSF1', 0), ('CSF2', 1), ('CSF3', 2)), (), 0, 0, -3.402823e+38, 3.402823e+38),

##	('CSLIP1', 'Relative tangent', 4, 'at surface nodes', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CSLIP2', 'Relative tangent', 4, 'at surface nodes', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('CSTATUS', 'Contact Status     ', 4, 'at surface nodes', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('DMENER', 'Damage dissipation energy density', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('EE', 'Elastic strain components', 2, 'at integration points', 9, 'tensor', 0,
##		(('Max. Principal', 0), ('Max. Principal (Abs)', 11), ('Mid. Principal', 1), ('Min. Principal', 2)),
##		(('EE11', 0), ('EE22', 1), ('EE33', 2), ('EE12', 3), ('EE13', 4), ('EE23', 5)), (), 0, 0, -3.402823e+38, 3.402823e+38),
##
##	('EENER', 'Electrostatic energy density', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('EVOL', 'Element volume', 5, 'for whole element', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('IE', 'Inelastic strain components', 2, 'at integration points', 9, 'tensor', 0,
##		(('Max. Principal', 0), ('Max. Principal (Abs)', 11), ('Mid. Principal', 1), ('Min. Principal', 2)),
##		(('IE11', 0), ('IE22', 1), ('IE33', 2), ('IE12', 3), ('IE13', 4), ('IE23', 5)), (), 0, 0, -3.402823e+38, 3.402823e+38),
##
##	('JENER', 'Electrical current dissipation per unit volume', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('LE', 'Logarithmic strain components', 2, 'at integration points', 9, 'tensor', 0,
##		(('Max. Principal', 0), ('Max. Principal (Abs)', 11), ('Mid. Principal', 1), ('Min. Principal', 2)),
##		(('LE11', 0), ('LE22', 1), ('LE33', 2), ('LE12', 3), ('LE13', 4), ('LE23', 5)), (), 0, 0, -3.402823e+38, 3.402823e+38),
##
##	('P', 'Pressure loads', 3, 'on element face', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('PDLOAD', 'Pressure from distributed loads', 3, 'on element face', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('PE', 'Plastic strain components', 2, 'at integration points', 9, 'tensor', 0,
##		(('Max. Principal', 0), ('Max. Principal (Abs)', 11), ('Mid. Principal', 1), ('Min. Principal', 2)),
##		(('PE11', 0), ('PE22', 1), ('PE33', 2), ('PE12', 3), ('PE13', 4), ('PE23', 5)), (), 0, 0, -3.402823e+38, 3.402823e+38),
##
##	('PEEQ', 'Equivalent plastic strain', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('PEMAG', 'Magnitude of plastic strain', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('PENER', 'Plastic dissipation energy density', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('PEQC1', 'Equivalent plastic strain', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('PEQC2', 'Equivalent plastic strain', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('PEQC3', 'Equivalent plastic strain', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('PEQC4', 'Equivalent plastic strain', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, -3.402823e+38, 3.402823e+38),
##	('RF', 'Reaction force', 1, 'at nodes', 4, 'vector', 0, (('Magnitude', 10),), (('RF1', 0), ('RF2', 1), ('RF3', 2)), (), 0, 0, -3.4028e+38, 3.4028e+38),
##	('S', 'Stress components', 2, 'at integration points', 9, 'tensor', 0,
##		(('Mises', 6), ('Max. Principal', 0), ('Max. Principal (Abs)', 11), ('Mid. Principal', 1), ('Min. Principal', 2), ('Tresca', 7), ('Pressure', 8),
##		('Third Invariant', 9)), (('S11', 0), ('S22', 1), ('S33', 2), ('S12', 3), ('S13', 4), ('S23', 5)), (), 0, 0, -3.402823e+38, 3.402823e+38),
##
##	('SENER', 'Strain energy density', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38),
##	('U', 'Spatial displacement', 1, 'at nodes', 4, 'vector', 0, (('Magnitude', 10),), (('U1', 0), ('U2', 1), ('U3', 2)), (), 0, 0, -3.4028e+38, 3.4028e+38),
##	('VENER', 'Viscous dissipation energy density', 2, 'at integration points', 3, 'scalar', 0, (), (), (), 0, 0, 0.0, 3.402823e+38))
##	>>>

##	outputPosition
##	A SymbolicConstant specifying the position from which to obtain data. Data can be obtained only from the position at which they were written to the
##	output database during the analysis. This position should be aligned with the field output variable. Possible values are:
##		UNDEFINED_POSITION
##		NODAL 节点
##		INTEGRATION_POINT 积分点
##		ELEMENT_FACE  单元表面
##		ELEMENT_NODAL 单元节点
##		ELEMENT_CENTROID 单元中心
##		WHOLE_ELEMENT 整个单元
##		WHOLE_REGION 整个区域
##		WHOLE_PART_INSTANCE 整个部件
##		WHOLE_MODEL 各个模型
##		GENERAL_PARTICLE 一般颗粒
##	The default value is UNDEFINED_POSITION.
##
##	dataType
##	A SymbolicConstant specifying the data type of the field output variable which should be aligned with the variable. Currently only SCALAR is supported.
##	Possible values are:
##		ENUMERATION
##		BOOLEAN
##		INTEGER
##		SCALAR
##		VECTOR
##		QUATERNION_2D
##		QUATERNION_3D
##		TENSOR
##		TENSOR_3D_FULL
##		TENSOR_3D_PLANAR
##		TENSOR_3D_SURFACE
##		TENSOR_2D_PLANAR
##		TENSOR_2D_SURFACE
##	The default value is SCALAR

##	print fnln(),'Reading fieldVariables...'
	vpnow = get_vpnow()
	display = vpnow.odbDisplay

	vars = {}
	for var in display.fieldVariables.variableList:  ## 获得odb中的所有可能的output variables及其output position
		main0 = var[0]
		main1 = main0
		if '   ' in main1:
			loc = main1.find('   ')
			main1 = main1[:loc]

		description = var[1]

		position = var[3]
		position0 = position
		if position == 'at nodes':
			position = NODAL
		elif position == 'at integration points':
			position = INTEGRATION_POINT
		elif position in ['at element nodes', 'at surface nodes']:
			position = ELEMENT_NODAL
		elif position == 'for whole element':
			position = WHOLE_ELEMENT
		elif position == 'on element face':  ## such as PLOAD(位置相关的分布压强载荷，如HPHT的anvil的压强分布）
			position = ELEMENT_FACE
		else:
			raise Exception('*** Fail to get the position. Please manually plot the variable contour ' + repr(main0) +' and find the position in .rpy file')
			## such as: plot EVOL variable in GUI:
##			session.viewports['Viewport: 1'].odbDisplay.setPrimaryVariable( variableLabel='EVOL', outputPosition=WHOLE_ELEMENT, )

		invariants = var[7]
		if invariants not in empty:
			newlist = []
			for sub_var,num in invariants:
				newlist.append(sub_var)
			invariants = newlist
		else:
			invariants = []

		components = var[8]
		if components not in empty:
			newlist = []
			for sub_var,num in components:
				newlist.append(sub_var)
			components = newlist
		else:
			components = []

		subs = invariants + components
		refinement = 'NA'
		if subs in empty:
			refinement = None
		else:
			if 'Magnitude' in subs:
				refinement = (INVARIANT, 'Magnitude')
			elif 'Max. Principal' in subs:
				refinement = (INVARIANT, 'Max. Principal')

		## 千万不能用main1作为key !!!
		vars[main0] = {'main':main0, 'main1':main1,'subs':subs, 'refinement':refinement, 'description':description, 'position':position, 'invariants':invariants, 'components':components, 'position0':position0}

##	vars = odb_variables()
##	vars1 = []
##	for var in vars.keys():
##		info = vars[var]
##		if (info['invariants'] in empty and info['components'] not in empty) or (info['invariants'] not in empty and info['components'] in empty): 其中一个为空
##			vars1.append(var)
##
##	print vars1	## 结果为：['COORD', 'ALPHA']
##	>>> odb_variables('COORD')
##	{'description': 'Coordinates', 'invariants': '', 'position0': 'at integration points', 'components': ['COORD1', 'COORD2'], 'position': INTEGRATION_POINT, 'main': 'COORD'}
##	>>> odb_variables('alpha')
##	{'description': 'Kinematic hardening shift tensor', 'invariants': '', 'position0': 'at integration points', 'components': ['ALPHA11', 'ALPHA22', 'ALPHA33', 'ALPHA12'], 'position': INTEGRATION_POINT, 'main': 'ALPHA'}
##	>>>

##	if 'COORD' in vars.keys():
##		vars['COORD']['components'] = ['COOR1', 'COOR2', 'COOR3','COORD1', 'COORD2', 'COORD3']

	if main not in empty:
		variable = main

	if variable not in empty:
		if variable[-1] in ['1','2','3'] and (variable[-2].isdigit() == False):
			seq = eval(variable[-1])
			variable = variable.upper()
			if variable[:-1] in vars.keys():
				var0 = variable
				variable = variable[:-1]
				if var0 in vars[variable]['subs']:	## COORD1
					sub = var0
				else:
					if seq == 1:
						if 'Max. Principal' in vars[variable]['invariants']:
							sub = 'Max. Principal'
					elif seq == 2:
						if 'Mid. Principal' in vars[var0]['invariants']:
							sub = 'Mid. Principal'
					elif seq == 3:
						if 'Min. Principal' in vars[var0]['invariants']:
							sub = 'Min. Principal'

		if variable.upper() in vars.keys():
			variable = variable.upper()
		else:
			for key, info in vars.items():
				if variable in info['subs']:
					sub = variable
					variable = key
					break

		if variable not in vars.keys():
			if variable == 'TEMP' and 'NT11' in vars.keys():
				variable = 'NT11'
		elif '(Avg: 75%)' in variable:
			loc = variable.find('(Avg: 75%)')
			variable = variable[:loc-1]
			variable = variable.strip()

		if variable in vars.keys():
			vars = vars[variable]

			if sub not in empty:
				if sub in vars['components']:
					refinement = (COMPONENT,sub)
					vars['refinement'] = refinement
				elif sub in vars['invariants']:
					refinement = (INVARIANT,sub)
					vars['refinement'] = refinement
				else:
					print fnln(),'sub=',sub
					raise Exception('*** Incorrect sub=' + sub)
		else:
			raise Exception('*** No such output variable =' + variable)

	return vars

def odb_insts_names(list1):
	## VER: 2011-12-29, v1.0

	list1 = tolist(list1)
	names = []
	for inst in list1:
		if type_of(inst) == 'ODBINSTANCE':
			if inst.name not in names:
				names.append(inst.name)

	return names

def odb_main_vars():
	## VER: 2014-03-24, v1.1

	vars = odb_variables()
	main_vars = sorted(vars.keys())
##	vars = odb.steps.values()[-1].frames[-1].fieldOutputs.keys()

	return main_vars

def odb_node_select(p,x=(),y=(),z=(), poiRefX=(), poiRefY=(),poiRefZ=(), space=(), nodes=None, elements=None, edges=None, faces=None,
	groupX=None, groupY=None, groupZ=None, include_mid_points=False, tryone=False,exterior=True,err=0.1,step=-1,frame=-1,nx=0,ny=0,nz=0,angle=10,err_angle=1):
	## VER: ('VER: 2015-12-09, v1.4')

	## Example: nodes = odb_node_select('p00',y=MIN,ny=-1)

##	p = import_part_from_odb('p00')   ## 先生成cae part，并在cae中选择比较灵活。
##	nodes1 = node_select(p,ny=-1,y=MIN)
##	nodes2 = node_select(p,nodes=nodes1,z=MID)

	p = check_odb_inst(p)
	name = p.name

	partname = import_part_from_odb(p,step_id=step,frame=frame)

	labels0 = []
	if nodes not in empty:
		nodes = tolist(nodes)
		if is_numbers(nodes):
			labels0 = nodes
		elif type_of(nodes[0]) == 'ODBMESHNODE':
			labels0 = labels_of_nodes(nodes)
		elif type_of(nodes[0]) == 'STR':
			labels0 = labels_of_odb_node_set(nodes[0])
		else:
			raise Exception('*** Error nodes')

	if (nx,ny,nz) != (0,0,0):
		nodes1 = nodes_by_face(partname,x=x,y=y,z=z,poiRefX=poiRefX, poiRefY=poiRefY,
			poiRefZ=poiRefZ, space=space,nx=nx,ny=ny,nz=nz,angle=angle,err=err_angle)

	else:
		nodes1 = node_select(partname, x=x, y=y, z=z, poiRefX=poiRefX, poiRefY=poiRefY, poiRefZ=poiRefZ, space=space, groupX=groupX, groupY=groupY,
			groupZ=groupZ, exterior=exterior, err=err)

	labels1 = labels_of_nodes(nodes1)
	if labels0 not in empty:
		labels = get_common(labels0,labels1)
	else:
		labels = labels1

	p1 = _part(partname)

	nodes = []
	for label in labels:
		nodes.append(p1.nodes[label-1])

	return nodes,labels   ## nodes can be highlighted in cae


def odb_node_select2(p,x=(),y=(),z=(), tryone=False, loc=None, tolerance=5, highlight=False, cae_method=False):
	## VER: ('VER: 2013-11-06, v1.3')
	## default tolerance = 1mm if loc not in empty.
	## exmaple: odb_node_select(FRL_A1,x=_xmin(FRL_A1) + 12, z=MIN,y=MIN, highlight=True)
	## tolerance in unit mm.

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) != 'ODB':
		raise Exception('No odb is plotted in the vpnow.')

	p = check_odb_inst(p)

	refresh()

	if type_of(loc) == 'TUPLE':
		x,y,z = loc

##	x,y,z = real_xyz(p,x,y,z)
##	x1,x2,y1,y2,z1,z2 = tospace(x,y,z)
##
##	if loc in empty and PK(x1,x2) == 0 and PK(y1,y2) == 0 and PK(z1,z2) == 0:
##		loc = (x1,y1,z1)
##	else:
##		print 'x1,x2,y1,y2,z1,z2 =',(x1,x2,y1,y2,z1,z2)

	if cae_method == True:
		cae_file_title = odb_title_of_inst(p)
		try:
			open_cae(cae_file_title)
		except:
			cae_method = False

	mynodes = []
	if cae_method == True:
		for inst in a.instances.keys():
			if inst.upper() == p.name:
				cae_inst = inst
				break

		cae_nodes = node_select(cae_inst,x=x,y=y,z=z,tryone=tryone, loc=loc, tolerance=tolerance)
		labels = labels_of_nodes(cae_nodes)
		mynodes = get_odb_nodes_by_labels(p,labels)

		if loc not in empty and highlight == True:
			print ' '
			light(mynodes[0])

	else:
		if is_numeric(x) == False or is_numeric(y) == False or is_numeric(z) == False:
			raise Exception('*** numeric x,y,z or the range is required.')

		x1,x2,y1,y2,z1,z2 = tospace(x,y,z)

		index = get_sequence_index(oa.instances.keys(), p.name)
		nodes = all_odb_nodes[index]

		if loc in empty:
			for node in tolist(nodes):
				loc = loc_of_odb_node(p,node.label)
				if within_range(loc[0],x1,x2):
					if within_range(loc[1],y1,y2):
						if within_range(loc[2],z1,z2):
							mynodes.append(node)

							if tryone == True:
								break

		else:
			print 'Finding nodes nearby loc=',loc,', with the select tolerance=',tolerance,'...'
			for node in tolist(nodes):
				loc0 = loc_of_odb_node(p,node.label)
				dist = get_distance(loc,loc0)
				if tolerance - dist > 1e-6 or abs(tolerance - dist) <= 1e-6:
					mynodes.append(node)

			print len(mynodes),'nodes are found. Now selecting the only one most close to',loc
			if len(mynodes) > 1:
				target = mynodes[0]
				for i in range(len(mynodes))[1:]:
					loc1 = loc_of_odb_node(p,target.label)
					loc2 = loc_of_odb_node(p,mynodes[i].label)

					dist1 = get_distance(loc,loc1)
					dist2 = get_distance(loc,loc2)
					if dist2 < dist1:
						target = mynodes[i]

				mynodes = [target]

		if len(mynodes) == 0:
			print fnln_fnln(),'******Selection of nodes failed.'
		else:
			print fnln_fnln(),len(mynodes),'nodes selected'
			if loc not in empty:
				print 'Node label=',mynodes[0].label,'fro loc=',loc
				if highlight == True:
					print ' '
					light(mynodes[0])

	return mynodes

def odb_node_set_to_nodes(setname):
	## VER: ('VER: 2015-06-23, v1.1')

##	>>> nodes = odb_node_set_to_nodes('dim_smallR_y')
##	>>> nodes
##	[session.openOdb(r'E:/FEM/A0242_sintering_simple/CM_A0242_compen_mapping_delta1_notray.odb').rootAssembly.instances['green_A1'].nodes[27], session.openOdb(r'E:/FEM/A0242_sintering_simple/CM_A0242_compen_mapping_delta1_notray.odb').rootAssembly.instances['green_A1'].nodes[71]]
##	>>> len(nodes)
##	2

	if type_of(setname) != 'STR':
		raise Exception('odb node setname is required.')

	setname = setname.upper()	## odb node set都会自动转为大写。
	if setname not in oa.nodeSets.keys():
		raise Exception('odb node setname= ' + setname + ' is not exist in oa.nodeSets.keys()')

	myset = oa.nodeSets[setname]

	## 假如只有一个inst，例如：create_odb_node_set(labels=(1,5,3),inst=FRL_A1,name='set2')
	## myset.nodes = (['OdbMeshNode object', 'OdbMeshNode object', 'OdbMeshNode object'], )
	## 假如有多个inst，例如: create_odb_node_set(nodes=(FRL_A1.nodes[0],FRL_A1.nodes[5],FRS_A1.nodes[3]),name='set3')
	## myset.nodes = (['OdbMeshNode object', 'OdbMeshNode object'], ['OdbMeshNode object'])
	## 可见：myset.nodes是sequence形式，其中的每个元素就是一个列表，对应一个实例。

	mynodes = []
	for i in range(len(myset.nodes)):
		for j in range(len(myset.nodes[i])):
			mynodes.append(myset.nodes[i][j])

	return mynodes


def odb_nodes_to_sequence(nodes=(),labels=None, inst=None):
	## VER: ('VER: 2012-04-04, v1.1')

	## 假如只有一个inst，例如：create_odb_node_set(labels=(1,5,3),inst=FRL_A1,name='set2')
	## myset.nodes = (['OdbMeshNode object', 'OdbMeshNode object', 'OdbMeshNode object'], )
	## 假如有多个inst，例如: create_odb_node_set(nodes=(FRL_A1.nodes[0],FRL_A1.nodes[5],FRS_A1.nodes[3]),name='set3')
	## myset.nodes = (['OdbMeshNode object', 'OdbMeshNode object'], ['OdbMeshNode object'])
	## 可见：myset.nodes是sequence形式，其中的每个元素就是一个列表，对应一个实例。

	## Odb label is stored with index = label - 1, such as:
##	>>> nodes = oa.instances.values()[0].nodes
##	>>> nodes[720].label
##	721


	if nodes in empty and inst in empty:
		inst = oa.instances.keys()[0]

	if inst not in empty:
		inst = check_odb_inst(inst)

	seq = []
	if labels not in empty:
		labels = tolist(labels)

		if type_of(labels[0]) != 'INT':
			raise Exception('label numbers are required.')

		labels.sort()

		if inst in empty:
			raise Exception('inst is required due to node labels are provided.')

		for label in labels:
			seq.append(inst.nodes[label-1:label])	## seq中的每一个元素就是一个片段.

	elif nodes not in empty:
		nodes = tolist(nodes)

		if type_of(nodes[0]) != 'ODBMESHNODE':
			raise Exception('odb nodes are required.')

		for node in nodes:
			poi = get_poi(node)
			label = node.label
			seq.append(poi.nodes[label-1:label])

	if len(seq) == 1:
		seq = (seq[0],)

	else:
		for i in range(len(seq)):
			for j in range(len(seq))[i + 1:]:
				if seq[j][0].label < seq[i][0].label:		##按升序排列
					temp = seq[i]
					seq[i] = seq[j]
					seq[j] = temp

	return seq

def odb_of_part():
	## VER: 2016-09-08, v1.1
	## To get the odb name of the deformed part imported, so as to save the mdb if unnamed.

##odb = session.odbs['Z:/A0271-A0274-USM_insert_B106_B109/sintering/batch2/AI_A0271_H10F_B102.odb']
##p = mdb.models['Model-1'].PartFromOdb(name='GREEN_A1', instance='GREEN_A1',
##    odb=odb, shape=DEFORMED, step=0, frame=17)

##	>>> odb_of_part()
##	'AI_A0271_H10F_B102.odb'
##	>>>

##	>>> get_cae_file_title()
##	'unnamed'
##	>>>

	get_current_model()

	dpo = get_dpo()
	if type_of(dpo) != 'PART':
		if len(_m.parts) == 1:
			dpo = _m.parts.values()[0]

		else:
			print '** Please switch the viewport to Part module.'
			return ''

	file1 = open(get_rpy()).readlines()
	odb = ''
	num = 0
	for i in range(len(file1) -1, -1, -1):
		num += 1
		if num > 1000:
			break

		line = file1[i]
		line_1 = file1[i-1]

		if ('.PartFromOdb(' in line and '#' not in line) and ('= session.odbs[' in line_1 and '/' in line_1):
			code = line_1.strip()
			loc = code.rfind('/')
			odb = code[loc + 1:-2]
			break

	if dpo.name == 'GREEN_A1':
		name1 = new_key(_m.parts.keys(),'sintered_part')
		rename(dpo.name,name1)

	if odb != '':
		print fnln(),'odb of imported part is',odb
	else:
		print fnln(),'*** Fail to get the odb of imported part.'

	return odb

def odb_shape():
	## VER: 2015-03-30, v1.0

	spaces = []
	for inst in oa.instances.values():
		space = inst.embeddedSpace  ## such as: THREED
		if space not in spaces:
			spaces.append(space)

	return spaces

def odb_title_of_inst(inst):
	## VER: ('VER: 2012-03-30, v1.0')

	inst = check_odb_inst(inst)

	if type_of(inst) != 'ODBINSTANCE':
		raise Exception('Odb instance object is required.')

	s = repr(inst)
	loc1 = s.rfind('/') + 1
	loc2 = s.find('.odb')

	title = s[loc1:loc2]

##	print fnln_fnln(),'--->Got odb title from inst=',inst.name

	return title

def odbs_res2file(*odbs):
	## VER: 2014-11-04, v1.0

	odbs = tolist(odbs)

	odbs = real_files(odbs,'.odb')
	for odb in odbs:
		open_odb(odb)
		res2file()

	return

def open_cae(title,new_name=None):
	## VER: ('VER: 2015-07-07, v1.6')
	## Reference: open_odb()

	global build_model

	build_model = False

	vpnow = get_vpnow()

	if type_of(title) != 'STR':
		raise Exception('*** cae file name is required.')

	if '.cae' not in title:
		title = title + '.cae'

##	if title[0] == '/':
##		title = title[1:]

	path1 = search_file(title)

##	if os.path.isfile(title):	## 大小写不相关
	if path1 not in empty:
		openMdb(pathName=path1)
		print fnln(),'Opened',title,', but viewport will be empty.'
	else:
		raise Exception('File not found, fail to open cae file=',title)

	get_current_model()

##	raise Exception
	if len(_m.materials.keys()) == 0:
		material_database()

	if len(_m.interactionProperties.keys()) == 0:
		create_contact_props(friction=0.2)					;please_check('default=0.15')

	if new_name in empty and 'inp_file_title' in globals().keys():
		new_name = inp_file_title

	if type_of(new_name) == 'STR':
		if new_name not in title:
			if new_name[-4:] in ['.cae','.CAE']:
				new_name = new_name[:-4]
			mdb.saveAs(pathName=new_name)

	refresh()


	return

def open_odb(odb_file='',readonly=True,ask=None):
	## VER: ('VER: 2017-05-10, v2.7')

	global plot_history, odb, oa

	vpnow = get_vpnow()
	dpo_type = type_of(vpnow.displayedObject)

	print fnln(),'odb_file=',odb_file
	if is_file_path(odb_file):
		odb = session.openOdb(name=odb_file)

	else:
		if odb_file not in empty:
			if type_of(odb_file) == 'ODB':
				odb = odb_file
				odb_file = odb.analysisTitle
			elif type_of(odb_file) != 'STR':
				raise Exception('odb file name is required.')

		else:
			jobs = mdb.jobs.keys()
			if len(jobs) == 0:
				raise Exception('*** odb_file is required.')
			elif len(jobs) == 1:
				odb_file = jobs[0]
			else:  ## len(jobs) > 1
				dict1 = {}
				for job in jobs:
					statinfo = os.stat(job+'.odb')
					dict1[job] = statinfo.st_ctime  ## create time
				tuple1 = sort_by_value(dict1,reverse=True)
				odb_file = tuple1[0][0]

		if odb_file[-4:].lower() != '.odb':
			odb_file = odb_file + '.odb'

		## odb is global var
		found = False
		for odb1 in session.odbs.keys():   ## requested odb has been opened
			if odb_file in odb1:
				odb = session.odbs[odb1]
				found = True
				break

		if not found:
			path1 = search_file(odb_file)
	##		odb=session.openOdb(name=odb_file, readOnly=readonly)   ## session.odb.keys() will have this odb_file
			if path1 not in empty:
				odb=session.openOdb(name=path1, readOnly=readonly)
			else:
				raise Exception('*** Cannot find the odb file ' + repr(odb_file))

##	print fnln(),type_of(odb)  ## odb

	vpnow.setValues(displayedObject=odb)
	step = odb.steps.values()[-1]
	if len(step.frames) == 2 and step.frames[-1].frameValue < 1e-5:  ##  The first frame is the undeformed frame.
		if len(odb.steps) > 1:
			step = odb.steps.values()[-2]
			set_step_and_frame(step=step,frame=-1)  ## To avoid error in display the last frame of last step.

	vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))
	oa = odb.rootAssembly
##	vpnow.odbDisplay.basicOptions.setValues(mirrorAboutXzPlane=False, mirrorAboutYzPlane=False)

	if readonly == False:
		print odb_file,'is opened for write.'
	else:
		print odb_file,'is opened for read.'

	refresh(ask=ask)

	return	odb_file  ## string

def write_inp(file_name='Job1',overwrite=True,model_name=None,memory=85,request_num=6,submit=False):
	## VER: ('VER: 2014-12-29, v2.2')
	## 有时候并行计算出现问题，计算不下去。单核计算就没问题(使用ALE时)。

	if model_name in empty:
		model_name = current_model_name
	else:
		if model_name not in mdb.models.keys():
			raise Exception('*** Error model name')

	import multiprocessing
	core0 = multiprocessing.cpu_count()

	if core0 > 6:
		core0 = 6  ## one license allow only 6 cores

	if request_num > core0:
		if get_computer_name()[0:3] != 'CND':
			request_num = core0
		elif submit == True:
			request_num = core0

##	if len(_m.adaptiveMeshControls) > 0:
##		request_num = 1   ## 有ALE，例如metal cutting and powder compaction

##	if get_computer_name()[0:3] == 'CND':
##		request_num = 1
##		if request_num > 1:
##			num1 = raw_input('request_num:')
##			num1 = eval(num1)
##
##			if type_of(num1) == 'INT':
##				request_num = min(num1,6)

	## Explicit中使用多核可能出错。

	## 生成job，并在界面上submit，并不会自动保存cae文件，而是自动保存inp文件。
	## 也就是说，同一个cae文件，做不同设置并分别提交job后，如果没有手动保存cae，则cae文件并没有改动。
	mdb.Job(atTime=None, contactPrint=OFF, description=file_name,
	    echoPrint=OFF, explicitPrecision=SINGLE, getMemoryFromAnalysis=True,
	    historyPrint=OFF, memory=memory, memoryUnits=PERCENTAGE, model=model_name,
	    modelPrint=OFF, multiprocessingMode=DEFAULT, name=file_name,
	    nodalOutputPrecision=SINGLE, numCpus=request_num, numDomains=request_num,
	    parallelizationMethodExplicit=DOMAIN, queue=None, scratch='',
	    type=ANALYSIS, userSubroutine='', waitHours=0, waitMinutes=0)

	mdb.jobs[file_name].writeInput(consistencyChecking=OFF)

	print '--->Inp file was written:', file_name + '.inp, model_name=',model_name

	## set the script file to be readonly
	file_path = get_script_file()
	file_path = '"' + file_path + '"'
	comm = 'attrib +R ' + file_path
	print fnln(),'command =',comm
	os.system(comm)  ## file_path必须是绝对路径。不能仅仅是文件名。
##	stop1()


	return

def write_odb(symm_center='',textname='',text=''):

	## VER: ('VER: 2012-05-08, v1.3')

	read_only = True
	try:
		read_only = odb.isReadOnly
	except AccessError:
		print '****AccessError. write_odb failed.'
		return

	if read_only == True:
		print fnln_fnln(),'******odb is readonly, write odb failed.'
		return

	else:
		odb.userData.Annotation(name='Title1', objectToCopy=mdb.annotations['Title1'])

		print fnln_fnln(),'symm_center=',symm_center
##		raise Exception

		if 'CSYS-1' not in oa.datumCsyses.keys() and symm_center not in empty:
			symm_dir = symm_center['dir']
			symm_loc = symm_center['loc']

			scratchOdb = session.ScratchOdb(odb)
			scratchOdb.rootAssembly.DatumCsysByThreePoints(name='CSYS-1',
		   	coordSysType=CARTESIAN, origin=symm_loc, point1=(symm_loc[0]+1,
		   	symm_loc[1], symm_loc[2]), point2=(symm_loc[0],symm_loc[1]+1, symm_loc[2]))

			scratchOdb = session.scratchOdbs[odb_file_full_name]   ## 临时odb
			csys1 = scratchOdb.rootAssembly.datumCsyses['CSYS-1']
			oa.DatumCsys(name='CSYS-1', datumCsys=csys1)
			scratchOdb.rootAssembly.DeleteDatumCsys(name='CSYS-1')

			print 'Coordinate system *CSYS-1 is created for contour review in full model level by mirror.'
			print 'symmetry center=',symm_center
			print ' '

		if textname != '' and text != '':
			if textname not in odb.userData.annotations.keys():
				t = session.odbs[odb.name].userData.Text(
				    name=textname, text=text, offset=(8, -36), anchor=TOP_LEFT, referencePoint=TOP_LEFT)
	##			session.viewports['Viewport: 1'].plotAnnotation(annotation=t)

		odb.save()

	return

def output_odb_node_sets(step_name=-1,frame=-1):
	## VER: 2015-06-12, v1.1

	step = check_odb_step(step=step_name)
	step_name = step.name

	filename = '_dims_' + odb_file_title + '.txt'

	dict1 = {}
	for setname in oa.nodeSets.keys():
		set1 = oa.nodeSets[setname]
		if len(setname) > 20 or len(set1.instances) > 1:
			continue

		inst = set1.instances[0].name
		dims = odb_node_set_dims(setname,step_name=step_name,frame=frame)

		dict1[setname] = dims

	inst = find_powder_inst()
	partname = import_part_from_odb(odb_file_title,inst_name=inst,step_name=step_name,frame=frame)
	p = _m.parts[partname]

	part_space = poi_space(p)
	spans = spans_of_poi(p)

	file1 = open(filename,'w')
	print >> file1,' '
	print >> file1,'Date and time:','20' + time.strftime("%y %m %d %H:%M")
	print >> file1,'Printing node set dims, odb file title =',odb_file_title + '.odb'
	print >> file1, ' '
	print >> file1,'*** Overall dimensions:',spans
	print >> file1,' '

	nodes = node_select(p,x=0)
	x1,x2,y1,y2,z1,z2 = objs_space(nodes)
	xdim = smart_round(x2-x1)
	ydim = smart_round(y2-y1)
	zdim = smart_round(z2-z1)

	print >>file1,'Dimensions for x=0 nodes:'
	print >>file1,(xdim,ydim,zdim),[(x1,x2),(y1,y2),(z1,z2)]
	print >>file1,' '

	nodes = node_select(p,y=0)
	x1,x2,y1,y2,z1,z2 = objs_space(nodes)
	xdim = smart_round(x2-x1)
	ydim = smart_round(y2-y1)
	zdim = smart_round(z2-z1)

	print >>file1,'Dimensions for y=0 nodes:'
	print >>file1,(xdim,ydim,zdim),[(x1,x2),(y1,y2),(z1,z2)]
	print >>file1,' '

	for key in dict1:
		print >> file1,'Node setname:',key
		print >> file1, dict1[key]
		print >> file1,' '

	file1.close()

	print ' '
	print 'Dimensions have been written to',filename

	return

output_dims = output_odb_node_sets

function_labels['mate_faces_in_inst'] = 'contact','interact','tie','mate','find_contacts'
def mate_faces_in_inst(inst,faces,side_num=None,ndir=None):
	## VER: 2016-10-25, v1.3
	## to find paring faces in inst. faces should be planes.
	## inst is the target inst
	## not applicable for shrinkft pair faces
	## find by seeds

	## Example: mate_faces_in_inst(punch_A1,f2,ndir='-x')

##	faces = face_select(bridge_A1,x=MIN)
##	faces2 = mate_faces_in_inst(rail_A1,faces=faces)

	if is_pia(faces):
		inst,faces = faces, inst

	inst = check_inst(inst)
	faces = tolist(faces)
	inst0 = get_poi(faces[0])

	source = faces
	if 'shell' in part_shape(inst0)[1]:
		if side_num in empty and ndir in empty:
			raise Exception('*** side_num or ndir of source faces should be provided.')
		source = create_surface(faces=faces,side_num=side_num, side=ndir)

	faces2 = []
	for face in faces:
		locs = seeds_of_face(face)
##		print len(locs)
		for loc in locs:
			face2 = face_at(inst,loc)
			if type_of(face2) == 'faces' and face2 not in faces2:
				faces2.append(face2)

##	print fnln(),'faces2=',faces2
	target = faces2
	if faces2 not in empty:
		if 'shell' in part_shape(inst)[1]:
			edir1 = edir_of_vector(faces[0].getNormal())
			edir2 = edir_of_vector(faces2[0].getNormal())
			if edir1 == edir2:
				side_num = 2
			else:
				side_num = 1

			target = create_surface(faces=faces2,side_num=side_num)

	return target   ## only target, no refine of source.

def is_xwalls(faces):
	## VER: 2016-08-11, v1.0

	faces = tolist(faces)
	result = True
	for face in faces:
		if parallel_to_axis(face,axis='x') == False:
			result = False
			break

	return result

def is_ywalls(faces):
	## VER: 2016-08-11, v1.0

	faces = tolist(faces)
	result = True
	for face in faces:
		if parallel_to_axis(face,axis='y') == False:
			result = False
			break

	return result

def is_zwalls(faces):
	## VER: 2016-08-11, v1.0

	faces = tolist(faces)
	result = True
	for face in faces:
		if parallel_to_axis(face,axis='z') == False:
			result = False
			break

	return result


def parallel_to_axis(face,axis='x'):
	## VER: 2016-08-04, v1.1

	if type_of(face) != 'faces':
		raise Exception('*** a face is required.')

	axis = axis.lower()
	if axis not in ['x','y','z']:
		raise Exception('*** axis x,y,or z is required.')

	result = False
	facing = facing_dir(face)
	if axis == 'x' and facing[0] == 0:
		result = True
	elif axis == 'y' and facing[1] == 0:
		result = True
	elif axis == 'z' and facing[2] == 0:
		result = True

##	result = False
##	try:
##		angle,dir = get_intersect_angle(face,axis=axis)
##		if angle == 0:
##			result = True
##	except:
##		curvature = get_curvature(face)
####		print fnln_fnln(), curvature
##		if curvature not in empty:
##			if axis == 'x':
##				if curvature['principalAxis1'] in [(1,0,0),(-1,0,0)] or curvature['principalAxis2'] in [(1,0,0),(-1,0,0)]:
##					result = True
##			elif axis == 'y':
##				if curvature['principalAxis1'] in [(0,1,0),(0,-1,0)] or curvature['principalAxis2'] in [(0,1,0),(0,-1,0)]:
##					result = True
##			elif axis == 'z':
##				if curvature['principalAxis1'] in [(0,0,1),(0,0,-1)] or curvature['principalAxis2'] in [(0,0,1),(0,0,-1)]:
##					result = True

	return result

def part2cae(part=None):
	## VER: 2014-07-14, v1.2

	if part in empty:
		dpo = get_dpo()
		if type_of(dpo) != 'PART':
			raise Exception('*** a part view is required.')
		else:
			part = dpo

	part = check_poi(part)
	if type_of(part) == 'PINSTANCE':
		part = part.part

	partname = part.name
	mdb.saveAs('_temp')

	get_current_model()

	if a.sets.keys() not in empty:
		a.deleteSets(setNames=totuple(a.sets.keys()))

	if a.surfaces.keys() not in empty:
		a.deleteSurfaces(surfaceNames=totuple(a.surfaces.keys()))

	if a.features.keys() not in empty:
		a.deleteFeatures(totuple(a.features.keys()))

	parts = unselect(_m.parts.keys(),partname)
	del_parts(parts)

	mdb.saveAs(partname)
	get_current_model()

	mdb.save()

	return

def part_byset(setname):
	## VER: 2010-12-02, v1.4

	pname = ''
##	print 'setname=',setname,'======================'
	for partname in _m.parts.keys():
		if setname in _m.parts[partname].sets.keys():
			print 'Found one part',partname,'by setname=',setname,'in part_byset(). Search stoped.'
			return _m.parts[partname]

	if pname == '':
		print fnln_fnln(),'******No part was found by setname=',setname,', line=7039, part_byset()'
		error_record('part_byset()')
		return 'NA'

	return

def parts_by_set(setname):
	## VER: 2011-12-12, v1.3

	part_names = []
	parts = []
	for part in _m.parts.keys():
		if setname in _m.parts[part].sets.keys():
			objs = set2objs(part,setname)
			if len(objs) > 0:				## 防止出现空的set
				part_names.append(part)
				parts.append(_m.parts[part])

	if parts not in empty:
		print 'Found',len(parts),'parts:',part_names,'by setname=',setname,'in parts_by_set().'
	else:
		print fnln_fnln(),'******No part was found by setname=',setname,', please check setname'
		error_record('parts_by_set()')

	return parts

def part_list(*partlist):
	## VER: 2010-02-19

	partlist = partlist[0]
	if len(partlist) == 1:
		if type_of(partlist[0]) == 'LIST':
			partlist = partlist[0]

	partlist1 = []
	for part in partlist:
		type1 = type_of(part)
		if type1 == 'STR':
			partlist1.append(_m.parts[part])
		elif type1 == 'PART':
			partlist1.append(part)
	partlist = partlist1

	return partlist

def part_now():
	## VER: 2013-12-15, v1.0
	## to get the reference of current displayed part, so that one do not need to input this part name
	## such as: p1 = part_now()  ## run in command line

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	if type_of(dpo) == 'PART':
		part = dpo
	else:
		part = None
		print '*** Current is not a part viewport.'

	return part


def part_of_pre(prefix):
	## VER: 2010-01-25

	parts = []
	num = len(prefix)
	for p1 in _m.parts.keys():
		if p1[0:num] == prefix:
			parts.append(_m.parts[p1])

	print 'Selected',len(parts),'parts with prefix',prefix

	return parts

def part_parallel(p,inst_name,face_set1,inst2,face_set2,start_point=(),to_loc=(),csys_KP='',adjust='yes', face2face = 'no'):
	## VER: 2010-12-10, v1.5

	part_name = p.name
	if csys_KP in empty:
		csys_KP = 'O1'

	start_point = None
	if start_point in empty:
		start_point = KPxyz(csys_KP,p)
	elif type_of(start_point) == 'STR':
		start_point = KPxyz(start_point,p)

##	print 'start_point=',start_point
	pt1 = point_at(p,loc=start_point)

	if type_of(pt1) == 'vertices':
		create_set(p, objs=pt1, name='p_original')
	else:
		raise Exception('******No vertice at the original reference point for move_part. line=2851, part_parallel()')

	if face2face == 'no':
		flip = OFF
	elif face2face == 'yes':
		flip = ON

	move_part(p,start=start_point,to_loc=to_loc)
	p = _m.parts[part_name]

	new_instance(p,'temp_A1')

	face1 = set2objs(face_set1,inst1)[0]
	face2 = set2objs(face_set2,inst2,)[0]
	a.ParallelFace(movablePlane=face1, fixedPlane=face2, flip=flip)

	face1 = set2objs(face_set1,temp_A1)[0]
	a.ParallelFace(movablePlane=face1, fixedPlane=face2, flip=flip)

	merge_instances(partname=part_name,insts=[inst1,temp_A1])
	print '--->',part_name,'was paralleled to instance',inst_name

##	KP_set(p,loc='O1')

	if adjust == 'yes':
		if start_point != ():
			move_part(p,start=KPxyz('p_original',p),to_loc=to_loc)
		else:
			move_part(p,start=KPxyz(p),to_loc=to_loc)

	return

def part_shape_and_type(part):
	## VER: 2014-12-23, v1.4

	shape = part_shape(part)
	type1 = part_type

	result = shape[0],shape[1],type1    ## symbol, description, symbol

	return result

def part_shape(part):
	## VER: 2015-03-24, v1.6
	## space即dimensionality有三种: THREE_D, TWO_D_PLANAR, AXISYMMETRIC
	## part_shape()[1]总是以solid, shell, wire, mesh结尾。

	part = check_pias(part)
	if type_of(part) == 'PINSTANCE':
		part = part.part

	discription = ''
	if 	part.space == THREE_D:
		if len(part.cells) > 0:
			discription = '3D_solid'
		elif len(part.faces) > 0:
			discription = '3D_shell'
		elif len(part.edges) > 0:
			discription = '3D_wire'
		elif len(part.vertices) > 0:
			discription = '3D_point'
		elif len(part.elements) > 0:
			e1 = part.elements[0]
			if len(e1.getElemFaces()) > 1:
				discription = '3D_solid_mesh'
			elif len(e1.getElemFaces()) == 1:
				discription = '3D_shell_mesh'
			elif len(e1.getElemEdges()) == 1:
				discription = '3D_wire_mesh'

	elif part.space == TWO_D_PLANAR:
		if len(part.faces) > 0:
			discription = '2D_planar_shell'
		elif len(part.edges) > 0:
			discription = '2D_planar_wire'
		elif len(part.elements) > 0:
			discription = '2D_planar_mesh'   ## no wire

	elif part.space == AXISYMMETRIC:
		if len(part.faces) > 0:
			discription = '2D_axisymmetric_shell'
		elif len(part.edges) > 0:
			discription = '2D_axisymmetric_wire'
		elif len(part.elements) > 0:
			e1 = part.elements[0]
			if len(e1.getElemFaces()) == 1:
				discription = '2D_axisymmetric_shell_mesh'
			if len(e1.getElemEdges()) == 1:
				discription = '2D_axisymmetric_wire_mesh'

	shape = [part.space, discription]

	return shape

def part_type(part):
	## VER: 2014-01-02, v1.4

	part = check_pias(part)
	if type_of(part) == 'PINSTANCE':
		part = part.part

	return part.type	## part.type = DEFORMABLE_BODY, ANALYTIC_RIGID_SURFACE, DISCRETE_RIGID_SURFACE

def partial_setname(inst,setname):
	## VER: 2010-12-28, v1.2，用于接触对的名字的命名

	if type_of(inst) != 'PINSTANCE':
		raise Exception('instance is required for partial_setname() info. ')

	if type_of(setname) == 'PINSTANCE' and type_of(inst) == 'STR':
		inst,setname = setname,inst

	partname = inst.partName
	if partname in setname:
		loc1 = setname.find(partname)
		string1 = setname[loc1 + len(partname) + 1:]
	elif setname[:2] == 'f_':
		string1 = setname[2:]
	elif setname[:3] in ['fc_','fm_','fs_']:
		string1 = setname[3:]
	else:
		string1 = setname

	return string1


def partkey_ofpre(prefix):
	## VER: 2010-01-25

	p_keys = []
	num = len(prefix)
	for p1 in _m.parts.keys():
		if p1[0:num] == prefix:
			p_keys.append(p1)

	print 'Found',len(p_keys),'parts keys with prefix',prefix

	return p_keys


def pattern1(inst,dir1,num1,space1):
	## VER: 2010-01-11

	inst_key = inst.name
	if dir1 == 'x':
		a.LinearInstancePattern(instanceList=(inst_key, ), direction1=(1, 0, 0), direction2=(0, 1, 0),
			number1=num1, number2=1, spacing1=space1, spacing2=0)
	elif dir1 == 'y':
		a.LinearInstancePattern(instanceList=(inst_key, ), direction1=(1, 0, 0), direction2=(0, 1, 0),
			number1=1, number2=num1, spacing1=0, spacing2=space1)
	elif dir1 == 'z':
		a.LinearInstancePattern(instanceList=(inst_key, ), direction1=(0, 0, 1), direction2=(0, 1, 0),
			number1=num1, number2=1, spacing1=space1, spacing2=0)

	print '--->',num1,'instances patterned in',dir1,'based on',inst_key

def parts_of_insts(insts):
	## VER: 2014-06-27, v1.0

	insts = real_insts(insts)
	parts = []
	for inst in insts:
		part = inst.part
		if part not in parts:
			parts.append(part)

	return parts  ## part obj list

def pattern(part,dir='x',step=0,num=5,dx1=0,dy1=0,dz1=0):
	## VER: 2014-09-05, v1.7, dx1,dy1,dz1是第一个inst相对于part位置的偏移量(在x,y,z方向)
	## step是指instance与instance之间的距离。

	part = check_part(part)
	for i in range(num):
		if dir == 'x':
			new_instance(part,dx=dx1 + i*step,dy=dy1,dz=dz1)
		elif dir == 'y':
			new_instance(part,dx=dx1,dy=dy1 + i*step,dz=dz1)
		elif dir == 'z':
			new_instance(part,dx=dx1,dy=dy1,dz=dz1 + i*step)

	a.regenerate()

	return

def patternx(part,step=0,num=1,dx1=0,dy1=0,dz1=0):
	## VER: 2010-12-27, v1.1
	return pattern(part,step=step,dir='x',num=num,dx1=dx1,dy1=dy1,dz1=dz1)

def patterny(part,step=0,num=1,dx1=0,dy1=0,dz1=0):
	## VER: 2010-12-27, v1.1
	return pattern(part,step=step,dir='y',num=num,dx1=dx1,dy1=dy1,dz1=dz1)

def patternz(part,step=0,num=1,dx1=0,dy1=0,dz1=0):
	## VER: 2010-12-27, v1.1
	return pattern(part,step=step,dir='z',num=num,dx1=dx1,dy1=dy1,dz1=dz1)

def pattern_xy(inst,xnum=1,xspace=0,ynum=1,yspace=0):
	## VER: 2010-02-03

	inst_key = inst.name
	a.LinearInstancePattern(instanceList=(inst_key, ), direction1=(1, 0, 0), direction2=(0, 1, 0),
		number1=xnum, number2=ynum, spacing1=xspace, spacing2=yspace)

	print '--->Instances patterned in x-y based on',inst_key,', x=',xnum,', ynum=',ynum

	return

def pattern_geometry(sketch,geometry=(), vertices=(),number1=1,spacing1=10,angle1=0, number2=1, spacing2=10,angle2=90):
	## VER: 2014-03-06, v1.0

	sketch = check_sketch(sketch)
	vertices = totuple(vertices)
	geometry = totuple(geometry)

	if vertices in empty:
		if len(sketch.geometry) == 0:
			vertices = totuple(sketch.vertices.values())

	if geometry in empty:
		if vertices in empty:
			geometry = totuple(sketch.geometry.values())

	if geometry in empty and vertices in empty:
		raise Exception('*** geometry or vertices are required.')

	if geometry not in empty:
		newlist = []
		for curve in geometry:
			if 'construction' not in type_of(curve):   ## construction lines will not pattern
				newlist.append(curve)
		geometry = totuple(newlist)

	sketch.linearPattern(geomList=geometry, vertexList=vertices, number1=number1,
	    spacing1=spacing1, angle1=angle1, number2=number2, spacing2=spacing2, angle2=angle2)

	return


def pattern_insts(insts,dir='x',number=2,spacing=1):
	## VER: 2013-09-11, v1.0
	## number - 1 instances will be added to the assembly

	global _m, a

	insts = real_insts(insts)
	if len(insts) == 0:
		raise Exception('*** One or more instances are needed for pattern.')

	names = poi_names(insts)
	names = totuple(names)

	if number < 2:
		raise Exception('*** number should be >=2 ')

	number = number + 1

	dir = dir.lower()
	if dir not in ['x','y','z']:
		raise Exception('** dir should be x, y, or z')

	if dir == 'x':
		a.LinearInstancePattern(instanceList=names, direction1=(1.0, 0.0, 0.0), number1=number, spacing1=spacing,
			direction2=(0.0, 1.0, 0.0),number2=1, spacing2=1)
	elif dir == 'y':
		a.LinearInstancePattern(instanceList=names, direction1=(1.0, 0.0, 0.0), number1=1, spacing1=1,
			direction2=(0.0, 1.0, 0.0),number2=number, spacing2=spacing)
	elif dir == 'z':
		a.LinearInstancePattern(instanceList=names, direction1=(0, 0.0, 1), number1=number, spacing1=spacing,
			direction2=(1, 0, 0.0),number2=1, spacing2=1)

	return

def plane_cut(part,sketch=None,x=None,y=None):
	## VER: 2014-06-14, v1.0
	## 对2D的cut

##	## create fins in 2D case for wiredraw case:
##	for i in range(grove_num):
##		plane_cut(case,x=(case_OD/2,case_OD/2 - grove_depth),y=(grove_to_edge + i*grove_width*2, grove_to_edge + i*grove_width*2 + grove_width))


## Example:
##	create_rectangle_shell('case0',corner2=(case_OD_x/2, case_OD_y/2),axis_symmetric = False)
##	plane_cut('case0',x=(0,case_ID_x/2), y=(0,case_ID_y/2))
##
##	s1 = create_base_sketch('sk_hole')
##	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y), radius=hole_D/2)
##	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y - hole2hole), radius=hole_D/2)
##	plane_cut('case0',sketch=s1)

	part = check_part(part)
	if '2D' not in part_shape(part)[1]:
		raise Exception('*** A 2D part is required.')

	x,y,z = real_xyz(part,x=x,y=y)

	if x not in empty and y not in empty:
		x1,x2,y1,y2 = tospace(x,y)

		sketch = create_base_sketch('sk_temp')
		sketch.rectangle(point1=(x1,y1),point2=(x2,y2))

	elif sketch not in empty:
		sketch = check_sketch(sketch)

	sketch.setPrimaryObject(option=SUPERIMPOSE)
	part.projectReferencesOntoSketch(sketch=sketch, filter=COPLANAR_EDGES)
	part.Cut(sketch=sketch)
	sketch.unsetPrimaryObject()

	update_part(part)

	return

function_labels['plane_dist'] = 'distance','2D','ndir','axis','plane'
def plane_dist(ndir='x'):
	## VER: 2017-08-09, v1.0

	ndir = map_data(ndir,(0,1,2),('x','y','z'))

##	if ndir == 0:
##		ndir = 'x'
##	elif ndir == 1:
##		ndir = 'y'
##	elif ndir == 2:
##		ndir = 'z'

	ndir = ndir.lower()
	if ndir not in ['x','y','z']:
		raise Exception('*** ndir should be x,y or z')

	file1 = open(get_rpy()).readlines()

	num = 0
	values = ()
	for i in range(len(file1) -1, -1, -1):
		num += 1
		if num > 200:
			break

		code = file1[i]  ## no change line mark

		if code.startswith('  ') or code.startswith('session.viewports['):
			continue

		if code.startswith('#: ') and 'Distance' in code and 'Components' in code:
			loc = code.rfind(':')
			values = code[loc+1:-1].strip()
			values = eval(values)
			break

	dist = 0
	if is_location(values):
		if ndir == 'x':
			dist = sqrt(values[1]*values[1] + values[2]*values[2])
		elif ndir == 'y':
			dist = sqrt(values[0]*values[0] + values[2]*values[2])
		elif ndir == 'z':
			dist = sqrt(values[0]*values[0] + values[1]*values[1])

		dist = int6(dist)

	return dist

def plane_normal_and_offset(face):

	## VER: ('VER: 2012-09-27, v1.2')	## 获取平面的法线及其offset. normal in num, not in text.

	if type_of(face) != 'faces':
		raise Exception('face object is required.')

	poi = get_poi(face)

	curvature = get_curvature(face)
	if curvature not in empty:
		print '**Cannot get the normal and offset for curve surface. poi=' + poi.name
		return {'normal':'NA','offset':'NA'}

	x0,y0,z0 = poi.vertices[face.getVertices()[0]].pointOn[0]

	normal_num = get_normal(face)
	nx,ny,nz = normal_num					## abaqus的法线是归一化的，也即nx*nx + ny*ny + nz*nz = 1
	mix = nx*x0 + ny*y0 + nz*z0
	distance = round(abs(mix),6)	## 原点到平面的距离

	if normal_num == (1,0,0) or normal_num == (-1,0,0):
		normal_text = 'x'
		offset_x = x0
		offset_y = 1e30
		offset_z = 1e30
		distance = x0		## 可能正，也可能为负。
	elif normal_num == (0,1,0) or normal_num == (0,-1,0):
		normal_text = 'y'
		offset_x = 1e30
		offset_y = y0
		offset_z = 1e30
		distance = y0
	elif normal_num == (0,0,1) or normal_num == (0,0,-1):
		normal_text = 'z'
		offset_x = 1e30
		offset_y = 1e30
		offset_z = z0
		distance = z0
	else:
		normal_text = 'slope'
		if abs(nx) < 1e-6:
			offset_x = 1e30
		else:
			offset_x = round(mix/nx,6)

		if abs(ny) < 1e-6:
			offset_y = 1e30
		else:
			offset_y = round(mix/ny,6)

		if abs(nz) < 1e-6:
			offset_z = 1e30
		else:
			offset_z = round(mix/nz,6)

	result = {}
	result['normal'] = normal_text		## 'x','y','slope'
	result['offset'] = distance	## 原点到平面的距离
	result['offset_x'] = offset_x
	result['offset_y'] = offset_y
	result['offset_z'] = offset_z

	return result

function_labels['name_of_RP'] = 'name','RP','referencePoints','feature'
def name_of_RP(RP):
	## VER: 2017-10-30, v1.0
	## RP obj -> RP index -> feature index -> feature name

	if type_of(RP) != 'referencePoints':
		raise Exception('*** RP object is required.')

	p1 = get_parent(RP)
	if type_of(p1) == 'PINSTANCE':
		p1 = a

	index = get_RP_index(RP)
	dict1 = RP_index_and_names(p1)
	name = dict1[index]

	return name

def name_of_set(set1):
	## VER: 2014-06-06, v1.0
	## Reference: type_of_set(), name_of_set(), pia_of_set()

	if type_of(set1) != 'SET':
		raise Exception('*** set like region is required.')

	name = get_repository_key(set1,'sets')

	return name

def name_of_surface(surf):
	## VER: 2016-11-29, v1.0

##	>>> name_of_surface(p1.surfaces['surf'])
##	'surf'
##	>>>

	if type_of(surf) != 'SURFACE':
		raise Exception('*** a surface is required.')

	text = repr(surf)
	locs = locs_of_substring(text,"'")
	name = text[locs[-2] + 1:locs[-1]]

	return name

def nbox_select(objs,x=(),y=(),z=(),err=0.1):
	## VER: 2015-06-08, v1.0

	if is_poi(objs):
		poi = check_poi(objs)
		objs = poi.nodes

	nodes = box_select(objs,x=x,y=y,z=z,err=err)

	return nodes

def ndir_and_offset_of_curve(edge):
	## VER: 2012-11-26, v1.1

##	x1,x2,y1,y2,z1,z2 = space_of_edges(edge)
	pointOns = pointOns_of_curve(edge,parameters=(0,0.5,1))
	x1,x2,y1,y2,z1,z2 = space_of_points(pointOns)

	pkx = PK(x1,x2)
	pky = PK(y1,y2)
	pkz = PK(z1,z2)

	pks = [pkx,pky,pkz]
	if pks.count(0) == 1:
		if pkx == 0:
			ndir = 'x'
			offset = x1
		elif pky == 0:
			ndir = 'y'
			offset = y1
		elif pkz == 0:
			ndir = 'z'
			offset = z1
	else:
		ndir = 'NA'
		offset = 'NA'

	return (ndir,offset)

def please_check(*comment):
	## VER: 2011-12-05, v1.2
	return

bookmark = please_check

def plot(obj,fitview=False):
	## VER: ('VER: 2014-08-20, v3.1')

	global dg, plot_history, odb, edels

	trace = get_traceback()
##	print 'Ploting trace =',trace

	unlight()

	vpnow = get_vpnow()
	if obj in empty:
		print fnln_fnln(),'******Empty object to plot.'
		vpnow.setValues(displayedObject=None)
		plot_history.append(get_traceback())
		print ' '
		return

	if is_poi(obj):
		obj = check_poi(obj)

	type1 = type_of(obj)
	if type1 in ['LIST','TUPLE']:
		type1 = type_of(obj[0])
		if len(obj) == 1:
			obj = obj[0]

	if type1 == 'INT':
		num = obj
		if 'edels' in globals().keys():
			if num in edels['dgs'].keys():
				plot_dg(edels['dgs'][num])
				print fnln_fnln(),'Plotting results=',edels['values'][num][:4]
			else:
				print fnln_fnln(),'******No such leaf with ndel=',num,', max ndel=',edels['num']
		else:
			print fnln_fnln(),'******Please run edel() first to get the dgs.'
		return

	if 'LEAF' in type1:
		leaf = obj
		module = repr(leaf.validModules)   ## PART, ASSEMBLY, or ODB
		module = module.lower()
##		exec 'vpnow.' + module + 'Display.displayGroup.replace(leaf=obj)'
		if module == 'part':
			vpnow.partDisplay.displayGroup.replace(leaf=leaf)
		elif module == 'assembly':
			vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)
		else:
			vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

	elif type1 == 'DISPLAYGROUP':
		leaf = obj.root.leaf
		plot(leaf)
		return

	elif type1 == 'ASSEMBLY':
		a.regenerate()
		vpnow.setValues(displayedObject=a)
		plot_history.append(get_traceback())
		vpnow.assemblyDisplay.meshOptions.setValues(meshTechnique=ON)   ## 不可省，否则不显示图形
##		if fitview == True:
##			vpnow.view.fitView()

	elif type1 == 'ODB':
		vpnow.setValues(displayedObject=odb)
		plot_history.append(get_traceback())

	elif type1 == 'PART':
		part = obj
		part.regenerate()
		vpnow.setValues(displayedObject=part)
##		plot_history.append(get_traceback())
##		vpnow.partDisplay.setValues(mesh=ON)
##		vpnow.partDisplay.meshOptions.setValues(meshTechnique=ON)
##		if fitview == True:
##			vpnow.view.fitView()

	elif type1 == 'PINSTANCE':
		insts = totuple(obj)
		if type_of(vpnow.displayedObject) != 'ASSEMBLY':
			vpnow.setValues(displayedObject=a)
		leaf = dgm.LeafFromInstance(instances=insts)
		vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)
##		vpnow.assemblyDisplay.meshOptions.setValues(meshTechnique=ON)

	elif type1 == 'ODBINSTANCE':
		names = poi_names(obj)
		names = totuple(names)
		leaf = dgo.LeafFromPartInstance(partInstanceName=names)
		vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

	elif type1 == 'STR':
		if '.cae' in obj or '.CAE' in obj:
			open_cae(obj)
		elif '.odb' in obj or '.ODB' in obj:
			obj = modify_string(obj,'.ODB','.odb')
			found = False
			for key1 in session.odbs.keys():
				if obj in key1:
					odb = session.odbs[key1]
					session.viewports['Viewport: 1'].setValues(displayedObject=odb)
					found = True
					refresh()
					break

			if not found:
				open_odb(obj)

	else:
		objs = tolist(obj)
		obj_type = type_of(objs[0])
		print fnln_fnln(),'obj_type=',obj_type
		if obj_type in ['edges','faces','cells']:
			seq = list2sequence(objs)
			if obj_type == 'faces':
				leaf = dgm.LeafFromGeometry(faceSeq=seq)
			elif obj_type == 'edges':
				leaf = dgm.LeafFromGeometry(edgeSeq=seq)
			elif obj_type == 'cells':
				leaf = dgm.LeafFromGeometry(cellSeq=seq)

			poi = get_poi(objs[0])
			type2 = type_of(poi)
			if type2 == 'PINSTANCE':
				vpnow.setValues(displayedObject=a)
##				plot_history.append(get_traceback())
				vpnow.assemblyDisplay.meshOptions.setValues(meshTechnique=ON)   ## 不可省，否则不显示图形
			elif type2 == 'PART':
				vpnow.setValues(displayedObject=poi)
				vpnow.partDisplay.meshOptions.setValues(meshTechnique=ON)
##				plot_history.append(get_traceback())

			dg = session.DisplayGroup(leaf=leaf, name='_leaf')
			print 'Created global variable dg in',type_of(vpnow.displayedObject),'viewport. Usage: plot(dg) or light(dg) + Replace All.'
			print ' '
			plot(leaf)
			light(dg)

		else:
			vpnow.setValues(displayedObject=a)
			vpnow.assemblyDisplay.meshOptions.setValues(meshTechnique=ON)   ## 不可省，否则不显示图形
			plot_history.append(get_traceback())

			insts = real_insts(obj)
			insts = tuple(insts)
			leaf = dgm.LeafFromInstance(instances=insts)

			dg = session.DisplayGroup(leaf=leaf, name='_leaf')
			plot(leaf)

	return

def plot_all():
	## VER: 2014-03-28, v1.0
	## plot_all => plot_variable => plot specific instance

	vpnow = get_vpnow()
	leaf = dgo.Leaf(leafType=DEFAULT_MODEL)   ## 有fitview的效果
	vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

	return

def plot_dg(dg):
	## VER: 2016-03-01, v1.2
	## Create display group: pick from viewport, then save selection as..

##	>>> plot_dg('arc_ymax')
##	Warning: Display groups containing only nodes are not supported in contour plot mode. Select a different plot mode and activate node symbols and/or labels to see the selected nodes.
##	>>> light('arc_ymax')  ## if a display group is nodes, use light() instead.

	## For display group in odb:
	## current display group object: vpnow.odbDisplay.displayGroup
	## All display group objects: session.displayGroups.keys()

##	>>> session.displayGroups.keys()
##	['All', 'arc_ymax']
##	>>>

##	>>> plot_dg('elems')  ## elements display group
##	>>>

	if type_of(dg) == 'DISPLAYGROUP':
		dg = dg.root
		leaf = dg.leaf
		next = dg.next
	elif type_of(dg) == 'DICT' and 'leaf' in dg.keys():
		leaf = dg['leaf']
		next = dg['next']
	elif type_of(dg) == 'dgKnot':
		leaf = dg.leaf
		next = dg.next
	elif type_of(dg) == 'STR' and dg in session.displayGroups.keys():
		dg = session.displayGroups[dg].root
		leaf = dg.leaf
		next = dg.next
	else:
		raise Exception('*** displaygroup or dg dict is required.')

	display = get_display_now() ## such as: vpnow.partDisplay, vpnow.assemblyDisplay, vpnow.odbDisplay
	display.displayGroup.replace(leaf=leaf)

	if type_of(dg) == 'DISPLAYGROUP':
		while next not in empty:
			leaf1 = next.leaf
			action = next.action
			next = next.next
			if action == ADD:
				display.displayGroup.add(leaf=leaf1)
			elif action == REMOVE:
				display.displayGroup.remove(leaf=leaf1)

	elif type_of(dg) == 'DICT':
		for i in range(len(next)):
			leaf1 = next[i]['leaf']
			action = next[i]['action']
			if action == ADD:
				display.displayGroup.add(leaf=leaf1)
			elif action == REMOVE:
				display.displayGroup.remove(leaf=leaf1)

	return


def plot_frequency_response(inst='LAM_A1',node=13,stepname='',stepnum=None,variable='U3',plotname='XYPlot-1',check_name=True,result_type=COMPLEX_MAGNITUDE,yscale=None):

	## VER: ('VER: 2012-06-11, v1.5')
	## result_type的种类: Possible values are COMPLEX_MAGNITUDE, COMPLEX_PHASE, REAL, IMAGINARY, and COMPLEX_VAL_AT_ANGLE. The default value is REAL.
	## 适合扫频响应分析

	inst = check_odb_instance(inst)
	inst = inst.name

	vpnow = get_vpnow()
	node = str(node)
	if node.isdigit() == False:
		raise Exception('Incorrect node number.')

	steps = []
	for i in range(len(odb.steps)):
		step = odb.steps.values()[i]
		if step.domain == FREQUENCY:
			steps.append(i)

	if steps in empty:
		raise Exception('没有频率扫频分析步来获得谐响应分析。')

	if stepname not in empty:
		if stepname not in odb.steps.keys():
			raise Exception('Error stepname=' + repr(stepname))

		if odb.steps[stepname].domain != FREQUENCY:
			raise Exception(stepname + '并不是一个扫频分析步.')

	if type_of(stepnum) == 'INT':
		if stepnum > len(odb.steps):
			raise Exception('Error stepnum=' + repr(stepnum))

		if odb.steps.values()[stepnum - 1].domain != FREQUENCY:
			raise Exception('第' + str(stepnum) + '载荷步并不是一个扫频分析步.')

	if stepname in empty:
		if type_of(stepnum) == 'INT':
			stepname = odb.steps.values()[stepnum-1].name

		else:
			stepname = odb.steps.values()[-1].name

	session.odbData[odb.name].setValues(activeFrames=((stepname, ('0:-1', )), ))

##	if plotname in session.xyPlots.keys():
##		if check_name == False:
##			xyp = session.xyPlots[plotname]
##
##		else:
##			plotname = new_key(plotname,session.xyPlots.keys())
##			xyp = session.XYPlot(plotname)
##	else:
##		xyp = session.XYPlot(plotname)

	clear_xyPlots()
	clear_xyDataObjects()
	xyp = session.XYPlot(plotname)

	variable = variable.upper()
	if variable == 'U3':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'U', NODAL, ((COMPONENT, 'U3'), )), ), numericForm=result_type, nodeLabels=((inst, (node, )), ))
	elif variable == 'U':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'U', NODAL, ((INVARIANT, 'Magnitude'), )), ), numericForm=result_type, nodeLabels=((inst, (node, )), ))
	elif variable == 'S1':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'S', INTEGRATION_POINT, ((INVARIANT, 'Max. Principal'), )), ), numericForm=result_type, nodeLabels=((inst, (node, )), ))
	elif variable == 'S':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'S', INTEGRATION_POINT, ((INVARIANT, 'Mises'), )), ), numericForm=result_type, nodeLabels=((inst, (node, )), ))


##	if variable == 'U3':
##		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
##		    'U', NODAL, ((COMPONENT, 'U3'), )), ), numericForm=result_type, nodeLabels=((inst, (node, )), ))
##	elif variable == 'U':
##		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
##		    'U', NODAL, ((INVARIANT, 'Magnitude'), )), ), numericForm=result_type, nodeLabels=((inst, (node, )), ))

	xyData = session.xyDataObjects.values()[-1]

##	print_dir(xyList)
##	print type_of(xyList)	## LIST，但只有一个元素。
##	print len(xyList)			## 1
##	print len(xyList[0])		## 96
##	print len(xyData)			## 96
##	print type_of(xyData)	## XYDATA
##	globals()['xyData'] = xyData
##
##	print 'type_of(xyList[0]) =',type_of(xyList[0])		## 结果: xyData
##	if xyList[0] == xyData:
##		print 'equal'   ## 结果：equal

	new_data = []
	values = []
	for data in xyData.data:
		if abs(data[1]) < 1e12:
			new_data.append(data)
			values.append(data[1])

	new_data = tuple(new_data)
	xyData.setValues(data=new_data)

	max_value = max(values)
	min_value = min(values)

	vpnow.odbDisplay.basicOptions.setValues(numericForm=result_type)

	chart = xyp.charts.values()[0]
	curveList = session.curveSet(xyData=[xyData])
	chart.setValues(curvesToPlot=curveList)

	chart.axes1[0].axisData.setValues(tickMode=TOTAL_NUMBER)
	chart.axes1[0].axisData.setValues(tickCount=10)
	chart.axes1[0].axisData.setValues(minorTickCount=1)
	chart.axes1[0].axisData.setValues(useSystemTitle=False, title='Frequency (Hz)')

	chart.axes2[0].axisData.setValues(scale=LOG)		;please_check
	if type_of(yscale) in ['FLOAT','INT']:
		chart.axes2[0].axisData.setValues(maxValue=yscale, maxAutoCompute=False)

	if variable == 'S1':
		chart.axes2[0].axisData.setValues(useSystemTitle=False, title='Stress (S1, MPa)')
	elif variable == 'S':
		chart.axes2[0].axisData.setValues(useSystemTitle=False, title='Stress (Mises, MPa)')
	elif variable in ['U', 'U1', 'U2', 'U3']:
		chart.axes2[0].axisData.setValues(useSystemTitle=False, title='Displace./deform. (mm)')

	chart.axes2[0].axisData.setValues(tickMode=TOTAL_NUMBER)
	chart.axes2[0].axisData.setValues(minorTickCount=8)

	vpnow.setValues(displayedObject=xyp)

	xyData1 = xyp.charts.values()[-1].curves.values()[-1].data
	if xyData1 == xyData:
		print 'Equal'		## V
	else:
		print 'Unequal'

	if yscale in empty:
		yscale = 'Automatic'

	print '--->Plotted modal response for stepname=',stepname,', variable=',variable, ', result_type=',result_type
	if len(values) > 10:
		print 'y_scale=',yscale,', max value=',max_value, ', min value=',min_value
	else:
		print 'y_scale=',yscale,', data points=',new_data
	print 'xyData.fileName =',xyData.fileName
	print ' '

	return xyData

def plot_insts(*insts):
	## VER: 2015-03-28, v1.3

##	plot_insts('carbide')  ##  model insts: carbide, frame, steel
##  refrence: plotset('carbide')

	vpnow = get_vpnow()
	dpo = get_dpo()
	refresh()

	insts = tolist(insts)
	if type_of(dpo) in ['PART','ASSEMBLY']:
		insts0 = real_insts(insts)
		names = poi_names(insts0)
		if names in empty:
			names = find_similars(insts,a.instances.keys())
			if names not in empty:
				insts0 = real_insts(names)
			else:
				raise Exception('*** insts are required.')

		hiden = get_hiden_insts()  ## names
		insts1 = get_common(names,hiden)
		if insts1 not in empty:
			show_hiden_insts(insts1)

		leaf = dgm.LeafFromInstance(instances=totuple(insts0))
		vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)

	elif type_of(dpo) == 'ODB':
		insts = find_similars(insts,oa.instances.keys())
		leaf = dgo.LeafFromPartInstance(partInstanceName=totuple(insts))
		vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

	return

def plot_insts_set(setname):
	## VER: 2014-07-17, v1.0
	## reference: plot_insts()

	if setname not in a.sets.keys():
		raise Exception('*** An insts setname is required.')

	vpnow = get_vpnow()
	set1 = a.sets[setname]

	if set1.instances in empty:
		raise Exception('*** An insts setname is required.')

	insts = leaf_ids_to_insts(set1.instances)

##	leaf = dgm.LeafFromSets(sets=(set1, ))
##	vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)

	plot_insts(insts)
	refresh()

	return insts

function_labels['triangle_insert'] = 'powder compaction','insert','triangle','pin','PFH','PV','OB','PW','PH'
def triangle_insert(jobname='A1_triangle_compact',partname='powder',innerD=15.488,cornerD=0.85, chamferH=0.45, pinD=5.945,mouthD=9.39, mouth_angle=29.633,
	R_pin_mouth=1.542, bot_chamfer=0.4, PFH=13.14, PH=6.12, PW=13.25, OB=0.6, PV=3.34, friction=0.2, round_by_chamfer=True,shrinkage=0.18):
	## VER: 2017-06-12, v1.6, job#: A0282, A0279
	## PH+OB+PV
	## chamferH: corner to chamfer face distance
	## mouth angle is the slope of mouth with pin axis (deg)
	## reference: PV_AB_by_ratio() to get the reference range of PFH
	## 调整顺序：设定一个PV -> 通过调整中模获得准确的填粉重量(粉体填满腔体)
	## default: PFH=1.61*PH + PV。如果PV偏小（由于调整比较的缘故），此时该等式不再成立，但PFH不变。因为粉体重量基本不变。

	## triangle_insert(PFH=13.14, OB=0.6, friction=0.15, jobname='AG1_A0282_PFH1314_OB06_fr015')
	## triangle_insert(PFH=13.14, OB=1.1, friction=0.15, jobname='AG2_A0282_PFH1314_OB11_fr015')
	## triangle_insert(PFH=13.14, OB=1.6, friction=0.15, jobname='AG3_A0282_PFH1314_OB16_fr015')

	## triangle_insert(PFH=13.14, OB=0.6, friction=0.2, jobname='AF1_A0282_PFH1314_OB06_fr02')
	## triangle_insert(PFH=13.14, OB=1.1, friction=0.2, jobname='AF2_A0282_PFH1314_OB11_fr02')
	## triangle_insert(PFH=13.14, OB=1.6, friction=0.2, jobname='AF3_A0282_PFH1314_OB16_fr02')

	## triangle_insert(PFH=13.14, OB=0.6, friction=0.1, jobname='AE1_A0282_PFH1314_OB06_fr01')
	## triangle_insert(PFH=13.14, OB=1.1, friction=0.1, jobname='AE2_A0282_PFH1314_OB11_fr01')
	## triangle_insert(PFH=13.14, OB=1.6, friction=0.1, jobname='AE3_A0282_PFH1314_OB16_fr01')

	## triangle_insert(PFH=13.14, OB=0.6, friction=0.2, jobname='AD1_A0282_PFH1314_OB06_fr02')
	## triangle_insert(PFH=13.14, OB=0.6, friction=0.15, jobname='AD2_A0282_PFH1314_OB06_fr015')
	## triangle_insert(PFH=13.14, OB=0.6, friction=0.1, jobname='AD3_A0282_PFH1314_OB06_fr01')

	## triangle_insert(PFH=12.5, OB=0.6, jobname='AC_A0282_insert_PHF125_OB06')
	## triangle_insert(PFH=13, OB=0.6, jobname='AC_A0282_insert_PHF13_OB06')
	## triangle_insert(PFH=13.5, OB=0.6, jobname='AC_A0282_insert_PHF135_OB06')
	## triangle_insert(OB=0.6,jobname='A0282_compact_insert_OB06')

##	>>> PV_AB_by_ratio(PV=3.34,PH=6.12,OB=0.6,PVPH=0.6,ask=False)
##
##	sinter_H  = 4.96
##	Shrinkage = 19.0 %
##	PH = 6.12
##	L=AB = 9.8
##	PFH = 13.14
##	Total press = 7.02
##	input ABPH = 1.6 , real facor K=1+PV/PH= 1.55 , PV/PH= 0.55 , AB/PH= 1.6
##	OB/PH = 0.1
##	compress ratio= 2.15
##	----
##	dip = 3.08 , ==> underfilling
##	nominal lower pressing:  PV = 3.34
##	nominal upper pressing:  OB = 0.6 , positive = False
##	lower pressing: negative_PV = (3.634, 3.328, 3.022)
##	lower pressing: positive_PV = (1.26, 1.76, 2.26)
##	--
##	upper pressing: negative_OB = (0.306, 0.612, 0.918)
##	upper pressing: positive_OB = (2.68, 2.18, 1.68)
##
##	inputs: {'PV': 3.34, 'sinter_H': None, 'grade': None, 'shrinkage': 0.19, 'OB': 0.6, 'print_info': True, 'PVPH': 0.6, 'ask': False, 'PH': 6.12, 'dip': None}
##	Initial: PFH= 13.14 (PV=3.34), under filling: 10.06 (PV=3.34), lower prsssing: 6.72 ,upper pressing: 6.12 (PH), after sinter: 4.96 (sinter_H)
##
##	{'AB': 9.8, 'PV': 3.34, 'PFH': 13.14, 'OB': 0.6, 'steps': 'Initial: PFH=13.14(PV=3.34), under filling:10.06(PV=3.34), lower prsssing:6.72,upper pressing:6.12(PH), after sinter:4.96(sinter_H)', 'PH': 6.12, 'compress ratio': 2.15, 'dip': 3.08}

##	>>> triangle_insert(PFH=14)
##	PFH= 14.0
##	density of filling part: 3.3436e-09

##	22.805 height
##	25.646 edge length
##
##	cornerD=0.8
##	25.832
##	25.44
##
##	cornerD=0.83
##	25.817
##	25.39
##
##	cornerD=0.84:
##	22.812
##	25.37
##
##	cornerD=0.85
##	22.807
##	25.35

	clear()

	## output variables
	f1 = '_triangle_GUI_inputs.log'
	line_print(f1,' ')
	line_print(f1,date_time())
	line_print(f1,'Simulation job name:',jobname)
	line_print(f1,'==Tool design parameters')
	var_print(f1,'Sintering shrinkage:',30,shrinkage)
	var_print(f1,'Corner round diameter:',30,cornerD)
	var_print(f1,'Corner chamfer height:',30,chamferH)
	var_print(f1,'Corner round by chamfer?',30,round_by_chamfer)
	var_print(f1,'Inner tangent circle diameter:',30,innerD)
	var_print(f1,'Pin hole diameter:',30,pinD)
	var_print(f1,'Mouth hole diameter:',30,mouthD)
	var_print(f1,'Mouth hole angle(deg):',30,mouth_angle)
	var_print(f1,'Pin to mouth round R:',30,R_pin_mouth)
	var_print(f1,'Bottom chamfer length:',30,bot_chamfer)

	line_print(f1,'==Process parameters (unit=mm)')
	var_print(f1,'Powder height(PFH):',30,PFH)
	var_print(f1,'Press height(PH):',30,PH)
	var_print(f1,'Press weight(PW):',30,PW)
	var_print(f1,'PV for Dost:',30,PV)
	var_print(f1,'Final OB:',30,OB)

	pinD = float(pinD)
	PFH = float(PFH)
	innerD = float(innerD)

	round_R = cornerD/2.
	innerR = innerD/2.
	length = 3*innerR/sinD(60)

	if type_of(round_by_chamfer) == 'STR':
		round_by_chamfer = round_by_chamfer.lower()
		if round_by_chamfer == 'yes' or round_by_chamfer == 'y':
			round_by_chamfer = True
		else:
			round_by_chamfer = False

	dip = PFH - PH - OB - PV
	if dip <= 0:
		print fnln(),'dip=',dip
		raise Exception('*** displacement of punch at first step is <=0')

	ref_PFH1 = PV_AB_by_ratio(PV=3.34,PH=6.12,OB=0.6,PVPH=0.55,ask=False)
	ref_PFH2 = PV_AB_by_ratio(PV=3.34,PH=6.12,OB=0.6,PVPH=0.6,ask=False)
	ref_PFH3 = PV_AB_by_ratio(PV=3.34,PH=6.12,OB=0.6,PVPH=0.65,ask=False)
	ref_PFH = {0.55:ref_PFH1['PFH'], 0.6:ref_PFH2['PFH'], 0.65:ref_PFH3['PFH'], 'range':(ref_PFH1['PFH'],ref_PFH3['PFH'])}
	PFH_default = 1.61*PH + PV
	print fnln(),'ref_PFH=',ref_PFH

	chamferL = round(chamferH/sinD(60),6)
	mouth_depth = (mouthD - pinD)/2*ctanD(mouth_angle)
	mouth_depth = round(mouth_depth,6)

	output_list = 'jobname',jobname,'shrinkage',shrinkage

	if partname in _m.parts.keys():
		del_parts(partname)

	material_database()

	if is_number(friction) == False:
		friction = 0.2
	create_contact_friction(name='Friction',friction=friction)

##	create_contact_props(friction=friction)					;please_check('default=0.15')

	## powder
	s1 = create_base_sketch('sk_powder')
##	loc1 = (-length/2,-innerR)
##	loc2 = (0,2*innerR)
##	loc3 = (length/2,-innerR)

	loc1 = (innerR,-length/2)
	loc2 = (innerR,length/2)
	loc3 = (-2*innerR,0)
	connect_points(s1,loc1,loc2,loc3,loc1)

	if round_by_chamfer == False:
		round_sketch_corner(s1,loc=loc1,radius=round_R)
		round_sketch_corner(s1,loc=loc2,radius=round_R)
		round_sketch_corner(s1,loc=loc3,radius=round_R)

	if partname in _m.parts.keys():
		del_parts(partname)

	partname = blank_part(partname)
	powder = extrude_sketch_to_part(partname,length=PFH,sketch=s1)

	if round_by_chamfer == True:
		edges = edge_select(powder,edir='z')
		chamfer_edges(powder,edges=edges,length=chamferL)
		print fnln(),'chamferL=',chamferL

	edges = edge_select(powder,z=MIN)
	chamfer_edges(powder,edges=edges,length=bot_chamfer)

	drill_hole(powder,ndir='z',radius=pinD/2)

	set_mat(powder,mat='H10pow')

	density = smart_round(PW/get_volume(powder)*1e-6)
	set_density('H10pow',table=density)   ## 3.234

	print ' '
	print 'PFH=',PFH
	print 'density of filling part:',get_density('H10pow')
	print fnln(),'ref_PFH=',ref_PFH
	print fnln(),'PFH_default=1.61*PH+PV=',PFH_default

##	raise Exception

	## pin & punch
	s1 = create_base_sketch('sk_pin')
	loc0 = (mouthD/2 + 2*innerR,0)
	locs = connect_points(s1,loc0,('x',mouthD/2),xytilt3(dx=(mouthD - pinD)/2,Ay=mouth_angle),('dy',-2*PFH))
	round_sketch_corner(s1,loc=locs[2], radius=R_pin_mouth)
	punch = revolve_sketch_to_part('punch',sketch=s1,solid=False,angle=360,rigid=True)  ## 3D, discrete rigid
	rotate_part(punch,rotate_center=(0,0,0),angle_x=90)

	edges = edge_select(punch,diameter=pinD)  ## mouthD > pinD时，这些edges并不是最顶部的edges
	space = objs_space(edges)
	V_height = _zmax(punch) - space[-1]
	V_height = round(V_height,3)
	V_height = V_height + 0.5
	move_part(punch,z1=MAX,z2=_zmax(powder) + V_height)

	new_instance(powder)
	new_instance(punch)

##	rotate_instance('punch_A1',angle_z=-30)

	## ejector
	faces = face_select(powder,nz=-1)
	ejector = faces_to_shellpart(faces,name='ejector',rigid=True)

	edges = edge_select(ejector,diameter=pinD)
	extend_faces_by_edges(edges,distance=0.5)

	edges = exterior_edges(ejector)
	edges1 = edge_select(ejector,D=pinD)
	edges = unselect(edges,edges1)
	extend_faces_by_edges(edges,distance=0.5)

##	edges = edge_select(ejector,z=MAX)
##	extend_faces_by_edges(edges,distance=0.5)

	new_instance(ejector)

	## die
	faces = face_select(powder,z=MID)
	faces1 = face_select(powder,diameter=pinD)
	faces = unselect(faces,faces1)
	die = faces_to_shellpart(faces,name='die')

	edges = edge_select(die,z=MAX)
	extend_faces_by_edges(edges,distance=1)

	edges = edge_select(die,z=MIN)
	extend_faces_by_edges(edges,distance=0.5)

	new_instance(die)

	save_as(jobname)

	## steps and outputs, adaptive mesh
	period0 = 0.1
	period1 = 0.3
	period2 = 0.3
	period3 = 0.1

	create_dynamic_explicit_step('form V',timePeriod=period0,scale_factor=800)
	create_dynamic_explicit_step('upper pressing',timePeriod=period1,scale_factor=800)
	create_dynamic_explicit_step('lower pressing',timePeriod=period2,scale_factor=800)
	create_dynamic_explicit_step('OB',timePeriod=period3,scale_factor=800)

	field_output_request(intervals=10)

	## divide for mesh
	divideD = mouthD + 1	;changing
	circular_divide(powder,ndir='z',D=divideD)
	divide(powder,y=0)

	locs1 = zlocs(ejector)
	if len(locs1) > 1:  ## concave
		locs = zlocs(powder)
		divide(powder,z=locs[1])

	## mesh powder
	set_element_shape(powder,technique='SWEEP')

	edges = edge_select(powder,z=MAX,diameter=divideD) + edge_select(powder,z=MAX,diameter=pinD)
	seed_edges(powder,edges=edges,enum=35)	;changing

	edges = edge_select(powder,z=MAX,length=(divideD-pinD)/2)
	seed_edges(powder,edges=edges,enum=4)

	edges = edge_select(powder,z=MAX)
	edges = exterior_edges(edges)
	list1 = edges_sort_by_length(edges)

	seed_edges(powder,edges=list1[0][1],enum=2)
	seed_edges(powder,edges=list1[1][1],enum=4)

	edges = edge_select(powder,z=MIN1)
	edges = exterior_edges(powder,edges)
	seed_edges(powder,edges=edges,enum=3)

	mesh_part(powder,esize=0.55)	;changing

##	raise Exception

	control = adaptive_mesh_control(predictor='previous', curvature=0.05, weight=(0.5,0,0.5), order='first')
##	control = adaptive_mesh_control(predictor='previous', curvature=1, weight=(1,0,0), order='first')
	powder_elems = _inst('powder_A1').elements

	apply_adaptive_mesh(step='form V',region=powder_elems,frequence=2,sweep=1, controls=control)
	apply_adaptive_mesh(step='upper pressing',region=powder_elems,frequence=2,sweep=1, controls=control)
	apply_adaptive_mesh(step='lower pressing',region=powder_elems,frequence=3,sweep=1, controls=control)
	apply_adaptive_mesh(step='OB',region=powder_elems,frequence=4,sweep=1, controls=control)

	create_tabular_amplitude('amp_step1',time_table=[(0,0),(period0,1)])
	create_tabular_amplitude('amp_step2',time_table=[(0,0),(period1,1)])
	create_tabular_amplitude('amp_step3',time_table=[(0,0),(period2,1)])
	create_tabular_amplitude('amp_step4',time_table=[(0,0),(period3,1)])

	## mesh punch
	divide(punch,y=0)
	divide(punch,x=0)
	mesh_part(punch,esize=0.6)

	## mesh die
	mesh_part(die,esize=0.6)

	## mesh ejector
	mesh_part(ejector,esize=0.6)

	## surfaces & interaction
	powder_A1 = 'powder_A1'
	faces = face_select(powder_A1,z=MID)
	faces1 = face_select(powder_A1,diameter=pinD)
	faces = unselect(faces,faces1)
	powder_die = create_surface(name='powder-die',faces=faces)

	faces = face_select(powder_A1,nz=-1)
	powder_ejector = create_surface(name='powder-ejector',faces=faces)

	faces = face_select(powder_A1,nz=1)
	faces1 = face_select(powder_A1,diameter=pinD)
	powder_punch = create_surface(name='powder-punch',faces=faces+faces1)

	m_die = create_surface(name='surf-die', poi='die_A1',side_num=2)
	m_ejector = create_surface(name='surf-ejector',poi='ejector_A1',side='+z')
	m_punch = create_surface(name='surf-punch',poi='punch_A1',side_num=2)

	s2s_interact_explicit('powder-die',mfaces=m_die, sfaces=powder_die)
	s2s_interact_explicit('powder-punch',mfaces=m_punch, sfaces=powder_punch)
	s2s_interact_explicit('powder-ejector',mfaces=m_ejector, sfaces=powder_ejector)

	## RP, set, amplitude, BC (RSAB)
	apply_gravity(Gz=-9800,insts='powder_A1')

	try:
		del _part('punch').features['O']
	except:
		pass

	vertices = vertice_select(punch,z=MAX)
	vertices = vertices_sort_byx(vertices)
	create_RP(punch,loc=vertices[0][1][0],name='RP_punch')
	set_punch = create_set('punch_A1',name='RP_punch',RP=_inst('punch_A1').referencePoints.values()[0])

	try:
		del _part('die').features['O']
	except:
		pass

	vertices = vertice_select(die,z=MAX)
	vertices = vertices_sort_byy(vertices)
	create_RP(die,loc=vertices[-1][1][0],name='RP_die')
	set_die = create_set('die_A1',name='RP_die',RP=_inst('die_A1').referencePoints.values()[0])

	try:
		del _part('ejector').features['O']
	except:
		pass

	vertices = vertice_select(ejector,z=MIN)
	vertices = vertices_sort_byy(vertices)
	create_RP(ejector,loc=vertices[-1][1][0],name='RP_ejector')
	set_ejector = create_set('ejector_A1',name='RP_ejector',RP=_inst('ejector_A1').referencePoints.values()[0])

	apply_disp_fix('punch_xy',region=set_punch,Ux=0,Uy=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix('die_xy',region=set_die,Ux=0,Uy=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix('ejector_xy',region=set_ejector,Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

	apply_disp_fix('punch_move',region=set_punch,U3=0,step_modifys=[('step1','u3',-V_height,'amp_step1'),
		('step2','u3',-dip,'amp_step2'),('step3','u3',-PV,'amp_step3'),('step4','u3',-OB,'amp_step4')])
	apply_disp_fix('die_move',region=set_die,U3=0,step_modifys=[('step3','u3',-PV,'amp_step3'),('step4','u3',0)])

	save_as(jobname)
	create_job(jobname)

	print ' '
	print 'PFH=',PFH
	print 'density of filling part:',get_density('H10pow')
	print fnln(),'ref_PFH=',ref_PFH
	print fnln(),'PFH_default=1.61*PH+PV=',PFH_default

	return

function_labels['triangle_insert_profile'] = 'flatness','straightness','sintering','coordinates','insert'
def triangle_insert_profile(jobnum=''):
	## VER: 2017-06-19, v1.1
	## please create the side1, side2, side3 sets first.

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) != 'PART':
		raise Exception('*** Please switch to the part module or display the part in the viewport')

	refresh()
	p1 = get_p1()
	side1 = ''
	side2 = ''
	side3 = ''
	for setname in p1.sets.keys():
		if setname.lower() == 'side1':
			side1 = setname
		elif setname.lower() == 'side2':
			side2 = setname
		elif setname.lower() == 'side3':
			side3 = setname

	if side1 == '':
		raise Exception('*** set side1 not created yet.')

	if side2 == '':
		raise Exception('*** set side2 not created yet.')

	if side3 == '':
		raise Exception('*** set side3 not created yet.')

	if jobnum in empty:
		jobnum = GUI_inputs('jobnum or key info to show in the result.txt file name:',info=p1.name)
	if jobnum[:-1] != '_':
		jobnum = jobnum + '_'

	side10 = get_mid_profile(p1,side1,axis='yx',filename=jobnum + 'side1.txt')
	side20 = get_mid_profile(p1,side2,axis='xy',filename=jobnum + 'side2.txt')
	side30 = get_mid_profile(p1,side3,axis='xy',factor=-1,filename=jobnum + 'side3.txt')
 	flatness = plot_lists({'side1':side10,'side2':side20,'side3':side30},xtitle='path',ytitle='flatness (mm)',path1=p1.name)

	return flatness

function_labels['plot_lists'] = 'xydata','xyplot','curve','chart','file'
def plot_lists(dict1,xtitle='x value',ytitle='y value',path1=''):
	## VER: 2017-06-13, v1.1

##	>>> list1 = [[1,2],[3,4],[5,6]]
##	>>> totable(list1)
##	((1, 2), (3, 4), (5, 6))
##	>>>
##	>>> totable(5)
##	((5,),)
##	>>> totuple(5)
##	(5,)
##	>>>

	## Triangle insert
## 	text1 = '_AD2_fr15_'
##	side1 = get_mid_profile(p1,'side1',axis='yx',filename=text1 + 'side1.txt')
##	side2 = get_mid_profile(p1,'side2',axis='xy',filename=text1 + 'side2.txt')
##	side3 = get_mid_profile(p1,'side3',axis='xy',factor=-1,filename=text1 + 'side3.txt')
## 	plot_lists({'side1':side1,'side2':side2,'side3':side3},xtitle='path',ytitle='flatness (mm)')

	if type_of(dict1) != 'DICT':
		raise Exception('*** a dict of lists with names are required.')

	del_all_curves()

	if 'XYPlot-1' in session.xyPlots.keys():
		del session.xyPlots['XYPlot-1']  ## xyp = session.xyPlots['XYPlot-1']
	xyp = session.XYPlot('XYPlot-1')

	xQuantity = visualization.QuantityType(type=NONE)
	yQuantity = visualization.QuantityType(type=NONE)
##	chart = chart_now()

	chartName = xyp.charts.keys()[0]
	chart = xyp.charts[chartName]   ## 此时的chart是空白的，没有曲线和坐标轴。

	curves = []
	lists = []
	names = []
	## 注意xyData的name并不是curve的name! 这是两个对象的名字。他们不一定相同，相互独立。

##	>>> curve1.data
##	xyDataObjects['side1']
##	>>>
##	>>> curve1.name
##	'side1'
##	>>> curve1.data.name
##	'side1'
##	>>>

	## 生成xyData时，session.XYData()与xyPlot.XYData()不同! XY DataManager界面上看到的是session.XYData()

	for name in dict1.keys():
		list1 = dict1[name]
		list1 = totable(list1)
		if type_of(list1) != 'TUPLE' or type_of(list1[0]) != 'TUPLE' or len(list1[0]) != 2:
			raise Exception('*** a tuple such as ((x1,y1),(x2,y2),...) is required.')

		if name in session.xyDataObjects.keys():
			del session.xyDataObjects[name]

		lists.append(list1)
		names.append(name)

		## Error
##		xy1 = xyPlot.XYData(name='_' + name,data=list1, sourceDescription=name, axis1QuantityType=xQuantity, axis2QuantityType=yQuantity, )
		data1 = session.XYData(name=name,data=list1, sourceDescription=name, axis1QuantityType=xQuantity, axis2QuantityType=yQuantity, )

		c1 = session.Curve(xyData=data1)
		curves.append(c1)

##		print 'name=',name
##		print 'curve name=',c1.name
		session.curves[name].symbolStyle.setValues(show=True)
		session.curves[name].symbolStyle.setValues(marker=FILLED_CIRCLE)
		session.curves[name].symbolStyle.setValues(size=2)

	curves = totuple(curves)
	chart.setValues(curvesToPlot=curves)
	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=xyp)

	if xtitle not in empty:
		axis1 = axis_x_now()
		axis1.axisData.setValues(useSystemTitle=False, title=xtitle)
		axis1.titleStyle.setValues(font='-*-arial-medium-r-normal-*-*-180-*-*-p-*-*-*')

	if ytitle not in empty:
		axis2 = axis_y_now()
		axis2.axisData.setValues(useSystemTitle=False, title=ytitle)
		axis2.titleStyle.setValues(font='-*-arial-medium-r-normal-*-*-180-*-*-p-*-*-*')

	xydata = xydata_now()
	gaps = []
	for data1 in xydata:
		values = []
		for item in data1.data:
			values.append(item[1])
		gap = max(values) - min(values)
		gaps.append(gap)

	average = sum(gaps)/len(gaps)
	average = round(average,4)
	refresh(text='flatness=' + str(average),ask=False,path1=path1)

##	print ' '
##	for i in range(len(lists)):
##		list_to_txt_lines(lists[i],filename=names[i] + '.txt')

	return average

def plot_nodal_path(nodes,path=None,sort='x',variable='U3',plotname='XYPlot-1',check_name=True,step=-1,frame=-1):
	## VER: ('VER: 2016-06-29, v1.3')

	## Example: plot_nodal_path('dim_bot_mid',sort='x',variable='U3')
	## plot_nodal_path('dim_bot_arc',sort='x',variable='COOR3')

	set_step_and_frame(step=step,frame=frame)

	if path in empty or type_of(path) != 'PATH':
		if nodes in empty:
			raise Exception('odb nodes or nodal path is required.')

		path = path_from_odb_nodes(nodes=nodes, sort=sort)

	if type_of(path) != 'PATH':
		raise Exception('No nodal path to plot.')

	## 首先要显示全部
	vpnow = get_vpnow()
	leaf = dgo.Leaf(leafType=DEFAULT_MODEL)
	vpnow.odbDisplay.displayGroup.replace(leaf=leaf)

	plot_variable(variable)

	if plotname in session.xyPlots.keys():
		if check_name == False:
			xyp = session.xyPlots[plotname]

		else:
			plotname = new_key(plotname,session.xyPlots.keys())
			xyp = session.XYPlot(plotname)
	else:
		xyp = session.XYPlot(plotname)

	## xyp.name就是plotname
	## xyPlot->charts->curves
	## xyp有其curves和charts，二者均是字典。另外还有curvesToPlot，是一个tuple.

	chart = xyp.charts.values()[0]	## 一个 xyPlot可以有几个chart

	xydata = xyPlot.XYDataFromPath(path=path, includeIntersections=False, shape=DEFORMED, labelType=TRUE_DISTANCE)
	curve1 = session.Curve(xyData=xydata)		## 画曲线

	print fnln_fnln(),'chart.curves=',chart.curves
	chart.setValues(curvesToPlot=(curve1, ), )		## 把curve1装到chart中。一个chart可以有几条curve
	vpnow.setValues(displayedObject=xyp)

	chart.axes1[0].axisData.setValues(tickMode=TOTAL_NUMBER)
	chart.axes1[0].axisData.setValues(tickCount=10)
	chart.axes1[0].axisData.setValues(minorTickCount=1)

	values = []
	for item in xydata:
		values.append(item[1])
	max_value = max(values)
	min_value = min(values)

	scale = LOG
	if max_value <= 10:
		scale = LINEAR

	chart.axes2[0].axisData.setValues(scale=scale)		;please_check

	print fnln_fnln(),'chart.curves=',chart.curves

	print '--->Plotted nodal path, name=',plotname,', variable=',variable
	print 'max_value=',max_value,', min_value=',min_value,', yaxis scale=',scale
	print '--->xyData name=',xydata.name,'. (x,y) data is stored in it.'
	print 'Returned result=',(plotname,xydata)
##	print 'xydata=',xydata
	print ' '

	return plotname,xydata

def plot_set(poi,setname):
	## VER: 2016-03-02, v1.0

	poi = check_pia(poi)
	if setname not in poi.sets.keys():
		raise Exception('*** set name not existed in ' + poi.name)

	set1 = poi.sets[setname]
	leaf = dgm.LeafFromSets(sets=(set1, ))
	session.viewports['Viewport: 1'].partDisplay.displayGroup.replace(leaf=leaf)

	dg = session.DisplayGroup(leaf=leaf, name='_dg')
	highlight(dg)

	return

def plot_nodes(nodes,poi=None):
	## VER: 2016-03-02, v1.0
	## Please shown on the node label in CAE
	## By plot the nodes, you can measure the distance between nodes, especially usefull for internal radius.

##	nodes = node_select('p1',x=0)
##	plot_nodes(nodes)   ## then measure the distance between two nodes in GUI.

	if type_of(nodes) == 'STR' and poi in empty:
		raise Exception('*** poi for the nodes is required.')

	if type_of(nodes) == 'STR':
		plot_set(poi=poi,setname=nodes)
	else:
		nodes = tolist(nodes)
		poi = get_poi(nodes)
		create_set(poi,nodes=nodes,name='_nodeset',check_name=False)
		plot_set(poi=poi,setname='_nodeset')

		print 'Created node set name=_nodeset for these nodes. You can replace and reselect nodes by edit this node set in GUI.'
		print ' '

	return

def plot_time_response(inst='LAM_A1',node=14,steps=None, stepname='',stepnum=None,variable='U3',plotname='XYPlot_1',check_name=True, yscale=None, print_axis=False):

	## VER: ('VER: 2012-06-11, v1.4')
	## Example: >>> plot_time_response(node=18346,variable='U')  ## 对于step1=frequency, step2=step3=time_response_modal_dynamics_step()适用，自动滤掉step1

	inst = check_odb_instance(inst)
	inst = inst.name

	node = str(node)
	if node.isdigit() == False:
		raise Exception('Incorrect node_label number.')

	if type_of(steps) == 'INT':
		stepnum = steps
	elif type_of(steps) == 'STR':
		stepname = steps

	if stepname not in empty:
		if stepname not in odb.steps.keys():
			raise Exception('Error stepname=' + repr(stepname))

	if type_of(stepnum) == 'INT':
		if stepnum > len(odb.steps):
			raise Exception('Error stepnum=' + repr(stepnum))

	if stepname in empty and type_of(stepnum) == 'INT':
		stepname = odb.steps.values()[stepnum-1].name

	if stepname not in empty:
		steps = [stepname]
	elif steps not in empty:
		if type_of(steps) not in ['LIST', 'TUPLE']:
			raise Exception('step names or step nums are required.')

		if type_of(steps[0]) == 'INT':
			steps0 = []
			for num in steps:
				name = odb.steps.keys()[num - 1]
				steps0.append(name)
			steps = steps0

		elif type_of(steps[0]) != 'STR':
			raise Exception('step names or step nums are required.')
	else:
		steps = []
		for step in odb.steps.values():
##			if step.domain != MODAL:
			if step.domain == TIME:
				steps.append(step.name)

	if steps in empty:
		raise Exception('No time domain step to plot the time response.')

	frames = []
	for stepname in steps:
		step_frames = (stepname, ('0:-1', ))
		frames.append(step_frames)
	frames = totuple(frames)
	session.odbData[odb.name].setValues(activeFrames=frames)

	clear_xyPlots()
	clear_xyDataObjects()

	xyp = session.XYPlot(plotname)

	variable = variable.upper()
	if variable == 'U3':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'U', NODAL, ((COMPONENT, 'U3'), )), ), nodeLabels=((inst, (node, )), ))
	elif variable == 'U':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'U', NODAL, ((INVARIANT, 'Magnitude'), )), ), nodeLabels=((inst, (node, )), ))
	elif variable == 'S1':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'S', INTEGRATION_POINT, ((INVARIANT, 'Max. Principal'), )), ), nodeLabels=((inst, (node, )), ))
	elif variable == 'S':
		xyList = xyPlot.xyDataListFromField(odb=odb, outputPosition=NODAL, variable=((
		    'S', INTEGRATION_POINT, ((INVARIANT, 'Mises'), )), ), nodeLabels=((inst, (node, )), ))

	xyData = session.xyDataObjects.values()[-1]

	new_data = []
	axis_V = []		## 纵坐标的值
	axis_H = []		## 横坐标的值
	for data in xyData.data:
		if abs(data[1]) < 1e12:
			new_data.append(data)
			axis_V.append(data[1])
			axis_H.append(data[0])

	new_data = totuple(new_data,open_element=False)
	xyData.setValues(data=new_data)

	max_value = max(axis_V)
	min_value = min(axis_V)

	chart = xyp.charts.values()[0]
	curveList = session.curveSet(xyData=[xyData])
	chart.setValues(curvesToPlot=curveList)

	chart.axes1[0].axisData.setValues(tickMode=TOTAL_NUMBER)
	chart.axes1[0].axisData.setValues(tickCount=10)
	chart.axes1[0].axisData.setValues(minorTickCount=1)
	chart.axes1[0].axisData.setValues(useSystemTitle=False, title='Time (sec)')

	if max_value <= 200:
		chart.axes2[0].axisData.setValues(scale=LINEAR)		;please_check
	else:
		chart.axes2[0].axisData.setValues(scale=LOG)

	if type_of(yscale) in ['FLOAT','INT']:
		chart.axes2[0].axisData.setValues(maxValue=yscale, maxAutoCompute=False)

	if variable == 'S1':
		chart.axes2[0].axisData.setValues(useSystemTitle=False, title='Stress (S1, MPa)')
	elif variable == 'S':
		chart.axes2[0].axisData.setValues(useSystemTitle=False, title='Stress (Mises, MPa)')
	elif variable in ['U', 'U1', 'U2', 'U3']:
		chart.axes2[0].axisData.setValues(useSystemTitle=False, title='Displace./deform. (mm)')

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=xyp)

	if yscale in empty:
		yscale = 'Automatic'

	print '--->Plotted step response for steps=',steps,', variable=',variable,', plotname=',plotname
	if len(axis_V) > 10:
		print '**y_scale=',yscale,', max value=',round(max_value,3), ', min value=',round(min_value,3)
	else:
		print 'y_scale=',yscale,', data points=',new_data
	print 'xyData.fileName =',xyData.fileName
	print 'All plotnames in session.xyPlots:',session.xyPlots.keys()
	print ' '

	if print_axis == True:
		print 'axis_H =',axis_H
		print ' '
		print 'axis_V =',axis_V
		print ' '

	return xyData

def plot_variable(variable='',main_var='',sub_var='', setting={}):
	## VER: ('VER: 2015-07-27, v1.8')
	## 不涉及step and frame
##	print 'Tip: You can get the primary variable by display.primaryVariableLabel'

	## Example: plot_variable('U1')

	global variable_dict

	vpnow = get_vpnow()
	plot_state = vpnow.odbDisplay.display.plotState[0]

	dpo = vpnow.displayedObject
	if type_of(dpo) != 'ODB':
		try:
			odb=session.openOdb(name=odb_file_title + '.odb', readOnly=False)   ## odb在当前工作目录
		except:
			odb = session.openOdb(name=odb_file_path,readOnly=False)   ## odb不一定在当前工作目录

		vpnow.setValues(displayedObject=odb)
		vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))
		refresh()
	else:
		vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))	  ## must go into contour state

	if setting in empty:
		info = odb_variables(variable=variable,main=main_var,sub=sub_var)
##		print fnln(),'info=',info
		if 'main' in info.keys():
			main_var = info['main']
			position = info['position']
			refinement = info['refinement']
		else:
			print fnln(),'variable=',variable,', main=', main_var, ', sub=', sub_var
			raise Exception

	else:
		main_var = setting['main0']  ## e.g., 'main0': 'CSHEARF  ASSEMBLY_SURF_ANVIL_INT/ASSEMBLY_SURF_CUTTER_INT'
		position = setting['position']
		refinement = setting['refinement']

	vpnow = get_vpnow()
	if refinement not in empty:
		vpnow.odbDisplay.setPrimaryVariable(variableLabel=main_var, outputPosition=position, refinement=refinement )
	else:
		vpnow.odbDisplay.setPrimaryVariable(variableLabel=main_var, outputPosition=position)
	vpnow.odbDisplay.display.setValues(plotState=(plot_state, ))

	setting = current_variable_setting()

	return setting   ## 不含value

def plotset(setname,inst=None):
	## VER: ('VER: 2012-10-10, v1.9')

	setname = tolist(setname)  ## 可能提供了多个setname的列表。

	vpnow = get_vpnow()
	type1 = type_of(vpnow.displayedObject)
	if type1 == 'ODB' or type1 == 'XYPLOT':
		if type1 == 'XYPLOT':
			vpnow.setValues(displayedObject=odb)
			vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))

		refresh()

		leaf = get_leaf_of_odb_sets(setname,inst=inst)
		vpnow.odbDisplay.displayGroup.replace(leaf=leaf)
		globals()['leaf_0'] = leaf
		globals()['_ndel'] = 0

	elif type1 == 'ASSEMBLY':
##		if 'cae_file_title' not in globals().keys() or get_cae_file_title() != cae_file_title:
##			refresh()

		refresh()

		sets = []
		for inst in a.instances.values():
			for set1 in setname:
				for set2 in inst.sets.keys():
					if set1.upper() == set2.upper():
						sets.append(inst.sets[set2])
						break

		if sets not in empty:
			leaf = dgm.LeafFromSets(sets = tuple(sets))
			vpnow.assemblyDisplay.displayGroup.replace(leaf=leaf)
		else:
			raise Exception('******No sets found in the assembly by setname=' + repr(setname))

	elif type1 == 'PART':
##		if 'cae_file_title' not in globals().keys() or get_cae_file_title() != cae_file_title:
##			refresh()

		refresh()

		sets = []
		part = vpnow.displayedObject
		for set1 in setname:
			for set2 in part.sets.keys():
				if set1.upper() == set2.upper():
					sets.append(part.sets[set2])
					break

		if sets not in empty:
			leaf = dgm.LeafFromSets(sets = tuple(sets))
			vpnow.partDisplay.displayGroup.replace(leaf=leaf)
		else:
			print 'Setnames in', part.name,':',part.sets.keys()
			print ' '
			raise Exception('******No sets found in the part ' + part.name + ' by setname=' + repr(setname))

	return

def poi_name_of_var(var):
	## VER: 2013-05-17, v1.0, I know var, wnant to know name of corresponding poi

	name = None
	if type_of(var) == 'STR' and var in globals().keys():
		type1 = type_of(globals()[var])
		if 'PART' in type1 or 'INSTANCE' in type1:
			name = globals()[var].name
	else:
		type1 = type_of(var)
		if 'PART' in type1 or 'INSTANCE' in type1:
			name = var.name

	if name == None:
		raise Exception('**** Fail to get the poi_name_of_var')

	return name

def poi_names(list1):
	## VER: ('VER: 2014-05-09, v1.3')

	if list1 in empty:
		return []

	list1 = tolist(list1)
	names = []
	for poi in list1:
		if type_of(poi) in ['PART','PINSTANCE','ODBINSTANCE']:
			if poi.name not in names:
				names.append(poi.name)

	return names

def poi_of_region(region):
	## VER: 2014-01-16, v1.0

	poi = None
	if type_of(region) == 'REGION':
		for seq in [region.cells, region.faces, region.side1Faces, region.side2Faces, region.edges, \
			region.side1Edges, region.side2Edges, region.vertices, region.elements, region.nodes]:

			if len(seq) > 0:
				poi = get_poi(seq[0])
				break

	elif type_of(region) == 'SURFACE':
		for seq in [region.faces, region.edges, region.elements, region.nodes]:
			if len(seq) > 0:
				poi = get_poi(seq[0])
				break

	if poi in empty:
		raise Exception('*** fail to get the poi of ' + type_of(region))

	return poi

def poi_span(poi=None,err=3e-3,sym='full'):
	## VER: 2016-09-30, v1.1

	x1,x2,y1,y2,z1,z2 = poi_space(poi=poi,err=err)
	spanx = x2-x1
	spany = y2-y1
	spanz = z2-z1

	if 'x' in sym:
		spanx = spanx*2
	if 'y' in sym:
		spany = spany*2
	if 'z' in sym:
		spanz = spanz*2

	return spanx,spany,spanz

def poi_span_by_nodes(p1):
	## VER: 2016-09-14, v1.0
	## used for dimension measurement after sintering

	p1 = check_poi(p1)
	if len(p1.nodes) == 0:
		raise Exception('*** no nodes in the part.')

	nx1 = node_select(p1,x=MIN,err=0.05)
	nx2 = node_select(p1,x=MAX,err=0.05)
	spanx = average_xdist(nx1,nx2)

	ny1 = node_select(p1,y=MIN,err=0.05)
	ny2 = node_select(p1,y=MAX,err=0.05)
	spany = average_ydist(ny1,ny2)

	nz1 = node_select(p1,z=MIN,err=0.05)
	nz2 = node_select(p1,z=MAX,err=0.05)
	spanz = average_zdist(nz1,nz2)

	return spanx,spany,spanz

def poi_space(poi=None,err=3e-3):
	## VER: 2014-10-20, v2.7
	## before: err=3e-3, 3um (too large??)
	## key sub functions: check_values(), check_loc()

##	>>> poi_space()
##	(-8.51965, 8.51965, -3.001, 0.291, -8.51965, 8.51965)
##	>>>

	if poi in empty and caller_name() == 'cliCommand':
		dpo = get_dpo()
		if type_of(dpo) == 'PART':
			poi = dpo
		else:
			raise Exception('*** poi is required, or switch to part view, instead of assembly view.')

	poi = check_poi(poi)
	if len(poi.vertices) == 0:
		if _len(poi.elements) == 0:
			x1,x2,x3,x4,x5,x6 = (0,0,0,0,0,0)
		else:
			nodes = poi.nodes
			if len(nodes) < 50000:
				x1,x2,x3,x4,x5,x6 = objs_space(poi.nodes)   ## mesh part, without geometry  (这种方法非常慢)
			else:
				box = nodes.getBoundingBox()
				x1,y1,z1 = box['low']
				x2,y2,z2 = box['high']
				x1,x2,x3,x4,x5,x6 = round6(x1,x2,y1,y2,z1,z2)

	else:
		space_v = space_of_sequence(poi.vertices[:])
		space_e = space_of_sequence(poi.edges[:])

	##	print fnln(),'vertice: space_v=',space_v   ## may also not precise enough even for vertice
	##	print fnln(),'edge: space_e=',space_e		 ## may also not precise enough even for edges
		space = check_space(space_v,space_e)

	##	print fnln(),'space=',space

		if len(poi.faces) > 0:
			space_f = space_of_sequence(poi.faces[:])
			f1,f2,f3,f4,f5,f6 = space_f
	##		print fnln(),'faces: space_f=',space_f

			space = check_space(space,space_f)
			x1,x2,x3,x4,x5,x6 = space

			## symmetric
			if PK(f1,-f2) == 0:
				x1,x2 = f1,f2

			if PK(f3,-f4) == 0:
				x3,x4 = f3,f4

			if PK(f5,-f6) == 0:
				x5,x6 = f5,f6

			y1,y2,y3,y4,y5,y6 = get_common_space(space_v,space_e,space_f)   ## point, edge, and face

			x1 = find_coarse(x1,y1,err=err,fail=x1)
			x2 = find_coarse(x2,y2,err=err,fail=x2)
			x3 = find_coarse(x3,y3,err=err,fail=x3)
			x4 = find_coarse(x4,y4,err=err,fail=x4)
			x5 = find_coarse(x5,y5,err=err,fail=x5)
			x6 = find_coarse(x6,y6,err=err,fail=x6)

			space = x1,x2,x3,x4,x5,x6

		else:   ## only edges and vertices
			f1,f2,f3,f4,f5,f6 = space_e
			x1,x2,x3,x4,x5,x6 = space

			## symmetric
			if PK(f1,-f2) == 0:
				x1,x2 = f1,f2

			if PK(f3,-f4) == 0:
				x3,x4 = f3,f4

			if PK(f5,-f6) == 0:
				x5,x6 = f5,f6

			space = x1,x2,x3,x4,x5,x6

		x1,x2,x3,x4,x5,x6 = space

	## check symmetry
	if PK(-x1,x2) == 0 and PK(-x5,x6) == 0:  ## circular, ndir=y
		x0 = find_coarse(x2,x6,err=2e-4, fail=None)
		if x0 != None:
			x1 = x5 = -x0
			x2 = x6 = x0

	if PK(-x1,x2) == 0 and PK(-x3,x4) == 0:
		x0 = find_coarse(x2,x4,err=2e-4,fail=None)
		if x0 != None:
			x1 = x3 = -x0
			x2 = x4 = x0

	if PK(-x5,x6) == 0 and PK(-x3,x4) == 0:
		x0 = find_coarse(x4,x6,err=2e-4,fail=None)
		if x0 != None:
			x3 = x5 = -x0
			x4 = x6 = x0

	return x1,x2,x3,x4,x5,x6

def poa_feature_objs(poa):
	## VER: 2014-06-25, v1.0

##>>> dict1 = poi_features(anvil)
##>>> type_of(dict1['datum_planes'][0])
##'DATUMPLANE'
##>>>
##>>> prettyPrint(dict1['datum_planes'][0])
##({'normal': 'tuple object',
##  'pointOn': 'tuple object'})
##>>>
##>>> dict1['datum_planes'][0]
##mdb.models['Model-1'].parts['anvil'].datums[7]
##>>>

	poa = check_pias(poa)
	if type_of(poa) == 'PINSTANCE':
		poa = a

	if type_of(poa) not in ['PART','ASSEMBLY']:
		raise Exception('*** part or assembly is required, such as: poa_features(a)')

	unknows = []
	datum_points = []
	datum_axis = []
	datum_planes = []
	RPs = []
	Csys = []
	insts = []
	partitions = []
	ids = []

	for name in poa.features.keys():
		obj = poa.features[name]
		index = obj.id
		ids.append(index)
		if index in poa.datums.keys():
			obj1 = poa.datums[index]
			if 'xValue' in obj.__members__:
				datum_points.append(obj1)
			elif 'direction' in obj1.__members__:
				datum_axis.append(obj1)
			elif 'normal' in obj1.__members__:
				datum_planes.append(obj1)
			elif 'coordSysType' in obj1.__members__:
				Csys.append(obj1)
		elif index in poa.referencePoints.keys():
			RPs.append(poa.referencePoints[index])
		elif poa == a and obj.name in a.instances.keys():
			obj1 = a.instances[obj.name]
			insts.append(obj1.name)
		elif obj.name.startswith('Partition cell-'):
			partitions.append(obj.name)
		else:
			unknows.append(obj.name)

	dict1 = {}
	dict1['insts'] = insts
	dict1['csys'] = Csys
	dict1['RPs'] = RPs
	dict1['ids'] = ids
	dict1['datum_points'] = datum_points
	dict1['datum_axis'] = datum_axis
	dict1['datum_planes'] = datum_planes
	dict1['partitions'] = partitions
	dict1['unknows'] = unknows

##	myprint(dict1)

	return dict1


def poi2poi(poi1,poi2):
	## 2010-12-17, v1.0

	poi1 = check_pias(poi1)
	poi2 = check_pias(poi2)

	space1 = poi_space(poi1)
	space2 = poi_space(poi2)

	dx = space2[0] - space1[0]
	dy = space2[2] - space1[2]
	dz = space2[4] - space1[4]

	return dx,dy,dz

def poi2sequence(poi,obj_type=None):
	## VER: 2010-09-30, v1.1

	poi = check_poi(poi)

	if obj_type in empty:
		if len(poi.cells) > 0:
			obj_type = 'cells'
		elif len(poi.faces) > 0:
			obj_type = 'faces'
		elif len(poi.edges) > 0:
			obj_type = 'edges'
		elif len(poi.elements) > 0:
			obj_type = 'elements'

	full_set = eval('poi.' + obj_type)
	num = len(full_set)

	sequence = full_set[0:num]

	return sequence

def poi2region(poi,obj_type='cells'):
	## VER: 2010-09-29, v1.0

	sequence = poi2sequence(poi=poi,obj_type=obj_type)

	if obj_type != 'faces':
		region = eval('Region(' + obj_type + '=sequence)')
	else:
		try:
			region = eval('Region(side1Faces = sequence)')
		except:
			region = eval('Region(faces = sequence)')
			print '**faces are from many sides.'

	print '--->',poi.name,'are grouped into a',obj_type,'region by poi2region()'

	return

def point_at(part,loc=(),dx=0,dy=0,dz=0,err=0.1):
	## VER: ('VER: 2015-07-07, v1.3')		## note: point should be used immediately,index is variable.

	part = check_poi(part)
	if loc in empty:
		print 'loc=',loc
		raise Exception('Error loc=' + totext(loc))

	if is_location(loc) == False:
		raise Exception('Error loc=' + totext(loc))

	loc = (loc[0]+dx,loc[1]+dy,loc[2]+dz)
	point = part.vertices.findAt(coordinates=loc, printWarning=False)		## type_of(point) = 'vertices' if found.
	if point == None:
		vertices = box_select(part.vertices,x=loc[0],y=loc[1],z=loc[2],err=err)
		if vertices not in empty:
			point = vertices[0]
		else:
			if type_of(part) == 'PINSTANCE':
				p = a
			else:
				p = part
			p.DatumPointByCoordinate(coords=loc)  ## only part or assembly have this method, part instance without
			index = p.datums.keys()[-1]
			point = p.datums[index]

	return point

vertice_at = point_at

def point_loc(point):
	## VER: 2014-10-17, v1.0

##	>>> point_loc((0,1))
##	(0, 1)
##	>>>

	if type_of(point) == 'vertices':
		parent = get_parent(point)
		if is_sketch(parent):
			point = point.coords   ## sketch point to loc
		else:
			point = point.pointOn[0]
	elif type_of(point) == 'nodes':
		node = point
		point = node.coordinates ## node to loc
	elif type_of(point) == 'DATUMPOINT':
		datum = point
		point = datum.pointOn

	if is_location(point) == False:
		raise Exception('*** fail to get the point loc.')

	return point


def point_nearby(p,setname,index1=0,dx=0,dy=0,dz=0):
	## VER: 2010-02-04

	loc = KPxyz(setname,p,index1)
	loc1 = (loc[0] + dx, loc[1] + dy, loc[2] + dz)
	point = point_at(p,loc1)

	return point


def point_range(loc=(),dx=0,dy=0,dz=0):
	## VER: 2010-03-12

	x1 = loc[0];	y1 = loc[1];	z1 = loc[2]
	x2 = x1 + dx;	y2 = y1 + dy;	z2 = z1 + dz

	return (x1,x2),(y1,y2),(z1,z2)

def pointOns2faces(p,points):
	## VER: 2010-05-13
	faces = []

	if type_of(points[0]) in ['FLOAT','INT']:
		points = [points]

	if len(points) > 0:
		for point in points:
			face1 = face_at(p,point)
			if face1 != None:
				faces.append(face1)

		if len(faces) > 0:
			print len(faces),'faces are selected from',p.name,'by pointOns2faces()'
		else:
			print fnln_fnln(),'******Faces not found by points. line=5076, pointOns2faces()'
			error_record('pointOns2faces()')

	return faces

def poi_with_setname(setname,allow_many=False):
	## VER: 2012-08-31, v1.0

	insts = insts_by_set(setname)
	parts = parts_by_set(setname)
	if insts in empty and parts in empty:
		if allow_many == True:
			return []
		else:
			raise Exception('poi is required.')

	poi = None
	if insts not in empty:
		if allow_many == True:
			return insts
		else:
			if len(insts) > 1:
				raise Exception('more than one instance has setname=',setname,', poi is required.')
			else:
				poi = insts[0]
	else:
		if allow_many == True:
			return parts
		else:
			if len(parts) > 1:
				raise Exception('more than one part has setname=',setname,', poi is required.')
			else:
				poi = parts[0]

	return poi

def pointOn_of(obj):
	## VER: 2010-01-14
	return obj[0].pointOn[0]

def edges_to_vertices(edges,sort=None):
	## VER: ('VER: 2017-10-26, v1.3')

	edges = tolist(edges)
	vertices = []

	if type_of(sort) == 'STR':
		sotr = sort.lower()

	if edges in empty:
		raise Exception('*** Empty edges.')

	poi = get_poi(edges[0])
	for edge in edges:
		indexs = edge.getVertices()
		for index in indexs:
			vertice = poi.vertices[index]
			if vertice not in vertices:
				if len(vertice.getEdges()) > 0:   ## To avoid the arc center point
					vertices.append(vertice)

	if sort == 'x':
		vertices = vertices_sort_byx(vertice,return_obj=True)
	elif sort == 'y':
		vertices = vertices_sort_byy(vertice,return_obj=True)
	elif sort == 'z':
		vertices = vertices_sort_byz(vertice,return_obj=True)

	return vertices

def faces_to_vertices(faces):

	## VER: ('VER: 2012-03-11, v1.1')		## 收集的是vertice。

	faces = tolist(faces)

	vertices = []
	for face in faces:
		poi = get_poi(face)
		for index1 in face.getVertices():
			vertice = poi.vertices[index1]
			if vertice not in vertices:
				vertices.append(vertice)

	return vertices

def pointOns_of_faces(faces):
	## VER: 2015-07-06, v1.1 收集的是点的位置信息。

	faces = tolist(faces)
	poi = get_poi(faces)

	points = []
	for face in faces:
		for index1 in face.getVertices():
			loc = poi.vertices[index1].pointOn[0]
			if loc not in points:
				points.append(loc)

		points.append(face.pointOn[0])

	return points

def pointOns_of_curve(edge,parameters=(0,0.1,0.25,0.5,0.75,0.9,1.0)):
	## VER: 2012-11-26, v1.1
	## edge可以来自instance，也可以来自part

	if type_of(edge) != 'edges':
		raise Exception('one edge object is required.')

	pointOns = []
	for loc in parameters:
		point = create_datum_point(edge=edge,parameter=loc)
		loc1 = point.pointOn
		if loc1 not in pointOns:
			pointOns.append(loc1)

	pointOns.append(edge.pointOn[0])

	return pointOns

def points_sort_byx(points,poi=''):
	## VER: 2010-10-08, v1.0

	if type_of(points) == 'STR':
		if poi != '':
			points = set2objs(points,poi)
		else:
			raise Exception('Part or instance name is needed. line=5546, points_sort_byx().')  ## ********

	num = len(points)
	for i in range(num - 1):
		loc1 = points[i].pointOn[0][0]
		for j in range(i + 1,num):
			loc2 = points[j].pointOn[0][0]
			if loc2 < loc1:
				point = points[i]
				points[i] = points[j]
				points[j] = point
				loc1 = loc2

	return points

def points_sort_byy(points,poi=''):
	## VER: 2010-10-08, v1.0

	if type_of(points) == 'STR':
		if poi != '':
			points = set2objs(points,poi)
		else:
			raise Exception('Part or instance name is needed. line=5546, points_sort_byx().')  ## ********

	num = len(points)
	for i in range(num - 1):
		loc1 = points[i].pointOn[0][1]
		for j in range(i + 1,num):
			loc2 = points[j].pointOn[0][1]
			if loc2 < loc1:
				point = points[i]
				points[i] = points[j]
				points[j] = point
				loc1 = loc2

	return points

def points_sort_byz(points,poi=''):
	## VER: 2010-10-08, v1.0

	if type_of(points) == 'STR':
		if poi != '':
			points = set2objs(points,poi)
		else:
			raise Exception('Part or instance name is needed. line=5546, points_sort_byx().')  ## ********

	num = len(points)
	for i in range(num - 1):
		loc1 = points[i].pointOn[0][2]
		for j in range(i + 1,num):
			loc2 = points[j].pointOn[0][2]
			if loc2 < loc1:
				point = points[i]
				points[i] = points[j]
				points[j] = point
				loc1 = loc2

	return points

def open_and_write_odb():

	## VER: ('VER: 2012-06-29, v2.9')	## 紧接着程序运算结束之后运行。否则用res2file1()

	vpnow = get_vpnow()
##	if type_of(vpnow.displayedObject) == 'ODB':
##		file_name = vpnow.displayedObject.analysisTitle + '.odb'
##	elif 'created_odb_file' in globals().keys():
##		file_name = created_odb_file
##	else:
##		print fnln_fnln(),'******No odb to open now.'
##		return

	open_odb(created_odb_file,readonly=False)
##	vpnow.odbDisplay.basicOptions.setValues(mirrorAboutXzPlane=False, mirrorAboutYzPlane=False)

##	refresh()

	write_odb(symm_center=symmetry)
	write_odb(textname='options',text=str(options))

	print fnln_fnln(),'Writed info for odb.name=',odb.name

##	raise Exception

##	res2file1()

	return

def print_attributes(obj,level=2):
	## VER: 2013-07-23, v1.0

	if mems_num(obj) > 0:
		for prop in obj.__members__:
			value = get_attrib(obj,prop)
			if value != 'unknow':
				if is_none_empty_structure(value):
					print prop,':'
					prettyPrint(value,level)
				else:
					print prop, ':', value

	return

def print_caller_code():
	## VER: 2011-11-09, v1.1

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

	tb = get_traceback()
	if len(tb) >= 5 and type_of(tb[-5]) == 'INT':
##		print 'Traceback in',tb[-4] + '():'
		print 'Traceback: results of command line ' + str(tb[-5]) + '):'
		print ' ',get_line_code(tb[-5])

	return

def print_contacts():
	## VER: 2014-06-11, v1.4

	print 'Interaction properties:'
	for prop in _m.interactionProperties.values():
		print 'InteractionProperty name:',prop.name
		print_attributes(prop,level=3)
		print ' '

	print ' '
	print 'interactions and constraints:'
	mycontacts = {}
	for contact in _m.interactions.values():
		print '---------------------'
		print 'Interact name:',contact.name
		print 'description:', contact.__doc__
		info = get_interact_surface(contact)
		keys = _sort(info.keys())
		for key in keys:
			if key not in ['mfaces','sfaces','surface']:
				print '   ', key,'=',info[key]

		print 'Active steps:',active_steps_of_interact(contact.name)

		prettyPrint(contact,2)

		j = 0
		for step in _m.steps.values()[1:]:  ## Initial step没有status这个属性
			if contact.name in step.interactionStates.keys():
				contact_obj = step.interactionStates[contact.name]
				if 'status' in contact_obj.__members__:
##					print load_obj.status
					if contact_obj.status not in [NOT_YET_ACTIVE,PROPAGATED]:
						j += 1
						if j >= 2:
							print '****'
						step_num = get_sequence_index(_m.steps.keys(),step.name)
						print '---in step '+ str(step_num) + ', name=',step.name,', action=',contact_obj.status

						keyname = contact.name + '(' + repr(type(contact_obj))[7:-7] + ')'
						value = 'In step ' + str(step_num) + '(' + step.name + '), ' + repr(contact_obj.status)
						if keyname not in mycontacts.keys():
							mycontacts[keyname] = [value]
						else:
							mycontacts[keyname].append(value)
##							mycontacts[load.name] = 'In step ' + str(step_num) + '(' + step.name + '), ' + repr(load_obj.status) + ' ' + repr(type(load_obj))[7:-7]
						if contact_obj.status != DEACTIVATED:
							prettyPrint(contact_obj,2)

		print ' '

	for contact in _m.constraints.values():
		type1 = get_constraint_type(contact.name)
		print '---------------------'
		print 'Constraint name:',contact.name
		print 'Constraint type:',type1
		print 'description:    ', contact.__doc__
		info = get_constraint_info(contact)
		keys = _sort(info.keys())
		for key in keys:
			if key not in ['mfaces','sfaces','surface']:
				print '   ', key,'=',info[key]

		prettyPrint(contact,2)
		if type1 == 'rigidbody':
			surface_name = contact.surfaceRegion[0]
			print 'surface_side:   ',get_surface_side(surface_name)

		print ' '

	return

def print_dir(obj,level=1):
	## VER: ('VER: 2013-12-14, v2.8')

	meths = []
	props = []
	keys = []
	dirs = dir(obj)
	get_functs = []

	print '**Usage: print_dir(obj,level=1)'
	print ' '

	preview = repr(obj)
	if len(preview) > 360:
		preview = preview[:360] + '......'
	print 'obj=',preview

	parent = get_parent(obj)
	parent_type = original_type(parent)
	if parent not in empty:
		parent = repr(parent)
		print 'parent of obj =',parent
	else:
		parent = ''
	print ' '

	type1 = type_of(obj)
	print '**type_of(obj)=',type1		## Array object没有keys和prop，但是有elem_num.
	elem_num = len_num(obj)
	key_num = keys_num(obj)
	mem_num = mems_num(obj)

	if type1 not in basic_types:
		dir1 = dir(obj)
		if len(dir1) < 30:
			print 'dir(obj) =',dir1
		print 'You can search for',repr(type(obj))[7:-2],'object for more detail in Abaqus Scripting Reference Manual.'
	print ' '

	meth_from_dir = False
	meth_from_methods = False

	prop_from_dir = False
	prop_from_members = False
	prop_from_keys = False

	## 收集methods
	for item in dir(obj):
		try:
			attrib = eval('obj.' + item)
			type1 = type_of(attrib)

			if item[:3] == 'get' and item + '()' not in get_functs:
				get_functs.append(item+'()')

			if item[:2] != '__':    ##非函数，即属性
				if 'METHOD' in type1 or 'FUNCTION' in type1:   ## 函数
					meths.append(item)
					meth_from_dir = True
				else:		## 属性
					props.append(item)
					prop_from_dir = True

			else:
				if 'method' in repr(type(attrib)):
					meths.append(item)
					meth_from_dir = True
				else:
					props.append(item)
					prop_from_dir = True
		except:
			pass

	try:
		methods = obj.__methods__
		if methods not in empty:
			meth_from_methods = True
		for item in methods:
			if item not in meths:
				meths.append(item)

	except:
		pass

	if mem_num <= 0:
		mems = []
	else:
		mems = obj.__members__

	if len(props) > 0:
		if mem_num == None:
			mem_num = 0
		non_mem_props = len(props) - mem_num
	else:
		non_mem_props = 0

	if len(props) < 50:
		print 'props =',props
	else:
		print 'props =',props[:50],'shown only 50 properties'

	if len(meths) < 50:
		print 'meths =',meths
	else:
		print 'meths =',meths[0:50],'(shown only 50 methods)'

	print ' '
	print 'method and properties: dir_num=',len(dir(obj)),', meth_num=',len(meths), ', props_num=',len(props), ', non_mem_props=',non_mem_props, ', mem_props=',mem_num
	print 'contents: len_num =',elem_num, ', keys_num=', key_num   ## key属于element的概念，是对某个element的引用。
	if len(props) > 0:
		print mem_num,'mem_props:',mems
		print len(props) - mem_num,'non_mem_props:',unselect(props,mems)
	print ' '

	## 对于诸如vertice, edge, face, cell, node, element
	if mem_num >= 1:
		prop_from_members = True
		for item in obj.__members__:
			if item not in props:
				props.append(item)

##	try:
##		membs = obj.__members__
##		if membs not in empty:
##			prop_from_members = True
##		for item in membs:
##			if item not in props:
##				props.append(item)
##	except:
##		pass

	if key_num >= 1:				## Repository是类似字典性质的object。
		prop_from_keys = True	##Repository类型对象, 如_m.parts，删除成员时，直接用：del _m.parts[partname]
		for item in obj.keys():
			if item not in keys:   ##按照key生成的时间顺序排列。
				keys.append(item)

##	try:
##		keys1 = obj.keys()   ## Repository类型对象, or 字典类型对象
##		prop_from_keys = True
##		for item in keys1:
##			if item not in keys:   ##按照key生成的时间顺序排列。
##				keys.append(item)
##	except:
##		pass

	if meths in empty:
		print '**obj has no methods'
	else:
		print '**There are',len(meths),'methods: obj.method()',

		if meth_from_dir == True:
			print ', meth_from_dir = True',
		else:
			print ', No method obtained by dir(obj)',

		if meth_from_methods == True:
			print ', meth_from_methods = True',
		else:
			print ', obj has no attribute __methods__',
		print

##		if meth_from_methods == True:
##			print 'method names are stored in obj.__methods__'
##		print 'obj有如下方法：'
##		print meths

		maxL = 1
		for item in meths:
			if len(item) > maxL:
				maxL = len(item)
		maxL = maxL + 2   ## 包含括号的长度
		num_line = int(130/maxL)

		row = 0
		have_item = False
		used = []
		for i in range(len(meths)):
			if meths[i][0] <= 'Z':
				have_item = True
				used.append(meths[i])
				row = row + 1
				str1 = meths[i] + '()'
				if row < num_line:
					print str1.ljust(maxL),
				elif row == num_line:
					print str1.ljust(maxL)
					row = 0

		if have_item == True:
			print
			print ' '

		row = 0
		have_item = False
		for i in range(len(meths)):
			if meths[i][0] >= 'a':
				have_item = True
				used.append(meths[i])
				row = row + 1
				str1 = meths[i] + '()'
				if row < num_line:
					print str1.ljust(maxL),
				elif row == num_line:
					print str1.ljust(maxL)
					row = 0

		other_methods = unselect(meths,used)
		print ' '
		print 'Other methods:'
		if len(other_methods) < 10:
			print other_methods
		else:
			print 'not shown.'

##		if have_item == True:
##			print
##			print ' '

	print ' '
	print '**There are',len(props),'properties or attribute members:'
	if prop_from_dir == False and prop_from_members == False:
		print 'obj has not property and attribute member.'
	else:
		if prop_from_dir == False:
			print 'obj has no property obtained by dir(obj)'
		else:
			print 'obj has property obtained by dir(obj)'

		if prop_from_members == False:
			print 'obj has no attribute member'
		else:
			print 'obj have attribute members'

	sub_length = 0
	sub_title = ''

	attrib_type = ''
	if props not in empty:
		if len(props) > 50:
			print '**Too much properties, will show properties only, without their values.'
			print props

		else:
			max_name_len = 1
			for item in props:
				if len(item) > max_name_len:
					max_name_len = len(item)   ## 收集prop名字的最长长度
			max_name_len = max_name_len + len('obj.')
			max_value_len = 200

			for item in props:
				if item in ['f_globals','f_builtins', 'modules']:
					print '**prop name =',item,', value is not shown'
					continue

				try:
					sub_obj = eval('obj.' + item)
					value1 = totext(sub_obj)
					value1 = value1[:max_value_len]
					type1 = original_type(sub_obj)
					value1 = modify_string(value1,parent,parent_type)

					print ('obj.' + item).ljust(max_name_len),'=',value1,'  //type=',type1,
					sub_len_num = len_num(sub_obj,printResults=False)
					sub_key_num = keys_num(sub_obj)
					sub_mem_num = mems_num(sub_obj)

					if sub_len_num > 0:
						print ', elements=',str(sub_len_num).ljust(2),
					if sub_key_num > 0:
						print ', keys=', str(sub_key_num).ljust(2),
					if sub_mem_num > 0:
						print ', mems=',sub_mem_num,
					print

					if sub_len_num > sub_length:
						sub_length = sub_len_num
						sub_title = 'for prop= ' + item

##					if len(value1) > max_value_len:   ## 可参考myprint
##						print ' '	## 增加一个空白行
				except:
					print 'Fail to get obj.' + item

			if type_of(obj) == 'ODB':
				print '*Note: odb=',obj

	print ' '
	print "**There are",len(keys),"keys: obj['key']"
	if prop_from_keys == False:
		print 'No obj.keys(). key_num = None'
	elif keys in empty:
		print 'Empty keys: obj.keys = [], key_num = 0'
	else:
		attrib_type = 'obj.keys'
		print 'obj.keys() =',obj.keys()
##		print "**For keys: obj['key']"
##		print 'keys are stored in obj.keys()'
		max_name_len = 1
		for item in keys:
			item1 = str(item)
			if len(item1) > max_name_len:
				max_name_len = len(item1)
		max_name_len = max_name_len + len('obj[')
		max_value_len = 200

		for item in keys:
			item1 = str(item)
			if type_of(item) == 'STR':
				name = "obj['" + item1 + "']"
##				sub_obj = eval("obj['" + item1 + "']")
			else:
				name = "obj[" + item1 + "]"
##				sub_obj = eval("obj[" + item1 + "]")
			sub_obj = eval(name)

##			value1 = repr(sub_obj)
			value1 = totext(sub_obj)
			value1 = value1[:max_value_len]
			type1 = type_of(sub_obj)
##			print item1.ljust(max_name_len),'=',value1
			print name.ljust(max_name_len),'=',value1,'  //type=',type1.lower(),

			sub_len_num = len_num(sub_obj,printResults=False)
			sub_key_num = keys_num(sub_obj)
			sub_mem_num = mems_num(sub_obj)

			if sub_len_num > 0:
				print ', elements=',str(sub_len_num).ljust(2),
			if sub_key_num > 0:
				print ', keys=', str(sub_key_num).ljust(2),
			if sub_mem_num > 0:
				print ', member props=',sub_mem_num,
			print

##			print '  //type=',type1,', elements=',str(sub_len_num).ljust(2), ', keys=', str(keys_num(sub_obj)).ljust(2), ', mems=',mems_num(sub_obj)

##			if num > sub_length:
##				sub_length = num
##				sub_title = 'for key= ' + item1
##
##			if len(value1) > max_value_num:
##				print ' '

	if type_of(obj) in ['TUPLE', 'LIST']:   ## 没有property，也没有key
		for obj1 in obj:
			if len_num(obj1) > sub_length:
				sub_length = len_num(obj1)
				sub_title = 'for ' + repr(obj1)

	if keys not in empty and props not in empty:
		attrib_type = 'obj.prop + obj[key]'
	elif keys not in empty and props in empty:
		attrib_type = 'obj[key]'
	elif keys in empty and props not in empty:
		attrib_type = 'obj.prop'
	elif len_num(obj) > 0 and keys_num(obj) > 0:
		attrib_type = 'obj[index]'
	else:
		attrib_type = type_of(obj)

##	print ' '
##	print '**type_of(obj)=',type_of(obj)		## Array object没有keys和prop，但是有elem_num.
##	print 'len_num =',len_num(obj), ', keys_num=', keys_num(obj), ', mems_num=',mems_num(obj), ', 其中len_num of',attrib_type,sub_title,'is',sub_length

	print ' '
	if level == 1:
		if elem_num < 150:
			print fnln_fnln(),'**Now use prettyPrint() to show these',attrib_type,': (level=',level,')'
			prettyPrint(obj,1)   ## 按照key的升序排列

		elif sub_length < 150:
			print fnln_fnln(),'**Now use prettyPrint() to show obj[0]: (level=',level,')'
			print 'type_of(obj[0]) =',type_of(obj[0])
			prettyPrint(obj[0],1)

	elif level >=2:
		if elem_num < 150 and sub_length < 150:
			print fnln_fnln(),'**Now use prettyPrint() to show these',attrib_type,':(level=',level,')'
			prettyPrint(obj,level)   ## 按照key的升序排列

		elif len_num(obj) > 0 and keys_num(obj) == None:
			if sub_length < 150:  ## tuple or list
				print fnln_fnln(),'**Now use prettyPrint() to show obj[0]: (level=',level,')'
				print 'type_of(obj[0]) =',type_of(obj[0])
				prettyPrint(obj[0],2)

			else:
				if len_num(obj[0]) > 0 and keys_num(obj[0]) == None:
					print fnln_fnln(),'**Now use prettyPrint() to show obj[0][0]: (level=',level,')'
					print 'type_of(obj[0][0]) =',type_of(obj[0][0])
					prettyPrint(obj[0][0],2)

		else:
			print '**prettyPrint() is not performed. len_num=',elem_num, 'for obj, sub_length =',sub_length,sub_title

	print ' '
	print '** get functions:'
	print get_functs

	print ' '
	print '**有括号的字典为属性(.)，没有括号的字典为key([])'
	print ' '

	return

def objs_of_dg(dg=None):
	## VER: 2016-03-01, v1.3

##	if dg not in empty:
##		plot_dg(dg)

	dpo = get_dpo()
	if type_of(dpo) == 'PART':
		objs = [dpo.name]
		return objs
##	else:
##		print type_of(dpo)

	if dg in empty:
		display = get_display_now()
		if display not in empty:
			dg = display.displayGroup
		else:
			return []
	else:
		if type_of(dg) == 'STR' and dg in session.displayGroups.keys():
			dg = session.displayGroups[dg]

	if type_of(dg) != 'DISPLAYGROUP':
		raise Exception('*** display group is required.')
	##		raise Exception('***part, assembly, or odb display is required.')

	leaf = dg.root.leaf  ## which part,instance, etc.
	next = []
	next1 = dg.root.next
	while next1 not in empty:
		leaf1 = next1.leaf
		action = next1.action
		next.append({'leaf':leaf1,'action':action})
		next1 = next1.next

	objs = []
##	print fnln(),'type_of(leaf)=',type_of(leaf)
##	raise Exception
	type1 = type_of(leaf)
	if type1 == 'INSTANCELEAF':	## ASSEMBLY
		objs = leaf_ids_to_insts(leaf.instances)
##		objs = unselect(objs,hide_insts)
	elif type1 == 'PARTINSTANCELEAF':  ## ODB
		objs = tolist(leaf.partInstanceName)
	elif type1 == 'ENUMERATIONLEAF':	## leaf.leafType = DEFAULT_MODEL, leaf.validModules = ALL
		if type_of(dpo) == 'ASSEMBLY':
			a.regenerate()
			objs = a.instances.keys()
##			objs = unselect(objs,hide_insts)
##			objs = unselect(objs,suppr_insts)

		elif type_of(dpo) == 'ODB':
			objs = oa.instances.keys()
	else:
		if type_of(dpo) == 'ODB':
			objs = objs_of_odb_leaf(leaf)
		else:
			objs = objs_of_mdb_leaf(leaf)

	for i in range(len(next)):
		objs1 = []
		leaf1 = next[i]['leaf']
		action = next[i]['action']

		if type_of(leaf1) == 'INSTANCELEAF':
			objs1 = leaf_ids_to_insts(leaf1.instances)
		elif type_of(leaf1) == 'PARTINSTANCELEAF':
			objs1 = tolist(leaf1.partInstanceName)
		elif type_of(dpo) == 'ODB':
			objs1 = objs_of_odb_leaf(leaf1)
		elif type_of(dpo) == 'PART':
			objs1 = objs_of_mdb_leaf(leaf1)

##		print fnln(),'objs1=',objs1
##		raise Exception

		if action == ADD:
			objs = objs + objs1
		elif action == REMOVE:
			objs = unselect(objs,objs1)

##	print fnln(),'objs=',objs
##	raise Exception

	if type_of(dpo) == 'ASSEMBLY':
##		print 'in assembly module'
		a.regenerate()
		hide_insts = get_hiden_insts()
		suppr_insts = get_suppressed_insts()  ## 不包含被suppressed的instance
		objs = unselect(objs,hide_insts)
		objs = unselect(objs,suppr_insts)

	objs = sorted(objs)

	return objs

function_labels['poly_line'] = 'connect_points','sketch'
def poly_line(sketch,locs=None):
	## VER: 2016-09-26, v1.0

	global poly_points, last_line

	sketch = check_sketch(sketch)
	if locs in empty:
		if 'poly_points' in globals().keys():
			locs = poly_points
		else:
			raise Exception('*** locs are required.')

	num = len(locs)
	if num > 1:
		for i in range(num - 1):
			sketch.Line(point1 = locs[i], point2 = locs[i+1])
		last_line = sketch.geometry.keys()[-1]
	else:
		raise Exception('*** more than one locs are required.')

	del globals()['poly_points']

	return

def poly_lines_in_sketch(sketch,expression='H=4,V=-1.5,H=-1.5,T=(2,3)',start=(0,0),absolute=False,closed=False):
	## VER: 2014-07-15, v1.6.   T表示斜线

	sketch = check_sketch(sketch)
	ndir = ndir_of_sketch(sketch)

	expression = expression.upper()
	expression = modify_string(expression,' ')
	expression = modify_string(expression,'start','begin')   ## start中含有t,所以要避开。

	## 在H,V,T前面加空格号，以便劈开字符窜。
	expression = modify_string(expression,'H',' H')
	expression = modify_string(expression,'V',' V')
	expression = modify_string(expression,'T',' T')

	list1 = expression.split(' ')
	lines = []
	for str in list1:
		if str != '':
			str0 = str
			if str0[-1] == ',':
				str0 = str0[:-1]
			lines.append(str0)

	print 'lines=',lines

	locs = [start]
	if absolute == False:
		for line in lines:
			data = eval(line[2:])
			x0,y0 = locs[-1]
			if line[0] == 'V':
				x1 = x0
				if ndir != 'y':
					y1 = y0 + data
				else:
					y1 = y0 - data
			elif line[0] == 'H':
				x1 = x0 + data
				y1 = y0
			elif line[0] == 'T':
				x1 = x0 + data[0]
				if ndir != 'y':
					y1 = y0 + data[1]
				else:
					y1 = y0 - data[1]
			locs.append((x1,y1))
	else:
		for line in lines:
			data = eval(line[2:])
			x0,y0 = locs[-1]
			if line[0] == 'V':
				x1 = x0
				y1 = data
			elif line[0] == 'H':
				x1 = data
				y1 = y0
			elif line[0] == 'T':
				x1 = data[0]
				y1 = data[1]
			locs.append((x1,y1))

	if closed == True:   ## 闭环，回到起点
		if locs[-1] != locs[0]:
			locs.append(locs[0])

	print 'locs=',locs

	num = len(locs)
	for i in range(num - 1):
		sketch.Line(point1 = locs[i], point2 = locs[i+1])

	return locs[0],locs[-1]  ## 返回polylines的起点和终点

def polyfit(x=(),y=(),points=(), degree=1):
	## VER: 2016-05-18, v1.1
	## degree = 1是一次多项式拟合，相当于线性拟合。

	## 例如:x^2 + (y - y0)^2 = R^2, then: y = -sqrt(R^2 - x^2) + y0

##	>>> points = odb_coords_by_xydata(nodes='dim_arc_ymax',axis1='x',axis2='y',sort='x',frame=-1)
##	>>> polyfit(points=points,degree=2)
##
##	Fit equation as below:
##	Y = 0.01425X^2 + 3.735e-05X + 7.6617
##
##	{'coeffs': [0.01425, 3.735e-05, 7.6617], 'accuracy': 0.9996}
##	>>>

	## Example:
	## y = 5x + 3,  then:
	## x = 1, y=8
	## x = 2, y=13
	## x = 3, y=18
	## x = 4, y=23
	## x = 5, y=28
	## points = [(1,8),(2,13),(3,18),(4,23),(5,28)]
##	>>> polyfit(points=points,degree=1)
##	{'coeffs': [5.0, 3.0], 'accuracy': 1.0}
##	>>>

	import numpy

	if type_of(degree) != 'INT':
		raise Exception('*** An interger, such as, 1,2,3 is required')

	if x in empty and y in empty:
		points = tolist(points)

		x = []
		y = []
		for x1,y1 in points:
			x.append(x1)
			y.append(y1)

	results = {}

	coeffs = numpy.polyfit(x, y, degree)
	list1 = tolist(coeffs)
	for i in range(len(list1)):
		list1[i] = smart_round(list1[i],6)

	results['coeffs'] = list1    ## [A,B] 表示Ax + B    [A,B,C]表示Ax^2 + Bx + C

	# r-squared
	p = numpy.poly1d(coeffs)
	# fit values, and mean
	yhat = p(x)                         # or [p(z) for z in x]
	ybar = numpy.sum(y)/len(y)          # or sum(y)/len(y)
	ssreg = numpy.sum((yhat-ybar)**2)   # or sum([ (yihat - ybar)**2 for yihat in yhat])
	sstot = numpy.sum((y - ybar)**2)    # or sum([ (yi - ybar)**2 for yi in y])
	results['accuracy'] = smart_round(ssreg/sstot,6) #准确率，相关性

	str1 = ''
	if len(list1) == 2:  ## 一次方程, degree=1
		str1 = str(list1[0]) + '*X + ' + str(list1[1])
	elif len(list1) == 3: ## 二次方程,degree=2
		str1 = str(list1[0]) + '*X*X + ' + str(list1[1]) + '*X + ' + str(list1[2])
	elif len(list1) == 4:
		str1 = str(list1[0]) + '*X*X*X + ' + str(list1[1]) + '*X*X + ' + str(list1[2]) + '*X + ' + str(list1[3])

	str1 = modify_string(str1,'+ -','- ')
	results['equation'] = str1

	if str1 not in empty:
		print ' '
		print 'Fit equation as below:'
		print 'Y =',str1
		print 'Accuracy:',results['accuracy']
		print ' '

	return results

function_labels['postres'] = 'post','result','file','collect','postprocessing'
def postres():
	## VER: 2017-08-01, v1.0

	if 'res' not in globals().keys():
		raise Exception('*** variable dict res is required to specify the results to retreave.')

	post()
	res2file(res)

	return

ps = postres

function_labels['positive_vector'] = 'normalized','positive','vector','direction','axis'
def positive_vector(vector):
	## VER: 2017-08-04, v1.0

	vector = normalized_vector(vector)
	x1,y1,z1 = vector

	num = 0
	if x1 < 0:
		num = num + 1
	if y1 < 0:
		num = num + 1
	if z1 < 0:
		num = num + 1

	if num >=2:
		x1,y1,z1 = -x1,-y1,-z1

	num1 = 0
	if x1 == 0:
		num1 = num1 + 1
	if y1 == 0:
		num1 = num1 + 1
	if z1 == 0:
		num1 = num1 + 1

	if num1 == 2 and num == 1:
		x1,y1,z1 = -x1,-y1,-z1

	return x1,y1,z1


function_labels['post'] = 'collect results','file','dict'
def post(job=1):
	## VER: 2015-04-23, v1.3
	## reference: res2file()

	vpnow = get_vpnow()

	if job == 1:
		if len(mdb.jobs) == 0:
			raise Exception('*** No job to get the results')

		job1 = mdb.jobs.keys()[0]
	elif job == 0:
		dpo = get_dpo()
		if type_of(dpo) == 'ODB':
			job1 = dpo.analysisTitle
		else:
			raise Exception('*** An odb viewport is required.')

	odb = session.openOdb(name=job1 + '.odb')
	vpnow.setValues(displayedObject=odb)
	vpnow.odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF, ))

	refresh()

	if '_results_dict' in globals().keys():
		collect_and_write_results(_results_dict)

	return

def post_disp():
	## VER: 2014-09-03, v1.5
	## do not need to run refresh() before post_disp()

	global _results_dict

	## Example:
##	_results_disp = {'punch_A1':('S1','Mises','U3')}
##	collect_and_write_results(_results_disp)

##	if '_results_disp' not in globals().keys():
##		raise Exception("*** Global variable _results_disp is required. such as: _results_disp = 'step1',['TRAY_A1','U2','S1','Mises']")

	set_annotation()

	vpnow = get_vpnow()
	dpo_type = type_of(vpnow.displayedObject)
	if dpo_type != 'ODB':
		open_odb()
	else:
		refresh()

	file0 = inp_file_title + '.vars'
	file0 = search_file(file0)
	if os.path.isfile(file0):
		read_vars_from_file(file0)

	print fnln(),'cae_file_title =',cae_file_title
	print fnln(),'inp_file_title =',inp_file_title

	if jobnum == 'A0194':
		global avg_density
		avg_density = average_density()

	plot(odb)
	collect_and_write_results(_results_disp)

	return

def post_temp():
	## VER: 2014-09-03, v1.5
	## do not need to run refresh() before post_disp()

	global _results_dict

	## Example:
##	_results_disp = {'punch_A1':('S1','Mises','U3')}
##	collect_and_write_results(_results_disp)

##	if '_results_temp' not in globals().keys():
##		raise Exception("*** Global variable _results_temp is required. such as: _results_disp = {'TRAY_A1':(('NT11',MAX),('NT11',MIN))}")

	set_annotation()

	vpnow = get_vpnow()
	dpo_type = type_of(vpnow.displayedObject)
	if dpo_type != 'ODB':
		open_odb()
	else:
		refresh()

	file_var = inp_file_title + '.vars'
	file_var = search_file(file_var)
	if os.path.isfile(file_var):
		read_vars_from_file(file_var)

	if have_running_job() == False:
		open_cae(inp_file_title)
		read_vars_from_model_description()
		print '*** cae file for this odb is opened.'

	print fnln(),'cae_file_title =',cae_file_title
	print fnln(),'inp_file_title =',inp_file_title

	plot(odb)
	collect_and_write_results(_results_temp)

	return

def post_temp_disp():
	## VER: 2014-01-18, v1.4
	## do not need to run refresh() before post_disp()

	global _results_dict

	## Example:
##	_results_disp = {'punch_A1':('S1','Mises','U3')}
##	collect_and_write_results(_results_disp)

##	if '_results_temp_disp' not in globals().keys() and '_results_dict' in globals().keys():
##		_results_temp_disp = _results_dict
##	else:
##		raise Exception("*** Global variable _results_temp_disp is required. such as: _results_disp = {'TRAY_A1':('NT11','U2','S1','Mises')}")

	set_annotation()

	vpnow = get_vpnow()
	dpo_type = type_of(vpnow.displayedObject)
	if dpo_type != 'ODB':
		open_odb()
	else:
		refresh()

	file_var = search_file(inp_file_title + '.vars')
	if os.path.isfile(file_var):
		read_vars_from_file(file_var)

	if have_running_job() == False:
		open_cae(inp_file_title)
		read_vars_from_model_description()
		print '*** cae file for this odb is opened.'

	print fnln(),'cae_file_title =',cae_file_title
	print fnln(),'inp_file_title =',inp_file_title

	plot(odb)
	collect_and_write_results(_results_dict)

	return

function_labels['fn_plate_stress_deflection'] = 'PV','suntech','mounting','pressure','module'
def fn_plate_stress_deflection(length=1956, width=992, thick=4, press=5400, deflection=None, stress=None, alpha=0.15, beta=0.015, modulus=None):

	## VER: ('VER: 2012-08-08, v1.0')	## mm单位制

	if modulus in empty:
		modulus = Glass_E
	press = press*1e-6

	length = float(length)
	width = float(width)
	thick = float(thick)
	press = float(press)

	## 垂直与长度方向，获得截面特性: width越大，越容易塌陷；厚度越厚，越不容易塌陷。
	## 应力与wt_ratio的二次方成正比；挠度与wt_ratio的二次方成正比。
	wt_ratio = width/thick
	LW_ratio = round(length/width,2)

	if stress == None:
		stress = alpha*wt_ratio**2*press
		stress = round(stress,1)
	else:
		alpha = stress/(wt_ratio**2*press)
		alpha = round(alpha,3)

	if deflection == None:
		deflection = beta*wt_ratio**4*press*thick/modulus
		deflection = round(deflection,1)
	else:
		beta = deflection*modulus/(wt_ratio**4*press*thick)
		beta = round(beta,3)

	print '--->LW_ratio=',LW_ratio, ', wt_ratio=',wt_ratio, ', stress=',stress, 'MPa, alpha=',alpha, ', deflection=', deflection, 'mm, beta=', beta,

	return

def fn_pressure2speed(pressure):
	## 2012-01-21, v1.0,  Unit: Pa
	##相反的换算函数: fn_speed2pressure()

	P3 = pressure/3		## 基本风压(3秒风速换算而来)
	ms3 = round(sqrt(1.6*P3),3)
	kph3 = round(ms3*3.6,2)

	ms600 = round(ms3*0.703,2)
	kph600 = round(ms600*3.6, 2)

	print '--->pressure=',pressure,'Pa，基本风压P3=',round(P3,2),'Pa, 3秒风速ms3=',round(ms3,2),'m/s(对应kph3=',kph3,'km/hr), 600秒风速ms600=', ms600,'m/s (对应kph600=',kph600,'km/hr)'

	return round(ms3,2)

def new_file(filename):
	## VER: 2016-08-08, v1.0

	if type_of(filename) != 'STR':
		raise Exception('*** text file name is required.')

##	filename = '_PV_OB.txt'
	file1 = open(filename,'w')   ## 清空内容
	file1.close()
##	file1 = filename

	return filename

def run_script(filename):
	## VER: 2017-06-19, v1.0
	## execfile('abaqus_plugins//BJ_A0219_compaction_GUI.py')
	## txt文件也可以运行，只要不会出现语法错误即可。

	if type_of(filename) != 'STR':
		raise Exception('*** filename is required.')

	loc = filename.find('.')
	if loc == -1:
		raise Exception('*** Please provide the full filename with extension.')

	execfile(filename)

	return

function_labels['line_print'] = 'file','write','variables','parameters','fprint'
def line_print(file_name,*args):
	## VER: ('VER: 2016-10-06, v1.4')	## 单行输出
	## 如果args为空，则新建一个空白文件。
	## 执行很快。

##	line_print('_test1.txt','a1=5','a2=6')
##	a1=5 a2=6    ## 一行

##	>>> file1 = 'test1.py'
##	>>> line_print(file1,'aa=5')
##	>>> line_print(file1,'bb=6')
##	>>> import test1
##	>>> aa
##	NameError: name 'aa' is not defined
##	>>> test1.py
##	AttributeError: 'module' object has no attribute 'py'
##	>>> import test1.py
##	ImportError: No module named py
##	>>> execfile(file1)
##	>>> aa
##	5
##	>>> bb
##	6
##	>>>

##	file1 = new_file('abc.txt')
##	line_print(file1,' ')
##	line_print(file1,'C1 =',C1)
##	line_print(file1,'shrinkage =',shrinkage)
##	line_print(file1,'shrinkage_factor =',shrinkage_factor)

	## Example
	## line_print(var_file_full,'## var_panel:',len(var_panel),'variables:')	结果为：## var_panel: 67 variables:

##	list1 = ['var1',5,'var2=',6]
##	line_print('_test1.txt',list1)
##	['var1', 5, 'var2=', 6]   ## 是什么就显示什么，不改变

	if type_of(file_name) == 'FILE':
		temp = file_name.name
		file_name.close()
		file_name = temp
	elif type_of(file_name) != 'STR':
		raise Exception('****File_name required.')

	screen = sys.stdout

	if len(args) == 0 or (len(args) == 1 and args[0] in ['w','new']):
		sys.stdout = open(file_name,'w')
	elif len(args) == 2 and args[-1] in ['w','new']:
		args = [args[0]]
		sys.stdout = open(file_name,'w')
	else:
		sys.stdout = open(file_name,'a')

	for item in args:
		print item,
	print

	sys.stdout = screen		## 输出到屏幕

	return

print2file = line_print

def print_DOE_table():
	## VER: 2011-04-24, v1.1

	print ' '
	print ' '*3,
	format = printw(DOE_factors)

	for seq in range(len(DOE_table)):
		treat = DOE_table[seq]
		treat = tuple(treat)
		print (str(seq+1)+'').ljust(3),format % treat

	print ' '

	return


def print_function_handler(func):
	## VER: 2011-04-28, v1.2

	func = check_func(func)

	handler_line_no = func.func_code.co_firstlineno
	py_file = func.func_code.co_filename

	file1 = open(py_file)
	lines = file1.readlines()
	file1.close()

	handler_code = ''

	print handler_line_no
	line1 = lines[handler_line_no - 1][:-1]
	line1 = line1.rstrip()
	print line1
	line0 = line1.lstrip()
	handler_code = handler_code + line0

	if line1[-2:] != '):':
		line2 = lines[handler_line_no][:-1]
		line2 = line2.rstrip()
		print line2
		line0 = line2.lstrip()
		handler_code = handler_code + line0

		if line2[-2:] != '):':
			line3 = lines[handler_line_no + 1][:-1]
			line3 = line3.rstrip()
			print line3
			line0 = line3.lstrip()
			handler_code = handler_code + line0

			if line3[-2:] != '):':
				line4 = lines[handler_line_no + 2][:-1]
				line4 = line4.rstrip()
				print line4
				line0 = line4.lstrip()
				handler_code = handler_code + line0

	return

def print_geometry_info(sketch,curves=(),reverse=False):
	## VER: 2013-10-30, v1.0

	sketch = check_sketch(sketch)

	if curves in empty:
		curves = sketch.geometry.values()   ## including construction lines

	curves1 = []
	for curve in curves:
		dict1 = {'id':curve.id, 'type':type_of(curve), 'size':curve.getSize(), 'locs':vertice_locs_of_geometry(sketch=sketch, geometry=curve)}
		curves1.append(dict1)

	curves1 = sort_dict_type_elements(curves1,key='size',reverse=reverse)

##	myprint(curves1)
	for curve in curves1:
		id = curve['id']
		type1 = curve['type']
		size = curve['size']
		points = curve['locs']
		print 'id=',id,', type=', type1, ', size=',round(size,6), ', points=', points

	return

def regular_lines_by_size(sketch,curves=(),reverse=False):
	## VER: 2013-10-30, v1.0

	sketch = check_sketch(sketch)

	if curves in empty:
		curves = sketch.geometry.values()   ## including construction lines

	curves1 = []
	for curve in curves:
		dict1 = {'id':curve.id, 'type':type_of(curve), 'size':curve.getSize(), 'locs':vertice_locs_of_geometry(sketch=sketch, geometry=curve)}
		curves1.append(dict1)

	curves1 = sort_dict_type_elements(curves1,key='size',reverse=reverse)
	newlist = []
	for curve in curves1:
		if curve['type'] == 'regular_line':
			newlist.append(curve)
	curves1 = newlist

	return newlist

def regular_arcs_by_size(sketch,curves=(),reverse=False):
	## VER: 2013-10-30, v1.0

	sketch = check_sketch(sketch)

	if curves in empty:
		curves = sketch.geometry.values()   ## including construction lines

	curves1 = []
	for curve in curves:
		dict1 = {'id':curve.id, 'type':type_of(curve), 'size':curve.getSize(), 'locs':vertice_locs_of_geometry(sketch=sketch, geometry=curve)}
		curves1.append(dict1)

	curves1 = sort_dict_type_elements(curves1,key='size',reverse=reverse)
	newlist = []
	for curve in curves1:
		if curve['type'] == 'regular_arc':
			newlist.append(curve)
	curves1 = newlist

	return newlist


def print_leaf_history():

	display = get_display_now()
	if display not in empty:
		dg = display.displayGroup
	else:
		raise Exception('***part, assembly, or odb display is required.')

	leaf = dg.root.leaf  ## which part,instance, etc.
	next = []
	prettyPrint(leaf,3)

	next1 = dg.root.next
	while next1 not in empty:
		print ' '
		print 'action:',next1.action
		leaf1 = next1.leaf
		next1 = next1.next
		prettyPrint(leaf1,3)

	return

def print_last_geometry(sketch,num=3):
	## VER: 2015-04-20, v1.2
	## 通过该函数，可以观察某个动作，如divide_geometry()的前后geometry的变化。
	## construction的size = -1

	sketch = _sketch(sketch)
	num = len(sketch.geometry)
	seq = sketch.geometry.keys()[-10:]

	print ' '
	print 'Totally',num,'geometry'
	for id in seq:
		g4 = sketch.geometry[id]
		print 'id:',g4.id,',type=',type_of(g4),',pointOn=',g4.pointOn, ', size=',g4.getSize()
	print ' '

##	g1 = sketch.geometry.values()[-1]
##	g2 = sketch.geometry.values()[-2]
##	if num >= 3:
##		g3 = sketch.geometry.values()[-3]
##	if num >= 4:
##		g4 = sketch.geometry.values()[-4]
##
##	print ' '
##	if num >= 4:
##		print 'id:',g4.id,',type=',type_of(g4),',pointOn=',g4.pointOn, ', size=',g4.getSize()
##	if num >= 3:
##		print 'id:',g3.id,',type=',type_of(g3),',pointOn=',g3.pointOn, ', size=',g3.getSize()
##	print 'id:',g2.id,',type=',type_of(g2),',pointOn=',g2.pointOn, ', size=',g2.getSize()
##	print 'id:',g1.id,',type=',type_of(g1),',pointOn=',g1.pointOn, ', size=',g1.getSize()

	return

print_last_geometrys = print_last_geometry

def print_load_BC():
	## VER: 2013-06-28, v1.0

	print ' '
	print 'interactions and constraints:'
	for load in _m.loads.values():
		print '---------------------'
		print 'Load name:',load.name
		print 'description:', load.__doc__
##		print 'Active steps:',active_steps_of_interact(load.name)
		prettyPrint(load,3)
		print ' '

	for BC in _m.boundaryConditions.values():
		print '---------------------'
		print 'BC name:',BC.name
##		print 'Constraint type:',get_constraint_type(BC.name)
		print 'description:', BC.__doc__
		prettyPrint(BC,3)
		print ' '

	for prefield in _m.predefinedFields.values():
		print '---------------------'
		print 'prefield name:',prefield.name
##		print 'Constraint type:',get_constraint_type(BC.name)
		print 'description:', prefield.__doc__
		prettyPrint(prefield,3)
		print ' '

	return


def print_mat_sections():
	## VER: 2013-06-07, v1.0
	## Note: A shell part can also use HomogeneousSolidSection

	print 'for section in _m.sections.values():'
	for section in _m.sections.values():
		print '  section.name =',section.name
		print '  section.material =', section.material
		print '  section.thickness =', section.thickness
		print '  section.__class__ =', section.__class__
##		print '  section.__doc__ =', section.__doc__
		print ' '

	return

def print_sketch_csys(ndir='x'):
	## VER: 2013-08-19, v1.1

	ndir = ndir.lower()
	print 'Usage: print_sketch_csys(ndir="x")'
	if ndir == 'z':  ## common sketch plane  x3=x2,   y3=y2   (x -> y -> z(大拇指，朝屏幕外))
		print ' '
		print '           Y                      '
		print '           A                      '
		print '           |                      '
		print '          o|________ X            '
		print ' '
		print 'x2 = x3, y2 = y3'

	elif ndir == 'y':  ## x3=x2, z3=-z2   (z -> x  -> y (大拇指，朝屏幕外))
		print ' '
		print '          o__________ X           '
		print '           |                      '
		print '           |                      '
		print '           V                      '
		print '           Z                      '
		print ' '
		print 'x2 = x3, z2 = -z3'

	elif ndir == 'x':  ## y3=y2,   z3=z2    ( y(四指) -> z -> x (大拇指，朝屏幕外))
		print ' '
		print '           Z                      '
		print '           |                      '
		print '           |                      '
		print '          o|________ Y            '
		print ' '
		print 'z2 = z3, y2 = y3'

	return

def print_steps():
	## VER: 2013-07-18, v1.4

	steps = get_steps_sequence()[1:]
	print ' '
	print 'All steps in model:', _m.steps.keys()
	print ' '

	vars = []
	for stepname in steps:
		step = _m.steps[stepname]
		var = text2varname(stepname,poi_type='other')
		globals()[var] = step
		vars.append(var)
		print '================================================='
		print 'step name:     ', step.name
		print 'procedure type:', step.procedureType
		print 'description:   ', step.description
		print '--'
		print 'Interacts:     ', step.interactionStates.keys()
		print 'Loads:         ', step.loadStates.keys()
		print 'BCs:           ', step.boundaryConditionStates.keys()
		print 'Prefields:     ', step.predefinedFieldStates.keys()
		print 'FieldOutputs:  ', step.fieldOutputRequestStates.keys()
		print 'HistoryOutputs:', step.historyOutputRequestStates.keys()
		print '--'

		shown = ['control','diagnosticPrint','procedureType','description','fieldOutputRequestStates','historyOutputRequestStates','interactionStates','loadStates','boundaryConditionStates','predefinedFieldStates']
		for prop in step.__members__:
			if prop not in shown:
				value = get_attrib(step,prop)

				if is_empty_repository(value):
					print prop,'=  ',value
					continue
				elif type_of(value) == 'REPOSITORY':
					print prop,'=  '
					prettyPrint(value,2)
					print ' '

##				else:
##					if value != 'unknow' and type_of(value) not in basic_types and 'SYMBOLICCONSTANT' not in type_of(value):
##						print prop,'=  '
##						prettyPrint(value,2)
##						print ' '
				else:
					print prop,'= ',value

	print ' '
	print 'Created global vars for steps:',vars
	print 'You can run prettyPrint(stepvar) for double check.'

	return

def print_table(table):
	## VER: 2014-08-06, v1.0
	## display the table vertically like Origin

	if type_of(table) not in ['LIST','TUPLE']:
		raise Exception('*** a list or tuple is required.')

	if len(table[0]) == 2:
		for k,v in table:
			print k,'   ',v
	elif len(table[0]) == 3:
		for k1,k2,k3 in table:
			print k1,'   ',k2,'   ',k3
	elif len(table[0]) == 4:
		for k1,k2,k3,k4 in table:
			print k1,'   ',k2,'   ',k3,'   ',k4
	elif len(table[0]) == 5:
		for k1,k2,k3,k4,k5 in table:
			print k1,'   ',k2,'   ',k3,'   ',k4,'   ',k5
	else:
		myprint(table)

	return


def print_traceback(variable=None):
	## VER: 2013-04-01, v2.1
	## 在代码中打印traceback: print get_traceback()
	## print_traceback()用于出错之后在命令框中输出错误的调用记录。


##	trace1 = get_traceback(instance_list=True,collect_code=True,overwrite=False)
##
##	prettyPrint(trace1,3)
##
##	raise Exception

	tb1 = traceback.sys.last_traceback.tb_next

	## Remark: tb is not the reversed calling sequence. So the former one calls the letter one.
	##[('<string>', 1, '<module>', None),
	## ('C:/Temp/A0191/AG_191die_model.py', 34414, '<module>', 'main(inp_file_title)\t\t;please_check'),
	## ('C:/Temp/A0191/AG_191die_model.py', 32745, 'main', 'stop()'),
	## ('C:/Temp/A0191/AG_191die_model.py', 30393, 'stop', 'raise Exception')]
	##File "C:/Temp/A0191/utrace.py", line 44, in print_traceback
	##    raise Exception
	##Exception


	print '************************printing traceback...'
	print ' '

	stack = traceback.extract_tb(traceback.sys.last_traceback)
	## stack[i]:
	## example: stack[i]= ('<input>', 1, '<module>', None)
	## exmaple: stack[i]= ('C:/Temp/A0191/AG_191die_model.py', 34414, '<module>', 'main(inp_file_title)\t\t;please_check')
	## format: (filename,command_lineno,frame_name,command_code), if frame_type is module, then frame_name='<module>'; if frame_type is function, then frame_name is the function name

##	numlist = range(len(stack) -1, -1, -1)
##	for i in numlist:
##		print 'stack[i][-2]=',stack[i][-2]
##		print 'stack[i][-1]=',stack[i][-1]
##		print 'stack[i]=',stack[i]
##		## stack[i]= ('<input>', 1, '<module>', None)
		## format: (filename,command_lineno,frame_name,command_code), if frame_type is module, then frame_name='<module>'; if frame_type is function, then frame_name is the function name

##		if stack[i][-2] in ['?','__main__','<module>'] and stack[i][-1] == None:
##		if stack[i] == None:
##			for j in range(i+1):  ## 包括0项
##				stack.pop(0)    ## remove previous history
##
##			for j in range(i):
##				tb1 = tb1.tb_next   ## 不可省略
##
##			break
##	print ' '
##	raise Exception

##	print 'type_of(stack)=',type_of(stack)
	count = 0
	for i in range(len(stack)):
##		print stack[i][-1]
		if stack[i][-1] == None:
			count = count + 1
		else:
			break
	stack1 = stack[count:]
##	print 'count=',count

	for i in range(len(stack) - len(stack1) - 1):  ## remove empty code history
		tb1 = tb1.tb_next


##	print 'stack[0][-1]=',stack[0][-1]
##	print 'stack[1][-1]=',stack[1][-1]
##
##	if stack[0][-1] == None:
##		print 'is None'

##	print ' '
##	print '========================='
##	prettyPrint(stack,2)

##	raise Exception

	if len(stack1) == 0:
		prettyPrint(stack,2)
		return

	stack = stack[count:]

	py_file = stack[0][0]
	err = str(traceback.sys.last_type)
	err_type = traceback.sys.last_value
	err_code = stack[-1][-1]
	err_line = stack[-1][-3]

	info = []
##	print '**in file=',py_file,':'
##	if '.py' in py_file:
##		file1 = open(py_file)
##		lines = file1.readlines()
##		file1.close()
##	print ' '

	for i in range(len(stack)):
		stack1 = stack[i]
##		if stack1[0] != py_file:
		py_file = stack1[0]
		print '**in file=',py_file,':'
##		print ' '
##		if '.py' in py_file:
##			file1 = open(py_file)
##			lines = file1.readlines()
##			file1.close()

		func_name = stack1[2]
		if func_name in ['?','<module>']:
			func_name = '<module>'
##			print 'Error line at main program:', stack1[1]
##			print '**exception code:',stack1[-1]
			print '---'
			print '**** final command: '
			print stack1[1],repr(stack1[-1])
		else:
			code1 = tb1.tb_frame.f_code
			code1 = repr(code1)[:-1]
			loc = code1.rfind(' ')
			handler_line = int(code1[loc+1:])  ## function handle line

			## 输出函数句柄
			print_function_handler(func_name)

			func_pars = get_function_pars(func_name)

			locals0 = tb1.tb_frame.f_locals
			locals_sorted = sort_by_key(locals0)
			other_vars = unselect(locals0.keys(),func_pars)

			if func_pars not in empty:
				maxL = 1
				for item in func_pars:
					if len(item) > maxL:
						maxL = len(item)

				n = 0
				print '--'
				for k in func_pars:
					v = locals0[k]
					if k == variable:
						symbol1 = '**'
					else:
						symbol1 = ''

					n = n + 1
					value1 = v
					if value1 == '':
						value1 == "''"
##					value1 = repr(value1)
					value1 = totext(value1)
					value1 = use_poi_var_name(value1)
					if len(value1) > 130 and n > 1:
						print '--'
					print (k + symbol1).ljust(maxL),'=',value1
					if len(value1) > 130:
						print '--'

			if other_vars not in empty:
				print ' '
				print '**Other local variables:'

				maxL = 1
				for item in other_vars:
					if len(item) > maxL:
						maxL = len(item)

				n = 0
				print '--'
				for k,v in locals_sorted:
					if k in ['command','locals1'] and type_of(v) == 'DICT':
						continue
					elif k in func_pars:
						continue

					if k == variable:
						symbol1 = '**'
					else:
						symbol1 = ''


					if type_of(v) in ['DICT','LIST'] and len(v) > 100:
						print k + symbol1,': value not shown due to items > 100'
						continue

					try:
						if len(repr(v)) > 1000:   ## AccessError: mdb.models['Model-1'].sketches['_powder'] no longer exists
							print k + symbol1,': value not shown value string > 1000'
							continue
					except:
						pass

					n = n + 1
					value1 = v
					if value1 == '':
						value1 == "''"
##					value1 = repr(value1)
##					print 'value1=',value1
					value1 = totext(value1)
					value1 = use_poi_var_name(value1)
					if len(value1) > 130 and n > 1:
						print '--'
					print (k + symbol1).ljust(maxL),'=',value1
					if len(value1) > 130:
						print '--'

			if info not in empty:
				func_error = str(info[-1][-1]) + '_' + func_name
				if func_error in _function_error.keys():
					print '--'
					print '**warning/error in this function:'
					for warn in _function_error[func_error]:
						print str(warn[0]) + ',',warn[1]

			print '--'
##			print str(stack1[1]) + ', **exception line in',func_name + '():'
##			print stack1[-1]

			print '**** final command:'
			print stack1[1],stack1[-1]

			if i == len(stack) - 1:
				print '******Error_type:',err,',',err_type

		if func_name == '<module>':
			info.append((1,'<module>',stack1[1]))
		else:
			info.append((handler_line,func_name,stack1[1]))

		tb1 = tb1.tb_next
		print ' '
		print ' '

##	print ' '
##	traceback.print_last()

	print 'Traceback summary:',info
	print 'Error line:',err_line
	print 'Error code:',err_code
	print '******Error:',err,',',err_type
	if len(stack) > 3:
##		print '请从',info[2],'开始调试、查找原因'
		print 'Please debug from',info[2]

##	print '如果要修改某个函数，请将其拷贝粘贴到一个新的临时py文件中进行修改，否则函数句柄的显示可能有误。'
	print 'findAt(): decimal part：.33=.333333, .67=.666667'
	print ' '

	return

def printw(*args):
	## VER: 2011-04-24, v1.0

	args = tolist(args)
	if len(args) == 1 and type_of(args[0]) == 'STR':
		args = args[0].split()
	args = tuple(args)

	format = ''
	for i in range(len(args)):
		item = args[i]
		if type_of(item) == 'STR':
			try:
				item1 = int(item)
			except:
				item1 = ''

			if item1 != '':
				format = format + '%-5.5s '
			else:
				L = str(len(item) + 2)
				format = format + '%-' + L + '.' + L + 's'

		elif type_of(item) in ['INT','FLOAT'] :
			float1 = abs(item - int(item))
			if float1 < 1e-6:
				format = format + '%-8.0f '
			else:
				format = format + '%-8.2f '

	print format % args   ## args必须是一个tuple

	return format

def project_axis_to_plane(poi,edge, plane):
	## VER: 2014-07-10, v1.0

##>>> normal_datum_plane_of_edge(e2, pt)
##mdb.models['Model-1'].parts['p342'].datums[72]
##>>> plane = mdb.models['Model-1'].parts['p342'].datums[72]
##>>> axis = feature_to_obj(p342,'Datum axis-1')
##>>> type_of(axis)
##'DATUMAXIS'
##>>>
##>>> project_axis_to_plane(p342, axis, plane)
##Projected datum axis: Datum axis-3
##mdb.models['Model-1'].parts['p342'].datums[77]
##>>>

	poi = check_poi(poi)

	if type_of(edge) not in ['edges','DATUMAXIS']:
		raise Exception('*** an edge or datum axis is required.')

	if type_of(plane) not in ['faces','DATUMPLANE']:
		raise Exception('*** a plane face or datum plane is required.')

	loc1,loc2 = two_points_of_edge(edge)
	datum_point1 = get_project_point(poi,loc1,plane)
	datum_point2 = get_project_point(poi,loc2,plane)

	axis = create_datum_axis_by_2points(poi,start=datum_point1, end=datum_point2)
	feature = obj_to_feature(axis)
	print 'Projected datum axis:',feature.name

	return axis


def pshow(part=None,*seq):
	## VER: 2011-02-25, v1.3. Brief of part_show. 通过highlight显示各个part的位置。
	## 给各个inst分配索引号，然后根据seq显示相应的实例。

	"""Usage:
   pshow()            -->show the parts list and their instances
   pshow(partname)    -->highlight all the instances of a part
   pshow(inst_id)     -->highlight specific instance
   unlight()          -->unhighlight instances.
	"""

	global dg, plot_history

	if get_inputs(locals()) in empty:
		print pshow.__doc__

	seq = tolist(seq)
	unlight()

	if seq in empty:
		seq = []

	if type_of(part) == 'INT':
		seq.append(part)
		part = None
	elif type_of(part) == 'PINSTANCE':
		light(part)
		return

	if seq in empty:
		seq = [1]

	insts1 = sorted(a.instances.keys())  ##列表
	insts = {}
	for i in range(1,len(insts1) + 1):
		insts[i] = insts1[i - 1]   ## 分配索引号

	max=0
	for inst in a.instances.values():
		partname = inst.partName
		if len(partname) > max:
			max = len(partname)        ##获取inst name的最大长度

	## printing
	print 'Parts and their instances...'
	i = 0
	for k,v in insts.items():
		i = i + 1

		if i == 1:
			part1 = a.instances[v].partName
			part2 = part1
		else:
			part1 = part2
			part2 = a.instances[v].partName

		k1 = str(k)
		if len(k1) == 1:
			k1 = k1 + ' '
		item = k1 + ' ' + v
		item = item.ljust(14)
		if part2 == part1:
			if i == 1:
				print part1.ljust(max),': ',
			print item,
		else:
			print
			print part2.ljust(max),': ',
			print item,
	print

	if type_of(part) == 'PART':
		part = part.name

	if type_of(part) == 'STR':
		seq = []
		for k,v in insts.items():
			partname = a.instances[v].partName
			if part == partname:
				seq.append(k)

	insts1 = []
	insts2 = []
	for i in seq:
		insts1.append(a.instances[insts[i]])
		insts2.append(insts[i])

	insts1 = tuple(insts1)
	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=a)
	plot_history.append(get_traceback())
	leaf = dgm.LeafFromInstance(instances=insts1)
	dg = session.DisplayGroup(leaf=leaf, name='_leaf')

	highlight(dg)
	print 'lighted insts=',insts2
	print ' '

	return

def psum(part=None):
	## VER: 2011-03-07, v1.0, parts summary

	parts = _m.parts.values()
	if type_of(part) == 'PART':
		parts = [part]

	for part in parts:
		insts = find_mdb_insts(part.name)
		if insts not in empty:
			print 'part=',part.name,', insts=',poi_names(insts)
			info = part.queryGeometry(printResults=False)
			x1,y1,z1 = info['boundingBox'][0]
			x2,y2,z2 = info['boundingBox'][1]
			x1,x2,y1,y2,z1,z2 = check_values(x1,x2,y1,y2,z1,z2)
			print 'space=',(x1,x2,y1,y2,z1,z2)
			print 'volume=',info['volume'],', cells num=',len(part.cells)
			mats = get_mats(part)[part.name]
			for mat in mats:
				setnames = mats[mat]
				volume = 0
				cell_num = 0
				num = 0;		seq = None
				for setname in setnames:
					cells_seq = part.allInternalSets[setname].cells
					cell_num += len(cells_seq)
					num = num + 1
					if num == 1:
						seq = cells_seq
					else:
						seq = seq + cells_seq

				if seq != None:
					volume += part.getVolume(seq)
				print mat + ': volume=',volume,', cells num=',cell_num

			print '---'
			stats = part.getMeshStats(part.cells)
			esize = get_part_esize(part)
			print 'Global esize: default=',esize[0],', assigned=',esize[1]
			print '**六面体单元数为',stats.numHexElems,
			if stats.numTetElems > 0:
				print ', 四面体单元数为',stats.numTetElems,
			print ', 节点总数为',stats.numNodes
			print ' '

	stats = a.getMeshStats(tuple(a.instances.values()))
	print '**Assembly mesh status: 六面体单元数为',stats.numHexElems,
	if stats.numTetElems > 0:
		print ', 四面体单元数为',stats.numTetElems,
	print ', 节点总数为',stats.numNodes
##	print 'viewport title=',ttl()
	print ' '

	return

function_labels['PV_AB_by_centroid'] = 'powder compaction','PV, AB, OB, PFH, PH', 'centroid method'
def PV_AB_by_centroid(green_part, axis='y', bpunch_faces=None, product_part=None, sinter_loss=None,filling_density=None,shrinkage=None,grade=None, dip=None, OB=None):
	## VER: 2016-12-13, v1.0

	## Example:
	## PV_AB_by_centroid('green',grade='060',axis='y', dip=4)
	## PV_AB_by_centroid('green',grade='060',axis='y', OB=1.5)
	## PV_AB_by_centroid('green',grade='060',axis='y')

##	>>>PV_AB_by_centroid('green',grade='060',axis='y', dip=4)  ## 重心法得到的PFH比较大，PV比较大，上压量比较小。
##	shrinkage= 0.19 , PH= 35.02
##	PFH_by_centroid= 81.8521 , PFH/PH= 2.34
##	AB_by_centroid= 51.1003 , AB/PH= 1.46 , AB-PH= 16.0803
##	PV_by_centroid= 30.7518 , PV/PH= 0.88
##	--below by ratio:
##	shrinkage= 0.19 , PH= 35.02
##	PFH_by_ratio= 76.98 , PFH/PH= 2.2
##	AB_by_ratio= 56.0 , AB/PH= 1.6 , AB-PH= 20.98
##	PV_by_ratio= 20.98 , PV/PH= 0.6
##	--below by ratio:
##	shrinkage= 0.2 , PH= 35.46
##	PFH_by_ratio= 77.9422 , PFH/PH= 2.2
##	AB_by_ratio= 56.7 , AB/PH= 1.6 , AB-PH= 21.24
##	PV_by_ratio= 21.2422 , PV/PH= 0.6

	green_part = check_part(green_part)
	if len(green_part.cells) == 0:
		raise Exception('*** green part should be 3D solid part.')
	Vg = get_volume(green_part)

	axis = axis.lower()
	if axis == 'z':
		PH = round(_zlength(green_part),6)
	elif axis == 'y':	## such as button
		PH = round(_ylength(green_part),6)
	else:
		raise Exception('*** axis of die should be in y or z.')

	if bpunch_faces in empty:
		if axis == 'y':
			bpunch_faces = face_select(green_part,ny=-1)
		elif axis == 'z':
			bpunch_faces = face_select(green_part,nz=-1)
		if bpunch_faces in empty:
			raise Exception('*** faces of green part surrounded by bot punch are required.')

	if grade not in empty:
		dict1 = powder_properties(grade)
		density_th = dict1['density_th']
		sinter_loss = dict1['sinter_loss']
		shrinkage = dict1['shrinkage']
		filling_density = dict1['filling_density']

	if is_number(sinter_loss) == False:
		raise Exception('*** sinter_loss is required.')

	if is_number(filling_density) == False:
		raise Exception('*** filling density is required to get the PFH by centroid method.')

	C1 = sinter_loss
	if C1 > 0.8:
		C1 = C1/100.

	if 0.5 < shrinkage < 1:
		shrinkage = 1 - shrinkage
	elif 10 <shrinkage<30:
		shrinkage = shrinkage/100
	elif 50 < shrinkage < 100:
		shrinkage = (100-shrinkage)/100

	shrinkage_factor = round(1/(1-shrinkage),5)	## scale   ##19%对应1.2346, 王春：截面方向一般用1.24, 高度方向一般用1.245

	if product_part in empty:
		product_part = copy_part(green_part,'product_part',scale=1-shrinkage)
	product_part = check_part(product_part)

	sinter_H = PH*(1-shrinkage)
	Vs = get_volume(product_part)
	press_weight = Vs*density_th/(1-C1)/1000   ## gram
	press_weight = ceil(press_weight*100)/100    ## 称量时精确至0.1g

	if type_of(bpunch_faces) == 'STR':
		bpunch_faces = set2objs(green_part,setname=bpunch_faces)
	bpunch_faces = tolist(bpunch_faces)

	x1,x2,y1,y2,z1,z2 = objs_space(bpunch_faces)
	bot_part = copy_part(green_part,'bot_part')
	if axis == 'y':
		edges = edge_select(green_part,faces=bpunch_faces, y=y2)
		if len(edges) == 0:
			faces_top = y2 + 0.5
		else:
			faces_top = y2
		H_bot = faces_top - y1
		bias_cut(bot_part,y=faces_top,sides='+')

		faces = face_select(bot_part,y=MAX)
		sect_area = get_area(faces)

	elif axis == 'z':
		edges = edge_select(greenpart,faces=bpunch_faces,z=z2)
		if len(edges) == 0:
			faces_top = z2 + 0.5
		else:
			faces_top = z2
		H_bot = faces_top - z1
		bias_cut(bot_part,z=faces_top,sides='+')

		faces = face_select(bot_part,z=MAX)
		sect_area = get_area(faces)

	weight_bot = get_volume(bot_part)*filling_density/1000
##	print fnln(),'press weight=',press_weight
##	print fnln(),'bot_weight=',weight_bot
##	print fnln(),'green vol=',get_volume(green_part)
##	print fnln(),'bot vol=',get_volume(bot_part)
##
##	raise Exception

##	green_part = copy_part(p2_product,'green_part',scale=shrinkage_factor)
##	PH = round(_zlength(green_part),6)
##	Vg = get_volume(green_part)  ## green part

##	density_green = Vs*th/(1-C1)/Vg
##	density_green = round(density_green,2)
##	ratio = round(density_green/th*100,2)
##
##	fill_vol_by_dens = press_weight/(filling_density/1000)
##	fill_vol_by_dens = round(fill_vol_by_dens,5)

	## 通过重心法得到的PFH
	PFH_by_centroid = (press_weight - weight_bot)/(filling_density*sect_area/1000) + H_bot
	PFH_by_centroid = round(PFH_by_centroid,4)

	h = centroid_to_fill_top = 0.5*press_weight/(sect_area*filling_density/1000)  ## above centroid
	## h = centroid_to_fill_top = 0.5*fill_vol_by_dens/sect_area		## above centroid, in fill part (与上一行等效)
	h2 = centroid_to_green_bot = centroid_H(green_part)  				## from bot to centroid, in the green part
	AB_by_centroid = centroid_to_fill_top + centroid_to_green_bot   ## 注意:PFH = AB + PV, PV是下冲单独往上走（实际表现为上冲和中模同时往下走)的量。
	                                                                ## 想象一下：下冲先压，剩下的粉体高度就是AB了。
	AB_by_centroid = round(AB_by_centroid,4)
	PV_by_centroid = PFH_by_centroid - AB_by_centroid   ## 重心法: PV=PFH-AB, 比例法:PV=K*PH

	top_press = AB_by_centroid - PH

	if is_number(dip):
		OB_by_centroid = round(top_press - dip,4)
		if OB_by_centroid > 3:
			raise Exception('*** OB is usuallly only about 1mm')
	else:
		if is_number(OB) == False:
			OB = 1.0
		OB_by_centroid = OB
		dip = top_press - OB

	results = {}
	results['PFH'] = PFH_by_centroid
	results['dip'] = dip
	results['PV'] = PV_by_centroid
	results['AB'] = AB_by_centroid
	results['OB'] = OB_by_centroid
	results['PH'] = PH
	results['compress ratio'] = round(PFH_by_centroid/PH,2)

	offset1 = 0	;changing
	shrinkage1 = shrinkage + offset1
	dict2 = PV_AB_by_ratio(shrinkage=shrinkage1,sinter_H=sinter_H,ABPH=1.6,print_info=False)
	PFH_by_ratio1 = dict2['PFH']
	AB_by_ratio1 = dict2['AB']
	PV_by_ratio1 = dict2['PV']
	PH_by_ratio1 = round(sinter_H/(1-shrinkage1),2)

	offset2 = 0.01	;changing
	shrinkage2 = shrinkage + offset2
	dict2 = PV_AB_by_ratio(shrinkage=shrinkage2,sinter_H=sinter_H,ABPH=1.6,print_info=False)
	PFH_by_ratio2 = dict2['PFH']
	AB_by_ratio2 = dict2['AB']
	PV_by_ratio2 = dict2['PV']
	PH_by_ratio2 = round(sinter_H/(1-shrinkage2),2)

	print ' '
	print 'shrinkage=',shrinkage, ', PH=',PH
	print 'PFH_by_centroid=',PFH_by_centroid, ', PFH/PH=',round(PFH_by_centroid/PH,2)
	print 'AB_by_centroid=',AB_by_centroid, ', AB/PH=',round(AB_by_centroid/PH,2), ', AB-PH=',AB_by_centroid - PH
	print 'PV_by_centroid=',PV_by_centroid, ', PV/PH=',round(PV_by_centroid/PH,2)
	print '--below by ratio:'
	print 'shrinkage=',shrinkage1, ', PH=',PH_by_ratio1
	print 'PFH_by_ratio=',PFH_by_ratio1, ', PFH/PH=',round(PFH_by_ratio1/PH_by_ratio1,2)
	print 'AB_by_ratio=',AB_by_ratio1, ', AB/PH=',round(AB_by_ratio1/PH_by_ratio1,2), ', AB-PH=',AB_by_ratio1 - PH_by_ratio1
	print 'PV_by_ratio=',PV_by_ratio1, ', PV/PH=',round(PV_by_ratio1/PH_by_ratio1,2)
	print '--below by ratio:'
	print 'shrinkage=',shrinkage2, ', PH=',PH_by_ratio2
	print 'PFH_by_ratio=',PFH_by_ratio2, ', PFH/PH=',round(PFH_by_ratio2/PH_by_ratio2,2)
	print 'AB_by_ratio=',AB_by_ratio2, ', AB/PH=',round(AB_by_ratio2/PH_by_ratio2,2), ', AB-PH=',AB_by_ratio2 - PH_by_ratio2
	print 'PV_by_ratio=',PV_by_ratio2, ', PV/PH=',round(PV_by_ratio2/PH_by_ratio2,2)
	print ' '

	return results

function_labels['PV_AB_by_ratio'] = 'powder compaction', 'PV, OB, AB, PH, PFH', 'insert'
def PV_AB_by_ratio(sinter_H=None,shrinkage=None,PH=None,PV=None,PFH=None,AB=None, dip=None,PVPH=None,ABPH=None,
	OB=None,grade=None,print_info=True,ask=True):
	## VER: 2017-09-27, v1.7
	## PFH reference: PH+OB+2PV, PH+OB+2PV + 0.5, PH+OB+2PV - 0.5, PH*(1+2*0.6), PH*(1+2*PV/PH)
	## dip is the underfilling mentioned by Kevin
	## 比例法：墨西哥采用，Richard Cheng采用。墨西哥给的数据中，PH, PV,OB,PW是准确的，但PFH往往有误，或需要根据填粉密度=3.3左右来调整PFH。比例也往往保持在1.6上下。
	## 重心法：考文垂采用，Chun Wang采用。
	## 注意，shrinkage为在设计模具时，所用的shrinkage。不同于粉末证书的shrinkage。例如：H10F的粉末证书shrinkage=0.19，但是设计模具时可能采用0.195甚至0.20，相当于压得松一点，防止模具变形开裂
	## westbranch的粉比考文垂的粉软一点，可以采用相对较低的收缩率，即可以压得更实一点。

##	>>> PV_AB_by_ratio(PH=6)
##
##	sinter_H  = 4.89
##	Shrinkage = 18.5 %
##	PH = 6.0
##	L=AB = 9.6
##	PFH = 13.2
##	Total press = 7.2
##	input ABPH = 1.6 , real ABPH=1+PV/PH= 1.6 , PV/PH= 0.6 , AB/PH= 1.6
##	OB/PH = 0.43
##	compress ratio= 2.2
##	----
##	dip = 1 , ==> underfilling
##	nominal lower pressing:  PV = 3.6
##	nominal upper pressing:  OB = 2.6 , positive = True
##	lower pressing: negative_PV = (5.9, 5.6, 5.3)
##	lower pressing: positive_PV = (3.6, 4.1, 4.6)
##	--
##	upper pressing: negative_OB = (0.3, 0.6, 0.9)
##	upper pressing: positive_OB = (2.6, 2.1, 1.6)
##
##	inputs: {'PV': None, 'sinter_H': None, 'grade': None, 'shrinkage': None, 'OB': None, 'print_info': True, 'PVPH': None, 'ask': True, 'PH': 6, 'dip': None}
##	Initial: PFH= 13.2 (PV=3.6), under filling: 12.2 (PV=3.6), lower prsssing: 8.6 ,upper pressing: 6.0 (PH), after sinter: 4.89 (sinter_H)
##
##	{'AB': 9.6, 'PV': 3.6, 'PFH': 13.2, 'OB': 2.6, 'steps': 'Initial: PFH=13.2(PV=3.6), under filling:12.2(PV=3.6), lower prsssing:8.6,upper pressing:6.0(PH), after sinter:4.89(sinter_H)', 'PH': 6.0, 'compress ratio': 2.2, 'dip': 1}
##	>>>

##	>>> PV_AB_by_ratio(PV=3.34,PH=6.12,OB=0.6,PVPH=0.61,shrinkage=0.18,ask=False)
##
##	sinter_H  = 5.02
##	Shrinkage = 18.0 %
##	PH = 6.12
##	L=AB = 9.9
##	PFH = 13.24
##	Total press = 7.12
##	input ABPH = 1.61 , real ABPH=1+PV/PH= 1.55 , PV/PH= 0.55 , AB/PH= 1.62
##	OB/PH = 0.1
##	compress ratio= 2.16
##	----
##	dip = 3.18 , ==> underfilling
##	nominal lower pressing:  PV = 3.34
##	nominal upper pressing:  OB = 0.6 , positive = False
##	lower pressing: negative_PV = (3.634, 3.328, 3.022)
##	lower pressing: positive_PV = (1.16, 1.66, 2.16)
##	--
##	upper pressing: negative_OB = (0.306, 0.612, 0.918)
##	upper pressing: positive_OB = (2.78, 2.28, 1.78)
##
##	inputs: {'PV': 3.34, 'sinter_H': None, 'grade': None, 'shrinkage': 0.18, 'OB': 0.6, 'print_info': True, 'PVPH': 0.61, 'ask': False, 'PH': 6.12, 'dip': None}
##	Initial: PFH= 13.24 (PV=3.34), under filling: 10.06 (PV=3.34), lower prsssing: 6.72 ,upper pressing: 6.12 (PH), after sinter: 5.02 (sinter_H)
##
##	{'AB': 9.9, 'PV': 3.34, 'PFH': 13.24, 'OB': 0.6, 'steps': 'Initial: PFH=13.24(PV=3.34), under filling:10.06(PV=3.34), lower prsssing:6.72,upper pressing:6.12(PH), after sinter:5.02(sinter_H)', 'PH': 6.12, 'compress ratio': 2.16, 'dip': 3.18}

	## Carmex insert:
##	>>> PV_AB_by_ratio(shrinkage=19.5,PH=4.35,PV=2.65) ## compress ratio=2.22
##	Initial:  9.65 (PV=2.65), under filling: 8.65 (PV=2.65), lower prsssing: 6.0 ,upper pressing: 4.35 , after sinter: 3.5
##	Another option with dip=1.5:
##	>>> PV_AB_by_ratio(shrinkage=19.5,PH=4.35,PV=2.65,dip=1.5)  ## compress ratio=2.22
##	Initial:  9.65 (PV=2.65), under filling: 8.15 (PV=2.65), lower prsssing: 5.5 ,upper pressing: 4.35 , after sinter: 3.5

	## USM insert (project):
##	>>> PV_AB_by_ratio(shrinkage=19.5, PH=6.216, PV=3.784)  ## compress ratio=2.22
##	Initial:  13.784 (PV=3.784), under filling: 12.784 (PV=3.784), lower prsssing: 9.0 ,upper pressing: 6.216 , after sinter: 5.0

	## USM insert (priority 4)
##	>>> PV_AB_by_ratio(sinter_H=4.9,ABPH=1.61)  ## 4.75 + 0.15(grind) = 4.9, compress ratio=2.21
##	Initial: PFH= 13.3506 (PV=3.6506), under filling: 12.3506 (PV=3.6506), lower prsssing: 8.7 ,upper pressing: 6.0494 (PH), after sinter: 4.9 (sinter_H)
##	(13.3506, 3.6506, 2.6506)
##	square_insert_compaction('insert',length=15.62,sideR=80,surf_neck=15.31,small_D_surf=7.3,small_L=1.32 + 0.15, big_D_surf=8.5, big_L=3.43, hole_angle_top=4,hole_angle_bot=-4,
##		topR=25, product_H=[5.3,4.9], PFH_by='ratio',ABPH=1.61)  ## priority 4: sinter_H = 4.9

##	>>> PV_AB_by_ratio(sinter_H=35.9,dip=4) ## compress ratio=2.2
##
##	sinter_H  = 35.9
##	Shrinkage = 19.0 %
##	PH = 44.321
##	L=AB = 70.9
##	PFH = 97.479
##	Total press = 53.158
##	input ABPH = 1.6 , real ABPH=1+PV/PH= 1.6 , PV/PH= 0.6 , AB/PH= 1.6
##	OB/PH = 0.51
##	----
##	dip = 4 , ==> underfilling
##	nominal lower pressing:  PV = 26.579
##	nominal upper pressing:  OB = 22.579 , positive = True
##	lower pressing: negative_PV = (46.9419, 44.7259, 42.5099)
##	lower pressing: positive_PV = (23.579, 24.079, 24.579)
##	--
##	upper pressing: negative_OB = (2.2161, 4.4321, 6.6481)
##	upper pressing: positive_OB = (25.579, 25.079, 24.579)
##
##	inputs: {'PV': None, 'sinter_H': 35.9, 'shrinkage': 0.19, 'OB': None, 'ABPH': 1.6, 'PH': None, 'dip': 4}
##	Initial: PFH= 97.479 (PV=26.579), under filling: 93.479 (PV=26.579), lower prsssing: 66.9 ,upper pressing: 44.321 (PH), after sinter: 35.9 (sinter_H)
##
##	{'AB': 70.9, 'PV': 26.579, 'PFH': 97.479, 'OB': 22.579, 'steps': 'Initial: PFH=97.479(PV=26.579), under filling:93.479(PV=26.579), lower prsssing:66.9,upper pressing:44.321(PH), after sinter:35.9(sinter_H)', 'PH': 44.321, 'dip': 4}
##	>>>

	inputs = repr(locals())

	if grade not in empty:
		dict1 = powder_properties(grade)
		shrinkage = dict1['shrinkage']

	if is_number(shrinkage):
		if shrinkage > 2:
			shrinkage = shrinkage/100

		if shrinkage > 0.7:
			shrinkage = 1 - shrinkage

	if is_numbers(sinter_H,PH):
		shrinkage = 1 - round(sinter_H/PH,3)

	## sinter_H, PH, shrinkage
	if is_numbers(sinter_H,shrinkage) and PH in empty:
		PH = sinter_H/(1-shrinkage)
	elif is_numbers(PH,shrinkage) and sinter_H in empty:
		sinter_H = round(PH*(1-shrinkage),2)
	elif is_numbers(sinter_H,PH):
		shrinkage = 1 - round(sinter_H/PH,3)

	if is_number(PVPH):
		if PVPH > 1:
			ABPH = PVPH
			PVPH = ABPH - 1
		else:
			ABPH = 1 + PVPH
	elif is_number(ABPH):
		if ABPH < 1:
			PVPH = ABPH
			ABPH = 1 + PVPH
		else:
			PVPH = ABPH - 1

	## 已知PH以及(PV, AB, PFH)中的一个
	if is_numbers(PH,PV):   ## provided PV
		## 在比例法中，若K=PV/PH,则AB/PH=1+K。在重心法中，并没有此关系。
		if is_number(PVPH) == False:
			PVPH = round(PV/PH,2)
			ABPH = 1 + PVPH

		if ask == True:
			factor0 = GUI_inputs(('set PVPH=',PVPH),'AB=PV+PH,               PFH=PV+AB=PH+2PV \n\nAB/PH=1+PV/PH,    PFH/PH=1+2PV/PH   \n\nPVPH=PV/PH  \n\nAB=(1+PVPH)*PH,   PFH=PH*(1+2*PVPH) \n\nFound different ratio, default=0.6, current='+str(PVPH))
			print fnln(),'Input PVPH=',factor0
			PVPH = factor0

	elif is_numbers(PH,PFH):
		if is_number(PVPH) == False:
			PVPH = round(0.5*(PFH/PV - 1),2)
			ABPH = 1 + PVPH

	elif is_numbers(PH,AB):
		if is_number(PVPH) == False:
			PVPH = round(AB/PH - 1,2)
			ABPH = 1 + PVPH

	## 到这一步, PVPH应该是已知量。
	if is_number(PVPH) == False:
		PVPH = 0.6
		ABPH = 1.6

	## 有时，仅仅提供一个参数，例如:
	## >>>PV_AB_by_ratio(PV=3)
	## >>>PV_AB_by_ratio(sinter_H=5)
	## >>>PV_AB_by_ratio(AB=10)
	## >>>PV_AB_by_ratio(PFH=16)
	## >>>PV_AB_by_ratio(PH=6)

	if is_number(PH) == False:
		if is_number(PFH):
			PH = round(PFH/(1+2*PVPH),3)
		elif is_number(AB):
			PH = round(AB/ABPH,3)
		elif is_number(sinter_H):
			if is_number(shrinkage) == False:
				shrinkage = 0.185
			PH = round(sinter_H/(1-shrinkage),3)
		elif is_number(PV):
			PH = round(PV/PVPH,3)

	## 到这一步, PH应该是已知量。
	if is_number(PH) == False:
		raise Exception('*** PH is unknow.')

	## shrinkage也可能是最后求出的量。
	if is_number(shrinkage) == False:
		if is_numbers(sinter_H,PH):
			shrinkage = 1 - round(sinter_H/PH,3)
		else:
			shrinkage = 0.185

	## sinter_H也可能是最后求出
	if is_number(sinter_H) == False:
		sinter_H = round(PH*(1-shrinkage),2)

	## 推导出其他量
	if is_number(AB) == False:
		AB = round(PH*ABPH,1)    ## Actually, AB = PH + PV ## Mexico mention L as AB
	if is_number(PV) == False:  ## or PV = PH*PVPH
		PV = AB - PH	## 注意，该公式只被墨西哥承认，考文垂不承认。考文垂认为PV, AB, PH之间没有固定关系，PV是可调的。墨西哥不是，而是调收缩率（压下量大点或小点，粉体多点或少点）
	if is_number(PFH) == False:
		PFH = AB + PV    		## Approximately, PFH = PH + PV + PV, PV是下冲的上压量(其实是上冲、中模同时往下走形成下冲往上走的效果。
	L = AB

	## 重心法:
	## AB_by_centroid = centroid_to_fill_top + centroid_to_green_bot
	## PFH_by_centroid = AB_by_centroid + PV_by_centroid = centroid_to_fill_top + centroid_to_green_bot + PV_by_centroid

	## K = 1+PV/PH = (PH+PV)/PH = AB/PH
	## PFH = PH + 2PV = AB + PV , 即:AB = PH + PV   ★★★ 我的理解是这里的PV是上压量和下压量的平均值，根据不同几何，可能上面多压点或下面多压点。
	K = 1 + round(PV/PH,2)
	total_press = PFH - PH
	if is_number(OB):
		dip = PFH - OB - PV - PH
	else:
		if dip == None:
			dip = 1
		OB = PFH - dip - PV - PH
	positive = False
	if OB/PH > 0.3:
		positive = True

	negative_OB = round(0.05*PH,4), round(0.1*PH,4), round(0.15*PH,4)
	n1,n2,n3 = negative_OB
	positive_OB = L - PH - 1, L - PH - 1.5, L - PH - 2
	p1,p2,p3 = positive_OB
	negative_PV = total_press - dip - n1, total_press - dip - n2, total_press - dip - n3
	positive_PV = total_press - dip - p1, total_press - dip - p2, total_press - dip - p3
	steps = 'Initial: PFH=' + str(PFH) + '(PV='+str(PV)+'), under filling:' + str(PFH-dip) + '(PV='+str(PV)+'), lower prsssing:' + str(PFH-dip-PV) +',upper pressing:' + str(PFH-dip-PV-OB) + '(PH), after sinter:' + str(sinter_H) +'(sinter_H)'

	if print_info == True:
		print ' '
		print 'sinter_H  =',sinter_H
		if is_number(shrinkage):
			print 'Shrinkage =',shrinkage*100,'%'
		print 'PH =',PH
		print 'L=AB =',AB
		print 'PFH =',PFH
		print 'Total press =',total_press
		print 'input ABPH =',ABPH,', real ABPH=1+PV/PH=',K,', PVPH=PV/PH=',round(PV/PH,2),', AB/PH=',round(AB/PH,2)
		print 'OB/PH =',round(OB/PH,2)
		print 'compress ratio=',round(PFH/PH,2)
		print '----'
		print 'dip =',dip, ', ==> underfilling'
		print 'nominal lower pressing:  PV =', PV
		print 'nominal upper pressing:  OB =', OB, ', positive =',positive
		print 'lower pressing: negative_PV =',negative_PV
		print 'lower pressing: positive_PV =',positive_PV
		print '--'
		print 'upper pressing: negative_OB =',negative_OB
		print 'upper pressing: positive_OB =',positive_OB
		print ' '
		print 'inputs:',inputs
		print 'Initial: PFH=',PFH,'(PV='+str(PV)+'), under filling:',PFH-dip,'(PV='+str(PV)+'), lower prsssing:',PFH-dip-PV,',upper pressing:',PFH-dip-PV-OB, '(PH), after sinter:',sinter_H,'(sinter_H)'
		print ' '

	results = {}
	results['PFH'] = PFH
	results['dip'] = dip
	results['PV'] = PV
	results['AB'] = AB
	results['OB'] = OB
	results['PH'] = PH
	results['steps'] = steps
	results['compress ratio'] = round(PFH/PH,2)

	return results

function_labels['PV_AB_of_model'] = 'PV, AB, OB, PFH, PH', 'powder compaction', 'compaction ratio'
def PV_AB_of_model(axis='z',tpunch=None,die=None,ejector=None,finish_step=None):
	## VER: 2016-12-26, v1.4

##	>>> PV_AB_of_model()
##	['GUI_inputs', 5173] inputs= ['z', '']
##
##	file:  A0278-ETops_pv20.cae, model name:  Model-1
##	pressing axis= z
##	punch steps= [0, -25.0, -20.0, -0.759, 0]
##	die steps= [0, 0, -20.0, 0, 0]
##	ejector steps= [0, 0, 0, 0, 0]
##	PFH= 89.88
##	PV= 20.0
##	AB= 69.88
##	PH= 44.321
##	OB= 0.759
##	real underfill= 24.8 , norminal= 25.0 (include gap)
##	top press/PH= 0.58 , norminal=0.6
##	bot press/PH = PV/PH= 0.45 , norminal = 0.6
##	AB/PH= 1.58 , norminal = 1.6
##	PHF/PH= 2.03 , norminal = 2.2
##	compressed/PH= 1.03 , norminal=1.2
##	Compress ratio = 2.03

	plot(a)

	insts = []
	BCs = valid_BCs()
	insts0 = all_valid_insts()

	for BC1 in BCs:
		insts1 = instances_of_BC(BC1)
		insts = insts + insts1
	insts = remove_repeated_items(insts)  ## inst objs
	if insts in empty:
		raise Exception('*** No BC in the model')

##	print fnln(),'insts=',insts
##	raise Exception

	powder = None
	for inst in insts0:
		mats = mats_of_poi(inst)
		if show_in_items(mats,'H10pow',capital=False):
			powder = inst
			break
	if powder == None:
		raise Exception('*** Fail to find the powder part')

	powder = check_inst(powder)
	insts0 = unselect(insts0,powder.name)

	if len(powder.cells) == 0:
		axis = 'y'
	else:
##		axis = GUI_inputs(('pressing axis','z'),info='please provide data')   ## 'pressing axis'是文本框左边的文字，文本框中的默认值为'z'
		text = 'steps: '
		for i in range(len(_m.steps)):
			text = text + str(i) + '-' + _m.steps.keys()[i] + ','
		text = text[:-1]
		text = text + '\nTools: ' + repr(insts0)[1:-1]  ## \n表示换行

		default = axis
		axis,finish_step = GUI_inputs([('pressing axis',default),'finish step num without ejection'],info=text)
		try:
			finish_step = int(finish_step)
		except:
			finish_step = None

	if die in empty:
		insts1 = inst_names_with('die')
		if len(insts1) == 1:
			die = insts1[0]

	if is_instance(die) == False:
		raise Exception('*** Please provide die instance.')
	else:
		die = check_inst(die)

	## 通常core pin不影响压高
	if ejector in empty:
		insts1 = inst_names_with('ejector')
		if len(insts1) == 1:
			ejector = insts1[0]

	if ejector in empty:
		insts1 = inst_names_with('bpunch')
		if len(insts1) == 1:
			ejector = insts1[0]

	if ejector in empty:
		insts1 = inst_names_with('L/P')
		if len(insts1) == 1:
			ejector = insts1[0]

	if ejector in empty:
		insts1 = inst_names_with('B/P')
		if len(insts1) == 1:
			ejector = insts1[0]

	if ejector in empty:
		insts1 = inst_names_with('bot','punch')
		if len(insts1) == 1:
			ejector = insts1[0]

	if is_instance(ejector) == False:
		raise Exception('*** Please provide ejector instance.')
	else:
		ejector = check_inst(ejector)

	insts = unselect(insts, [ejector,die])
	if tpunch in empty:
		if len(insts) == 1:
			tpunch = insts[0]
		else:
			insts1 = inst_names_with('punch')
			if len(insts1) == 1:
				tpunch = insts1[0]

			if tpunch in empty:
				insts1 = inst_names_with('top','punch')
				if len(insts1) == 1:
					tpunch = insts1[0]

			if tpunch in empty:
				insts1 = inst_names_with('T/P')
				if len(insts1) == 1:
					tpunch = insts1[0]

			if tpunch in empty:
				insts1 = inst_names_with('U/P')
				if len(insts1) == 1:
					tpunch = insts1[0]

	if is_instance(tpunch) == False:
		raise Exception('*** Please provide tpunch instance.')
	else:
		tpunch = check_inst(tpunch)

	actions1 = BC_of_inst_in_dir(tpunch,dir='x')
	actions2 = BC_of_inst_in_dir(tpunch,dir='y')
	actions3 = BC_of_inst_in_dir(tpunch,dir='z')

	if sum(actions3) != 0:
		print 'guess direction=z'
	elif sum(actions2) != 0:
		print 'guss direction=y'
	elif sum(actions1) != 0:
		print 'guess direction=x'

	axis = axis.lower()
	if axis not in ['x','y','z']:
		raise Exception('*** pressing axis should be in x,y or z')

	punch_steps=BC_of_inst_in_dir(tpunch,dir=axis)
	ejector_steps = BC_of_inst_in_dir(ejector,dir=axis)
	die_steps = BC_of_inst_in_dir(die,dir=axis)

	disp_punch = sum(punch_steps)
	disp_ejector = sum(ejector_steps)
	disp_die = sum(die_steps)

##	disp_punch = displacement_BC_of_inst(tpunch,dir1=axis,finish_step=finish_step)
##	disp_ejector = displacement_BC_of_inst(ejector,dir1=axis,finish_step=finish_step)
##	disp_die = displacement_BC_of_inst(die,dir1=axis,finish_step=finish_step)

	if disp_punch < 0:
		punch_at_top = True
	else:
		punch_at_top = False

	disp_punch = abs(disp_punch)
	disp_die = abs(disp_die)
	disp_ejector = abs(disp_ejector)

	if axis == 'z':
		PFH = _zlength(powder)
		if punch_at_top:
			initial_H = _zmax(tpunch) - _zmin(powder)
		else:
			initial_H = _zmax(powder) - _zmin(tpunch)
	elif axis == 'y':
		PFH = _ylength(powder)
		if punch_at_top:
			initial_H = _ymax(tpunch) - _ymin(powder)
		else:
			initial_H = _ymax(powder) - _ymin(tpunch)
	elif axis == 'x':
		PFH = _xlength(powder)
		if punch_at_top:
			initial_H = _xmax(tpunch) - _xmin(powder)
		else:
			initial_H = _xmax(powder) - _xmin(tpunch)

	PFH = round(PFH,3)
	indexs = range(len(ejector_steps))

	print fnln(),'ejector_steps=',ejector_steps
	if disp_ejector > 0:	## double action pressing
		PV = disp_ejector
		for i in indexs:
			if ejector_steps[i] != 0:
				start = i
				break
		for i in _reverse(indexs):
			if ejector_steps[i] != 0:
				end = i
				break

	else:
		PV = disp_die
		for i in indexs:
			if die_steps[i] != 0:
				start = i
				break
		for i in _reverse(indexs):
			if die_steps[i] != 0:
				end = i
				break

	AB = PFH - PV
	if end == indexs[-1]:
		OB = 0
	else:
		OB = abs(sum(punch_steps[end+1:]))

##	print fnln(),'initial H=',initial_H
	total_press = disp_punch + disp_ejector   ## 含有punch与powder之间的gap
	PH = round(initial_H - total_press,3)

	compress_ratio = round(PFH/PH,2)
	norminal_PVPH = (compress_ratio - 1)/2
	print ' '
	print 'file: ',cae_file_title + '.cae, model name: ', _m.name
	print 'pressing axis=',axis
	print 'punch steps=',punch_steps
	print 'die steps=',die_steps
	print 'ejector steps=',ejector_steps
	print 'PFH=',PFH
	print 'PV=',PV   ## 在lower pressing step, die和top punch的BC位移量都是PV (modified as PV)
	print 'AB=',AB
	print 'PH=',PH
	print 'OB=',OB
	print 'real underfill=',AB - OB - PH, ', norminal=',abs(sum(punch_steps[:start])),'(include tool gap)'
	print 'top press/PH=',round((AB-PH)/PH,2),', norminal=0.6'
	print 'bot press/PH = PV/PH=',round(PV/PH,2),', norminal = 0.6'
	print 'AB/PH=',round(AB/PH,2),', norminal = 1.6'
	print 'PHF/PH=',round(PFH/PH,2),', norminal = 2.2'
	print 'compressed/PH=',round((PFH-PH)/PH,2),', norminal=1.2'
	print 'Compress ratio =',compress_ratio
	print ' '

	return

def qtr_rect_frame(partname,heng,shu):
	## VER: 2011-05-20, v1.7

	blank_part(partname)
	frm = _m.parts[partname]

	keys0 = locals().keys()
	bot_lip_top = base_thick + leg_gap_H + bot_lip_thick
	top_lip_tipx = heng - top_lip_width
	top_lip_tipy = shu - top_lip_width
	bot_lip_tipx = heng - bot_lip_width
	bot_lip_tipy = shu - bot_lip_width
	flange_tipx = heng - frame_bot_width
	flange_tipy = shu - frame_bot_width

	locals2globals(keys0,locals())

	create_block(frm,(0,heng),(0,shu),(0,frame_height))

	hex_cut(frm,(0,flange_tipx),(0,flange_tipy),(0,base_thick))
	hex_cut(frm,(0,heng - outer_wall_thick),(0,shu - outer_wall_thick),(base_thick,base_thick + leg_gap_H))

	hex_cut(frm,(0,heng - outer_wall_thick - silic_side),(0,shu - outer_wall_thick - silic_side),
		(bot_lip_top + bot_adhesive_thick,frame_height - top_lip_thick - top_adhesive_thick))

	hex_cut(frm,(0,heng - top_lip_width - bot_lip_extx),(0,shu - top_lip_width - bot_lip_exty),
		(base_thick + leg_gap_H, bot_lip_top + bot_adhesive_thick))

	hex_cut(frm,(0,heng - top_lip_width),(0,shu - top_lip_width),
		(frame_height, frame_height - top_lip_thick - top_adhesive_thick))

	## small leg
	if beam_dir == 'x':
		create_block(frm,(0,heng - outer_wall_thick),(shu - outer_wall_thick - leg_gap,shu - outer_wall_thick - leg_gap - inner_wall_thick),
			(0,bot_lip_top + bot_adhesive_thick))

	elif beam_dir == 'y':
		create_block(frm,(heng - outer_wall_thick - leg_gap,heng - outer_wall_thick - leg_gap - inner_wall_thick),
			(0,shu - outer_wall_thick), (0,bot_lip_top + bot_adhesive_thick))

	set_mat(frm,mat='Al_6063',subset='Frame')

	faces = faces_of_cut(frm,z=frame_height - top_lip_thick - top_adhesive_thick)
	create_set(frm,faces=faces,name='fs_frm_adhesive_top')

	faces = faces_of_cut(frm,z=bot_lip_top + bot_adhesive_thick)
	create_set(frm,faces=faces,name='fs_frm_adhesive_bot')

	faces = faces_of_cut(frm,x=heng - outer_wall_thick - silic_side)
	create_set(frm,faces=faces,name='fs_frm_adhesive_sidex')

	faces = faces_of_cut(frm,y=shu - outer_wall_thick - silic_side)
	create_set(frm,faces=faces,name='fs_frm_adhesive_sidey')

	create_side_sets(frm)

	dir_points(frm,'x')
	dir_points(frm,'y')
	dir_points(frm,'z')

	batch_divide(frm,x='p_frm_dirx')
	batch_divide(frm,y='p_frm_diry')
	batch_divide(frm,z='p_frm_dirz')

	divide(frm,z=bot_lip_top)
	divide(frm,z=frame_height - top_lip_thick)

	divide(frm,z=bot_lip_top + bot_adhesive_thick + TPT_thick)
	divide(frm,z=bot_lip_top + bot_adhesive_thick + TPT_thick + EVA_thick)

	cells = cell_select_by_container(frm,x=(0,heng - outer_wall_thick), y=(0,shu - outer_wall_thick), z=(bot_lip_top,frame_height - top_lip_thick))
	cross_set_mat(frm,cells=cells,mat='Silic')

	new_instance(frm)

	return

def radial_cut(p,ndir,x1=None,x2=None,y1=None,y2=None,z1=None,z2=None,x=None,y=None,z=None,center0=(),ref_face=None,
	R=None, radius=None, D=None, R1=None, R2=None, ID=0,OD=5000,L=0,partition=True):
	## VER: 2016-05-31, v2.7

	## Example:
	## radial_cut('anvil',ndir='x', ID=grove_OD,x1=grove_x1,x2=grove_x2)  ## x方向上，从x1到x2一段，进行radial_cut()
	## radial_cut(shaft,ndir='x', x1=210, x2=150, R1=57.25)
	## radial_cut(shaft,ndir='x', center0=(210,0,0), R1=57.25,L=-70)
	## radial_cut(shaft,ndir='x',ID=shaft_D2,x1=shaft_D1_length,x2=MAX)
	## radial_cut(shaft,ndir='x',ID=shaft_D2,center0=(MAX,0,0),L=-151.75)
	## radial_cut(carbide,ndir='x',ID=_leny(cutter) - 4e-3)   ## 使cutter的直径比carbide大4um,单边大2um。
	## radial_cut('cutEdge',ndir='x',OD=147)
	## radial_cut('p1',center0=(-3.4, 4,5, 73.9), R1=0, R2=1, L=-0.5, ndir='z',partition=False)

	p = check_part(p)
	vol0 = get_volume(p)

	if is_number(radius):
		R = radius

	x1,y1,z1 = real_xyz(p,x1,y1,z1)
	x2,y2,z2 = real_xyz(p,x2,y2,z2)
	if is_numbers(x1,x2):
		x1,x2 = _sort(x1,x2)
	if is_numbers(y1,y2):
		y1,y2 = _sort(y1,y2)
	if is_numbers(z1,z2):
		z1,z2 = _sort(z1,z2)

	x,y,z = real_xyz(p,x,y,z)  ## Results maybe x=None,y=None,z=None

	if ndir not in ['x','y','z']:
		raise Exception('*** ndir should be in x, y, or z')

	if is_number(D):
		R = D/2.0

	if is_number(R):  ## drilling hole
		R1 = 0
		R2 = R

	if type_of(R1) not in numerics:
		R1 = ID/2.0

	if type_of(R2) not in numerics:
		R2 = OD/2.0

	if is_numbers(R1,R2):
		R1,R2 = _sort(R1,R2)

	if L == 0:
		if ndir == 'x':
			if is_numbers(x1,x2) == False:  ## L未确定，多切点
				L = _xlength(p) + 1
			else:
				L = x2 - x1  ## positive	## L已确定
		elif ndir == 'y':
			if is_numbers(y1,y2) == False:
				L = _ylength(p) + 1
			else:
				L = y2 - y1   ## positive
		elif ndir == 'z':
			if is_numbers(z1,z2) == False:
				L = _zlength(p) + 1
			else:
				L = z2 - z1   ## positive

	if type_of(L) not in numerics:
		raise Exception('*** L should be numeric.')

	if ref_face not in empty:
		ndir0 = face_ndir(ref_face)
		if ndir0 != 'cylindrical':
			raise Exception('*** a cylindrical face is required.')
		else:
			center0,vector0,axis = center_axis_of_cylind_face(ref_face)

	if is_numbers(x,y,z):
		center0 = (x,y,z)

	else:
		if ndir == 'z':
			if x in empty:
				x = 0
			if y in empty:
				y = 0
			if is_numbers(x,y) == False:
				raise Exception('*** x,y are required for center0')

			if is_number(z):
				center0 = (x,y,z)
			elif is_numbers(z1,z2):
				center0 = (x,y,z1)
			else:   ## 轴向范围没有信息
				center0 = (x,y,_zmin(p)-0.1)

		elif ndir == 'x':
			if y in empty:
				y = 0
			if z in empty:
				z = 0
			if is_numbers(y,z) == False:
				raise Exception('*** y,z are required for center0')

			if is_number(x):
				center0 = (x,y,z)
			elif is_numbers(x1,x2):
				center0 = (x1,y,z)
			else:   ## 轴向范围没有信息
				center0 = (_xmin(p)-0.1,y,z)

		elif ndir == 'y':
			if x in empty:
				x = 0
			if z in empty:
				z = 0
			if is_numbers(x,z) == False:
				raise Exception('*** x,z are required for center0')

			if is_number(y):
				center0 = (x,y,z)
			elif is_numbers(y1,y2):
				center0 = (x,y1,z)
			else:   ## 轴向范围没有信息
				center0 = (x,_ymin(p)-0.1,z)

	print fnln(),'ndir=',ndir
	print fnln(),is_numbers(x,y)
	print fnln(),'x=',x
	print fnln(),'center0 =',center0
##	raise Exception

	if center0 in empty:
		raise Exception('*** center0 required.')

	center0 = list(center0)
	x0,y0,z0 = center0
	x0,y0,z0 = real_xyz(p,x0,y0,z0)
	center0 = [x0,y0,z0]

	flip = ON   ## cut is reverse the axial direction, grow is along the axis direction
	if L < 0:
		flip = OFF

	if ndir == 'x':
		offset = center0[0]
	elif ndir == 'y':
		offset = center0[1]
	elif ndir == 'z':
		offset = center0[2]

	## conver 3D points to sketch points
	center0 = threeD_to_sketch_points(center0,ndir)
	x0 = center0[0];	y0 = center0[1]

	## create blank sketch
	sketch1 = create_part_sketch(p,ndir,offset=offset,name='temp_sketch1')
	s = sketch1['sketch']
	datum_plane1 = sketch1['datum_plane']
	right_edge1 = sketch1['right_edge']
	side1 = sketch1['side']

	## draw lines
	if R1 > 0:
		s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + R1, y0))
	s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + R2, y0))

	## extrude
	p.CutExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1,
	    sketchPlaneSide=side1, sketchOrientation=RIGHT, sketch=s, depth=abs(L),
	    flipExtrudeDirection=flip)

	print '--->Performed radial cut in',ndir,', ID=',2*R1,', OD=', 2*R2

	if partition == True:
		faces = face_select(p,radius=R1)
		if len(faces) > 0:
			divide_by_face(p,face=faces[0])

		faces = face_select(p,radius=R2)
		if len(faces) > 0:
			divide_by_face(p,face=faces[0])

	vol1 = get_volume(p)
	if vol0 > vol1:
		print fnln(),p.name,'is radial cutted.'
	else:
		print '***',p.name,'is not cutted.'

	return


def radial_constraint(arc,radius=None):
	## VER: 2014-09-10, v1.0

	type1 = type_of(arc)
	if 'arc' not in type1 and 'circle' not in type1:  ## regular_arc, regular_circle
		raise Exception('*** an arc or circle is required.')

	id = arc.id
	sketch = get_parent(arc)

	if radius in empty:
		radius = radius_of_geometry(arc)

	loc = arc.pointOn
	loc = loc[0] + 1, loc[1]

	sketch.RadialDimension(curve=sketch.geometry[id],textPoint=loc, radius=radius)

	return

function_labels['radial_grow'] = 'cylinder','radial','grow','ID','OD'
def radial_grow(p,ndir,x1=None,x2=None,y1=None,y2=None,z1=None,z2=None,x=None,y=None,z=None,center0=(0,0,0),ID=None, OD=None,R=None, D=None,L=0):
	## VER: 2013-09-04, v2.1, reference: cylinder_grow()

	## Example:
	## radial_grow(shaft,ndir='x',x1=210,x2=150,ID=0,OD=80)
	## radial_grow(shaft,ndir='x',x1=210,x2=150,ID=73,OD=80)

	p = check_part(p)

	if type_of(ndir) != 'STR':
		raise Exception('*** ndir is required.')
	ndir = ndir.lower()

	center0 = list(center0)
	if type_of(R) in numerics:
		ID = 0  ## zero
		OD = 2*R
	if type_of(D) in numerics:
		ID = 0  ## zero
		OD = D

	if type_of(ID) in numerics and type_of(OD) in numerics:
		if ID > OD:
			ID,OD = OD,ID

	x0,y0,z0 = center0
	x0,y0,z0 = real_xyz(p,x0,y0,z0)
	center0 = [x0,y0,z0]

	x1,y1,z1 = real_xyz(p,x1,y1,z1)
	x2,y2,z2 = real_xyz(p,x2,y2,z2)
	x,y,z = real_xyz(p,x,y,z)

	if type_of(L) not in numerics:
		raise Exception('*** L should be numeric.')

	if L != 0:
		if ndir == 'x' and x1 not in empty and x2 not in empty:
			L = 0
		elif ndir == 'y' and y1 not in empty and y2 not in empty:
			L = 0
		elif ndir == 'z' and z1 not in empty and z2 not in empty:
			L = 0

	if L == 0:
		if ndir == 'x':
			if x1 not in empty and x2 not in empty:
				if x1 > x2:
					x1,x2 = x2,x1

##				print 'x1,x2=',(x1,x2)
				L = x2 - x1
				center0[0] = x1
			else:
				raise Exception('*** x1,x2 or L is required.')

			if type_of(y) in numerics:
				center0[1] = y
			if type_of(z) in numerics:
				center0[2] = z

		elif ndir == 'y':
			if y1 not in empty and y2 not in empty:
				if y1 > y2:
					y1,y2 = y2,y1

				L = y2 - y1
				center0[1] = y1
			else:
				raise Exception('*** y1,y2 or L is required.')

			if type_of(x) in numerics:
				center0[0] = x
			if type_of(z) in numerics:
				center0[2] = z

		elif ndir == 'z':
			if z1 not in empty and z2 not in empty:
				if z1 > z2:
					z1,z2 = z2,z1

				L = z2 - z1
				center0[2] = z1
			else:
				raise Exception('*** z1,z2 or L is required.')

			if type_of(x) in numerics:
				center0[0] = x
			if type_of(y) in numerics:
				center0[1] = y

	else:
		if L < 0:
			if ndir == 'x':
				center0[0] += L
			elif ndir == 'y':
				center0[1] += L
			elif ndir == 'z':
				center0[2] += L

##	print 'center0=',center0
	flip = OFF  ## cut is reverse the axial direction, grow is along the axis direction

	if ndir == 'x':
		offset = center0[0]
	elif ndir == 'y':
		offset = center0[1]
	elif ndir == 'z':
		offset = center0[2]

	center1 = center0

	## conver 3D points to sketch points
	center0 = threeD_to_sketch_points(center0,ndir)
	x0 = center0[0];	y0 = center0[1]

	## create blank sketch
	sketch1 = create_part_sketch(p,ndir,offset=offset,name='temp_sketch1')
	s = sketch1['sketch']
	datum_plane1 = sketch1['datum_plane']
	right_edge1 = sketch1['right_edge']
	side1 = sketch1['side']

	## draw lines
	if ID > 0:
		s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + ID/2.0, y0))
	s.CircleByCenterPerimeter(center=(x0, y0), point1=(x0 + OD/2.0, y0))

	## extrude
	p.SolidExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1,
	    sketchPlaneSide=side1, sketchOrientation=RIGHT, sketch=s, depth=abs(L),
	    flipExtrudeDirection=flip, keepInternalBoundaries=ON)

	print '--->Performed radial growth in',ndir,', ID=',ID,', OD=', OD

	return

function_labels['radial_pattern'] = 'instance','radius','pattern','angle','translate'
def radial_pattern(R,angle,center=(0,0),ndir='z'):
	## VER: 2017-08-02, v1.0  angle is the angle with the 水平轴（横坐标）

##	>>> radial_pattern(R=52,angle=-15)   ## 角度为负，说明x取正,y取负值
##	(50.228142, -13.45859)

	if is_location(center) == False:
		raise Exception('*** Please provide the center location')

	ndir = ndir.lower()
	center1 = center
	if len(center) == 3:
		if ndir == 'z':
			center1 = center[0],center[1]
		elif ndir == 'y':
			center1 = center[0],center[2]
		elif ndir == 'x':
			center1 = center[1],center[2]
		else:
			raise Exception('*** ndir should be in x,y, or z')

	x0,y0 = center1
	x1 = R*cosD(angle) + x0
	y1 = R*sinD(angle) + y0

	x1 = int6(x1)
	y1 = int6(y1)

	center2 = (x1,y1)
	if len(center) == 3:
		if ndir == 'z':
			center2 = x1,y1,center[2]
		elif ndir == 'y':
			center2 = x1,center[1],y1
		elif ndir == 'x':
			center2 = center[0],x1,y1

	return center2

def radial_select(part,axis_dir,axis_center=(),objs=None, Rmin=None,Rmax=None,R_range=(),D_range=(),obj_type='cell'):
	## VER: 2014-12-09, v1.2
	## 如有必要，请先用circular_divide()确保准确选择.
	## Example:
	## cells1 = radial_select(shaft,axis_dir='x',axis_center=(0,0,0),objs=cells, Rmin=63)
	## cells = radial_select(bearer,axis_dir='x', axis_center=(0,0,0), Rmax=bearer_D2/2.)  ## 如果是在GUI中运行此命令，则不能写成Rmax=bearer_D2/2，2的后面需要有.

	part = check_poi(part)

	if axis_dir not in ['x','y','z']:
		raise Exception('*** axis_dir should be x, y, or z')

	if axis_center in empty:
		center,axis = center_axis_of_poi(part)
		axis_center = center

	if is_location(axis_center) == False:
		raise Exception('*** axis_center is required.')

	if D_range not in empty:
		if type_of(D_range) in numerics:
			Rmin = Rmax = D_range/2
		elif type_of(D_range) in ['TUPLE','LIST'] and len(D_range) == 2:
			Rmin,Rmax = D_range[0]/2,D_range[1]/2
			if Rmax < Rmin:
				Rmin,Rmax = Rmax,Rmin

	if R_range not in empty:
		if type_of(R_range) in numerics:
			Rmin = Rmax = R_range
		elif type_of(R_range) in ['TUPLE','LIST'] and len(R_range) == 2:
			Rmin,Rmax = R_range
			if Rmax < Rmin:
				Rmin,Rmax = Rmax,Rmin

	if Rmin in empty:
		Rmin = 0

	if Rmax in empty:
		Rmax = 5000

	if objs in empty:
		if obj_type == 'cell':
			objs = part.cells
		elif obj_type == 'face':
			objs = part.faces
		elif obj_type == 'edge':
			objs = part.edges
		elif obj_type == 'vertice':
			objs = part.vertices

	objs1 = []
	x0,y0,z0 = axis_center
##	print 'axis_dir=',axis_dir
##	print len(objs)
	for obj in objs:
		x1,y1,z1 = obj.pointOn[0]
		if axis_dir == 'x':
			dist = round(sqrt((y1-y0)**2 + (z1-z0)**2),4)
		elif axis_dir == 'y':
			dist = round(sqrt((x1-x0)**2 + (z1-z0)**2),4)
		elif axis_dir == 'z':
			dist = round(sqrt((x1-x0)**2 + (y1-y0)**2),4)

##		print 'dist=',dist
		if Rmin <= dist <= Rmax:
			objs1.append(obj)

	print '--->',len(objs1),obj_type,'are selected. Rmin=',Rmin,', Rmax=',Rmax

	return objs1

##def radius_of_curvature(obj,pointOn=None,par=None):
##	## VER: 2014-07-15, v1.1
##	## get_radius(3 points) -> radius_of_curvature(one point) -> get_curvature(one point)
##
##	cur1 = get_curvature(obj=obj,par=par,pointOn=pointOn)
##	R = 'flat'
##	if cur1 == None:
##		R = 'flat'
##	elif 'radius' in cur1 and type_of(cur1['radius']) in numerics:
##		R = cur1['radius']
##	elif 'curvature1' in cur1 and 'curvature2' in cur1:
##		cv1 = cur1['curvature1']
##		cv2 = cur1['curvature2']
##		if is_numbers(cv1,cv2):
##			if PK(cv1,cv2) == 0:
##				R = 1/cv1
##			elif PK(cv1*cv2,0) == 0:   ## Gussian curvature
####				print fnln(),'cv1,cv2=',cv1,cv2
##				R = 'conical'   ## cylindrical is a special situation of conical.
##			else:
##				R = 'complex'
####		if and cur1['curvature1'] == cur1['curvature2']:
####		if type_of(cur1['curvature1']) in numerics:
####			R = 1/cur1['curvature1']
##
##	return R

def radius_of_geometry(arc):
	## VER: 2014-09-10, v1.0

	id = arc.id
	sketch = get_parent(arc)

	sketch1 = copy_sketch(sketch)
	sketch1 = _sketch(sketch1)

	arc = sketch1.geometry[id]
	curves = sketch1.geometry.values()

	curves = unselect(curves,arc)
	sketch1.delete(objectList = totuple(curves))

	part1 = sketch_to_wire(sketch1)
	radius = get_radius(_part(part1).edges[0])

	if is_number(radius) == False:
		raise Exception('*** Fail to get the radius')

	del _m.parts[part1]
	show_sketch(sketch)

	return radius


def railedge2frame_contact(type='tie',rail_inst=None,frame_inst=None,x=None,y=None,z=None):

	## VER: ('VER:2012-07-20, v1.0')

	if type == 'condition':
		if clamp2corner <= edge_tie_limit:
			type = 'tie'

	if rail_inst in empty:
		rail_inst = rail_A1

	if frame_inst in empty:
		frame_inst = frL_A1

	rail_inst = check_inst(rail_inst)
	frame_inst = check_inst(frame_inst)

	rail_edges = edge_select(rail_inst,x=x,y=y,z=z)
	dir1 = edge_dir(rail_edges[0])
	space = space_of_edges(rail_edges[0])

	if dir1 == 'x':
		faces = faces_of_cut(frame_inst,z=MIN,y=(space[2] - 1, space[2] + 1))
	elif dir1 == 'y':
		faces = faces_of_cut(frame_inst,z=MIN,x=(space[0] -1, space[0] + 1))

	if type == 'interact':
		line2surface_interact(edges=rail_edges,faces=faces)
	elif type == 'tie':
		line2surface_tie(edges=rail_edges,faces=faces)

	return

def random_sub_set(objs,num=4):
	## VER: 2012-12-19, v1.0，结果不一定刚好得到num个，也可能少。

	objs = tolist(objs)
	objs1 = randomize(objs)

	objs2 = []
	if len(objs1) > num:
		if num > 3:
			objs2 = objs1[:num-2]

		if objs[0] not in objs2:
			objs2.append(objs[0])

		if objs[-1] not in objs2:
			objs2.append(objs[-1])
	else:
		objs2 = objs1

	return objs2

def randomize(list1):
	## VER: 2011-04-25, v1.0  打乱序列，然后从中抽取前几个元素，达到随即抽取的目的。

	list1 = tolist(list1)
	shuffle(list1)

	return list1

def read_vars_from_file(file1=None):
	## VER: ('VER: 2013-12-31, v1.5')
	## The vars will be set as global vars.

	if file1 == None:
		file1 = var_file_full

	file_codes = read_lines(file1,remove_blank=False)

	vars = []
	_vars = {}

	lines_num = len(file_codes)

	i = -1
	while i < lines_num - 1:
		i = i + 1
		line1 = file_codes[i]
##		print ' '
##		print 'line1=',line1
		if len(line1) == 0:
			continue

		if line1.find('"""') >= 0 or line1.find("'''") >= 0:
			while i < lines_num - 1:
				i = i + 1
				line1 = file_codes[i]
				if line1.find('"""') != -1 or line1.find("'''") != -1:  ## 没有"""
					break

			continue

		loc1 = line1.find('=')
		loc2 = line1.find('#')
		if loc2 != 0 and loc1 > 0:
			var = line1[:loc1]
			var = var.strip()
			value_str = line1[loc1 + 1:]
			try:
##				print 'var=',var
##				print 'value=',value_str
				globals()[var] = eval(value_str)
				_vars[var] = eval(value_str)
##				add2my_globals(var)
			except SyntaxError:    ##分多行书写
				if i < lines_num - 1:
					for j in range(lines_num)[i+1:]:
						value_str = value_str + file_codes[j]
						try:
							globals()[var] = eval(value_str)
							_vars[var] = eval(value_str)
##							add2my_globals(var)
							i = j
							break
						except SyntaxError:
							pass

			vars.append(var)

##	print '--->Below global variables are read from',file1
##	print vars
##	print ' '

	return _vars

def read_rpy(lineno=-1):
	## VER: ('VER: 2012-08-01, v1.0')

	file1 = open(get_rpy()).readlines()
	line = file1[lineno][:-1].strip()

	return line

def real_files(names,ext):
	## VER: 2014-11-04, v1.0

	possibles = files_in_folder(ext)   ## possibles = files_in_folder('.inp')
	if possibles in empty:
		raise Exception('*** No inp files found in working directory.')

	possibles0 = copy.deepcopy(possibles)
	for i in range(len(possibles)):
		possibles[i] = possibles[i].lower()

	files = []
	if names in empty:
		names = [1]

	if names in ['all','ALL','*']:
		files = possibles
		found = True
	elif len(names) == 1 and type_of(names[0]) == 'INT':
		num = abs(names[0])
		possibles = sort_files_by_time(possibles)
		files = possibles[-num:]
		for i in range(len(files)):
			files[i] = files[i][0]
		found = True
	else:
		found = False

	if found == False:
		names = tolist(names)

		for i in range(len(names)):
			names[i] = names[i].lower()

		for name in names:
			if name in possibles:
				files.append(name)

		if files in empty:
			for name in names:
				for file1 in possibles:
					if file1.startswith(name) == True and file1 not in files:
						files.append(file1)

		if files in empty:
			for name in names:
				for file1 in possibles:
					if file1.endswith(name) == True and file1 not in files:
						files.append(file1)

	if files not in empty:
		newlist = []
		for file1 in possibles0:
			if file1.lower() in files:
				newlist.append(file1)
		files = newlist
		files = remove_repeated_items(files)

		print 'Found below files with extension',ext,':'
		for name in files:
			print name

	else:
		raise Exception('*** files not found.')

	return files

def real_insts(insts):
	## VER: 2012-10-09, v1.5

	insts = tolist(insts)

##	print 'type_of(insts)=',type_of(insts)
##	print fnln_fnln(),'insts=',insts

	if insts in empty:
		return []

	new_list = []
	if len(insts) > 0:
		for inst in insts:
			type1 = type_of(inst)
			if type1 == 'PINSTANCE':
				try:
					name = inst.name
				except:
					continue
				new_list.append(inst)

			elif type1 == 'STR':
				if inst in a.instances.keys():
					new_list.append(a.instances[inst])

##	print fnln_fnln(),'insts=',new_list

	return new_list

def RC_shape(obj,pointOn=None,par=None):
	## VER: 2014-12-20, v1.4
	## get_radius(3 points) -> RC_shape(one point)

## 也可以用part.getCurvature(list2sequence(obj))来获得curvature，此时，结果如下：
##	For an arc, the curvature is constant over the entire edge(arc是一个圆的一部分，即圆弧）, and equal to the inverse of the radius. 是半径的倒数，如：radius=2.5，则curvature=0.4
##	For a straight line, the curvature is constant and equal to 0.
## For a spline edge, the curvature varies over a range, and this methods computes the maximum.（该maximum可能为0)

##>>> edge.getCurvature(edge.pointOn[0])	## 有半径，但是只是代表改点处的半径，不代表该曲线就一定是圆形的。
##{'tangent': (-0.70710678118654, -0.707106781186555, -0.0), 'evaluationPoint': (469.582233047034, 1.76776695296634, -27.8), 'radius': 2.5, 'curvature': (0.282842712474622, -0.282842712474616, 0.0)}

##>>> get_curvature(e1,pointOn=(63.567694, 426.612388, 44.105148))
##{'tangent': (0.072827184316877, -0.727074880892728, 0.682684640811042), 'evaluationPoint': (63.5676946551372, 426.612388261358, 44.1051482084637), 'radius': 60.5816926820255, 'curvature': (0.00146376919200282, -0.0111761586668492, -0.0120590180709216)}
##>>>

	if type_of(obj) not in ['edges','faces']:
		raise Exception('******An edge or face is required.')

	obj_type = type_of(obj)

	if type_of(pointOn) == 'vertices':
		point = pointOn
		pointOn = point.pointOn[0]

	if type_of(par) in numerics and type_of(obj) != 'edges':
		raise Exception('edge object is required.')

	if par in empty and pointOn in empty:
		pointOn = obj.pointOn[0]

	please_check
	cur1 = None  ##平面的curvature=None，也就是完全度=0
	## 对于edge, 只要在任意一点求曲率失败，就说明该edge是直线。(??)
	if pointOn not in empty:
		try:
			cur1 = obj.getCurvature(point=pointOn)	## radius = curvature['radius']
		except:
			pass
	else:
		try:
			cur1 = obj.getCurvature(parameter=par)	## not applicable for a straight line ## radius = curvature['radius']
		except:
			pass

##	print fnln(),'cur1=',cur1
##例如：一条斜线的结果可能为：
##['RC_shape', 150] cur1= {'tangent': (0.0933407086930582, 0.995634226059288, -0.0),
##	 'evaluationPoint': (0.117187495643756, 6.2499999535334, 7.105427357601e-15),
##	'radius': 1.#INF, 'curvature': (0.0, 0.0, 0.0)}
##	print ' '

	## 以下为圆柱面的例子  ## f1是凹面，内表面，所以曲率为负。
##	cur1= {'evaluationPoint': (25.0, -214.01744, -48.787909),
##		'principalAxis1': (-1.0, -0.0, -0.0), 								'curvature1': 0.0, 		## 轴向为x方向
##		'principalAxis2': (0.0, -0.765901236218352, 0.642958238425483), 	'curvature2': -0.0156985871271585,  ## 负的曲率
##		'gaussianCurvature': -0.0}		## 高斯曲率为0表示各个地方的curvature1和curvature2均恒定。此时，为圆柱面。

##	 ## f2为凸面，外表面，所以曲率为正。
##	cur1= {'evaluationPoint': (25.0, -104.512841, 57.544764),
##		'principalAxis1': (1.0, 0.0, 0.0), 								'curvature1': 0.0, 		## 轴向为x方向
##		'principalAxis2': (0.0, 0.642958258343565, -0.765901219497534), 'curvature2': 0.0111731843575419, 	##正的曲率
##		'gaussianCurvature': 0.0}

##	>>> RC_shape(e2)  ## 半径为27.5的edge
##	(27.5, {'tangent': (-0.0, -0.382683422111021, 0.923879536758661), 'evaluationPoint': (295.0, -147.654312739137, 10.5237941080531),
##	'radius': 27.5, 'curvature': (-0.0, -0.0335956195184968, -0.0139157608040371)}, None)
##	>>>   ## x方向的曲率半径为0，说明该线平行于yoz平面。

##	>>> INFINITE > 5
##	True
##	>>>

##	R = 'flat'
	R = None
	shape = None
	if cur1 == None:
		R = 'flat'  ##
		shape = 'flat'
	elif 'radius' in cur1 and type_of(cur1['radius']) in numerics:  ## for edge only
		R = cur1['radius']
##		print fnln(),'R=',R
##		print fnln(),repr(R)
##		if R == INFINITE:
##			print INFINITE
		if abs(R) > 1e15:
			R = 'flat'
			shape = 'flat'
		else:
			shape = 'curved'
	elif 'curvature1' in cur1 and 'curvature2' in cur1:   ## for face only, not applicable for edge
		## 注意曲率值是有正负的。
		cv1 = abs(cur1['curvature1'])
		cv2 = abs(cur1['curvature2'])
		cv3 = abs(cur1['gaussianCurvature'])

		cv1,cv2 = _sort(cv1,cv2)
##		print fnln(),'(cv1,cv2=',(cv1,cv2)

		if is_numbers(cv1,cv2):
			if PK(cv1,cv2) == 0 and cv1 != 0:	## 相等
				R = 1/cv2   ## sphere
			elif cv3 == 0:
				R = 1/cv2
			elif PK(cv1*cv2,0) == 0:   ## Gussian curvature
				R = 'conical'   ## cylindrical is a special situation of conical.
			else:
				R = 'complex'

		if is_number(R) and R > 1e15:
			R = 'flat'

		## shape: flat, A, or U, or curved
		face = obj
		pointOn = face.pointOn[0]
		centroid = face.getCentroid()[0]   ## edge object has no centroid
		normal = face.getNormal(point=pointOn)

		x0,y0,z0 = pointOn
		x1,y1,z1 = centroid
		x2,y2,z2 = x0 + normal[0], y0 + normal[1], z0 + normal[2]

		dx1,dy1,dz1 = x1 - x0, y1 - y0, z1 - z0
		dx2,dy2,dz2 = x2 - x0, y2 - y0, z2 - z0

		xx, yy, zz = dx1*dx2, dy1*dy2, dz1*dz2

		list1 = [xx,yy,zz]
		max1 = max(abs(xx),abs(yy),abs(zz))
		for value in list1:
			if PK(abs(value),max1) == 0:
				if value > 1e-6:
					shape = 'U'
				elif value < -1e-6:
					shape = 'A'
				else:
					shape = 'curved'
				break

	return R, cur1,shape

RCS = RC_shape

def read_lines(file,line_nums=(),remove_blank=False):
	## VER: 2015-07-08, v1.2, can read one line or multy lines.

	if type_of(file) == 'FILE':
		name = file.name
		file.close()
		file = name

	file = search_file(file)
	if not os.path.isfile(file):
		raise Exception('*** No such file',repr(file))

	file_codes = open(file).readlines()

	line_nums = tolist(line_nums)
	if line_nums  in empty:
		line_nums =  range(len(file_codes))

	codes = []
	for i in line_nums:
		line1 = file_codes[i]
##		print 'line1[-1] =',repr(line1[-1])
		if repr(line1[-1]) == '\n':		## 回车换行
			line1 = line1[:-1]

		line1 = modify_string(line1,'\t','    ')	##
		line1 = line1.strip()       		 ## 去除首尾空格和行末的回车号,每一行都进行此操纵.而get_line_code()仅针对特定的行进行此操纵。
		if remove_blank == True:
			line1 = modify_string(line1,' ')		;please_check  ## 如果待读取的字符串中间有空格,则空格将被去除.
		codes.append(line1)

	if len(codes) == 1:
		codes = codes[0]

	return codes

def read_odbs(pattern,sort_by_time=True):

	## VER: ('VER: 2011-06-07, v1.0')	## patten是文件通配符，例如：C6*.odb。支持*,?通配符
	## res2file1<<<

	files = glob.glob(pattern)
	if sort_by_time == True:
		files1 = []
		for i in range(len(files)):
			for j in range(len(files))[i+1:]:
				time_i = os.stat(files[i]).st_ctime
				time_j = os.stat(files[j]).st_ctime
				if time_i > time_j:
					temp = files[i]
					files[i] = files[j]
					files[j] = temp

	for file1 in files:
		open_odb(file1)
		res2file1()
		close_odb(file1)

	return

def real_key(list1,key1):
	## VER: 2013-06-02, v1.0

	if type_of(list1) == 'STR' and type_of(key1) in ['TUPLE','LIST']:
		list1,key1 = key1, list1

	if type_of(key1) != 'STR':
		raise Exception('**** key name is required.')

	list1 = tolist(list1)

	name = None
	key1 = key1.upper()
	for name1 in list1:
		if name1.upper() == key1:
			name = name1
			break

	return name

def real_modifys(modifys):
	## VER: 2016-04-01, v1.2

##	>>> modifys=[('cooling','Amp_temp')]
##	>>> real_modifys(modifys)
##	[('cooling', 1, 'Amp_temp')]
##	>>>
##	>>> modifys=('cooling','Amp_temp')
##	>>> real_modifys(modifys)
##	[('cooling', 1, 'Amp_temp')]
##	>>>

## 对场的修改：
##		modifys = real_modifys(modifys)
##		for item in modifys:
##			stepname,mag1,amp1 = item
##			if amp1 in empty:
##				_m.predefinedFields[name].setValuesInStep(stepName=stepname, magnitudes=(mag1,))
##			else:
##				_m.predefinedFields[name].setValuesInStep(stepName=stepname, magnitudes=(mag1,),amplitude=amp1)

##对BC的修改：
##		modifys = real_modifys(modifys)
##		for item in modifys:
##			stepname,mag1,amp1 = item
##			if amp1 in empty:
##				_m.boundaryConditions[name].setValuesInStep(stepName=stepname, magnitude=mag1)
##			else:
##				_m.boundaryConditions[name].setValuesInStep(stepName=stepname, magnitude=mag1,amplitude=amp1)

	modifys1 = []
	modifys = totable(modifys)
	for item in modifys:
		mag1 = 1
		amp1 = None
		if len(item) == 2:
			stepname, temp1 = item
			if is_number(temp1):
				mag1 = temp1
			elif is_amplitude(temp1):
				amp1 = temp1
			elif type_of(temp1) in ['TUPLE','LIST'] and len(temp1) == 2:
				mag1,amp1 = temp1
				if is_number(mag1) == False or is_amplitude(amp1) == False:
					raise Exception('*** Errr input of magnitude and amplitude.')

		elif len(item) == 3:
			stepname,mag1,amp1 = item
			if is_number(mag1) == False or is_amplitude(amp1) == False:
				raise Exception('*** Errr input of magnitude and amplitude.')
		else:
			raise Exception('*** Fail to get the stepname from modifys')

		stepname = check_step(stepname)

		if amp1 not in empty and is_amplitude(amp1) == False:
			raise Exception('*** Error amplitude')

		modifys1.append((stepname,mag1,amp1))

	return modifys1

def real_objs(objs,p=None):
	## VER: 2013-06-12, v1.1

	if type_of(objs) in ['PART','PINSTANCE']:
		objs,p = p,objs

	if objs in empty:
		return []

	if p not in empty:
		p = check_pias(p)

	if type_of(objs) == 'STR' and p not in empty:
		objs = set2objs(p,objs)

	objs = tolist(objs)

	return objs

def real_odb_insts(insts):
	## VER: 2012-10-09, v1.1

	insts = tolist(insts)

	if insts in empty:
		return []

	new_list = []
	if len(insts) > 0:
		for inst in insts:
			type1 = type_of(inst)
			if type1 == 'ODBINSTANCE':
				try:
					name = inst.name
				except:
					continue
				new_list.append(inst)

			elif type1 == 'STR':
				if inst.upper() in oa.instances.keys():
					new_list.append(oa.instances[inst.upper()])

	return new_list


def real_parts(parts):

	## VER: ('VER: 2012-03-31,v1.7')

	parts = tolist(parts)

	if parts in empty:
		return []   ;please_check

	vpnow = get_vpnow()
	new_list = []
	if len(parts) > 0:
		for part in parts:
			type1 = type_of(part)
			if type1 == 'PART':
				try:
					name = part.name
				except:
					continue
				new_list.append(part)

			elif type1 == 'STR':
				if part in _m.parts.keys():
					new_list.append(_m.parts[part])
				elif type_of(vpnow.displayedObject) == 'ODB':
					if part in odb.parts.keys():
						new_list.append(odb.parts[part])

	return new_list

def real_shrinkage(shrinkage=None,offset=-0.3, C1=0.024,th=14.46,low=0.02,high=0.98):
	## VER: 2016-09-14, v1.1
	## reference: average_shrinkage()

##	>>>average_shrinkage(for_green=False)   ## refresh()时，用此数据。为LE云图的中间值
##	(-0.2007, 14.13, 2.81)
##	>>>average_shrinkage(for_green=True)
##	(0.1901, 14.13, 2.81)
##	>>>real_shrinkage()
##	(0.1901, 14.13, 2.81)

##	>>> real_shrinkage(shrinkage=20.77,offset=-0.4, C1=2.757, th=14.15)
##	['shrinkage_to_density_with_PEG', 18657] relative density= 0.511458757409
##	0.1934   ## Exp L=25.7, FEM=25.80 (BA_A0262)
##	>>> real_shrinkage(shrinkage=20.41,offset=-0.3, C1=2.757, th=14.15)
##	['shrinkage_to_density_with_PEG', 18657] relative density= 0.518462280143
##	0.1934   ## Exp L=25.7, FEM=25.90  (B9_A0262)
##	>>>
##	>>> real_shrinkage(shrinkage=20.05,offset=-0.2, C1=2.757, th=14.15)
##	['shrinkage_to_density_with_PEG', 18657] relative density= 0.525529446721
##	0.1934    ## Exp L=25.7, FEM=26.0  (BB_A0262)
##	>>>

	if shrinkage in empty:
		shrinkage,th,C1 = average_shrinkage(C1=C1,th=th,low=low,high=high,for_green=False)

	shrinkage1 = abs(shrinkage)
	density1 = shrinkage_to_density_with_PEG(shrinkage=shrinkage1, C1=C1, th=th)  ## 7.2371
##	density = density - offset  ## 7.6371 for offset=-0.4
	density2 = density1 + abs(offset)
	if density2 > 8:
		density2 = int(density2*10)/10

	shrinkage2 = density_with_PEG_to_shrinkage(density=density2, C1=C1, th=th)

	print ' '
	print fnln(),'th=',th,', C1=',C1
	print fnln(),'offseted density=',(density1,round(density1/th,3)), ', corresponding shrinkage=',shrinkage1
	print fnln(),'initial density (no offset,green part)=',(density2,round(density2/th,3)), ', corresponding shrinkage=',shrinkage2

	return shrinkage2, th, C1

def real_space(poi,x=None,y=None,z=None, space=(), base_x=None, base_y=None, base_z=None, dx=0, dy=0, dz=0,
	thx=None, thy=None, thz=None, poiRefX=(),poiRefY=(),poiRefZ=(), ref_locx=(),ref_locy=(),ref_locz=(),
	addRP=False,empty2space=True,inbound=None,PRx=None,PRy=None,PRz=None):
	## VER: 2016-10-21, v1.7，empty2space = False
	## base_x: x方向尺寸标注的基准线
	## base_y: y方向尺寸标注的基准线
	## base_z: z方向尺寸标注的基准线
	## poiRefX, poiRefY, poiRefZ都是一个范围。

	## empty2space = True: batch_divide(), divide(), hex_cut(), create_block(), node_line(),
	## empty2space = False: edge_select(), faces_of_cut(), face_select(),

##	xline1 = create_block(frL,x=(0,-top_lip_width),z=(0,-top_lip_thick - top_adhesive_thick),y=(-module_top_length/2,module_top_length/2))
##	xline2 = create_block(frL,x=(0,-bot_lip_width),PRz=(xline1[4], -lam_thick, -bot_adhesive_thick - bot_lip_thick))

##	>>> real_space('frL',PRx=(-legs_span,inner_wall_thick))
##	(-14.3, -13.0, -820.0, 820.0, -35.0, 0.0)
##	>>>

	poi = check_pia(poi)

	if PRx not in empty:
		poiRefX = PRx
	if PRy not in empty:
		poiRefY = PRy
	if PRz not in empty:
		poiRefZ = PRz

	if space not in empty and len(space) == 6:
		x = space[0:2]
		y = space[2:4]
		z = space[4:6]
	else:  ## 如果提供了poiRefX，则原来的x的值将被忽略。
##		print fnln(),'x=',x
		if len(poiRefX) == 2:
			base_x,thx = poiRefX
		elif len(poiRefX) == 3:
			base_x,dx,thx = poiRefX   ## base_x + dx to get the real base_x
		elif len(ref_locx) == 2:
			x, dx = ref_locx

		if len(poiRefY) == 2:
			base_y,thy = poiRefY
		elif len(poiRefY) == 3:
			base_y,dy,thy = poiRefY   ## 例如：base_y是上一个create_block()的一条边，该边偏移dy后到新的create_block()的一条边，利用thy继续获得block的另外一条边
		elif len(ref_locy) == 2:
			y,dy = ref_locy

		if len(poiRefZ) == 2:
			base_z, thz = poiRefZ
		elif len(poiRefZ) == 3:
			base_z, dz, thz = poiRefZ
		elif len(ref_locz) == 2:
			z, dz = ref_locz

##		print fnln(),'x=',x

		## thx, thy, thz可正，可负。
		## poiRefX被转化为了base_x和thx,并更新x，例如原来x=(MIN,MAX)
		if thx not in empty:
			x = (0, thx)   ## 这里的x是在base_x基础上的x，不是一个绝对的x
		if thy not in empty:
			y = (0, thy)
		if thz not in empty:
			z = (0, thz)

##		print fnln_fnln(),(x,y,z)
##		print fnln(),'x=',x
		x,y,z = real_xyz(poi,x,y,z, empty2space = empty2space)
##		x,y,z = real_xyz(poi,x,y,z)   ## None, value or defined space
##		print fnln(),'x=',x
##		print fnln_fnln(),(x,y,z)
##		raise Exception

##	stop1()
	x1,x2,y1,y2,z1,z2 = tospace(x,y,z)  ## if x == None, then x1=-1e6, x2=1e6
##	print fnln(),'=====x1,x2,y1,y2,z1,z2=',[x1,x2,y1,y2,z1,z2]
##	stop1()

	base_x, base_y, base_z = real_xyz(poi,base_x,base_y,base_z)
	if is_empties(base_x,base_y,base_z) == False:
		addRP = False

	## 确定base_x, base_y, base_z，如果有参考点且addRP=True，就base on 参考点
	if addRP == True:
		x0,y0,z0 = RPxyz(poi)  ## base on RP
	else:
		x0=y0=z0=0		## absolute

	if base_x in empty:
		base_x = x0   ## 如果addRP=False, 则base_x=0
	if base_y in empty:
		base_y = y0
	if base_z in empty:
		base_z = z0

##	print fnln(),'base_x,dx,x1=',(base_x,dx,x1)
	x = base_x + dx + x1, base_x + dx + x2
	y = base_y + dy + y1, base_y + dy + y2
	z = base_z + dz + z1, base_z + dz + z2

	x1,x2 = sort(x)
	y1,y2 = sort(y)
	z1,z2 = sort(z)

##	print fnln(),'=====x1,x2,y1,y2,z1,z2=',[x1,x2,y1,y2,z1,z2]
##	stop1()

	return x1,x2,y1,y2,z1,z2

def real_xyz_in_space(space,empty2space=False, **vars):
	## VER: 2016-04-05, v1.1

	if type_of(space) not in ['TUPLE','LIST']:
		try:
			poi = check_poi(space)
			space = poi_space(poi)
		except:
			pass
	elif type_of(space[0]) in ['vertices','edges','faces','cells']:
		space = objs_space(space)

	if type_of(space) not in ['TUPLE','LIST']:
		raise Exception('*** a space is required.')

	datas = []
	if 'x' in vars.keys():
		x = vars['x']
		x = real_value_in_range(space[0:2], x, empty2space=empty2space)
		datas.append(x)

	elif 'ref_x' in vars.keys():
		ref_x = vars['ref_x']
		x = real_value_in_range(space[0:2], ref_v=ref_x, empty2space=empty2space)
		datas.append(x)

	if 'y' in vars.keys():
		y = vars['y']
		y = real_value_in_range(space[2:4], y, empty2space=empty2space)
		datas.append(y)
	elif 'ref_y' in vars.keys():
		ref_y = vars['ref_y']
		y = real_value_in_range(space[2:4], ref_v=ref_y, empty2space=empty2space)
		datas.append(y)

	if 'z' in vars.keys() and len(space) == 6:
		z = vars['z']
		z = real_value_in_range(space[4:6], z, empty2space=empty2space)
		datas.append(z)
	elif 'ref_z' in vars.keys() and len(space) == 6:
		ref_z = vars['ref_z']
		z = real_value_in_range(space[4:6], ref_v=ref_z, empty2space=empty2space)
		datas.append(z)

	if len(datas) == 1:
		datas = datas[0]

	return datas

def real_to_sketch_loc(loc,ndir):
	## VER: 2016-07-08, v1.1
	## 可能有误，慎用。其实需要控制datum plane的side

	if type_of(ndir) == 'STR':
		ndir = ndir.lower()

	if ndir not in ['x','y','z']:
		raise Exception('*** ndir should be in x,y,or z')

	if is_numbers(loc) == False:
		raise Exception('*** loc is required.')

	if len(loc) == 3:
		x1,y1,z1 = loc
		if ndir == 'x':
			loc = (y1,z1)   ;please_check
		elif ndir == 'y':
			loc = (x1,z1)
		elif ndir == 'z':
			loc = (x1,y1)

	if len(loc) != 2:
		raise Exception('*** len(loc) should be 2')

	H1,V1 = loc
	if ndir == 'z':
		H,V = H1,V1
	elif ndir == 'y':   ## 正确草图视图：xoz, x向右，z向上，Y向里。
		H,V = H1,-V1
	elif ndir == 'x':
		H,V = H1,V1

	return H,V

def real_value_in_range(range1, v=None, ref_v=None, empty2space=False):
	## VER: 2016-06-27, v1.2

	## Example:
##	>>> range1 = [3,7]
##	>>> real_value_in_range(range1,ref_v=(MIN,1))
##	[3.0, 4.0]
##	>>> real_value_in_range(range1,ref_v=(MID,1))
##	[5.0, 6.0]
##	>>> real_value_in_range(range1,ref_v=(MID,-1))
##	[4.0, 5.0]
##	>>> real_value_in_range(range1,ref_v=(MAX,-1))
##	[6.0, 7.0]
##	>>>

	if type_of(range1) not in ['TUPLE', 'LIST']:
		raise Exception('*** a range is required.')

	if len(range1) != 2:
		raise Exception('*** a range is required.')

	if type_of(ref_v) in ['TUPLE','LIST']:
		if len(ref_v) == 2:
			base,inc = ref_v
			if base in [MAX,'MAX','max']:
				base = range1[1]
			elif base in [MIN,'MIN','min']:
				base = range1[0]
			elif base in [MID,'MID','mid']:
				base = (range1[0] + range1[1])/2.

			if is_number(base) == False:
				raise Exception('*** base should be a number')

			if is_number(inc) == False:
				raise Exception('*** inc should be a number.')

			v = sorted([base, base + inc])
		else:
			raise Exception('*** base and inc are required.')

	elif ref_v not in empty and v in empty:
		v = ref_v

	if v in empty:
		if empty2space == True:
			v = range1
		return v

	if v in [MAX,'MAX','max']:
		v = range1[1]
	elif v in [MIN,'MIN','min']:
		v = range1[0]
	elif v in [MID,'MID','mid']:
		v = (range1[0] + range1[1])/2.
	elif v == 'MAX1':
		v = range1[1] - _nearby
	elif v in ['MAXp','MAX+']:	## MAX+
		v = range1[1] + _nearby
	elif v == 'MIN1':
		v = range1[0] + _nearby
	elif v in ['MINp','MIN+']:
		v = range1[0] - _nearby

	if type_of(v) in numerics:
		v = round(v,6)
		if v < _min:
			v = _min
		elif v > _max:
			v = _max

	elif type_of(v) in ['TUPLE','LIST'] and v not in empty:
		type0 = type_of(v)
		v = tolist(v)
		for i in range(len(v)):
			v[i] = real_value_in_range(range1,v=v[i])

		if type0 == 'TUPLE':
			v = totuple(v)

	else:
		raise Exception('*** fail to get v by ' + repr(v))

	return v

def real_xyz(p=None,x=None,y=None,z=None,space=(),poiRefX=(), poiRefY=(),poiRefZ=(), empty2space=False,Xonly=False,Yonly=False,Zonly=False):
	## VER: ('VER: 2015-12-07, v2.6')
	## Example: x,y,z = real_xyz(p,x=MAX,y='RP')
	## reference: real_xyz_in_space(), real_value_in_range()

	## example:
##	real_xyz(powder_s,x=0,y=None,z=(MAX,MAX,-0.15))   ## 结果: (0, None, [-0.15, 0.0])
##	x,y,z = real_xyz(p,x,y,z,space=space,poiRefX=poiRefX,poiRefY=poiRefY,poiRefZ=poiRefZ)

	if is_numbers(space):
		x=space[0:2]
		y=space[2:4]
		z=space[4:6]

	if Xonly:
		result = real_coord(p=p, coord=x, span=poiRefX, dir1='x', space=space, empty2space = empty2space)
	elif Yonly:
		result = real_coord(p=p, coord=y, span=poiRefY, dir1='y', space=space, empty2space = empty2space)
	elif Zonly:
		result = real_coord(p=p, coord=z, span=poiRefZ, dir1='z', space=space, empty2space = empty2space)
	else:
		determined = False
		xok = yok = zok = False
		if is_numbers(x):
			xok = True
		elif x in empty and empty2space == False and poiRefX in empty:
			x = None
			xok = True

		if is_numbers(y):
			yok = True
		elif y in empty and empty2space == False and poiRefY in empty:
			y = None
			yok = True

		if is_numbers(z):
			zok = True
		elif z in empty and empty2space == False and poiRefZ in empty:
			z = None
			zok = True

		if xok == yok == zok == True:
			determined = True

		if determined == False:
			if space in empty:
				space = poi_space(p)

##			print fnln(),'z=',z
			x = real_coord(p=p, coord=x, span=poiRefX, dir1='x', space=space, empty2space = empty2space)
			y = real_coord(p=p, coord=y, span=poiRefY, dir1='y', space=space, empty2space = empty2space)
			z = real_coord(p=p, coord=z, span=poiRefZ, dir1='z', space=space, empty2space = empty2space)

		result = (x,y,z)

	return result

def real_x(p=None,x=None,empty2space=False,space=(),poiRefX=()):
	## VER: 2015-06-16, v1.1

	result = real_coord(p=p, coord=x, dir1='x', space=space, empty2space = empty2space,span=poiRefX)

	return result

def real_y(p=None,y=None,empty2space=False,space=(),poiRefY=()):
	## VER: 2015-06-16, v1.1

##	>>> real_y('p1',poiRefY=(MIN,1))
##	[-8.140622, -7.140622]
##	>>> _ymin('p1')
##	-8.140622
##	>>>

	result = real_coord(p=p, coord=y, dir1='y', space=space, empty2space = empty2space, span=poiRefY)

	return result

def real_z(p=None,z=None,empty2space=False,space=(),poiRefZ=()):
	## VER: 2015-06-16, v1.1

	result = real_coord(p=p, coord=z, dir1='z', space=space, empty2space = empty2space, span=poiRefZ)

	return result

def real_coord(p=None,coord=None,span=(),empty2space=False,space=(),dir1='x',pspace=()):
	## VER: 2017-05-27, v1.5, space mean space of poi, not (-1e6, 1e6)
	## e.g,
	## coord = real_z(powder_s,coord=(MAX,MAX, -0.15))   ## 相当于coord = real_z(powder_s,z=(MAX,MAX-0.15)), 但又不能这么书写。

##>>> x = real_coord(powder,span=(MAX,-0.1),dir1='x')
##>>> x
##[4.275, 4.375]
##>>>

##	>>> real_coord(powder,coord=MIN1,dir1='z')
##	0.0005
##	>>>

	if type_of(coord) in numerics:
		return coord

	p = check_poi(p)

	if type_of(dir1) == 'STR':
		dir1 = dir1.lower()

	if dir1 == 'x':
		dir1 = 0
	elif dir1 == 'y':
		dir1 = 1
	elif dir1 == 'z':
		dir1 = 2

	if dir1 not in [0,1,2]:
		raise Exception('*** dir1 should be 0,1,2 or x,y,z')

##	if type_of(coord) == 'STR':
##		coord = coord.lower()

	if space in empty:
		space = poi_space(p)
	x1,x2,y1,y2,z1,z2 = space

	if dir1 == 0:
		loc1,loc2 = x1,x2
	elif dir1 == 1:
		loc1,loc2 = y1,y2
	else:
		loc1,loc2 = z1,z2

	if _len(span) > 0:
		if len(span) == 2:
			base,thick = span
			if is_number(thick) == False:
				raise Exception('*** thick should be a detailed number for a reference range.')

			base = real_coord(p,coord=base,dir1=dir1)
			coord = _sort(base, base + thick)
		elif len(span) == 3:
			base,dx,thick = span
			base = real_coord(p,coord=base,dir1=dir1)
			coord = _sort(base + dx, base + dx + thick)
			coord = _sort(base, base + thick)
	else:
		if coord == CENTROID:
			if centroid in empty:
				xc,yc,zc = poi_centroid(p)

			if dir1 == 0:
				cent = xc
			elif dir1 == 1:
				cent = yc
			else:
				cent = zc

		please_check
	##	if coord == _min:
	##		coord = MIN
	##	elif coord == _max:
	##		coord = MAX

	##	stop1()

		if type_of(coord) in ['FLOAT','INT']:
			coord = round(coord,6)
			if coord < _min:
				coord = _min
			elif coord > _max:
				coord = _max

	##		if empty2space == True:
	##			if coord <= _min:
	##				coord = loc1
	##			elif coord >= _max:
	##				coord = loc2
		elif coord in empty and empty2space == True:
			coord = [loc1,loc2]
		elif str(coord).upper() == 'MIN':
			coord = loc1
		elif str(coord).upper() == 'MAX':
			coord = loc2
		elif str(coord).upper() == 'MIN1':
			coord = loc1 + _nearby
		elif str(coord).upper() in ['MINP','MIN+']:  ## 比最小值还要小
			coord = loc1 - _nearby
		elif str(coord).upper() == 'MAX1':
			coord = loc2 - _nearby
		elif str(coord).upper() in ['MAXP','MAX+']:  ## 比最大值还要大
			coord = loc2 + _nearby
		elif str(coord).upper() == 'MID':
			coord = (loc1 + loc2)/2
		elif coord == CENTROID:
			coord = cent
		elif str(coord).upper() == 'RP':
			coord = RPz(p)
		elif type_of(coord) in ['TUPLE','LIST'] and coord not in empty:
			coord = tolist(coord)   ## tuple will be changed to list
			for i in range(len(coord)):
				element = coord[i]
				if str(element).upper() == 'MIN':
					element = loc1
				elif str(element).upper() == 'MAX':
					element = loc2
				elif str(element).upper() == 'MIN1':
					element = loc1 + _nearby
				elif str(element).upper() in ['MINP','MIN+']:
					element = loc1 - _nearby
				elif str(element).upper() == 'MAX1':
					element = loc2 - _nearby
				elif str(element).upper() in ['MAXP','MAX+']:
					element = loc2 + _nearby
				elif str(element).upper() == 'MID':
					element = (loc1 + loc2)/2
				coord[i] = round(element,6)

				if coord[i] < _min:
					coord[i] = _min
				elif coord[i] > _max:
					coord[i] = _max

			if len(coord) > 2:
				coord[1] = coord[1] + coord[2]
				coord = coord[:2]
				coord = sort(coord)

	return coord

def real_pshape_and_ptype(pshape='3D',ptype='deformable',symmetric=False):
	## VER: 2014-06-12, v1.2

	pshape = totext(pshape)
	pshape = pshape.upper()
	if 'SYM' in pshape or symmetric == True:
		pshape = AXISYMMETRIC
	else:
		if pshape in ['3D', 'THREE_D']:
			pshape = THREE_D
		elif pshape in ['2D', 'TWO_D','PLANAR']:
			pshape = TWO_D_PLANAR
		else:
			raise Exception('**** Error pshape = ' + pshape)

	ptype = totext(ptype)
	ptype = ptype.lower()
	if 'deformable' in ptype:
		ptype = DEFORMABLE_BODY
	elif 'disc' in ptype:
		ptype = DISCRETE_RIGID_SURFACE	## need to mesh and create reference point on it.Can convert to deformable body
	elif 'anal' in ptype:
		ptype = ANALYTIC_RIGID_SURFACE	## need to create reference point on it, does not need to mesh.Can convert to deformable body
													## sketch can only compose of arcs (less than 180 degree for each) and lines
	else:
		raise Exception('**** Error ptype = ' + ptype)

	return pshape, ptype

function_labels['open_dir'] = 'path','windows','directory','file'
def open_dir(dir1):
	## VER: 2016-09-29, v1.0

##	>>> path1 = 'Z:/A0271-A0274-USM_insert_B106_B109/sintering/batch2/images/Max Principal'
##	>>> open_dir(path1)
##	>>>

	path = real_dir(dir1,tilt='left')
	os.system('explorer.exe ' + path)

	return

function_labels['is_file_path'] = 'file','path','dir','root','open'
def is_file_path(str1):
	## VER: 2017-05-10, v1.0

##	>>> os.path.isfile('E:/FEM/GEA/BH_A0259_GEA_gap20um_tipnochamfer.odb')
##	True

	return os.path.isfile(str1)

function_labels['real_dir'] = 'path','windows','directory','file','folder'
def real_dir(dir1,tilt='right'):
	## VER: 2015-07-17, v1.4. 只要不用os.command()，右斜杠都是适用的。
	## 直接提供路径时，需要在路径的坐标加r，声明没有转义，否则很可能出错。
	## Example: real_dir(r"E:\FEM\194_compaction\py") = 'E:/FEM/194_compaction/py'
	## 			real_dir("E:\FEM\194_compaction\py") = 'E:/FEM\x0194_compaction/py' (Error)
	##文件名与路径之间用'/'相连。
	##也适用于文件名。此时文件名后面不能有'/'。
	## 为了统一起见，real_path(路径)的结果最后一位都不是'/'
	## 对于Visual Basic, 路径斜杠tilt='left'

##	>>> real_dir('D:///text1.txt')
##	'D:/text1.txt'
##	>>>

##	>>> path = r'T:\Modelling'
##	>>> path
##	'T:\\Modelling'
##	>>>
##	>>> os.system("explorer.exe %s" % path)  ## 成功
##	1
##	>>> os.system('explorer.exe ' + path)   ## 成功
##	1
##	os.system("explorer.exe C:/JYQ/_desktop")   ## 失败

	## 路径的判断
##	>>> dir1 = 'E:/FEM/A0241_Cap_Eugene/py'
##	>>> os.path.isdir(dir1)
##	True
##	>>> os.path.isdir(dir1+'/')  ##路径后面带或不带'/'都是正确的
##	True
##	>>>

	## 创建新文件夹:带创建的文件夹名字以'/'结尾也是正确的。
##	>>> dir1
##	'E:/FEM/A0241_Cap_Eugene/py'
##	>>> os.makedirs(dir1+'/test1/')  ##成功
##	>>> os.makedirs(dir1+'/test2')  ##成功
##	>>>

	if type_of(dir1) != 'STR':
		raise Exception('**** direction is required.')

	dir1 = modify_string(dir1,'\\', '/')
	dir1 = modify_string(dir1,'//', '/')
	if dir1[-1] == '/' and dir1[-2] != ':':
		dir1 = dir1[:-1]

	## "E:/"是一个绝对路径，而E:是一个不完整路径，表示E盘的当前路径，真正代表的路径可能是"E:/FEM/A0242_sintering_simple"

	if dir1[0] == '/':
		cur = os.getcwd().upper()
		dir1 = cur[:2] + dir1  ## 补足盘符，例如E:/

	## 如果不转使用\\而是使用/，则os.system ("copy %s %s" % (sourceF, targetF)) 不支持。

	if tilt == 'left':
		dir1 = modify_string(dir1,'/','\\')   ## 与window os的表述一致，路径被windows命令认可(向右倾斜不认可，但被python认可)。(易出错)

##	print dir1.__repr__()  ## 会使每个\变成\\，所以\\变成\\\\
##	print dir1.__str__()

	return dir1

def real_xy_sketch(sketch,  H=None,V=None,x=None, y=None, loc=(),partx=None, party=None, partz=None, ndir=None,
	empty2space=False, Honly=False, Xonly=False, Vonly=False, Yonly=False):
	## VER: ('VER: 2013-11-01, v1.4'). H=horizon, 水平轴；V=vertical, 竖直轴。
	## 当ndir='x'时，H代表Y轴坐标，V代表Z轴坐标。
	## 当ndir='y'时，H代表X轴坐标，V代表Z轴坐标。
	## 当ndir='z'时，H代表X轴坐标，V代表Y轴坐标。
	## Example: H = real_xy_sketch(sketch,H=MAX,Honly=True)

	## 例如：loc = real_xy_sketch(sketch,loc=(MAX,0))
	##       x,y = real_xy_sketch(sketch,loc=(MIN,MIN))

##>>> real_xy_sketch('sk_nib',y=MIN)
##(None, -2.041)
##>>> real_xy_sketch('sk_nib')
##(None, None)
##>>>

	determined = False
	_nearby = 1e-3		;changing

	if Xonly == True:
		Honly = True

	if Yonly == True:
		Vonly = True

	if is_empties(partx,party,partz) == False and ndir not in ['x','y','z']:
		if partx not in empty and party not in empty and partz in empty:
			ndir = 'z'
		elif partx not in empty and party in empty and partz not in empty:
			ndir = 'y'
		elif partx in empty and party not in empty and partz not in empty:
			ndir = 'x'

		if ndir not in ['x','y','z']:
			raise Exception("**** ndir of sketch is required.")

	if loc not in empty:
		H,V = loc

	if x not in empty:
		H = x

	if y not in empty:
		V = y

##	print fnln_fnln(),'x=',x
##	print fnln_fnln(),'H,V=',(H,V)

	if is_empties(H,V) == True and is_empties(partx,party,partz) == False:
		if ndir == 'x':
			H = party
			V = partz
		elif ndir == 'y':
			H = partx
			V = partz
			reverse = True
		elif ndir == 'z':
			H = partx
			V = party

	if empty2space == False:
		if type_of(H) in ['INT','FLOAT','None'] and type_of(V) in ['INT','FLOAT','None']:
			determined = True
##			return H,V
	else:
		if type_of(H) in numerics and type_of(V) in numerics:
			determined = True
##			return H,V

	if determined == False:
		reverse = False

##		print fnln_fnln(),'H=',H
		x1,x2,y1,y2 = space_of_sketch(sketch)		## 模型复杂时比较费时
	##	show_sketch(sketch)

		if type_of(H) in ['FLOAT','INT']:
			H = round(H,6)
		elif H in empty and empty2space == True:
			H = [x1,x2]
		elif H in ['min',MIN,'MIN']:
			H = x1
		elif H in ['min1','MIN1']:
			H = x1 + _nearby
		elif H in ['MINp','MIN+']:
			H = x1 - _nearby
		elif H in ['max',MAX,'MAX']:
			H = x2
		elif H in ['max1','MAX1']:
			H = x2 - _nearby
		elif H in ['MAXp','MAX+']:
			H = x2 + _nearby
		elif H in ['mid','MID']:
			H = (x1 + x2)/2
		elif type_of(H) in ['TUPLE','LIST'] and H not in empty:
			H = tolist(H)
			print fnln_fnln(),'H=',H
			for i in range(len(H)):
				element = H[i]
				if element in ['min',MIN,'MIN']:
					element = x1
				elif element in ['min1','MIN1']:
					element = x1 + _nearby
				elif element in ['MINp','MIN+']:
					element = x1 - _nearby
				elif element in ['max',MAX,'MAX']:
					element = x2
				elif element in ['max1','MAX1']:
					element = x2 - _nearby
				elif element in ['MAXp','MAX+']:
					element = x2 + _nearby
				elif element in ['mid','MID']:
					element = (x1 + x2)/2
				H[i] = round(element,6)

		if type_of(V) in ['FLOAT','INT']:
			V = round(V,6)
		elif V in empty and empty2space == True:
			V = [y1,y2]
		elif V in ['min',MIN]:
			V = y1
		elif V in ['min1','MIN1']:
			V = y1 + _nearby
		elif V in ['MINp','MIN+']:
			V = y1 - _nearby
		elif V in ['max',MAX]:
			V = y2
		elif V in ['max1','MAX1']:
			V = y2 - _nearby
		elif V in ['MAXp','MAX+']:
			V = y2 + _nearby
		elif V in ['mid','MID']:
			V = (y1 + y2)/2
		elif type_of(V) in ['TUPLE','LIST'] and V not in empty:
			V = tolist(V)
			for i in range(len(V)):
				element = V[i]
				if element in ['min',MIN]:
					element = y1
				elif element in ['min1','MIN1']:
					element = y1 + _nearby
				elif element in ['MINp','MIN+']:
					element = y1 - _nearby
				elif element in ['max',MAX]:
					element = y2
				elif element in ['max1','MAX1']:
					element = y2 - _nearby
				elif element in ['MAXp','MAX+']:
					element = y2 + _nearby
				elif element in ['mid','MID']:
					element = (y1 + y2)/2
				V[i] = round(element,6)

		if reverse == True:
			if type_of(V) in numerics:
				V = -V
			elif type_of(V) in ['TUPLE','LIST']:
				V = [-V[1],-V[0]]
				V.sort()

##	print 'Honly=',Honly
	if Honly:
		result = H
	elif Vonly:
		result = V
	else:
		result = (H,V)

	return result

def record_time(benchmark=1,text=''):

	## VER: ('VER: 2012-08-16, v1.0')

	global run_times

	_time2 = time.time()
	cae_time = round((_time2 - start_time)/60,2)

	if text in empty:
		text = caller_fnln()

	run_times.append((text,cae_time,benchmark))

	print ' '
	print 'run_times='
	print run_times

	return

def rect_bolt(partname,inst_name='',csys_KP='',ndir='z',center0=(0,0,0),size=(12,24,5),ext=0,rotate='no'):
	## VER: 2010-02-24

	bolt1,bolt1A = half_bolt(partname,inst_name,csys_KP=csys_KP,ndir=ndir,center0=center0,size=size,rotate=rotate)
	sign = 1
	if rotate == 'yes':
		sign = -1
	if ext > 0:
		out1,out1A = bolt_outside('out1','out1A',ndir=ndir,center0=center0,D=size[0],
			rectL = size[1] + 2*ext,thick=sign*abs(size[2]))
		merge_instances(partname=partname, insts=[bolt1A,out1A],RP=RPxyz(bolt1), csys_KP=KPxyz(csys_KP))
##		del _m.parts['out1']
		del_parts('out1')

	return

def rect_face_info(face):
	## VER: 2012-09-04, v1.0

	info = {}
	ndir = face_ndir(face)
	if ndir not in ['x','y','z']:
		info['isRect'] = False
		info['length_dir'] = 'NA'
		info['width_dir'] = 'NA'

		return info

	x1,x2,y1,y2,z1,z2 = objs_space(face,method='simple')
	area = get_area(face)

	if ndir == 'x':
		area1 = round(abs(y2-y1)*abs(z2-z1),3)
	elif ndir == 'y':
		area1 = round(abs(x2-x1)*abs(z2-z1),3)
	else:
		area1 = round(abs(x2-x1)*abs(y2-y1),3)

	if equal(area,area1) == False:
		info['isRect'] = False
		info['length_dir'] = 'NA'
		info['width_dir'] = 'NA'

		return info

	info['isRect'] = True
	info['area'] = area
	info['ndir'] = ndir

	dict1 = {'x':x2-x1, 'y':y2-y1, 'z':z2-z1}
	list1 =sort_by_value(dict1,reverse=True)

	info['length'] = list1[0][1]
	info['length_dir'] = list1[0][0]

	info['width'] = list1[1][1]
	info['width_dir'] = list1[1][0]

	return info

def rect_frame(partname,frame_length,has_inner_wall=True):
	## VER: 2011-05-12, v1.0

	blank_part(partname)
	part = _m.parts[partname]

	bot_lip_top = base_thick + leg_gap_H + bot_lip_thick

	create_block(part,(0,outer_wall_thick),(0,frame_length),(0,frame_height))
	create_block(part,(0,frame_bot_width),(0,frame_length),(0,base_thick))

	create_block(part,(0,top_lip_width),(0,frame_length),(frame_height - top_lip_thick, frame_height))
	create_block(part,(0,top_lip_width + bot_lip_extx),(0,frame_length),(base_thick + leg_gap_H, base_thick + leg_gap_H + bot_lip_thick))

	move_RP(part,z=frame_height - top_lip_thick)
	create_block(part,(0,top_lip_width),(0,frame_length),(0,-top_adhesive_thick))

	move_RP(part,x=outer_wall_thick)
	create_block(part,(0,silic_side),(0,frame_length),(base_thick + leg_gap_H, frame_height))

	move_RP(part,z=base_thick + leg_gap_H + bot_lip_thick)
	create_block(part,(0,top_lip_width + bot_lip_extx),(0,frame_length),(0,bot_adhesive_thick))

	move_RP(part,gohome=True)

	if has_inner_wall == True:
		create_block(part,(outer_wall_thick + leg_gap, outer_wall_thick + leg_gap + inner_wall_thick), (0,frame_length),(0,bot_lip_top + bot_adhesive_thick))

	cells1 = cell_select_by_container(part,x=(outer_wall_thick,1e5),z=(bot_lip_top,frame_height - top_lip_thick))
	set_mat(part,cells=cells1,mat=Silic)

	cells2 = unselect(part.cells,cells1)
	set_mat(part,cells=cells2,mat=Al_6063,subset='Frame')

	if has_inner_wall == True:
		rotate_part(part,angle_z=-90)
	else:
		rotate_part(part,angle_z=180)

		part = _m.parts[partname]
		move_part(part,y1=MIN,y2=0)

		part = _m.parts[partname]
		KP_set(part)

	return

def rect_steel(p,edgeL,thick,length,dir='x'):
	## VER: 2010-07-23, v1.0

	if dir == 'x':
		create_block(p,(0,length),(0,edgeL),(0,edgeL))
		hex_cut(p,(0,length),(thick,edgeL - thick),(thick,edgeL - thick))
		mid_divide(p,['y','z'])
		batch_divide(p,y='p_' + p.name + '_diry')
		batch_divide(p,z='p_' + p.name + '_dirz')

	elif dir == 'y':
		create_block(p,(0,edgeL),(0,length),(0,edgeL))
		hex_cut(p,(thick,edgeL - thick),(0,length),(thick,edgeL - thick))
		mid_divide(p,['x','z'])
		batch_divide(p,x='p_' + p.name + '_dirx')
		batch_divide(p,z='p_' + p.name + '_dirz')

	elif dir == 'z':
		create_block(p,(0,edgeL),(0,edgeL),(0,length))
		hex_cut(p,(thick,edgeL - thick),(thick,edgeL - thick),(0,length))
		mid_divide(p,['x','y'])
		batch_divide(p,x='p_' + p.name + '_dirx')
		batch_divide(p,y='p_' + p.name + '_diry')

	return

def rectangle(sketch,x=(),y=(),point1=(),point2=()):
	## VER: ('VER: 2016-09-20, v1.4')
	## 弊端：矩形上的某个点无法挪动，还不如connect_points()灵活。

##	rectangle(s1,x=(carbide_D0/2,carbide_D1/2),y=(0,carbide_thick))

	sketch = check_sketch(sketch)

	if point1 in empty and point2 in empty:
		if sketch.vertices.keys() not in empty:
			x,y = real_xy_sketch(sketch,x,y)

		point1 = (x[0],y[0])
		point2 = (x[1],y[1])
##		print fnln_fnln(),'point1,point2=',point1,point2

	if is_location(point1) == False or is_location(point2) == False:
		raise Exception('*** corners are required.')

	sketch.rectangle(point1=tuple(point1), point2=tuple(point2))

	return

def reduce_insts_names():
	## VER: 2011-04-07, v1.3

	print ' '
	print 'Reducing insts names...'
	changed = False

	for part in _m.parts.keys():
		insts = insts_of_parts(part)

		insts_names = []
		if len(insts) > 0:
			for inst in insts:
				insts_names.append(inst.name)

			insts_names.sort()

			num = len(insts)
			prefix = part + '_A'

			for i in range(1,num + 1):
				name1 = insts_names[i - 1]
				name2 = prefix + str(i)

				if name1 != name2:
					try:
						a.features.changeKey(fromName=insts_names[i - 1],toName=prefix + str(i))
						print name1,'was changed name to',name2
						changed = True
					except:
						pass

	get_current_model()
##	create_poi_vars()
	if changed == False:
		print 'No change.'

	return

def reduce_model(renew=False,_text=True):
	## 2011-06-16, v1.0

	global analysis_factors

	"""start:
项                                   系数  系数标准误         T      P
常量                             -3352.17     26.8235  -124.971  0.000
outer_wall_thick                       19.34     11.5107     1.680  0.112
frame_height                         3.67      0.5030     7.297  0.000
base_thick                         484.26     11.5107    42.071  0.000
inner_wall_thick                   -129.97     10.9492   -11.871  0.000

outer_wall_thick*outer_wall_thick         -0.93      2.0778    -0.446  0.662  ## AA
frame_height*frame_height           -0.00      0.0038    -0.446  0.662  ## BB
base_thick*base_thick               -0.93      2.0778    -0.446  0.662  ## CC
inner_wall_thick*inner_wall_thick     -0.93      2.0778    -0.446  0.662  ## DD
outer_wall_thick*frame_height          13.81      0.1190   116.000  0.000
outer_wall_thick*base_thick           -16.67      2.7778    -6.000  0.000
outer_wall_thick*inner_wall_thick       -0.00      2.7778    -0.000  1.000  ## AD
frame_height*base_thick             -0.00      0.1190    -0.000  1.000  ## BC
frame_height*inner_wall_thick        14.05      0.1190   118.000  0.000
base_thick*inner_wall_thick         -11.11      2.7778    -4.000  0.001
	"""

	if _text == True:
		py_file,handler_line,lines = get_function_info('_text')
	else:
		py_file,handler_line,lines = get_function_info(reduce_model)

##	print 'py_file=',py_file

	if 'analysis_factors' not in globals().keys() or renew == True:
		analysis_factors = {}

	found = False
	start = handler_line - 1
	item_ratio = []

	for i in range(len(lines))[handler_line-1:]:
		line = lines[i].strip()

		if line in empty:
			continue

		if '"""start' in line:
			found = True
			start = i
			continue
		elif i <= start + 2:
			continue

		if found == True:
			if '"""' in line:
				break

			loc = line.find('#')
			if loc != -1:
				line = line[:loc]

			if line not in empty:
				line = line.split()
				line = [line[0],eval(line[4])]
				item_ratio.append(line)

##	myprint(item_ratio)
##	print ' '

	if analysis_factors in empty:
		for i in range(len(item_ratio)):
			item = item_ratio[i][0]
			if '*' in item:
				break
			elif i == 0:
				analysis_factors[item] = 'A'
			elif i == 1:
				analysis_factors[item] = 'B'
			elif i == 2:
				analysis_factors[item] = 'C'
			elif i == 3:
				analysis_factors[item] = 'D'
			elif i == 4:
				analysis_factors[item] = 'E'
			elif i == 5:
				analysis_factors[item] = 'F'
			elif i == 6:
				analysis_factors[item] = 'G'
			elif i == 7:
				analysis_factors[item] = 'H'
			elif i == 8:
				analysis_factors[item] = 'I'

##	myprint(analysis_factors)

	factors = sort_by_value(analysis_factors,reverse=False)
	for item in factors:
		print item[1],'=',item[0]

	for i in range(len(item_ratio)):
		item = item_ratio[i][0]
		if '*' not in item and item in analysis_factors.keys():
			item_ratio[i] = [analysis_factors[item],item_ratio[i][1]]
		elif '*' in item:
			item = item.split('*')
			item1 = ''
			for j in range(len(item)):
				item1 = item1 + analysis_factors[item[j]] + '*'
			item_ratio[i] = [item1[:-1],item_ratio[i][1]]

	print ' '
	myprint(item_ratio)

	reduce_items = []
	for item in item_ratio:
		if item[1] > 0.05:
			reduce_items.append(item[0])

	if len(reduce_items) > 0:
		print '--->Items need to reduce:',reduce_items
	else:
		print 'No items can be reduced in the model.'

	return

def _rsort(*values):
	## VER: 2014-09-08, v1.0 降序

	values = tolist(values)
	values = sorted(values)
	values.reverse()

	return values


def _sort(*values):
	## VER: 2014-05-05, v1.0 升序

	values = tolist(values)
	values = sorted(values)

	return values

def _reverse(*values):
	## VER: 2014-07-14, v1.0

##	>>> ind1 = [1,5,3]
##	>>> ind1.reverse()
##	>>> ind1
##	[3, 5, 1]
##	>>>

	values = tolist(values)
	values.reverse()

	return values


def _text():

	"""start
项                                  系数  系数标准误       T      P
常量                             249.333     40.1785   6.206  0.000
outer_wall_thick                     -1.699     17.2416  -0.099  0.923
frame_height                      -2.067      0.7534  -2.743  0.014
base_thick                       -12.976     17.2416  -0.753  0.463
inner_wall_thick                    4.587     16.4006   0.280  0.783
outer_wall_thick*outer_wall_thick       -3.861      3.1123  -1.241  0.233
frame_height*frame_height          0.017      0.0057   2.972  0.009
base_thick*base_thick             -1.916      3.1123  -0.616  0.547
inner_wall_thick*inner_wall_thick    0.361      3.1123   0.116  0.909
outer_wall_thick*frame_height         0.213      0.1783   1.195  0.249
outer_wall_thick*base_thick           5.139      4.1608   1.235  0.235
outer_wall_thick*inner_wall_thick     -4.472      4.1608  -1.075  0.298
frame_height*base_thick            0.080      0.1783   0.447  0.661
frame_height*inner_wall_thick      -0.127      0.1783  -0.714  0.485
base_thick*inner_wall_thick         3.528      4.1608   0.848  0.409
"""

	return

def cross_edges_of_faces(poi,faces1=None,faces2=None,D=None,nx=None,ny=None,nz=None):
	## VER: 2014-07-14, v1.0   can be used to collect wires.
	## Example: edges3 = cross_edges_of_faces('part-342',nx=1,D=121)

	poi = check_poi(poi)

	faces1 = tolist(faces1)
	faces2 = tolist(faces2)

	if faces1 in empty:
		if type_of(D) in numerics:
			faces1 = face_select(poi,diameter=D)
			D = None
		elif nx not in empty:
			faces1 = face_select(poi,nx=nx)
			nx = None
		elif ny not in empty:
			faces1 = face_select(poi,ny=ny)
			ny = None
		elif nz not in empty:
			faces1 = face_select(poi,nz=nz)
			nz = None

	if faces1 in empty:
		raise Exception('*** faces1 is required.')

	if faces2 in empty:
		if type_of(D) in numerics:
			faces2 = face_select(poi,diameter=D)
			D = None
		elif nx not in empty:
			faces2 = face_select(poi,nx=nx)
			nx = None
		elif ny not in empty:
			faces2 = face_select(poi,ny=ny)
			ny = None
		elif nz not in empty:
			faces2 = face_select(poi,nz=nz)
			nz = None

	if faces2 in empty:
		raise Exception('*** faces2 is required.')

	edges1 = faces_to_edges(faces1)
	edges2 = faces_to_edges(faces2)
	edges = get_common(edges1,edges2)

	print fnln(),'Found',len(edges),'common edges.'

	return edges


def cross_faces_by_dir_inplane(faces1,faces2,dir1,refined_insts='_',fix='_'):

	## VER: ('VER: 2012-07-20, v1.6')	## caller = refine_faces_pair_inplane()
	## faces1通常是base faces, faces2很可能是mate faces.
	## refined_insts相当于获得cross_space后，重新选择。

	global msfaces_trace

	add_to_process()

	please_check
	if faces1 in empty or faces2 in empty:
##		return [],[]
		return faces1,faces2

	inst1 = get_poi(faces1).name
	inst2 = get_poi(faces2).name

##	fix,refined_insts = check_fix_extend(fix=fix,refined_insts=refined_insts,p1=inst1,p2=inst2)

	faces1_prop = plane_normal_and_offset(faces1[0])
	normal1,offset1 = faces1_prop['normal'], faces1_prop['offset']
	if normal1 not in ['x','y','z']:
		print 'Only refine faces normal in x,y,z.'
		return faces1,faces2

	faces2_prop = plane_normal_and_offset(faces2[0])
	normal2,offset2 = faces2_prop['normal'], faces2_prop['offset']
	if normal2 not in ['x','y','z']:
		print 'Only refine faces normal in x,y,z.'
		return faces1,faces2

	if normal1 != normal2:
		print '**normal1 != normal2. Cannot refine the faces.'
		return faces1, faces2

	ndir = normal1

	if inst1 in fix and inst2 in fix:
		print 'No need to refine faces in',dir1,'due to they are all fixed.'
		return faces1,faces2

	x01,x02,y01,y02,z01,z02 = objs_space(faces1)
	x1,x2,y1,y2,z1,z2 = objs_space(faces2)
	cross_x = cross_of_ranges((x01,x02),(x1,x2))
	cross_y = cross_of_ranges((y01,y02),(y1,y2))
	cross_z = cross_of_ranges((z01,z02),(z1,z2))

	cross_x0 = cross_x['range']
	cross_y0 = cross_y['range']
	cross_z0 = cross_z['range']

	cross_x1 = [cross_x0[0] - 2, cross_x0[1] + 2]
	cross_y1 = [cross_y0[0] - 2, cross_y0[1] + 2]
	cross_z1 = [cross_z0[0] - 2, cross_z0[1] + 2]

	if dir1 == 'x':
		if inst1 not in fix:		## 不固定，则select
			if inst1 in refined_insts:
				if ndir == 'z':
					faces1 = faces_of_cut(inst1,x=cross_x1,y=cross_y0,z=offset1)
				elif ndir == 'y':
					faces1 = faces_of_cut(inst1,x=cross_x1,y=offset1,z=cross_z0)
			else:
				faces1 = face_select(inst1,faces=faces1,x=cross_x0)

		if inst2 not in fix:
			if inst2 in refined_insts:
				if ndir == 'z':
					faces2 = faces_of_cut(inst2,x=cross_x1,y=cross_y0,z=offset2)
				elif ndir == 'y':
					faces2 = faces_of_cut(inst2,x=cross_x1,y=offset2,z=cross_z0)
			else:
				faces2 = face_select(inst2,faces=faces2,x=cross_x0)

		trace0 = get_traceback()[-2:];		trace0[0] = '      ' + trace0[0]
		msfaces_trace.append(trace0 + [inst1 + '_faces1',objs_num(faces1),inst2 + '_faces2',objs_num(faces2), 'dir1=x', 'cross_x', cross_x0, 'ext=' + refined_insts])

	elif dir1 == 'y':
		if inst1 not in fix:
			if inst1 in refined_insts:
				if ndir == 'x':
					faces1 = faces_of_cut(inst1,x=offset1,y=cross_y1,z=cross_z0)
				elif ndir == 'z':
					faces1 = faces_of_cut(inst1,x=cross_x0,y=cross_y1,z=offset1)
			else:
				faces1 = face_select(inst1,faces=faces1,y=cross_y0)

		if inst2 not in fix:
			if inst2 in refined_insts:
				if ndir == 'x':
					faces2 = faces_of_cut(inst2,x=offset2,y=cross_y1,z=cross_z0)
				elif ndir == 'z':
					faces2 = faces_of_cut(inst2,x=cross_x0,y=cross_y1,z=offset2)
			else:
				faces2 = face_select(inst2,faces=faces2,y=cross_y0)

		trace0 = get_traceback()[-2:];		trace0[0] = '      ' + trace0[0]
		msfaces_trace.append(trace0 + [inst1 + '_faces1',objs_num(faces1),inst2 + '_faces2',objs_num(faces2), 'dir1=y', 'cross_y',cross_y0,'ext=' + refined_insts])

	elif dir1 == 'z':
		if inst1 not in fix:
			if inst1 in refined_insts:
				if ndir == 'x':
					faces1 = faces_of_cut(inst1,x=offset1,y=cross_y0,z=cross_z1)
				elif ndir == 'y':
					faces1 = faces_of_cut(inst1,x=cross_x0,y=offset1,z=cross_z1)
			else:
				faces1 = face_select(inst1,faces=faces1,z=cross_z0)

		if inst2 not in fix:
			if inst2 in refined_insts:
				if ndir == 'x':
					faces2 = faces_of_cut(inst2,x=offset2,y=cross_y0,z=cross_z1)
				elif ndir == 'y':
					faces2 = faces_of_cut(inst2,x=cross_x0,y=offset2,z=cross_z1)
			else:
				faces2 = face_select(inst2,faces=faces2,z=cross_z0)

		trace0 = get_traceback()[-2:];		trace0[0] = '      ' + trace0[0]
		msfaces_trace.append(trace0 + [inst1 + '_faces1',objs_num(faces1),inst2 + '_faces2',objs_num(faces2), 'dir1=z', 'cross_z',cross_z0, 'ext=',refined_insts])

	return faces1, faces2

##def refine_faces_pair_inplane(faces1,faces2,refined_insts='_',fix='_'):
##
##	## VER: ('VER: 2012-07-25, v1.6')	## 假定法向已经refine，现在refine其他两个方向。
##	## 本函数进行的是refine，若有fix，则不进行refine
##	## caller: get_msface_and_msregion()
##	## 如果法线不是'x','y','z'，则无法refine
##
##	global contact_pairs, msfaces_trace
##
##	add_to_process()
##
##	normal1 = face_ndir(faces1[0])
##	normal2 = face_ndir(faces2[0])
##
##	inst1 = get_poi(faces1).name
##	inst2 = get_poi(faces2).name
##
##	fix,refined_insts = check_fix_extend(fix=fix,refined_insts=refined_insts,p1=inst1,p2=inst2)
##
##	trace0 = get_traceback()[-2:];		trace0[0] = '    ' + trace0[0]
##	msfaces_trace.append(trace0 + [inst1+'_faces1',objs_num(faces1),inst2 + '_faces2',objs_num(faces2), 'normal=' + normal1, 'ext=' + refined_insts, 'fix=' + fix])
##
####	print 'len(faces1)=',len(faces1)
####	print 'len(faces2)=',len(faces2)
####
####	globals()['faces1'] = faces1
####	globals()['faces2'] = faces2
####
####	raise Exception
##
##	if normal1 == normal2 and normal1 in ['x','y','z']:
##		print fnln_fnln(),'Refine faces1 and faces2 in plane...'
##		faces1,faces2 = refine_faces_pair_inplane(faces1,faces2,refined_insts=refined_insts,fix=fix)	## 同时refine 2个方向
##
##	else:
##		print fnln_fnln(),'faces1 and faces2 are not refined. normal1=',normal1,', normal2=',normal2
##
##	trace0 = get_traceback()[-2:];		trace0[0] = '    ' + trace0[0]
##	msfaces_trace.append(trace0 + [inst1+'_faces1',objs_num(faces1),inst2 + '_faces2',objs_num(faces2), 'ext=' + refined_insts, 'fix=' + fix])
##
##	return faces1,faces2

def search_file(filename,dir1=None):
	## VER: 2017-06-09, v1.3
	## Reference: my_walk()

##	>>> search_file('uloc.py')
##	'E:/FEM/A0241_Cap_Eugene/py/uloc.py'
##	>>> search_file('ca214202-1.jpg')
##	'E:/FEM/A0241_Cap_Eugene/images/ca214202-1.jpg'
##	>>> search_file('ca214501_model_1.png')
##	'E:/FEM/A0241_Cap_Eugene/images/model/ca214501_model_1.png'
##	>>>

##	>>> dict1 = my_walk()
##	>>> min(dict1.keys())
##	'E:/FEM/A0241_Cap_Eugene'  ## 获取最短的路径，也就是当前目录，而不是子目录
##	>>>

##	print_traceback()
##	print fnln(),'script filename=',get_file_name()

	script = get_file_name()
##	print fnln(),'filename=',filename

	please_check
	if script in filename:
		return get_file_path()

	if dir1 in empty:
		dir1 = get_work_dir()

	dir1 = real_dir(dir1)
	dict1 = my_walk(dir1)
	current_dir = min(dict1.keys())

	filename =real_dir(filename)
	if '/' in filename:
		loc = filename.rfind('/')
		filename = filename[loc+1:]
	filename0 = filename.lower()

	path1 = ''

	files = dict1[current_dir]['files']   ## 优先搜索当前目录
	if files not in empty:
		for i in range(len(files)):
			if filename0 == files[i].lower():
				filename = files[i]
				path1 = current_dir
				break

	if path1 == '':
		for path in dict1:
			files = dict1[path]['files']
			if files not in empty:
				for i in range(len(files)):
					if filename0 == files[i].lower():
						filename = files[i]
						path1 = path
						break

			if path1 != '':
				break

	if path1 == '':
		print fnln_fnln(), '*** Cannot find ' + filename + ' in ' + dir1
	else:
		path1 = path1 + '/' + filename

	return path1

def search_dir(dirname,dir1=None,search_disk=False):
	## VER: 2015-07-20, v1.2
	## reference: my_walk()
	## 如果路径是完整路径，则判断该路径是否存在；否则，仅搜索当前目录及其子目录(seach_disk=False的情况下)

##	>>> search_dir('model')
##	'E:/FEM/A0241_Cap_Eugene/images/model'
##	>>> search_dir('py')
##	'E:/FEM/A0241_Cap_Eugene/py'
##	>>> search_dir('odbs')
##	'E:/FEM/A0241_Cap_Eugene/odbs'
##	>>> search_dir('eugene')
##	'E:/FEM/A0241_Cap_Eugene/incomming/Eugene'
##	>>>

##	>>> dict1 = my_walk()
##	>>> min(dict1.keys())
##	'E:/FEM/A0241_Cap_Eugene'  ## 获取最短的路径，也就是当前目录，而不是子目录
##	>>>

	cur = os.getcwd()
	cur = real_dir(cur)
##	print fnln(),'current dir=',cur

	if dir1 in empty:
##		dir1 = get_work_dir()
		dir1 = cur

	dir1 = real_dir(dir1)
	dict1 = my_walk(dir1)
	current_dir = min(dict1.keys())

	dirname = real_dir(dirname)
	if os.path.isdir(dirname):
##		print fnln(),'Found'
		if '/' not in dirname:
			dirname = current_dir + '/' + dirname
		return dirname

	if '/' in dirname:
		loc = dirname.rfind('/')
		dirname = dirname[loc+1:]
	dirname0 = dirname.lower()
	print fnln(),'To search dirname=',dirname

	path1 = ''

	dirs = dict1[current_dir]['sub_dirs']   ## 优先搜索当前目录
	if dirs not in empty:
		for i in range(len(dirs)):
			if dirname0 == dirs[i].lower():
				dirname = dirs[i]
				path1 = current_dir
				break

##	print fnln(),'path1=',path1

	if path1 == '':  ## 再搜索当前目录下的子目录
		for path in dict1:
			dirs = dict1[path]['sub_dirs']
			if dirs not in empty:
				for i in range(len(dirs)):
					if dirname0 == dirs[i].lower():
						path1 = path
						dirname = dirs[i]
						break

			if path1 != '':
				break

##	print fnln(),'path1=',path1
##	print 'search_disk=',search_disk
	if path1 == '' and search_disk == True:
		cur = os.getcwd().upper()
		cur = real_dir(cur)
		dict1 = my_walk(cur[:3])

		current_dir = min(dict1.keys())

		dirs = dict1[current_dir]['sub_dirs']   ## 优先搜索当前目录
		if dirs not in empty:
			for i in range(len(dirs)):
				if dirname0 == dirs[i].lower():
					dirname = dirs[i]
					path1 = current_dir
##					print fnln(),'Found'
					break

		if path1 == '':  ## 再搜索当前目录下的子目录
			for path in dict1:
				dirs = dict1[path]['sub_dirs']
				if dirs not in empty:
					for i in range(len(dirs)):
						if dirname0 == dirs[i].lower():
							path1 = path
							dirname = dirs[i]
							break

				if path1 != '':
					break

	if path1 == '':
		print fnln(), '*** Cannot find ' + dirname + ' in ' + dir1
	else:
		path1 = path1 + '/' + dirname

	return path1

def set_temperature_BC(name,objs=None,region=None,temp=None,magnitude=1,amplitude='',step='step1',modifys=None,deactive_step=None):
	## VER: 2014-11-18, v1.4
	## 用于thermal_stress类型或者temp类型的procedure type, 不能用于Static General类型。
	## 理论上也可以通过set_temperature_BC()来设置step='Initial'时的温度，不过此时的温度值只能为0（Initial step的温度只能为0，如果通过BC manager来设置的话）。
	## amplitude只能是一个名称。

	## Exmaple:
##	set_temperature_predefined_field(temp=room_temperature)
##	set_temperature_BC('high_temp',temp=300,step='step1');	please_check	## heat up
##	set_temperature_BC('room_temp',temp=room_temperature,step='step2')		## cool down

	step = check_step(step)
	if step == 'Initial':
		raise Exception('*** Please use set_temperature_predefined_field()来设置Initial step的温度值。')

	name = new_key(_m.boundaryConditions.keys(),name)

	_lineno = lineno_and_codes()[-2]
	seq = get_SN(_m.boundaryConditions,2)
	name = '_' + seq + '_' + name + '_' + str(_lineno)

	name = new_key(_m.boundaryConditions,name)

	if is_surface(region):
		region = check_surface(region)

	if objs not in empty:
		type1 = type_of(objs)
		if type1 == 'STR':
			objs = set2objs(objs)

		if type_of(objs) not in ['REGION','SET']:
			objs = tolist(objs)
			region = list2region(objs, region_type='set')

		else:
			region = objs

	elif region in empty:
		insts = a.instances.values()

		sequence = None
		for inst in a.instances.values():
			if len(inst.cells) > 0:
				if sequence == None:
					sequence = inst.cells[:]
				else:
					sequence = sequence + inst.cells[:]

		if sequence not in empty:
			region = Region(cells=sequence)
		else:
			sequence = None
			for inst in a.instances.values():
				if len(inst.faces) > 0:
					if sequence == None:
						sequence = inst.faces[:]
					else:
						sequence = sequence + inst.faces[:]

			if sequence not in empty:
				region = Region(faces=sequence)

	if region in empty:
		raise Exception('*** cell region or face region is required.')

	if is_number(amplitude):  	## error input, transfer to magnitude.
		magnitude = amplitude
		amplitude = None
	elif (amplitude not in empty) and amplitude not in _m.amplitudes.keys():
		raise Exception('*** Error emplitude.')

	if is_number(temp):
		magnitude = temp

	if name not in _m.boundaryConditions.keys():
		_m.TemperatureBC(name=name, createStepName=step,
		    region=region, fixed=OFF, distributionType=UNIFORM, fieldName='', magnitude=0, amplitude=UNSET)  ## temporary, will be modified

	if amplitude in empty:
		_m.boundaryConditions[name].setValues(magnitude=magnitude)
	else:
		_m.boundaryConditions[name].setValues(magnitude=magnitude,amplitude=amplitude)   ## First step

	modified = False
	if modifys not in empty:   ## consider: real_modifys()
		modifys = real_modifys(modifys)
		for item in modifys:
			stepname,mag1,amp1 = item
			if amp1 in empty:
				_m.boundaryConditions[name].setValuesInStep(stepName=stepname, magnitude=mag1)
			else:
				_m.boundaryConditions[name].setValuesInStep(stepName=stepname, magnitude=mag1,amplitude=amp1)
			modified = True

	if deactive_step not in empty:
		deactive_step = check_step(deactive_step)
		_m.boundaryConditions[name].deactivate(deactive_step)

	print '--->Applied temperature BC in BC manager, name=',name,', temp=',temp,'degC, step=',step
	if modified == True:
		print '      modifys = ',modifys

	## note: static general step ('stress')没有 temperature BC, 只有temperature pre-defined field for initial step and other steps.

	return name

def remove_empty(*list1):
	## VER: 2011-11-09, v1.0

## Example:
##	inputs0 = remove_empty(x,y,z)
##	if len(inputs0) == 1 and inputs0[0] in [MAX1,MIN1,MID]:
##		mark_select = True

##	>>> remove_empty(None,None)
##	[]
##	>>>

	list1 = tolist(list1)

	if type_of(list1) not in ['LIST','TUPLE']:
		raise Exception('A list or tuple is required.')

	list2 = []
	for item in list1:
		if item not in empty:
			list2.append(item)

	return list2

def refresh_gap():
	## VER: 2016-04-07, v1.0

	refresh(value_loc='gap')
	return

function_labels['refs'] = 'refresh','update','p1'
def refs():
	## VER: 2017-06-19, v1.0

	refresh()
	get_p1()

	return

def refresh(text='', component='',vname='', value_loc='', input_text='', fitview=False, path1='', scale=1,unit='', float=2,print_result=True,th=14.44,C1=2.505,ask=None):
	## VER: 2017-08-09, v6.1
	## update current mdb, and if current viewport is odb, the odb will be also updated.

	## Example: refresh(value_loc='min')

##	>>> refresh('side1')  ## text='side1'

	## in GUI clip command window:  (for density viewport)
	## refresh():   no prompt for density confirmation
	## refresh(ask=True): prompt for density confirmation
	## refresh(text='side1 flatness')  ## text is the annotation text for xyplot

	global cae_file_title

##	get_current_model()

	auto()
	if vname == 'help':
		print "refresh(vname='', input_text='', value_loc='',scale=1,unit='',float=2)"
		print 'vname =value name, such as: displacement, stress.'
		print 'input_text =type of value, such as, min, max, gap.'
		return

	get_fontsize()		;please_check
##	raise Exception

	if text not in empty:
		input_text = text
	update_all_viewports(component=component, vname=vname, input_text=input_text, path1=path1, value_loc=value_loc, scale=scale, unit=unit,
		float=float,print_result=print_result,th=th,C1=C1,ask=ask)

	hide_datum()
##	globals()['_hide_datum'] = True
	vpnow = get_vpnow()
	if fitview == True:
		vpnow.view.fitView()

##	if '_hide_datum' not in globals().keys():  ## not run set_annotation()
##		if caller_name() == 'cliCommand':
####			set_annotation()
##			hide_datum()
##			globals()['_hide_datum'] = True
##			vpnow = get_vpnow()
##			vpnow.view.fitView()
##	else:
##		dpo = get_dpo()
##		if type_of(dpo) in ['PART','ASSEMBLY']:
##			print ' '
##			print 'run hide_datum() if the parts is not properly displayed.'

	if type_of(vpnow.displayedObject) in ['PART','ASSEMBLY']:
		print ' '
		print 'run hide_datum() or show_datum() for datum display options.'

	return


def region2objs(region):
	## VER: 2014-01-16, v1.0

	objs = []
	if type_of(region) == 'REGION':
		for seq in [region.cells, region.faces, region.side1Faces, region.side2Faces, region.edges, \
			region.side1Edges, region.side2Edges, region.vertices, region.elements, region.nodes]:

			if len(seq) > 0:
				objs = tolist(seq)
				break

	elif type_of(region) == 'SURFACE':
		for seq in [region.faces, region.edges, region.elements, region.nodes]:
			if len(seq) > 0:
				objs = tolist(seq)
				break

	if objs in empty:
		raise Exception('*** fail to get the objs of ' + type_of(region))

	return objs

def related_jobs(model_name=None):
	## VER: 2014-06-10, v1.0

	if model_name in empty:
		model_name = current_model_name

	if model_name not in mdb.models.keys():
		raise Exception('*** No such model name in this cae file.')

	jobs = []
	for job in mdb.jobs.values():
		if job.model == model_name:
			jobs.append(job.name)

##	print 'Related jobs for model',model_name
##	print jobs

	return jobs

def remesh_region(part,objs=None, region=None,faces=None,cells=None,edges=None,elemShape=None,technique=None,algorithm=None,allowMapped=None, sizeGrowth=None):
	## VER: 2013-10-10, v1.1

	part = check_part(part)

	objs = get_real_input(objs,faces,cells,edges)
	if objs not in empty:
		region = list2sequence(objs)

	else:
		if is_empty(region):
			pshape = part_shape(part)[1]
			if '3D' in pshape:
				region = part.cells
			elif '2D' in pshape:
				region = part.faces
			elif '1D' in pshape:
				region = part.edges

	if type_of(region) != 'SEQUENCE':
		raise Exception('*** faces, cells, or edges are required for unmesh.')

	part.deleteMesh(regions=region)
	set_element_shape(part, region=region, elemShape=elemShape,technique=technique,algorithm=algorithm,allowMapped=allowMapped, sizeGrowth=sizeGrowth)
	part.generateMesh(regions=region)
	part.regenerate()
	a.regenerate()

	return

def remove_cells(part,cells, del_faces=True):
	## VER: 2015-07-06, v1.1
	## edges, vertices and faces of these cells will not be deleted.
	## This method converts a solid entity to a shell entity

##	boolean_cut(part,cutters=ball1,del_cutters=True)
##	cells=  cell_select(part,z=MAX1)
##	remove_cells(part,cells=cells)

	part = check_part(part)

	cells = list2sequence(cells)
	if cells in empty:
		cells = part.cells

	num = len(cells)

	faces = []
	if del_faces == True:
		faces = faces_of_cells(cells)
		newlist = []
		for face in faces:
			cells1 = faces_to_cells(face)
			cells2 = unselect(cells1,cells)
			if len(cells2) == 0:  ## 如果一个面与其他不相关的cells共享，则该面不删除
				if face not in newlist:
					newlist.append(face)
		faces = newlist

	part.RemoveCells(cellList=cells)

	if del_faces == True and len(faces) > 0:
		remove_faces(part,faces)

	print '--->',num,'cells has been removed in',part.name

	return

def remove_faces(part,faces=None,remove_shell=False):
	## VER: 2015-07-06, v1.4
	## edges and vertices of these faces will be deleted if applicable.
	## This method removes faces from a solid entity or from a shell entity
	## if you create wire in a part, and you remove all the faces of the part, you will get the wire.
	## reference: remove_cells()

	## Example:
##	vertices1 = vertice_select('cylind',x=MIN,groupZ=MAX)
##	vertices2 = vertice_select('cylind',x=MIN,groupZ=MIN)
##	faces = vertices_to_faces(vertices1 + vertices2)
##	remove_faces('cylind',faces=faces)

	if is_part(faces):
		faces,part = part,faces

	part = check_part(part)

	if remove_shell == True:
		faces = []
		for face in part.faces:
			if len(face.getCells()) == 0:
				faces.append(face)

	if faces in empty:
		raise Exception('*** faces are required to remove.')

	faces = tolist(faces)
	faces = list2sequence(faces)

	num = len(faces)
	part.RemoveFaces(faceList=faces, deleteCells=False)

	print '--->',num,'faces has been removed in',part.name

	return

def remove_minmax(removed='max'):
	## VER: 2014-12-03, v1.1

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	setting = current_variable_setting()
	position = setting['position']

	value_loc = vpnow.getPrimVarMinMaxLoc()

	if position == INTEGRATION_POINT:
		max_inst = value_loc['maxPartInstanceName']
		max_elem = value_loc['maxElementLabel']
		max_value = value_loc['maxValue']

		min_inst = value_loc['minPartInstanceName']
		min_elem = value_loc['minElementLabel']
		min_value = value_loc['minValue']

		if removed in ['max',MAX]:
			_inst = max_inst;		_elem = max_elem;		value_before = abs(max_value)
		else:
			_inst = min_inst;		_elem = min_elem;		value_before = abs(min_value)

		element = dgo.LeafFromModelElemLabels(elementLabels=((_inst, (_elem, )), ))
		display.displayGroup.remove(leaf=element)
		print removed,'element',(_inst,_elem),'is removed'

	elif position == NODAL:
		max_inst = value_loc['maxPartInstanceName']
		max_node = value_loc['maxNodeLabel']
		max_value = value_loc['maxValue']

		min_inst = value_loc['minPartInstanceName']
		min_node = value_loc['minNodeLabel']
		min_value = value_loc['minValue']

		if removed in ['max',MAX]:
			_inst = max_inst;		_node = max_node;		value_before = abs(max_value)
		else:
			_inst = min_inst;		_node = min_node;		value_before = abs(min_value)

		node = dgo.LeafFromModelNodeLabels(nodeLabels=((_inst, (_node, )), ))
		display.displayGroup.remove(leaf=node)
		print removed,'node',(_inst,_node),'is removed'


	if removed in ['max',MAX]:
		value_after = display.contourOptions.autoMaxValue
	else:
		value_after = display.contourOptions.autoMinValue

	value_before = round(value_before,4)
	value_after = round(value_after,4)
	leaf = dgo.LeafFromElementVarRange()

	return value_before, value_after, leaf

def remove_redundant_edges(part,edges=None):
	## VER: 2014-08-08, v1.1

##	edges = edge_select(ejector,edir='y')
##	remove_redundant_edges(ejector, edges=edges)

	refresh()
	part = check_part(part)

	num1 = len(part.edges)

	if edges in empty:
		edges = tolist(part.edges)

		for edge in edges:
			try:
				part.RemoveRedundantEntities(edgeList=(edge,))
				part.checkGeometry()
			except:
				pass
	else:
		edges = tolist(edges)
		part.RemoveRedundantEntities(edgeList = edges)
		part.checkGeometry()

	num2 = len(part.edges)
	print fnln(),num2 - num1, 'redundant edges are deleted.'

	return

def remove_sub(str1,str2):
	## VER: 2011-03-10, v1.0

	len2 = len(str2)
	while str1.find(str2) >= 0:
		loc = str1.find(str2)
		if loc == len(str1) + 1 - len2:
			str1 = str1[:-len2]
		else:
			str1 = str1[:loc] + str1[loc + len2:]

	return str1

function_labels['remove_item'] = 'list','remove','delete','item','element'
def remove_item(list1,value):
	## VER: 2016-12-01, v1.2

##	>>> list1 = [1,1,2,3]
##	>>> remove_item(list1,1)
##	[2, 3]
##	>>>

	list1 = tolist(list1)
	while True:
		try:
			list1.remove(value)
		except:
			break

	return list1

def res2file1(stepname=None):				##**************************
	## VER: ('VER: 2013-05-09, v2.4')

##	dict4 = {'vars':('inter_bot','inter_top','force'), 'surf_pocketint_int3':('S1','U2'),'carbide_A1':'U2'}
##	dict4 = ('vars','inter_bot','inter_top','force'),('surf_pocketint_int3','S1','U2'),('carbide_A1','U2')
##	res2file(dict4,steps=[1,2])

	global options

	print ' '
	print 'Usage: res2file1(stepname=None)'
	print ' '

	vpnow = get_vpnow()
	if type_of(vpnow.displayedObject) != 'ODB':
		raise Exception('Please change to Visulization module and open an odb file.')

	refresh()

	if stepname in empty:  ## collect results for all steps
		for step in odb.steps.keys():
			output_list = get_output_list(stepname=step)
			list_to_txt_line(result_file,output_list)
		if len(odb.steps.keys()) > 1:
			line_print(result_file, ' ')
	else:
		if stepname not in odb.keys():
			raise Exception('**** Error stepname=' + repr(stepname))

		output_list = get_output_list(stepname=stepname)
		list_to_txt_line(result_file,output_list)

	print 'Please use such as plotset("Frame") to plot the specific set contour.'
	print ' '

	return

def reselect_by_pointOn(objs,xmin=False,xmax=False,ymin=False,ymax=False,zmin=False,zmax=False):
	## VER: 2012-11-16, v1.0

	objs = tolist(objs)

	pointOns = []
	for obj in objs:
		pointOn = obj.pointOn[0]
		pointOns.append(pointOn)

	x1,x2,y1,y2,z1,z2 = space_of_points(pointOns)

	if xmin == True:
		newlist = []
		for obj in objs:
			x,y,z = obj.pointOn[0]
			if PK(x,x1) == 0:
				newlist.append(obj)
		objs = newlist

	elif xmax == True:
		newlist = []
		for obj in objs:
			x,y,z = obj.pointOn[0]
			if PK(x,x2) == 0:
				newlist.append(obj)
		objs = newlist

	if ymin == True:
		newlist = []
		for obj in objs:
			x,y,z = obj.pointOn[0]
			if PK(y,y1) == 0:
				newlist.append(obj)
		objs = newlist

	elif ymax == True:
		newlist = []
		for obj in objs:
			x,y,z = obj.pointOn[0]
			if PK(y,y2) == 0:
				newlist.append(obj)
		objs = newlist

	if zmin == True:
		newlist = []
		for obj in objs:
			x,y,z = obj.pointOn[0]
			if PK(z,z1) == 0:
				newlist.append(obj)
		objs = newlist

	elif zmax == True:
		newlist = []
		for obj in objs:
			x,y,z = obj.pointOn[0]
			if PK(z,z2) == 0:
				newlist.append(obj)
		objs = newlist

	print '--->',len(objs),'objs remained by reselect_by_pointOn()'

	return objs

def reselect_faces(faces, x=(),y=(),z=(),space=(), exterior=True,ndir=None,ao_tu=None,shape=None, radius=None,
	parallel=None, nx=None,ny=None,nz=None,include_ends=False, mark_select=False,	method='simple'):
	## VER: 2013-12-10, v1.0

	if space in empty:
		space = objs_space(faces)

	x,y,z = real_xyz(x=x,y=y,z=z,space=space)
	x1,x2,y1,y2,z1,z2 = tospace(x,y,z)

##	print fnln_fnln(),'y=',y
##	print x1,x2,y1,y2,z1,z2

	faces = check_facing_dir(faces,ndir=ndir,exterior=exterior,nx=nx,ny=ny,nz=nz)

	if shape != None:
		faces1 = []
		for face in faces:
			shape1 = face_shape(face)
			if shape == shape1:
				faces1.append(face)
		faces = faces1

	if radius != None:
		faces1 = []
		for face in faces:
			radius0 = get_radius(face)
			if is_number(radius0) and PK(radius0,radius) == 0:
				faces1.append(face)
		faces = faces1

	if parallel in ['x','y','z']:
		faces1 = []
		for face in faces:
			if parallel_to_axis(face,axis=parallel) == True:
				faces1.append(face)
		faces = faces1

	if ao_tu not in empty:   ## U, A, or flat
		faces1 = []
		for face in faces:
			status = AV_shape(face)
			if status == ao_tu:
				faces1.append(face)
		faces = faces1

	##	print len(p.faces)
	##	print len(faces)
	##	raise Exception

	fix_DOF = []   ## 对x,y,z的约束情况. (_min,_max)为无约束。
##	print fnln_fnln(),x,y,z
	if (x1,x2) != (_min,_max):
		fix_DOF.append('x')
	if (y1,y2) != (_min,_max):
		fix_DOF.append('y')
	if (z1,z2) != (_min,_max):
		fix_DOF.append('z')

	##	print 'fix_DOF=',fix_DOF
	##	print 'len(fix_DOF) =',len(fix_DOF)
	##	raise Exception

	##	print (allow_mark_select_x, allow_mark_select_y, allow_mark_select_z)
##	print fnln_fnln(),fix_DOF
	if len(fix_DOF) == 1:
		if 'x' in fix_DOF:
##			print 'before: len(faces)=',len(faces)
			faces1 = []
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face,method=method)
				if meet_search_range((x01,x02),(x1,x2), include_ends=include_ends) == True:
					faces1.append(face)
			faces = faces1

	##			print 'after: len(faces)=',len(faces)
	##			raise Exception

		elif 'y' in fix_DOF:
##			print 'before: len(faces)=',len(faces)
##			light(faces)
##			raise Exception

			faces1 = []
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face,method=method)
##				print 'y01,y02=',(y01,y02)
				if meet_search_range((y01,y02),(y1,y2),include_ends=include_ends) == True:
					faces1.append(face)
			faces = faces1

		elif 'z' in fix_DOF:
			faces1 = []
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face,method=method)
				if meet_search_range((z01,z02),(z1,z2), include_ends=include_ends) == True:
					faces1.append(face)
			faces = faces1

	elif len(fix_DOF) >= 2:
		faces1 = []
		if ndir != 'y' and ndir != 'z':
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face,method=method)
	##				if not meet_search_range((x01,x02),(x1,x2),mark_select=allow_mark_select_x, include_ends=include_ends):
				if not meet_search_range((x01,x02),(x1,x2),include_ends=include_ends):
					continue
				if not meet_search_range((y01,y02),(y1,y2), include_ends=include_ends):
					continue
				if not meet_search_range((z01,z02),(z1,z2), include_ends=include_ends):
					continue

				faces1.append(face)

		elif ndir == 'y':
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face,method=method)
				if not meet_search_range((y01,y02),(y1,y2),include_ends=include_ends):
					continue
				if not meet_search_range((z01,z02),(z1,z2),include_ends=include_ends):
					continue
				if not meet_search_range((x01,x02),(x1,x2),include_ends=include_ends):
					continue

				faces1.append(face)

		elif ndir == 'z':
			for i in xrange(len(faces)):
				face = faces[i]
				x01,x02,y01,y02,z01,z02 = objs_space(face,method=method)
				if not meet_search_range((z01,z02),(z1,z2),include_ends=include_ends):
					continue
				if not meet_search_range((x01,x02),(x1,x2),include_ends=include_ends):
					continue
				if not meet_search_range((y01,y02),(y1,y2),include_ends=include_ends):
					continue

				faces1.append(face)
		faces = faces1

	return faces

def restart_analysis(odb_title1,new_model='restart',import_state=True,import_stress=False):
	## VER: 2015-01-14, v1.0, import last step, last frame
	## 注意：如果把odb_title1对应的cae, odb, rst一起改成另外一个相同的名字，然后才进行restart_analysis，将会出现错误。(error during part, assembly process)

	## Example:
##	odb_title1 = inp_file_title
##	create_inp(inp_file_title,request_num=6,submit=False)
##	mdb.jobs[odb_title1].submit()
##	mdb.jobs[odb_title1].waitForCompletion()
##
##	restart_analysis(odb_title1,import_state=True)
##
##	create_dynamic_explicit_step(step='draw', timePeriod=draw_time)
##	field_output_request(timepoints=timepoints2)
##
##	create_general_contact_exp(friction=0.1)

	if type_of(odb_title1) != 'STR':
		raise Exception('*** odb title is required.')

	if job_status(odb_title1) in [RUNNING,SUBMITTED]:
		mdb.jobs[odb_title1].waitForCompletion()

	copy_model(to_name=new_model)
	clear_model_settings()

	if import_stress == True:
		import_state = False

	if import_state == True:
		import_initial_state(odb_title1)
		print '---> initial state is imported.'

	if import_stress == True:
		import_initial_stress(odb_title1)
		print '---> initial stress is imported.'

	return

def reverse_points():
	## VER: 2016-09-16, v1.0

##	set_point0(loc0)
##	loc1 = add_points(('x',steel_D1/2),('y',steel_thick),('x',steel_D2/2 - 2.54),xytilt4(dy=2.54,Ay=45),('y',steel_H2),
##		('x',steel_D3/2),('y',steel_H1),('x',steel_D4/2),('y',0))
##	reverse_points()
##	add_points(xytilt4(y=0,Ay=steel_exit_angle),loc1)
##	poly_line(s1)

	global poly_points

	if 'poly_points' not in globals().keys():
		raise Exception('*** poly_points are required.')

	poly_points.reverse()
	last_point = poly_points[-1]

	return

def revolve_sketch_to_part(partname,sketch,angle=90,solid=True, rigid=None, counter_clock=True,axis='V'):
	## VER: 2017-05-27, v2.1. 注意是绕H轴或V轴，生成一个圆环或圆柱
	## Note: the sketch to be revolved must be unsymmetric, otherwise, it maybe error. The sketch can only at oneside of the axis.
	## reference: sketch_to_wire(), sketch_to_shell()
	## If solid = False, then it is a shell part
	## 草图ndir == 'x'时，草图坐标点为(y0,z0), axis='Y'或axis='|'表示绕着Z轴旋转，
	## axis='X'或axis='_'表示表示绕着y轴旋转。

##	test code for ndir == 'x':
##	s1 = create_part_sketch('pin1',name='sk_pin1',ndir='x',offset=10)
##	partname = s1['partname']
##	loc0 = (10,0,0)
##	loc1 = (10,5,0)
##	loc2 = (10,5,1)
##	loc3 = (10,0,1)
##	locs = connect_points(s1,loc0,loc1,loc2,loc3,loc0,ndir='x')
##	print locs	## [(0, 0), (5, 0), (5, 1), (0, 1), (0, 0)]  ## element = (y0,z0)而不是(z0,y0)
##	pin = revolve_sketch_to_part(partname,sketch=s1,angle=360,axis='x')

	## test code for ndir == 'y':
##	s1 = create_part_sketch('pin2',name='sk_pin1',ndir='y',offset=0)
##	partname = s1['partname']
##	loc0 = (0,0,0)
##	loc1 = (10,0,0)
##	loc2 = (10,0,1)
##	loc3 = (0,0,1)
##	locs = connect_points(s1,loc0,loc1,loc2,loc3,loc0)
##	print locs  ## [(0, 0), (10, 0), (10, 1), (0, 1), (0, 0)]  ## element = (x0,z0)而不是(z0,x0)
##	pin = revolve_sketch_to_part(partname,sketch=s1,angle=360,axis='V')

##	## GEA bush
##	s1 = create_base_sketch('sk_bush')
##	loc0 = (bush_ID/2,0)
##	connect_points(s1,loc0,('dy',topbush_H),('dx',bush_thick),('dy',-topbush_H + bush_thick),('dx',bush_flang_ext),('dy',-bush_thick),loc0)
##	round_sketch_corner(s1,loc=loc0,radius=bush_round)
##	revolve_sketch_to_part('bush',s1,angle=360)

	## Example:
##	create_base_sketch('_anvil',ndir='z')
##	point1,point2,arc1 = create_arc('_anvil',center=(0,0),radius=20, quarter=4)
##	connect_points('_anvil',point2,'H=5','V=15','H=-25',point1)
##
##	revolve_sketch_to_part('anvil',sketch='_anvil',angle=90)
##	revolve_sketch_to_part('cutter',sketch='sk_edge', angle=360, axis='H')

##	global _m, a

	if is_sketch(partname):
		sketch, partname = partname, sketch

	if type_of(sketch) != 'DICT':
		sketch = check_obj(sketch,_m.sketches)
		sketch0 = sketch
	else:
		sketch0 = sketch  ## sketch0 is a dict
		sketch = sketch0['sketch']

	if is_part(partname):
		p = check_part(partname)
	else:
		partname = blank_part(partname)
		p = _m.parts[partname]

	temp_sketch = new_key('bag_sketch_solid',_m.sketches)

	if len(sketch.geometry) == 0:  ## no geometry
		raise Exception('*** sketch ' + sketch.name + ' is empty.')

	axis = axis.upper()
	if axis == '|':
		axis = 'V'
	elif axis == '_':
		axis = 'H'

	## BaseSolidRevolve表明是基于真实的xoy平面来旋转。即使草图的平面可能不是xoy平面。
	if sketch == sketch0:
		s = _m.ConstrainedSketch(name=temp_sketch, sheetSize=200.0)
		s.setPrimaryObject(option=STANDALONE)
		s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
		if axis in ['Y','V','|']:
			s.ConstructionLine(point1=(0.0, -100.0), point2=(0.0, 100.0))	## construction line as center line   对称轴是Y方向
		elif axis in ['H','X','_']:
			s.ConstructionLine(point1=(-100.0, 0), point2=(100.0, 0))	## construction line as center line   对称轴是Y方向

		s.FixedConstraint(entity=s.geometry[2])

		s.retrieveSketch(sketch=sketch)  ## retrieve method

		if solid == True:
			## Base feature = Solid and Revolve
			p.BaseSolidRevolve(sketch=s, angle=angle, flipRevolveDirection=counter_clock)   ## may slow
		else:
			p.BaseShellRevolve(sketch=s, angle=angle, flipRevolveDirection=counter_clock)

		s.unsetPrimaryObject()

	else:
		sketch.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
		if axis in ['Y','V']:
			sketch.ConstructionLine(point1=(0.0, -100.0), point2=(0.0, 100.0))	## construction line as center line   对称轴是Y方向
		elif axis in ['H','X']:
			sketch.ConstructionLine(point1=(-100.0, 0), point2=(100.0, 0))	## construction line as center line   对称轴是Y方向

		sketch.FixedConstraint(entity=sketch.geometry.values()[-1])

		if solid == True:  ## 参考p.SolidExtrude()
			p.SolidRevolve(sketch=sketch,sketchPlane=sketch0['datum_plane'],sketchUpEdge=sketch0['right_edge'],sketchPlaneSide=sketch0['side'],
				sketchOrientation=RIGHT, angle=angle, flipRevolveDirection=counter_clock)
		else:
			p.ShellRevolve(sketch=sketch,sketchPlane=sketch0['datum_plane'],sketchUpEdge=sketch0['right_edge'],sketchPlaneSide=sketch0['side'],
				sketchOrientation=RIGHT, angle=angle, flipRevolveDirection=counter_clock)

	p = _m.parts[partname]
	if solid == False and rigid == True:
		p.setValues(space=THREE_D,  type=DISCRETE_RIGID_SURFACE)  ## 离散刚体

	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=p)

	return partname

def right_edge_of_datum_plane(p,plane=None,ndir=None,sketch_right=None):
	## VER: 2016-07-08, v2.3
	## reference: create_right_edge()

	p = check_part(p)

	if type_of(ndir) == 'STR' and len(ndir) == 2:
		raise Exception('ndir should be one char: x,y,or z')

	if type_of(plane) == 'DATUMPLANE':
		ndir = plane.normal

	elif type_of(plane) == 'STR':
		plane = plane.upper()

	lenx, leny, lenz = spans_of_poi(p)
	if lenx != 0:
		lenx += 5
	else:
		lenx = 500  ## sheet size

	if leny != 0:
		leny += 5
	else:
		leny = 500

	if lenz != 0:
		lenz += 5
	else:
		lenz = 500

	if is_location(ndir):
		x0,y0,z0 = ndir
		x0 = abs(x0)
		y0 = abs(y0)
		z0 = abs(z0)

		max0 = max(x0,y0,z0)
		if PK(max0,x0) == 0:
			ndir = 'x'
		elif PK(max0,y0) == 0:
			ndir = 'y'
		elif PK(max0,z0) == 0:
			ndir = 'z'

##	print fnln(),'ndir=',ndir
##	print fnln(),'sketch_right=',sketch_right

	if ndir == 'z' or plane == 'XYO' or plane == 'XOY':
		if is_number(sketch_right):
			right_loc = sketch_right + 5
		else:
##			right_loc = max(2000,x2)
			right_loc = int(lenx + leny)

		p.DatumPointByCoordinate(coords=(right_loc, 0, 0))    ## 如果border_x不够大导致要生成的几何位置超过border_x，就会往相反方向建草图。这是错的。
		p.DatumPointByCoordinate(coords=(right_loc, 5, 0))	;changing  ## origin = 100

##		p.DatumPointByCoordinate(coords=(border_x, 0, 0))
##		p.DatumPointByCoordinate(coords=(border_x, 100, 0))

##		print ' '
##		print '           Y                      '
##		print '           A                      '
##		print '           |                      '
##		print '          o|________ X            '
##		print ' '

	elif ndir == 'y' or plane == 'XOZ' or plane == 'ZOX':
##		p.DatumPointByCoordinate(coords=(border_x, 0, 100))	; please_check
##		p.DatumPointByCoordinate(coords=(border_x, 0, 0))

		if is_number(sketch_right):
			right_loc = sketch_right + 5
##			right_loc = sketch_left - 5
		else:
			right_loc = int(lenz + lenx)
##			right_loc = -int(lenz + lenx)

		p.DatumPointByCoordinate(coords=(right_loc, 0, 5))	;changing  ## origin = 100
		p.DatumPointByCoordinate(coords=(right_loc, 0, 0))

##		print ' '
##		print '          o__________ X           '
##		print '           |                      '
##		print '           |                      '
##		print '           V                      '
##		print '           Z                      '
##		print ' '

	elif ndir == 'x' or plane == 'OYZ' or plane == 'YOZ':   ## 横坐标是Y，所以Y取最大值border_y
##		p.DatumPointByCoordinate(coords=(0,border_y, 0))
##		p.DatumPointByCoordinate(coords=(0,border_y, 100))

##		p.DatumPointByCoordinate(coords=(0,leny, 0))
##		p.DatumPointByCoordinate(coords=(0,leny, 100))

		if is_number(sketch_right):
			right_loc = sketch_right + 5
		else:
##			right_loc = max(2000,y2)
			right_loc = int(leny + lenz)

		p.DatumPointByCoordinate(coords=(0,right_loc, 0))
		p.DatumPointByCoordinate(coords=(0,right_loc, 5))		;changing  ## origin = 100

##		print ' '
##		print '           Z                      '
##		print '           |                      '
##		print '           |                      '
##		print '          o|________ Y            '
##		print ' '

	p.DatumAxisByTwoPoint(point1=p.datums[p.datums.keys()[-1]], point2=p.datums[p.datums.keys()[-2]])
	right_edge = p.datums[p.datums.keys()[-1]]

	return right_edge

def xend_faces(poi,y=None,z=None):
	## VER: 2013-12-03, v1.0
	return xmax_faces(poi,y=y,z=z) + xmin_faces(poi,y=y,z=z)

def xtilt(dx,deg):
	## VER: 2015-04-15, v1.1
	## dx的符号代表x的符号, deg代表y的符号

	global last_point

	if type_of(dx) == 'TUPLE' and dx[0] in ['x','X']:
		dx = dx[1] - last_point[0]
##	print fnln_fnln(),'last_point=',last_point
	print fnln_fnln(),'dx=',dx

	return get_dxdy(dx=dx,deg=deg)

function_labels['get_work_dir'] = 'directory','current','folder'
def get_work_dir():
	## VER: 2014-07-07, v1.0

	work_dir = os.path.abspath('.')
	work_dir = modify_string(work_dir,'\\', '/') + '/'		## Phython用"\\"来表示一个反斜杠字符'\'，而'\'并不是\本身(转义)。

	## 另外一个方法:
##	import os
##	work_dir = os.getcwd()  ## 'Z:\\A0282 new triangle verify\\compact619_OB'

	return work_dir

def xydata_of_nodes(nodes,variable=None,inst=None,step=-1,frame=-1,sort=None,name='xyData_nodes_1'):
	## VER: 2015-11-20, v1.1

	## Odb label is stored with index = label - 1, such as:
##	>>> nodes = oa.instances.values()[0].nodes
##	>>> nodes[720].label
##	721


##	>>> xydata_of_nodes(720,variable='COOR1')
##	7.66653251647949
##	>>> xydata_of_nodes(6201,variable='COOR1')
##	7.68087911605835
##	>>> xydata_of_nodes(6201,variable='U1')
##	-1.51171839237213
##	>>>

	nodes = tolist(nodes)
	num = len(nodes)
	if type_of(nodes[0]) == 'INT':
		if inst in empty:
			inst = oa.instances.keys()[0]
		inst = check_odb_inst(inst)

		if len(nodes) == 1:   ## request only one node
			nodes.append(1000)   ## temporary node label

		list1 = []
		for item in nodes:
			list1.append(inst.nodes[item-1])
		nodes = list1

	set_step_and_frame(step=step,frame=frame)

##	print fnln(),'variable=',variable
	if variable not in empty:
		plot_variable(variable)   ## Example: plot_variable('COOR3')

##	print 'sort=',sort
	path = path_from_odb_nodes(nodes=nodes,sort=sort)

	name = new_key(session.xyDataObjects.keys(),name)
	session.XYDataFromPath(name=name, path=path, includeIntersections=False,
	    pathStyle=PATH_POINTS, numIntervals=10, shape=DEFORMED,  labelType=TRUE_DISTANCE)

	xyData = session.xyDataObjects[name].data

	if num == 1:
		xyData = xyData[0][1]

	return xyData

function_labels['xyp_now'] = 'xyplot','chart','curve','xydata','session'
def xyp_now():
	## VER: 2017-06-13, v1.0

	vpnow = get_vpnow()
	xyp = vpnow.displayedObject

	if type_of(xyp) != 'XYPLOT':
		raise Exception('*** No xyplot displayed.')

	return xyp

function_labels['xycurve_now'] = 'xyplot','chart','curve','xydata','session'
def xycurve_now():
	## VER: 2017-06-13, v1.0

	xyp = xyp_now()
	curves = xyp.curves.values()

	return curves

function_labels['xydata_now'] = 'xyplot','chart','curve','xydata','session'
def xydata_now():
	## VER: 2017-06-13, v1.0

	xyp = xyp_now()
	curves = xyp.curves.values()

	xydata = []
	for curve in curves:
		xydata.append(curve.data)

	return xydata

function_labels['chart_now'] = 'xyplot','chart','curve','xydata','session'
def chart_now():
	## VER: 2017-06-13, v1.0
	## 如果xyplot的所有curve都被删除(删除相应的xydata, 在xydata manager中)，则xyplot的横坐标和纵坐标自动也跟着删除。
	## 但chart本身并不自动跟着被删除。也就是说，此时的chart为空白屏，没有坐标轴，也没有曲线。当然此时，也就不能设置横坐标与纵坐标。
##	>>> chart.axes1
##	()
##	>>> chart.axes2
##	()
##	>>>

	xyp = xyp_now()
	charts = xyp.charts.values()
	if len(charts) == 0:
		raise Exception('*** No chart in the xyplot')

	if len(charts) > 1:
		raise Exception('*** More than one chart in the xyplot.')

	chart = charts[0]
	if len(chart.curves) == 0:
		print '*** No curves and axis in the plot yet.'

	return chart

function_labels['axis_x_now'] = 'xyplot','chart','curve','xydata','session'
def axis_x_now():
	## VER: 2017-06-13, v1.0

	chart = chart_now()
	if len(chart.curves) > 0:
		axis = chart.axes1[0]
	else:
		raise Exception('*** No x axis in the chart.')

	return axis

function_labels['axis_y_now'] = 'xyplot','chart','curve','xydata','session'
def axis_y_now():
	## VER: 2017-06-13, v1.0

	chart = chart_now()
	if len(chart.curves) > 0:
		axis = chart.axes2[0]
	else:
		raise Exception('*** No x axis in the chart.')

	return axis

def xyplot_curves_to_file(filename='',update=True):
	## VER: 2014-09-01, v1.2

	viewport = get_vpnow()
	dpo = get_dpo()
	if type_of(dpo) != 'XYPLOT':
		raise Exception('*** xyplot viewport is required.')

	curves = dpo.curves.values()

	datas = {}
	for i in range(len(curves)):
		curve = curves[i]
		data = curve.data.data
		datas[i] = data

	num = len(datas[0])

	screen()

	work_dir = get_work_dir()
	if filename in empty:
		if len(session.viewports) == 1:
			filename = odb_file_title
		else:
			filename = curves[0].data.fileName
			filename = filename[:-4]   			## remove '.odb'
			loc = filename.rfind('/')
			filename = filename[loc + 1:]

		variables = get_xyplot_variables()
		filename = filename + '_' + variables

	path0 = viewport.odbDisplay.name   ## use the odb direction as the base directory.
	loc = path0.rfind('/')
	path = real_dir(path0[:loc])

	time1 = time_slot()
	filename = path + '/images/xyplot/' + filename + '_' + time1 + '.txt'

	filename = check_file_name(filename,format='TXT')
	if update == True:
		create_xyplot_annotation(viewport=viewport,text='Fig.' + time1, xloc=40, yloc=30)

##	print fnln(),'filename=',filename
	sys.stdout = open(filename,'w')

	for i in range(num):
		print datas[0][i][0], '   ',
		for curve_id in datas.keys():
			print datas[curve_id][i][1], '   ',
		print

	screen()

	path, name, extension = split_file_path(filename)
	print ' '
	print fnln(),'curve datas saved in'
	print name + '.' + extension
	print path

	return	name


def yend_faces(poi,x=None,z=None):
	## VER: 2013-12-03, v1.0
	return ymax_faces(poi,x=x,z=z) + ymin_faces(poi,x=x,z=z)

def xytilt_test(dim=None,angle=None):
	## VER: 2016-9-22,v1.0
	## 检查xytilt1(),xytilt2(),xytilt3(),xytilt4()的结果的一致性

	if dim in empty:
		dim = 1.0

	if angle in empty:
		angle  = 45

	for i in [1,2,3,4]:
		name = 'xytilt' + str(i)
		func = eval(name)

		print '-----------------------------'
		print 'xytilt' + str(i) + ':'
		print func(dy=dim,Ay=angle)
		print func(dy=-dim,Ay=angle)
		print func(dy=dim,Ay=-angle)
		print func(dy=-dim,Ay=-angle)
		print '--'
		print func(dx=dim,Ay=angle)
		print func(dx=-dim,Ay=angle)
		print func(dx=dim,Ay=-angle)
		print func(dx=-dim,Ay=-angle)
		print ' '

	return

def xytilt1(start=(),dx=0,dy=0,Ax=0,Ay=0,x1=None,x2=None,y1=None,y2=None,x=None,y=None):
	## VER: 2017-07-26, v1.4  从原点开始, 第一象限的生长

	if start not in empty and is_location(start) == False:
		raise Exception('*** start should be a location.')

	code = get_caller_code()
	loc = code.find('xytilt3')
	code = code[:loc]
	num = code.count(',')
	if num >= 2:
		first_loc = False
	else:
		first_loc = True

	if is_number(x) or is_number(y):
		if first_loc == False and start in empty:
			raise Exception('*** Please provide start loc, or ensure xytilt3() be the first loc, if target x or y is provided.')  ## 例如：add_points(xytilt4(y=0,Ay=steel_exit_angle),loc1)

	result = xytilt(start=start,dx=dx,dy=dy,x1=x1,x2=x2,y1=y1,y2=y2,x=x,y=y,Ax=abs(Ax),Ay=(Ay))

	dict1 = {}
	for key in result.keys():
		if key == 'DT':
			dx,dy = result[key]
			dict1[key] = (abs(dx),abs(dy))  ## 假如人为输入有正有负，将强力纠错
		elif key == 'DX':
			dict1[key] = abs(dx)
		elif key == 'DY':
			dict1[key] = abs(dy)

	result2 = dict1
	if start not in empty:
		result2 = [start,dict1]

	return result2

def xytilt2(start=(),dx=0,dy=0,Ax=0,Ay=0,x1=None,x2=None,y1=None,y2=None,x=None,y=None):
	## VER: 2017-07-26, v1.4  从原点开始, 第二象限的生长

	if start not in empty and is_location(start) == False:
		raise Exception('*** start should be a location.')

	code = get_caller_code()
	loc = code.find('xytilt3')
	code = code[:loc]
	num = code.count(',')
	if num >= 2:
		first_loc = False
	else:
		first_loc = True

	if is_number(x) or is_number(y):
		if first_loc == False and start in empty:
			raise Exception('*** Please provide start loc, or ensure xytilt3() be the first loc, if target x or y is provided.')  ## 例如：add_points(xytilt4(y=0,Ay=steel_exit_angle),loc1)

	result = xytilt(start=start,dx=dx,dy=dy,x1=x1,x2=x2,y1=y1,y2=y2,x=x,y=y,Ax=Ax,Ay=Ay)

	dict1 = {}
	for key in result.keys():
		if key == 'DT':
			dx,dy = result[key]
			dict1[key] = (-abs(dx),abs(dy))  ## 假如人为输入有正有负，将强力纠错
		elif key == 'DX':
			dict1[key] = -abs(dx)
		elif key == 'DY':
			dict1[key] = abs(dy)

	result2 = dict1
	if start not in empty:
		result2 = [start,dict1]

	return result2

def xytilt3(start=(),dx=0,dy=0,Ax=0,Ay=0,x1=None,x2=None,y1=None,y2=None,x=None,y=None):
	## VER: 2017-07-26, v1.4  从原点开始, 第三象限的生长

	if start not in empty and is_location(start) == False:
		raise Exception('*** start should be a location.')

	code = get_caller_code()
	loc = code.find('xytilt3')
	code = code[:loc]
	num = code.count(',')
	if num >= 2:
		first_loc = False
	else:
		first_loc = True

	if is_number(x) or is_number(y):
		if first_loc == False and start in empty:
			raise Exception('*** Please provide start loc, or ensure xytilt3() be the first loc, if target x or y is provided.')  ## 例如：add_points(xytilt4(y=0,Ay=steel_exit_angle),loc1)

	result = xytilt(start=start,dx=dx,dy=dy,x1=x1,x2=x2,y1=y1,y2=y2,x=x,y=y,Ax=Ax,Ay=Ay)
##	print fnln(),'result=',result  ## result= {'DT': (2.46857772991851, -14)}

	dict1 = {}
	for key in result.keys():
		if key == 'DT':
			dx,dy = result[key]
			dict1[key] = (-abs(dx),-abs(dy)) ## 假如人为输入有正有负，将强力纠错
		elif key == 'DX':
			dict1[key] = -abs(dx)
		elif key == 'DY':
			dict1[key] = -abs(dy)

	result2 = dict1
	if start not in empty:
		result2 = [start,dict1]

	return result2

def xytilt4(start=(),dx=0,dy=0,Ax=0,Ay=0,x1=None,x2=None,y1=None,y2=None,x=None,y=None):
	## VER: 2017-07-26, v1.4  从原点开始, 第四象限的生长

##	## 由于强力纠错，结果与dx,dy及角度输入的正负无关了，很方便
##	>>> xytilt4(dy=2.54,Ay=45)
##	{'DT': (2.54, -2.54)}
##	>>> xytilt4(dy=-2.54,Ay=45)
##	{'DT': (2.54, -2.54)}
##	>>> xytilt4(dy=-2.54,Ay=-45)
##	{'DT': (2.54, -2.54)}
##	>>> xytilt4(dy=2.54,Ay=-45)
##	{'DT': (2.54, -2.54)}
##	>>>

##	connect_points(s1,loc0,xytilt4(y=0,Ay=steel_exit_angle),loc1)
##	此时将会触发错误，因为connect_points()的各个参数并不是按照先后顺序来读的，因此last_point并不是这里的loc0

	if start not in empty and is_location(start) == False:
		raise Exception('*** start should be a location.')

	code = get_caller_code()
	loc = code.find('xytilt3')
	code = code[:loc]
	num = code.count(',')
	if num >= 2:
		first_loc = False
	else:
		first_loc = True

	if is_number(x) or is_number(y):
		if first_loc == False and start in empty:
			raise Exception('*** Please provide start loc, or ensure xytilt3() be the first loc, if target x or y is provided.')  ## 例如：add_points(xytilt4(y=0,Ay=steel_exit_angle),loc1)

	result = xytilt(start=start,dx=dx,dy=dy,x1=x1,x2=x2,y1=y1,y2=y2,x=x,y=y,Ax=Ax,Ay=Ay)
##	print fnln(),'result=',result

	dict1 = {}
	for key in result.keys():
		if key == 'DT':
			dx,dy = result[key]
			dict1[key] = (abs(dx),-abs(dy))  ## 假如人为输入有正有负，将强力纠错
		elif key == 'DX':
			dict1[key] = abs(dx)	## 原点往第4象限走，总有dx>0
		elif key == 'DY':
			dict1[key] = -abs(dy)  	## 原点往第4象限走，总有dy<0

	result2 = dict1
	if start not in empty:
		result2 = [start,dict1]

	return result2

def xytilt(start=(),dx=0,dy=0,Ax=0,Ay=0,x1=None,x2=None,y1=None,y2=None,x=None,y=None):
	## VER: 2017-07-26, v1.8 不能直接给出最终的x或y来，因为一个参数的值不能依赖于同一次调用中的另外一个参数的值。
	## Ax: angle with Axis x, if negative, then x decreases.
	## Ay: angle with axis y, if negative, then y decreases.

##	>>> str1 = 'aabc'
##	>>> str1.count('a')
##	2
##	>>> str1.count('b')
##	1
##	>>>

	## Example:
##	s1 = create_base_sketch('sk_tpunch')
##	loc0 = (tpunch_OD/2.0 + 0.5, 0)
##	locs = connect_points(s1, loc0, (x,tpunch_OD/2.0), (dx,-tpunch_land), xytilt(dx=-die_R + tpunch_mid_D/2, Ay=tpunch_land_angle),
##		xytilt(dy=tpunch_mid2top,Ax=-tpunch_cap_angle), (x, 0))

	## start0是斜线的起始点的坐标位置
	if is_number(x) or is_number(y) or start not in empty:
		if start in empty:
			if 'last_point' not in globals().keys():
				raise Exception('*** last_point is not defined.')
			elif is_location(last_point) == False:
				raise Exception('*** last_point should be a location.')
			start = last_point
		elif is_location(start) == False:
			raise Exception('*** start0 should be known location.')

		if is_number(x):
			dx = x - start[0]

		if is_number(y):
			dy = y - start[1]

##	print fnln(),'dx=',dx
##	print fnln(),'dy=',dy

	loc = {}
	if is_numbers(x1,x2):
		dx = x2 - x1

	if is_numbers(y1,y2):
		dy = y2 - y1

##	caller = caller_name()
##	print fnln(),'caller=',caller
##	raise Exception

##	if caller == 'xytilt4': ## dx>0,dy<0
##		if dx != 0:   ## 已知dx求dy，保证所有角度都为负，因为dy<0
##			Ax = -abs(Ax)
##			Ay = -abs(Ay)
##		elif dy != 0: ## 已知dy求dx，保证所有角度都为正，因为dx>0
##			Ax = abs(Ax)
##			Ay = abs(Ay)
##
##	elif caller == 'xytilt3': ## dx<0,dy<0
##		Ax = -abs(Ax)
##		Ay = -abs(Ay)
##
##	elif caller == 'xytilt2': ## dx<0,dy>0
##		if dx != 0:  ## 已知dx求dy，保证所有角度都为正，因为dy>0
##			Ax = abs(Ax)
##			Ay = abs(Ay)
##		elif dy != 0: ## 已知dy求dx，保证所有角度都为负，因为dx<0
##			Ax = -abs(Ax)
##			Ay = -abs(Ay)
##
##	elif caller == 'xytilt1': ## dx>0,dy>0
##		Ax = abs(Ax)
##		Ay = abs(Ay)

	## 只接受锐角
	if Ax!= 0 and abs(Ax) > 90:
		raise Exception('*** Angle with axis X should be < 90')

	if Ay != 0 and abs(Ay) > 90:
		raise Exception('*** Angle with axis Y should be < 90')

	if dx !=0:  ## 求Ax进而求dy, dy的正负取决于角度Ax的正负
		if Ay > 0:
			Ax = 90-Ay
		elif Ay < 0:
			Ax = -(90+Ay)

		if Ax !=0:
			loc = dxAx(dx=dx,Ax=Ax)
		else:
			if Ay == 0:
				loc = {'DX':dx}
			else:
				raise Exception('*** Incorrect Ax.')

	elif dy !=0:  ## 求Ay进而求dx, dx的正负取决于角度Ay的正负
		if Ax > 0:
			Ay = 90-Ax
		elif Ax < 0:
			Ay = -(90+Ax)

		if Ay !=0:
			loc = dyAy(dy=dy,Ay=Ay)
		else:
			if Ax == 0:
				loc = {'DY':dy}
			else:
				raise Exception('*** Incorrect Ay.')

	if loc in empty:
		raise Exception('*** Fail to get the loc for tilt')

	return loc

def ytilt(dy,deg):
	## VER: 2015-04-15, v1.1, 用于草图。
	## y方向的竖直边变成了斜边
	## if dist < 0: dy < 0
	## if deg < 0: dx < 0

	global last_point

	if type_of(dy) == 'TUPLE' and dy[0] in ['y','Y']:
		dy = dy[1] - last_point[1]

	return get_dxdy(dy=dy,deg=deg)

def zend_faces(poi,x=None,y=None):
	## VER: 2013-12-03, v1.0
	return zmax_faces(poi,y=y,x=x) + zmin_faces(poi,y=y,x=x)

def xlocs(poi,x=None,y=None,z=None,nx=None,ny=None,nz=None,pointOn=False,loc=None,axis=None):
	## VER: 2014-12-29, v1.2
	## reference: xlocs(),ylocs(),zlocs(),locs_of_poi(),loc_at()

	## locs = xlocs(powder,ny=-1,x=(MIN1,MAX1))
	## [10.347359, 11.110957, 11.158772]

	if loc == True:
		pointOn = True
	elif loc == False:
		pointOn = False

	if axis == True:
		pointOn = False
	elif axis == False:
		pointOn = True

	if is_poi(poi) and is_sketch(poi):
		print '** search for poi, not for sketch.'

	locs = locs_of_poi(poi,dir='x',x=x,y=y,z=z,pointOn=pointOn,nx=nx,ny=ny,nz=nz)

	return locs

def xlocs_sketch(sketch,y=None,pointOn=True,search_in='part',loc=None,axis=None):
	## VER: 2014-09-16, v1.1

	if loc == True:
		pointOn = True
	elif loc == False:
		pointOn = False

	if axis == True:
		pointOn = False
	elif axis == False:
		pointOn = True

	locs = locs_of_sketch(sketch,dir='x',y=y,pointOn=pointOn,search_in=search_in)

	return locs

def ylocs(poi,x=None,y=None,z=None,pointOn=False,loc=None,axis=None,nx=None,ny=None,nz=None):
	## VER: 2014-12-29, v1.3
	## reference: xlocs(),ylocs(),zlocs(),locs_of_poi(),loc_at()

	if loc == True:
		pointOn = True
	elif loc == False:
		pointOn = False

	if axis == True:
		pointOn = False
	elif axis == False:
		pointOn = True

	if is_poi(poi) and is_sketch(poi):
		print '** search for poi, not for sketch.'

	locs = locs_of_poi(poi,dir='y',x=x,y=y,z=z,pointOn=pointOn,nx=nx,ny=ny,nz=nz)

	return locs

def ylocs_sketch(sketch,x=None,pointOn=True,search_in='part',loc=None,axis=None):
	## VER: 2014-09-16, v1.1

	if loc == True:
		pointOn = True
	elif loc == False:
		pointOn = False

	if axis == True:
		pointOn = False
	elif axis == False:
		pointOn = True

	locs = locs_of_sketch(sketch,dir='y',x=x,pointOn=pointOn,search_in=search_in)

	return locs

def zlocs(poi,x=None,y=None,z=None,pointOn=False,loc=None,axis=None,nx=None,ny=None,nz=None):
	## VER: 2014-12-29, v1.2
	## reference: xlocs(),ylocs(),zlocs(),locs_of_poi(),loc_at()

	## Example:
##	locs_of_poi('powder',y=MID,groupX=MAX)  ## 结果:[(11.201, 26.78, 0.0)]

	if loc == True:
		pointOn = True
	elif loc == False:
		pointOn = False

	if axis == True:
		pointOn = False
	elif axis == False:
		pointOn = True

	locs = locs_of_poi(poi,dir='z',x=x,y=y,z=z,pointOn=pointOn,nx=nx,ny=ny,nz=nz)

	return locs

def xmax_faces(poi, y=None, z=None):

	## VER: ('VER: 2012-01-06, v1.0')

	poi = check_pias(poi)
	faces = faces_of_cut(poi, x=MAX, y=y, z=z)

	return faces

def rigid_to_deformable_part(part):
	## VER: 2013-05-17, v1.0
	## if a analytical rigid part is converted to deformable body, it will not convert back to analytical rigid, only to discrete rigid
	## discrete_rigid can convert to deformable body, and deformable body can also convert to discrete rigid. (both 2D and 3D)
	## Both analytical rigid and discrete rigid can convert to deformable body

	part = check_part(part)
	part.setValues(space=THREE_D, type=DEFORMABLE_BODY)

	return

def rotate_plane_to_datum_plane(face,edge,angle):
	## VER: 2013-12-19, v1.1

	if type_of(face) not in ['faces','DATUMPLANE']:
		raise Exception('*** a face is required.')

	if type_of(face)  == 'faces':
		curvature = get_curvature(face)
		if curvature not in empty:
			raise Exception('**Flat face is required to create a datum plane.')

	if type_of(edge) not in ['edges','DATUMAXIS']:
		raise Exception('*** Edge or datum axis is required.')

##	edges = faces_to_edges(face)
##	if edge not in edges:
##		raise Exception('*** One straight edge of the face is required.')

	poi = get_parent(face)
	if type_of(poi) == 'PINSTANCE':
		poi = a

	poi.DatumPlaneByRotation(plane=face, axis=edge, angle=angle)   ## angle  > 0: counter clock
	datum_index = poi.datums.keys()[-1]
	plane = poi.datums[datum_index]

	return plane

function_labels['rotate_inst_to_parallel'] = 'rotate','instance','angle','straightness','flatness','parallel','insert'
def rotate_inst_to_parallel(nodes=None,parallel='x',rotate_axis='z'):
	## VER: 2017-02-20, v1.2

	## Example: rotate_inst_to_parallel(nodes=v1,parallel='x',rotate_axis='z')
	## angle_of_pick_nodes(nodes=v1,axis='x')

	if nodes in empty:
		pick()
		nodes = v1

	else:
		if type_of(nodes) == 'STR':
			nodes = set2objs(a,nodes)

	parallel = parallel.lower()
	rotate_aixis = rotate_axis.lower()

	if parallel not in ['x','y','z']:
		raise Exception('*** parallel axis should be x,y or z.')

	if rotate_axis not in ['x','y','z']:
		raise Exception('*** rotate axis should be x, y, or z.')

	if parallel == rotate_axis:
		raise Exception('*** parallel axis should be vertical to rotate axis.')

	if type_of(nodes[0]) != 'nodes':
		raise Exception('*** please create the node set with two nodes in CAE.')

	poi = get_poi(nodes)
	if type_of(poi) != 'PINSTANCE':
		raise Exception('*** sets should be created in ASSEMBLY, since rotation of instance is easier.')

	if parallel == 'x':
		nodes = nodes_sort_byx(nodes)
	elif parallel == 'y':
		nodes = nodes_sort_byy(nodes)
	elif parallel == 'z':
		nodes = nodes_sort_byz(nodes)

##	center = nodes[0].coordinates
	x0,y0,z0 = _xmid(nodes),_ymid(nodes),_zmid(nodes)
##	center = (0,0,0)
	angle1 = angle_of_pick_nodes(nodes=nodes,axis=parallel)

	print fnln(),'angle1=',angle1,'parallel=',parallel
	if angle1 < 1e-4:
		return
##	raise Exception

	if rotate_axis == 'y':
		center = (x0,0,z0)
		rotate_instances(poi,angle_y=angle1,rotate_center=center)
	elif rotate_axis == 'z':
##		raise Exception
		center = (x0,y0,0)
		rotate_instances(poi,angle_z=angle1,rotate_center=center)
	elif rotate_axis == 'x':
		center = (0,y0,z0)
		rotate_instances(poi,angle_x=angle1,rotate_center=center)

	angle2 = angle_of_pick_nodes(nodes=nodes,axis=parallel)
	print fnln(),'angle2=',angle2

	if angle2 > angle1:
		if rotate_axis == 'y':
			rotate_instances(poi,angle_y=-2*angle1,rotate_center=center)
		elif rotate_axis == 'z':
			rotate_instances(poi,angle_z=-2*angle1,rotate_center=center)
		elif rotate_axis == 'x':
			rotate_instances(poi,angle_x=-2*angle1,rotate_center=center)
		angle2 = angle_of_pick_nodes(nodes=nodes,axis=parallel)

	print fnln(),'before rotation, angle=',angle1
	print fnln(),'after parallel, angle=',angle2

##	light(nodes)

	return

def rotate_instances(insts=(),rotate_center=(),ref_face=None, ref_part=None, angle_x=None, angle_y=None, angle_z=None,rotation=None):
	## VER: ('VER: 2014-11-12, v1.6')
	## 角度单位，不是弧度单位。眼睛在拇指上方时（逆着旋转轴看），逆时针为正，顺时针为负。
	## 注意，只选择instance，并不选择part
	## 注意，很多时候，可以先进行load/BC,interact,mesh，然后在rotate_instances，此时前面的工作不受影响。
	## original instance will not be deleted.
	## reference: move_instances()
	## 对某个面施加载荷(包括重力场)与边界条件，然后旋转，不影响载荷与边界条件。例如，PV module systems
	## 例如；重力场为-z方向，旋转部件一定角度后，重力场仍然是-z方向

	## GUI操作: 选择一个instance，输入旋转轴的起点(如绕z轴旋转为(0,0,0))，输入旋转轴的终点(如绕z轴旋转为(0,0,1))，
	##          输入旋转角度（instance在旋转轴方向的负端，正角为逆时针旋转，负角为顺时针旋转）。完成。

	## Example:
	## rotate_instances(insts='crack_A1',angle_y=-45)
	## rotate_instances(angle_z=45)

	global _m, a

	insts = real_insts(insts)
	if insts in empty:
		insts = a.instances.values()	## 所有的instance都要旋转。

	inst_names = poi_names(insts)
	inst_names = totuple(inst_names)

	if angle_x==angle_y==angle_z==rotation==None:
		raise Exception('Rotation angle and axis are required.')
	elif rotate_center == rotation == None:
		raise Exception('Rotation center is required.')

	if rotation not in empty:
		rotate_center,dir1,angle = rotation
		axis = dir1

		a.translate(instanceList=inst_names, vector=rotate_center)

	else:
		if rotate_center in empty:
			if ref_face in empty:
				if ref_part not in empty:
					faces = face_select(ref_part,ndir='cylindrical')
				else:
					faces = face_select(insts[0],ndir='cylindrical')

				if faces not in empty:
					ref_face = faces[0]

			if ref_face not in empty:
				ndir0 = face_ndir(ref_face)
				if ndir0 != 'cylindrical':
					raise Exception('*** a cylindrical face is required.')
				else:
					rotate_center,vector0,axis = center_axis_of_cylind_face(ref_face)

		if rotate_center in empty:
			rotate_center = (0,0,0)  ## 如果对称中心就在(0,0,0)附近，则尽量不要用其他点来旋转。
			print 'rotate_center=',rotate_center

		axis = 'NA'
		if angle_x not in empty:
			axis = 'x'
			angle = angle_x
		elif angle_y not in empty:
			axis = 'y'
			angle = angle_y
		elif angle_z not in empty:
			axis = 'z'
			angle = angle_z

		if axis == 'x':
			dir1 = (1,0,0)
		elif axis == 'y':
			dir1 = (0,1,0)
		elif axis == 'z':
			dir1 = (0,0,1)

	a.rotate(instanceList=inst_names, axisPoint=rotate_center, axisDirection=dir1, angle=angle)

	if len(inst_names) == 1:
		inst_names = inst_names[0]

	if 'temp' not in inst_names:
		print fnln_fnln(),'--->',inst_names,'are rotated, center=',rotate_center, ', axis=',dir1, ', angle=',angle

	a.regenerate()   ## assembly changed.

	return (rotate_center, dir1, angle)

rotate_instance = rotate_instances

function_labels['simple_rotate'] = 'instance','rotate','angle','axis'
def simple_rotate(insts,axis=None,angle=None,angle_x=None,angle_y=None,angle_z=None,loc1=None,loc2=None,reference='',sign=1):
	## VER: 2017-05-03, v1.0

	insts = real_insts(insts)
	if insts in empty:
		raise Exception('*** insts required.')

	names = poi_names(insts)
	insts = tuple(names)
	print 'insts=',insts

##	angle = None
	end2 = None

	if type_of(axis) == 'STR':
		axis = axis.lower()
		if axis not in ['x','y','z']:
			raise Exception('*** rotate axis should be x,y or z')

		if axis == 'x':
			end2 = (1,0,0)
		elif axis == 'y':
			end2 = (0,1,0)
		elif axis == 'z':
			end2 = (0,0,1)

	if is_number(angle_x):
		end2 = (1,0,0)
		angle = angle_x
	elif is_number(angle_y):
		end2 = (0,1,0)
		angle = angle_y
	elif is_number(angle_z):
		end2 = (0,0,1)
		angle = angle_z

	if is_location(loc1) and is_location(loc2):
		reference = reference.lower()
		if reference not in ['x','y','z']:
			raise Exception('*** reference axis should be x,y or z')

		angle = vector_angle(start=loc1,end=loc2,axis=reference)
		angle = abs(angle)*sign

	if end2 in empty:
		raise Exception('*** rotate axis is required.')

	if angle in empty:
		raise Exception('*** rotate angle is required.')

	a.rotate(instanceList=insts, axisPoint=(0.0, 0.0, 0.0), axisDirection=end2, angle=angle)
	print '---> Rotated insts by angle=',angle

	return

def rotate_part(p,rotate_center=(),center_x=None,center_y=None,center_z=None, ref_face=None, angle_x=None, angle_y=None, angle_z=None, getRotation=(),default_center=False):
	## VER: ('VER: 2016-08-12, v3.7') 如果是为了测量角度而旋转，用rotate_instances()更好。
	## 角度单位，不是弧度单位。眼睛在拇指上方时（逆着旋转轴看），逆时针为正，顺时针为负。或者说，右手螺旋式前进为正。
	## rotate_part之后，原有的instance没有了，需要重新生成。
	## 返回(rotate_center, dir1, angle)，可以应用于后面的其他的part的选择，假如是同时选择的话。
	## 注意：shell的merge不支持。

	## Example: rotate_part(stamp,angle_x=90)
##	rotate_part(anvil, angle_x=45)

	## 掉个旋转180度后使某平面所在位置不变，例如：（好处是几个部件之间在位置上具有关联性）
	## p3 = copy_part('p2_product','p3')
	## rotate_part('p3',angle_x=180,center_z=MIN)   ## MIN => MAX
	## print _zmin('p2_product')  ## 19.99
	## print _zmax('p3')		## 19.99

	global _m, a

	p = check_part(p)

	for inst in a.instances.keys():
		if a.instances[inst].partName == p.name:
			del_insts(inst)

	if getRotation not in empty:
		rotate_center, dir1, angle = getRotation

	if is_empties(angle_x,angle_y,angle_z):
		raise Exception('Rotate angle is required.')

	if rotate_center in empty:
		if (center_x,center_y,center_z) != (None,None,None):
			center_x,center_y,center_z = real_xyz(p,center_x,center_y,center_z)
			rotate_center = [0,0,0]
			if is_number(center_x):
				rotate_center[0] = center_x
			if is_number(center_y):
				rotate_center[1] = center_y
			if is_number(center_z):
				rotate_center[2] = center_z

	if rotate_center in empty:
		if ref_face in empty:
			faces = face_select(p,ndir='cylindrical')
			if faces not in empty:
				ref_face = faces[0]

		if ref_face not in empty:
			ndir0 = face_ndir(ref_face)
			if ndir0 != 'cylindrical':
				raise Exception('*** a cylindrical face is required.')
			else:
				rotate_center,vector0,axis = center_axis_of_cylind_face(ref_face)

	if rotate_center in empty:
		rotate_center = (0,0,0)
		print 'rotate_center=',rotate_center

##		default_center = True
##		rotate_center = poi_centroid(p)
##		rotate_center = mids_of_poi(p)    ## sometimes will have problem if the location have floate number of 6

	if getRotation in empty:
		if angle_x not in empty:
			axis = 'x'
			angle = angle_x
		elif angle_y not in empty:
			axis = 'y'
			angle = angle_y
		elif angle_z not in empty:
			axis = 'z'
			angle = angle_z

		if axis == 'x':
			dir1 = (1,0,0)
		elif axis == 'y':
			dir1 = (0,1,0)
		elif axis == 'z':
			dir1 = (0,0,1)

	if angle == 0:
		print fnln_fnln(),'angle=0, part is not rotated.'
		return

	new_instance(p,'temp_A1')
	new_instance(p,'temp_A2')

	part_name = p.name

	a.rotate(instanceList=('temp_A1', ), axisPoint=rotate_center, axisDirection=dir1, angle=angle)
	a.rotate(instanceList=('temp_A2', ), axisPoint=rotate_center, axisDirection=dir1, angle=angle)
	merge_instances(partname=part_name,insts=['temp_A1','temp_A2'])

##	if default_center == True:
##		move_part(part_name,from_loc=mids_of_poi(part_name),to_loc=(0,0,0))

	if getRotation in empty:
		print '--->',part_name,'was rotated, angle=',angle,', axis=',axis
	else:
		print '--->',part_name,'was rotated, parameter getRotation=',getRotation

	update_part(part_name)

	return rotate_center, dir1, angle

def rotate_part_from_xysketch(p,ndir):
	## VER: 2012-10-24, v1.0	p的sketch的ndir必须是'z'，否则错误。这里假设p先用xysketch绘制好(例如fillet)，然后选择到另外的sketch方向。

	global _m, a

	p = check_part(p)
	partname = p.name

	if ndir == 'y':
		rotate_part(p,angle_x=90)
		p = _m.parts[partname]
	elif ndir == 'x':
		rotate_part(p,angle_y=-90)
		p = _m.parts[partname]

	create_RP(p,(0,0,0))

##	globals()[partname] = p
	vpnow = get_vpnow()
##	vpnow.setValues(displayedObject=p)

	cross_section_plot(ndir)

	return

function_labels['rotate_profile'] = 'flatness','straightness','insert','coords','angle','xyplot','xydata'
def rotate_profile(coords,ref_loc1=None,ref_loc2=None,left=None,right=None,angle=None,relative=None,filename='_coords_nodes.txt'):
	## VER: 2017-06-08, v1.3

##	nodes = set2objs(p1,'side1')
##	nodes1 = node_select(p1,nodes=nodes,z=MID,err=0.15)
##	coords = cae_coords_of_nodes(nodes=nodes1,axis='yx',sort=True,filename='_side1.txt')
##	>>> rotate_profile(coords,right=-4)
##	TUPLE has been printed to file Z:/A0282 new triangle verify/sinter/results/_list1.txt
##	values: min= 6.335774 , max= 6.360308 , gap= 0.024534
##	>>>

	if is_number(right):
		ref_loc2 = right
	if is_number(left):
		ref_loc1 = left

	if is_number(angle) == False:
		if ref_loc1 == None:
			ref_loc1 = 0
		if ref_loc2 == None:
			ref_loc2 = -1

	if is_integer(ref_loc1) and is_integer(ref_loc2) and angle in empty:
		ref_loc1 = coords[ref_loc1]
		ref_loc2 = coords[ref_loc2]
		x1,y1 = ref_loc1
		x2,y2 = ref_loc2
		angle = atan((y2-y1)/(x2-x1))

	if is_number(angle) == False:
		raise Exception('*** please provide the rotation angle')

	angle = -angle

	list1 = []
	values = []
	for i in range(len(coords)):
		x,y = coords[i]
		x1 = x*cos(angle) - y*sin(angle)
		y1 = y*cos(angle) + x*sin(angle)
		x1 = round(x1,6)
		y1 = round(y1,6)
		list1.append((x1,y1))
		values.append(y1)

	if relative == True:
		base = min(values)
		newlist = []
		for i in range(len(list1)):
			x1,y1 = list1[i]
			newlist.append((x1,y1-base))
		list1 = newlist

##	list_to_txt_lines(list1,filename=filename)

	list1 = totuple(list1)
	if 'XYPlot-1' in session.xyPlots.keys():
		del session.xyPlots['XYPlot-1']
	xyp = session.XYPlot('XYPlot-1')
##	xyp = session.xyPlots['XYPlot-1']
	chartName = xyp.charts.keys()[0]
	chart = xyp.charts[chartName]
	xQuantity = visualization.QuantityType(type=NONE)
	yQuantity = visualization.QuantityType(type=NONE)
	xy1 = xyPlot.XYData(data=list1,
	    sourceDescription='rotated profile', axis1QuantityType=xQuantity,
	    axis2QuantityType=yQuantity, )
	c1 = session.Curve(xyData=xy1)
	chart.setValues(curvesToPlot=(c1, ))
	session.viewports['Viewport: 1'].setValues(displayedObject=xyp)

	curve = xyp.curves.values()[-1]
	curvename = curve.name
	session.curves[curvename].symbolStyle.setValues(show=True)
	session.curves[curvename].symbolStyle.setValues(marker=FILLED_CIRCLE)
	session.curves[curvename].symbolStyle.setValues(size=2)
	session.curves[curvename].symbolStyle.setValues(color='#FF0000')

##	list_to_txt_lines(list1,filename=filename)
	loc = filename.rfind('.')
	name1 = filename[:loc]
	for item in list1:
		list2csv(name1,item,'ab')
	print ' '
	print '-->profile saved as ',name1 + '.csv'
	print 'values: min=',min(values),', max=',max(values),', gap=',max(values) - min(values)


	return list1


def rotated_vector(vector, angle=90):
	## VER: 2014-03-20, v1.0

	if type_of(vector) == 'edges':
		vector = edge_to_vector(vector)
	elif type_of(vector) == 'DATUMAXIS':
		vector = vector.direction

	if is_vector(vector) == False:
		raise Exception('*** A vector, straight edge, or datum axis is required.')

	from_axis = create_datum_axis(a, point1=(0,0,0), point2 = vector)
	point = create_datum_point(a, loc=(0,0,0))

	feature = a.DatumAxisByRotation(line=from_axis, point=point, angle=angle)
	axis = a.datums[feature.id]
	x0,y0,z0 = axis.direction

	x0 = round(x0,6)
	y0 = round(y0,6)
	z0 = round(z0,6)
	vector2 = x0, y0, z0

	return vector2

def round6(*nums):
	## VER: 2011-04-01, v1.0 避免出现诸如979.000000000001，484.999999999999这种数据

	type1 = 'NA'
	if type_of(nums[0]) == 'TUPLE':
		type1 = 'tuple'

	nums = tolist(nums)
	newlist = []
	for num in nums:
		newlist.append(round(num,6))

	nums = newlist
	if len(nums) == 1:
		nums = nums[0]

	if type1 == 'tuple':
		nums = tuple(nums)

	return nums

def round5(*nums):
	## VER: 2014-05-04, v1.0 避免出现诸如979.000000000001，484.999999999999这种数据

	nums = tolist(nums)
	newlist = []
	for num in nums:
		newlist.append(round(num,5))

	nums = newlist
	if len(nums) == 1:
		nums = nums[0]

	return nums

def round_corner(part,loc=(),radius=1, x=None,groupY=None, y=None, groupX=None):
	## VER: 2014-10-29, v1.1
	## reference: round_edges() for 3D model
	## Example: round_corner(nib,x=MAX,groupY=MIN,radius=cut_round)  ## nib is 2D

	part = check_part(part)
	if '2D' not in part_shape(part)[1]:
		raise Exception('*** Please use round_edges() instead.')
	partshape = part_shape(part)[1]
	if 'axisym' in partshape:
		symm = True
	else:
		symm = False

	if is_location(loc) == True:
		if len(loc) == 3:
			loc == loc[0],loc[1]
	partname = part.name

	sketch = shellpart_to_sketch(part,sketchname='sk_' + partname)
	if loc in empty:
		loc = find_loc(sketch,x=x,groupY=groupY,y=y,groupX=groupX)
		if is_location(loc) == False:
			raise Exception('*** corner location is required.')

	round_sketch_corner(sketch,loc=loc,radius=radius)
	partname1 = sketch_to_shell(sketch,partname=partname,symmetric=symm)
	del_parts(partname)
	rename(_part(partname1),partname)
	get_current_model()

	return

def round_edges(part,edges=None,vertices=None, radius=1,x=None,y=None,z=None,edir=None):
	## VER: 2013-12-26, v1.6. 生成倒角。该角应该是凸角。
	## 仅对3D模型适用，对2D模型不适用。use round_sketch_corner() instead.
	## reference: round_corner() for 2D model

	## Example
##	edges = edge_select(ejector,D=land_ID)
## 这些edges其实属于一个完整的圆弧的一部分，此时，只能选择其中一条进行倒角，但效果是整个圆弧（其他连接线)都被倒角了。
##	round_edges(ejector, edges=edges[0], radius=0.05)


	## edges are parallel to the rounded surface.

	if not (type_of(radius) in numerics and radius > 0):
		print '**** radius is required for round_edges'
		return

	if type_of(edges) == 'PART':
		part,edges = edges,part

	part = check_part(part)
	pshape = part_shape(part)[1]
	partname = part.name

	if 'solid' in pshape:
		if edges in empty:
			edges = edge_select(part,x=x,y=y,z=z,edir=edir)
		else:
			if edir not in empty:
				edges = edge_select(part,edges=edges, edir=edir)

		if edges in empty:
			raise Exception('**** empty edges for corner_round')

		part.Round(radius=radius, edgeList=totuple(edges))

	elif '2D_wire' in pshape:
		vertices = tolist(vertices)
		if vertices in empty:
			vertices = vertice_select(part,x=x,y=y,z=z)

		if vertices in empty:
			raise Exception('**** empty vertices for corner_round')

		part.Round(radius=radius, vertexList=totuple(vertices))

	elif '2D_shell' in pshape:
		vertices = tolist(vertices)
		sketch1 = shellpart_to_sketch(part,sketchname='s_temp')
		part_w = sketch_to_wirepart1(sketch=sketch1,partname='p_temp')
		if vertices not in empty:
			locs = []
			for vertice in vertices:
				locs.append(vertice.pointOn[0])

			pts = []
			for loc in locs:
				pt = _m.parts[part_w].vertices.findAt(coordinates=loc, printWarning=False)
				if type_of(pt) == 'vertices':
					pts.append(pt)

			vertices = pts

		if vertices in empty:
			vertices = vertice_select(part_w,x=x,y=y,z=z)

		if vertices in empty:
			raise Exception('**** empty vertices for corner_round')

		_m.parts[part_w].Round(radius=radius, vertexList=totuple(vertices))

		partname = part.name
		del_parts(part)

		sketch2 = wirepart_to_sketch(part_w)
		part_s = sketch_to_shellpart(sketch2)
##		change_part_name(part_s,newname=partname)
		rename(_m.parts[part_s], partname)
		del_parts(part_w)

	clear_empty_sets(partname)

	print '--->Edges are rounded for',partname, ', radius=',radius

	return

def round_grow(p,ndir,center0, R0= 1, R1= 5, corner=(-1,1), depth1=100):
	## VER: 2011-09-20, v1.3

	flip = OFF   ## 正轴向生长
	if ndir == 'x':
		offset = center0[0]
	elif ndir == 'y':
		offset = center0[1]
	elif ndir == 'z':
		offset = center0[2]

	## conver 3D points to sketch points
	center0 = threeD_to_sketch_points(center0,ndir)
	x = center0[0];	y = center0[1]

	x1 = corner[0]
	y1 = corner[1]

	if ndir == 'x' or ndir == 'y':
		corner = (-x1,y1)
	elif ndir == 'z':
		corner = (y1,x1)

	if corner == (-1,1):
		pt1 = (x - R1, y)
		pt2 = (x, y + R1)
		pt3 = (x - R0, y)
		pt4 = (x, y + R0)
	elif corner == (1,1):
		pt1 = (x, y + R1)
		pt2 = (x + R1,y)
		pt3 = (x, y + R0)
		pt4 = (x + R0, y)
	elif corner == (1,-1):
		pt1 = (x + R1, y)
		pt2 = (x, y - R1)
		pt3 = (x + R0, y)
		pt4 = (x, y - R0)
	elif corner == (-1,-1):
		pt1 = (x, y - R1)
		pt2 = (x - R1, y)
		pt3 = (x, y - R0)
		pt4 = (x - R0, y)

	circle_dir = CLOCKWISE

	## create blank sketch
	sketch = create_part_sketch(p,ndir,offset)
	s = sketch['sketch']
	datum_plane1 = sketch['datum_plane']
	right_edge1 = sketch['right_edge']
	side1 = sketch['side']

	## draw lines
	s.ArcByCenterEnds(center=center0, point1=pt1, point2=pt2, direction=circle_dir)
	s.ArcByCenterEnds(center=center0, point1=pt3, point2=pt4, direction=circle_dir)
	s.Line(point1=pt1, point2=pt3)
	s.Line(point1=pt2, point2=pt4)

	## extrude
	p.SolidExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1,
	    sketchPlaneSide=side1, sketchOrientation=RIGHT, sketch=s, depth=abs(depth1),
	    flipExtrudeDirection=flip, keepInternalBoundaries=ON)
##	del s

	print '--->Rounded grow in',ndir

	return

def RP2region(inst=None,RP=None):
	## VER: 2015-04-23, v1.2

	if type_of(inst) == 'referencePoints':
		inst,RP = RP,inst

	if is_RP(RP):
		tuple1 = (RP,)
		region1=regionToolset.Region(referencePoints=tuple1)
	else:
		inst = check_inst(inst)
		if len(inst.referencePoints) == 0:	## created in part, but used the referencePoint of instant
			RP = create_RP(inst)
##			raise Exception('*** reference point is required.')
		else:
			RP = inst.referencePoints.values()[0]

		tuple1 = (RP,)
		region1=regionToolset.Region(referencePoints=tuple1)

	return region1

def RPx(p):
	## VER: 2010-02-12
	if type_of(p) != 'PART':
		print fnln_fnln(),'******Part is needed for the RPx() function.'
		error_record('RPx()')
	return p.features['RP'].xValue

def RPy(p):
	## VER: 2010-02-12
	if type_of(p) != 'PART':
		print fnln_fnln(),'******Part is needed for the RPy() function.'
		error_record('RPy()')
	return p.features['RP'].yValue

def RPz(p):
	## VER: 2010-02-12
	if type_of(p) != 'PART':
		print fnln_fnln(),'****Part is needed for the RPz() function'
		error_record('RPz()')
	return p.features['RP'].zValue

def round_loc(loc,num=8):
	## VER: 2017-08-03, v1.3
	## 慎用，可能会影响connect_points()精度，也可能会影响find_loc()的结果
	## 考虑用int6()

	if is_location(loc) == False:
		raise Exception('*** location is required.')

	if len(loc) == 2:
		x0,y0 = loc
		if num< 6:
			x0 = round(x0,num)
		else:
			x0 = int6(x0)

		if num<6:
			y0 = round(y0,num)
		else:
			y0 = int6(y0)

		if PK(x0,0) == 0:
			x0 = 0
		if PK(y0,0) == 0:
			y0 = 0
		loc = (x0,y0)

	elif len(loc) == 3:
		x0,y0,z0 = loc
		if num< 6:
			x0 = round(x0,num)
		else:
			x0 = int6(x0)

		if num<6:
			y0 = round(y0,num)
		else:
			y0 = int6(y0)

		if num<6:
			z0 = round(z0,num)
		else:
			z0 = int6(z0)

		if PK(x0,0) == 0:
			x0 = 0
		if PK(y0,0) == 0:
			y0 = 0
		if PK(z0,0) == 0:
			z0 = 0

		loc = (x0,y0,z0)

	return loc

def round_locs(locs):
	## VER: 2015-04-20, v1.0

	locs = totable(locs)

	locs1 = []
	for loc in locs:
		loc1 = round6(loc)
		locs1.append(loc1)

	return locs1

def round_sketch_corner(sketch,curve1=None, curve2=None, radius=1, H=None, V=None, vertex=None, loc=None,ndir='z'):
	## VER: 2014-10-31, v1.6
	## Example: round_sketch_corner('s_punch',radius=0.18, loc=find_loc('s_punch',y=MIN,groupX=MIN))
	## round_sketch_corner(s1,radius=corner_radius, loc=point3[0])

	sketch = check_sketch(sketch)

	if radius < 0.001:
		return

	if H not in empty and V not in empty:
		H,V = real_xy_sketch(sketch,H=H,V=V)

	if type_of(H) in numerics and type_of(V) in numerics:
		loc = (H,V)

	if type_of(vertex) == 'vertices':
		loc = vertex.coords

	if type_of(loc) == 'vertices':
		loc = loc.coords

	print fnln(),'loc=',loc
##	print fnln(),'vertex=',vertex
##
##	stop1()

	if loc in empty and vertex in empty:
		raise Exception('**** corner location or vertex is required.')

##	raise Exception

	H,V = loc
	if ndir == 'y':
		loc = (H,-V)

	if curve1 in empty or curve2 in empty:
		curves = geometry_at(sketch,loc=loc,vertex=vertex,ID=False)
		if len(curves) != 2:
			raise Exception('**** Cannot find two curves at location= ' + str(loc))
		curve1,curve2 = curves

	x0,y0 = loc
	x1,y1 = curve1.pointOn
	x2,y2 = curve2.pointOn
##	point1 = (x0+x1)/2, (y0+y1)/2
##	point2 = (x0+x2)/2, (y0+y2)/2

	point1 = x0 + (x1-x0)*0.1, y0 + (y1-y0)*0.1
	point2 = x0 + (x2-x0)*0.1, y0 + (y2-y0)*0.1


	all_geometry = all_regular_geometry(sketch)
	if curve1 in all_geometry and curve2 in all_geometry:
		sketch.FilletByRadius(radius=radius, curve1=curve1, curve2=curve2, nearPoint1=point1, nearPoint2=point2)

	return

def RPxyz(RP):
	## VER: ('VER: 2014-06-26, v1.3')

	## Example
##	>>> RPxyz(bpunch)
##	(0.0, -10.19, 0.0)
##	>>>

	feature = RP
	if type_of(RP) != 'FEATURE':
		if type_of(RP) == 'referencePoints':
			feature = obj_to_feature(RP)
		else:
			poa = check_pias(RP)
			if type_of(poa) == 'PINSTANCE':
				poa = poa.part
			RPs = poa_feature_objs(poa)['RPs']
			if RPs not in empty:
				RP = RPs[0]
				feature = obj_to_feature(RP)

	if type_of(feature) != 'FEATURE':
		loc = (0,0,0)	;please_check
	else:
		loc = [feature.xValue, feature.yValue]
		try:
			loc.append(feature.zValue)   ## 2D model do not have zValue
		except:
			pass

	return tuple(loc)

def s2s_contact_std(name='',action='interact',master_inst=None,slave_inst=None,insts=None,parts=None,x=None,
	y=None,z=None, mfaces=None,sfaces=None, face_set=None, mregion=None, sregion=None, surface2surface=True,
	xEdges_m=None, xEdges_s=None, xEdges=None,force_create=False, loc_pair=(), fix='_', refined_insts='_',
	prop='Frictionless',  friction=None, step='step1',search_or_find=None,
	sliding=FINITE, adjust=NONE,overclosure=NONE,initial_clearance=NONE,deactive_step=None):
	## VER: 2016-09-01, v6.7	##要求同时具有master和slave的相关信息。
	## 过盈只有如下两种情形：
	## 1. 建模时几何界面有交错(看得见的过盈)：此时，只能输入overclosure参数(为具体的值，或为SHRINK_FIT), 最终化为interference_fit=UNIFORM或者SHRINK_FIT
	## 2. 建模时几何界面有交错(重合，看不见的过盈)：此时，只能输入initial_clearance参数。
	## 如果有初始过盈却没有使用overclosure参数，很可能一开始就不收敛。

	## use tie property in interaction
##	s2s_contact_std('interact',mfaces=ymin_faces(anvil_A1),sfaces=ymax_faces(blank_A1),prop='tie',step='step2')

	## Example: s2s_interact_std('int_pin_side',mfaces=faces2,sfaces=faces1,overclosure=-0.01,friction=0.2)
	## s2s_contact_std('tie', name='powder2_powder3',mfaces=powder3_top, sfaces=powder2_bot)

	## prop = 'Friction' can help to avoid always fixing all the instances in all directions
	## 本函数为s2s_interact_std和s2s_tie的共同流程。
	## 目标：1. 明确master_inst和slave_inst
	## 		2. 明确contact name

	## Example
##	faces = face_select(punch_A1,nx=1,x=MAX1)
##	sfaces,mfaces = mate_faces_in_inst(shell_A1,faces=faces)
##	s2s_interact_std('right',mfaces=mfaces,sfaces=sfaces,initial_clearance=0.04)

	## s2s_interact_std(sfaces='f_steel_contact',mfaces='f_carbide1_contact',force_create=True,step='step1',interference_fit=SHRINK_FIT,prop='Friction')

##mdb.models['Model-1'].SurfaceToSurfaceContactStd(name='Int-1',
##    createStepName='shrink_fit', master=region1, slave=region2, sliding=FINITE,
##    thickness=ON, interactionProperty='Frictionless',
##    interferenceType=SHRINK_FIT, adjustMethod=NONE, initialClearance=OMIT,
##    datumAxis=None, clearanceRegion=None)
###: The interaction "Int-1" has been created.
##
##mdb.models['Model-1'].interactions['Int-1'].setValues(initialClearance=OMIT,
##    adjustMethod=NONE, sliding=FINITE, enforcement=SURFACE_TO_SURFACE,
##    thickness=ON, contactTracking=TWO_CONFIG, interferenceType=UNIFORM,
##    overclosure=-0.04, interferenceDirectionType=COMPUTED, amplitude=None,
##    bondingSet=None)


	global contact_pairs, msfaces_trace, mrefine

##	stop1()

##	print fnln(),'froce_create=',force_create
##	raise Exception

	if name in ['interact','tie']:
		name,action = action,name

	add_to_process()
	step = check_step(step)

	if search_or_find != 'find':
		search_or_find = 'search'

	if action not in ['interact', 'tie']:
		raise Exception('*** action should be interact or tie.')

	## 检查property
	if action  == 'interact':
		if _m.steps[step].explicit == True:
			raise Exception('*** Please use s2s_interact_explicit() instead.')

		if is_number(friction):
			prop = create_contact_friction(friction=friction)

		elif type_of(friction) == 'STR':
			prop = friction
			friction = None

		if prop not in _m.interactionProperties.keys() and len(_m.interactionProperties.keys()) > 0:
			prop1 = _m.interactionProperties.keys()[0]
			print '**Default contact property',prop,'not existed, use',prop1,'instead.'
			prop = prop1

		if sliding not in [FINITE,SMALL]:
##			print fnln_fnln(),sliding
			raise Exception('*** sliding should be FINITE or SMALL')

	## 检查clearance, overclosure
	initial_clearance, adjust, overclosure = to_symbol(initial_clearance, adjust, overclosure)

	interference_fit = NONE
	## if input=initial_clearance: 初始几何是重合的。
	if type_of(initial_clearance) in numerics:
		adjust = NONE
		overclosure = NONE
		interference_fit = NONE

	## if input=overclosure: 初始几何不重合，有过盈。
	if overclosure == 0:
		overclosure = NONE
		interference_fit = NONE
	elif type_of(overclosure) in numerics:
		interference_fit = UNIFORM
		adjust = NONE
	elif overclosure == SHRINK_FIT:
		interference_fit = SHRINK_FIT
		overclosure = NONE
		adjust = NONE

	## if input=adjust
	if totext(adjust).upper == 'OVERCLOSED':  ## 注意，此时几何模型可能有误，需要修正。
		adjust = OVERCLOSED

	print fnln(), 'interference_fit, overclosure, initial_clearance, adjust=',
	print (interference_fit, overclosure,initial_clearance, adjust)

	## check interference_fit
	if interference_fit not in [NONE,SHRINK_FIT,UNIFORM]:  ## shrink fit表示几何上就存在过盈(但不需要指出过盈量多少)。
		raise Exception('**** interference_fit type should be None, SHRINK_FIT, or UNIFORM. And SHRINK_FIT is only allowed for 1st step.')

	if interference_fit == SHRINK_FIT:
		if step != _m.steps.keys()[1]:
			raise Exception('**** SHRINK_FIT is only allowed in 1st step.')

	## check adjust
##	print fnln_fnln(),'adjust=',adjust
	if adjust not in [NONE,OVERCLOSED,TOLERANCE,SET]:
		raise Exception('**** adjust should be NONE,OVERCLOSED,TOLERANCE or SET')   ## NONE is not the same as None

	## mfaces, sfaces
	if loc_pair not in empty and len(loc_pair) == 4:
		ms, inst1,loc,inst2,ms = loc_pair   ## 根据inst1找inst2的faces，也就是说ms是对inst1的描述。
		if loc not in ['xmax','xmid','xmin','ymax','ymid','ymin','zmax','zmid','zmin']:
			raise Exception('*** Error loc, should be such as: xmax, ymin')

		ndir = loc[0]
		func1 = '_' + loc
		loc = eval(func1 + '(' + _inst(inst1).name + ')')

		if is_numbers(loc) == False:
			raise Exception('*** Error loc info')

		if ms in ['m','master']:
			master_inst = check_inst(inst1)
			if ndir == 'x':
				mfaces = face_select(master_inst,x=loc)
			elif ndir == 'y':
				mfaces = face_select(master_inst,y=loc)
			elif ndir == 'z':
				mfaces = face_select(master_inst,z=loc)
			sfaces = mate_faces_in_inst(inst2,faces=mfaces)

		elif ms in ['s','slave']:
			slave_inst = check_inst(inst1)
			if ndir == 'x':
				sfaces = face_select(slave_inst,x=loc)
			elif ndir == 'y':
				sfaces = face_select(slave_inst,y=loc)
			elif ndir == 'z':
				sfaces = face_select(slave_inst,z=loc)
			mfaces = mate_faces_in_inst(inst2,faces=sfaces)
		else:
			raise Exception('*** Incorrect ms specification, should be master or slave')

		force_create = True

	## check master_inst, slave_inst
	if insts not in empty:
		master_inst = insts[0]
		slave_inst = insts[1]
	elif parts not in empty:
		parts = real_parts(parts)
		master_inst = insts_of_parts(parts[0])[0]
		slave_inst = insts_of_parts(parts[1])[0]

	if slave_inst not in empty:
		slave_inst = check_inst(slave_inst)

	if master_inst not in empty:
		master_inst = check_inst(master_inst)

##	raise Exception

##	msfaces_trace.append(get_traceback()[-2:] + ['mfaces',objs_num(mfaces),'sfaces',objs_num(sfaces), 'ext=' + refined_insts,'fix=' + fix,'force=' + repr(force_create)])

	## check sequence: region -> surface -> set -> objs
	## 确定region，如果有region，则不需要mfaces, sfaces
	mregion_done = False
	if mregion not in empty:
		if is_surface(mregion):
			mregion = check_obj(mregion,a.surfaces)
			mfaces = None
		elif type_of(mregion) != 'REGION':
			mfaces = mregion
			mregion = None

	if is_surface(mfaces):
		mregion = check_obj(mfaces,a.surfaces)
		mfaces = None

	elif type_of(mfaces) == 'REGION':
		mregion = mfaces
		mfaces = None

	if type_of(mregion) in ['SURFACE','REGION']:
		mregion_done = True
		if master_inst in empty:
			master_inst = poi_of_region(mregion)

	sregion_done = False
	if sregion not in empty:
		if is_surface(sregion):
			sregion = check_obj(sregion, a.surfaces)
			sfaces = None
		elif type_of(sregion) != 'REGION':
			sfaces = sregion
			sregion = None

	if is_surface(sfaces):
		sregion = check_obj(sfaces,a.surfaces)
		sfaces = None
	elif type_of(sfaces) == 'REGION':
		sregion = sfaces
		sfaces = None

	if type_of(sregion) in ['SURFACE','REGION']:
		sregion_done = True
		if slave_inst in empty:
			slave_inst = poi_of_region(sregion)

	if mregion_done == False or sregion_done == False:
		mset = None  ## master_set
		sset = None
		if type_of(mfaces) == 'STR':
			mset = mfaces
			mfaces = None

			if master_inst in empty:	## master_inst可以为空
				insts0 = insts_by_set(mset)
				if len(insts0) > 0:
					master_inst = insts0[0]
					mfaces = set2objs(master_inst,mset)
				elif mset in a.sets.keys():
					mfaces = set2objs(a, mset)
					master_inst = get_poi(mfaces[0])
				else:
					raise Exception('*** No such set name =' + mset)

			else:
				mfaces = set2objs(master_inst,mfaces)

		if type_of(sfaces) == 'STR':
			sset = sfaces
			sfaces = None

			if slave_inst in empty:
				insts0 = insts_by_set(sset)
				if len(insts0) > 0:
					slave_inst = insts0[0]
					sfaces = set2objs(slave_inst,sset)
				elif sset in a.sets.keys():
					sfaces = set2objs(a, sset)
					slave_inst = get_poi(sfaces[0])
				else:
					raise Exception('*** No such set name =' + sset)
			else:
				sfaces = set2objs(slave_inst,sfaces)

		if type_of(face_set) == 'STR':
			if face_set in _m.parts[master_inst.partName].sets.keys():
				mfaces = set2objs(face_set,master_inst)
			elif face_set in _m.parts[slave_inst.partName].sets.keys():
				sfaces = set2objs(face_set,slave_inst)
			else:
				raise Exception('****master_inst or slave_inst of face_set is required')

		if mfaces not in empty:
			mfaces = tolist(mfaces)

			if type_of(mfaces[0]) not in ['faces','edges']:
				raise Exception('*** faces or edges are required as mfaces.')

			if master_inst in empty:		## 2D model, use edges
				master_inst = get_poi(mfaces)
				if type_of(master_inst) == 'PART':
					raise Exception('******mfaces should be from instance, not from part.')

		if sfaces not in empty:
			sfaces = tolist(sfaces)

			if type_of(sfaces[0]) not in ['faces','edges']:
				raise Exception('*** faces or edges are required as sfaces.')

			if slave_inst in empty:		## 2D model, use edges
				slave_inst = get_poi(sfaces)
				if type_of(slave_inst) == 'PART':
					raise Exception('******sfaces should be from instance, not from part.')

		## not provide mregion and mfaces; not provide sregion and sfaces
		if (x,y,z) != (None,None,None):
			mfaces = faces_of_cut(master_inst,x=x, y=y, z=z)
			if mfaces in empty:
				raise Exception('No mfaces was found in ' + master_inst.name + ' by (x,y,z)=' + repr((x,y,z)))

			sfaces = faces_of_cut(slave_inst,x=x,y=y,z=z)
			if sfaces in empty:
				raise Exception('No mfaces was found in ' + slave_inst.name + ' by (x,y,z)=' + repr((x,y,z)))

			mfaces,sfaces = refine_faces_pair_inplane(mfaces,sfaces, refined_insts=refined_insts)

	if mregion_done == False and mfaces in empty:
		print fnln(),'*** faces or surface of master inst required.'

	if sregion_done == False and sfaces in empty:
		print fnln(),'*** faces or surface of slave inst required.'

	master_inst = check_inst(master_inst)
	slave_inst = check_inst(slave_inst)

	if master_inst in empty or slave_inst in empty:
		print fnln_fnln(),'****master_inst or slave_inst is empty.',action,'was not created.'
		return

	msfaces_trace.append(get_traceback()[-2:] + [master_inst.name + '_mface',objs_num(mfaces),slave_inst.name + '_sface',objs_num(sfaces), 'ext=' + refined_insts,'fix=' + fix,'force=' + repr(force_create)])

##	raise Exception

	## 要求已经知道master_inst,slave_inst
	check_pars = [mfaces,sfaces,mregion,sregion,xEdges_m,xEdges_s,xEdges]
	if check_pars == [None]*7:
		print '**turn to find_contacts() instead of s2s_contact_std()...'
		find_contacts(action=action,master_insts=master_inst,slave_insts=slave_inst,search_or_find=search_or_find,prop=prop,step=step)
		return

	if name in empty:
		if face_set not in empty:
			if face_set in _m.parts[slave_inst.partName].sets.keys():
				sset = face_set
			elif face_set in _m.parts[master_inst.partName].sets.keys():
				mset = face_set

		if mset not in empty:
			string1 = partial_setname(master_inst,mset)
			name = slave_inst.name + '//' + master_inst.name + '_' + string1 + '(m)'
		elif sset not in empty:
			string1 = partial_setname(slave_inst,sset)
			name = master_inst.name + '//' + slave_inst.name + '_' + string1 + '(s)'
		else:
			name = master_inst.name + '//' + slave_inst.name + '(s)'

	if action == 'interact':
		seq = get_SN(_m.interactions,3)
	elif action == 'tie':
		seq = get_SN(_m.constraints)

	if action == 'interact' and name[:4].lower() != 'int_':
		name = 'int_' + name
	elif action == 'tie' and name[:4].lower() != 'tie_':
		name = 'tie_' + name

	fric = '_hasf_'
	if prop == 'Frictionless':
		fric = '_nof_'

	name = '_' + seq + '_' + name

##	print_traceback()
	trace = get_traceback()
	_lineno = str(trace[3])

	if action == 'interact':
		name = name + fric + _lineno
	else:
		name = name + '_' + _lineno

	if action == 'interaction':
		name = new_key(_m.interactions,name)
	elif action == 'tie':
		name = new_key(_m.constraints,name)

	print '---'
	print "Trying to create",action,': master_inst=',master_inst.name,', slave_inst=',slave_inst.name

##	msfaces_trace.append(get_traceback()[-2:] + [master_inst.name + '_mface',objs_num(mfaces),slave_inst.name + '_sface',objs_num(sfaces), 'ext=' + refined_insts, 'fix=' + fix,'force=' + repr(force_create), '**determined=' + repr(msfaces_determined)])

##	print fnln(),mregion
##	print fnln(),sregion
##	raise Exception

	if mregion in empty or sregion in empty:
		mfaces,sfaces,xEdges_m,xEdges_s,mregion,sregion = get_msface_and_msregion(master_inst=master_inst,slave_inst=slave_inst,mfaces=mfaces,sfaces=sfaces, info=action[:3],
			mregion=mregion,sregion=sregion,xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges, search_or_find=search_or_find, force_create=force_create,fix=fix, refined_insts=refined_insts)

##	print fnln(),type_of(mfaces)
##	print fnln(),type_of(sfaces)

##	msfaces_trace.append(get_traceback()[-2:] + [master_inst.name + '_mface',objs_num(mfaces),slave_inst.name + '_sface',objs_num(sfaces), 'ext=' + refined_insts, 'fix=' + fix,'force=' + repr(force_create)])

		create = check_in_contact(contact_name=name,mfaces=mfaces,sfaces=sfaces,xEdges_m=xEdges_m, xEdges_s=xEdges_s, force_create=force_create)
##	stop1()

	else:
		create = True

	if create == True:
##		mset = name + '(master)'
##		sset = name + '(slave)'
##		if mfaces not in empty:
##			create_set(master_inst, objs=mfaces, name=mset)
##			contact_pairs[-1]['master_set'] = mset
##
##		if sfaces not in empty:
##			create_set(slave_inst, objs=sfaces, name=sset)
##			contact_pairs[-1]['slave_set'] = sset

		if action == 'interact':
			print fnln_fnln(),'step=',step
			print fnln_fnln(),'interference_fit=',interference_fit
			print fnln_fnln(),'overclosure=',overclosure
			print fnln_fnln(),'adjust=',adjust
			print fnln_fnln(),'initial_clearance=',initial_clearance

			_m.SurfaceToSurfaceContactStd(name=name,createStepName=step, master=mregion, slave=sregion, sliding=FINITE,
			    enforcement=SURFACE_TO_SURFACE, thickness=ON, interactionProperty=prop, surfaceSmoothing=NONE,
			    adjustMethod=NONE, initialClearance=OMIT, datumAxis=None, clearanceRegion=None)

			if surface2surface == False:  ## node-to-surface
				_m.interactions[name].setValues(enforcement=NODE_TO_SURFACE, thickness=OFF)   ## node-to-surface比surface-to-surface更省内存

			if sliding == SMALL:
				_m.interactions[name].setValues(sliding=SMALL,supplementaryContact=SELECTIVE,tied=OFF)

			if type_of(initial_clearance) in numerics:
				_m.interactions[name].setValues(sliding=SMALL,initialClearance=initial_clearance,supplementaryContact=SELECTIVE)
			else:
				## Gradually remove slave node overclosure during the step
				## shrink fit是几何上就有超差，不重合。shrink fit和overclosure不能同时使用。
				if interference_fit == SHRINK_FIT:   ## automatic to release (OK for precision model build up, with actual overclosure initially)
					_m.interactions[name].setValues(interferenceType=SHRINK_FIT)
				elif interference_fit == UNIFORM:    ## overclosure is the magnitude, different meaning based on the initial overclosure or gap or well-fit
					_m.interactions[name].setValues(interferenceType=UNIFORM,overclosure=overclosure)
					## overclosure < 0表示过盈，overclosure > 0表示存在间隙
				else:
					## Note: if adjust != None: slave surface will be adjusted to be precisely in contact with the master surface at the beginning of analysis
					if adjust == OVERCLOSED:
						_m.interactions[name].setValues(adjustMethod=OVERCLOSED, tied=OFF)   ## adjust only to remove overclosure  (Error for interference_fit stress calculation)

			if deactive_step not in empty:
				deactive_step = check_step(deactive_step)
				_m.interactions[name].deactivate(deactive_step)

		elif action == 'tie':
			_m.Tie(name=name, master=mregion, slave=sregion, positionToleranceMethod=COMPUTED,
				adjust=ON, tieRotations=ON, thickness=ON)

			if deactive_step not in empty:
				deactive_step = check_step(deactive_step)
				_m.constraints[name].deactivate(deactive_step)

		print '--->' + action,name,'was created, prop=',prop
		print '**In model: Total ties=',len(_m.constraints), ', total interactions=',len(_m.interactions)
		print ' '

##		stop1()

##		print '最后一个接触对的建立的过程为: myprint(msfaces_trace)'
##		myprint(msfaces_trace)
##		print ' '

	return create

def s2s_interact_std(name='',master_inst=None,slave_inst=None,insts=None,parts=None,x=None,y=None,z=None,mfaces=None,sfaces=None, face_set=None, mregion=None, sregion=None,
	xEdges_m=None, xEdges_s=None, xEdges=None, collect_edges=None, force_create=False,gap=None, fix='_', refined_insts='_',deactive_step=None,surface2surface=True,
	prop='Frictionless',friction=None, step='step1',search_or_find=None, sliding=FINITE, adjust=NONE,interference=None,overclosure=None,initial_clearance=None):

	## VER: ('VER: 2016-03-30, v5.2')	## 要求同时具有master和slave的相关信息。gap是一个无用的占位参数。
	## 本函数几乎不做什么，只是确定action type，然后就转到s2s_contact_std
	## node based surface can only act as slave surface.
	## 金属与金属之间摩擦系数=0.2太大了，经常不收敛，或出现奇怪的错误信息。无摩擦则很好收敛。

##	s2s_tie('tie_leg1_base', insts=(base_A1, leg1_A1), y=_ymax(base_A1))
##	s2s_tie('tie_leg1_base', insts=(base_A1, leg1_A2), y=_ymax(base_A1))

	## Example:
	## s2s_interact_std(mfaces=faces_glass,sfaces=faces_rail,force_create=True)
	## s2s_interact_std('int_pull',mfaces=faces1,sfaces=faces2,overclosure=0.01,prop='Friction')
	## s2s_interact_std('int_pull',mfaces=faces1,sfaces=faces2,adjust=OVERCLOSED,friction=friction)

##	edges1 = edge_select(carbide_A1,radius=carbide_OD/2.)
##	edges2 = edge_select(case_A1,radius=steel_ID/2.)
##	s2s_interact_std(mfaces=edges1,sfaces=edges2,interference='shrink_fit')


	global find_process,s2s_process,msfaces_trace

##	stop1()

	if mfaces == []:
		raise Exception('*** Empty mfaces')

	if sfaces == []:
		raise Exception('*** Empty sfaces')

	try:
		find_process.append('s2s_interact_std')
	except:
		pass

	s2s_process = ['s2s_interact_std']
	caller = caller_name()

##	print caller_names()
##	raise Exception

	please_check
	if show_in_items(caller_names(),'main'):  ## 如果是主程序调用的，则force_create，不必再细化了。
		force_create = True

	if 'find_contacts' not in get_traceback():	##直接调用s2s_interact_std
		msfaces_trace = []
		globals()['collect_edges'] = collect_edges

	if search_or_find == None:   ##未指定
		search_or_find = 'search'

##	stop1()

##	if type_of(mfaces) in ['REGION','SURFACE']:
##		mregion = mfaces
##		mfaces = None
##
##	if type_of(sfaces) in ['REGION','SURFACE']:
##		sregion = sfaces
##		sfaces = None

##	stop1()

##	## 先不急确定master_inst和slave_inst
##	msfaces_trace.append(get_traceback()[-4:] + ['mface_num=' + repr(objs_num(mfaces)), 'sface_num=' + repr(objs_num(sfaces)),'ext=' + repr(refined_insts),'fix=' + repr(fix),'force=' + repr(force_create)])

	s2s_contact_std(action='interact',master_inst=master_inst,slave_inst=slave_inst,insts=insts,parts=parts, x=x,y=y,z=z,name=name,mfaces=mfaces,sfaces=sfaces, face_set=face_set, mregion=mregion, sregion=sregion,
		xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges,force_create=force_create,fix=fix, refined_insts=refined_insts, prop=prop, friction=friction, step=step,search_or_find=search_or_find,
		sliding=sliding, adjust=adjust,overclosure=overclosure,initial_clearance=initial_clearance,deactive_step=deactive_step,surface2surface=surface2surface)

	print ' '
##	print fnln_fnln(),'**s2s_process='
	print_caller_code()
	print 'Calling process:'
	print s2s_process
	print ' '

	return

def scale_list(list1,scale):
	## VER: 2014-08-29, v1.0

	if type_of(scale) in ['TUPLE','LIST']:
		list1, scale = scale, list1

	type1 = type_of(list1)
	if type1 not in ['TUPLE','LIST']:
		raise Exception('*** a tuple or a list is required.')

	list1 = tolist(list1)
	for i in range(len(list1)):
		list1[i] = list1[i]*scale

	if type1 == 'TUPLE':
		list1 = totuple(list1)

	return list1

function_labels['s2s_interact_exp'] = 'surface', 'interaction','explicit dynamics','master','slave','finite sliding','small sliding','friction','interference'
def s2s_interact_exp(name,master_region=None,slave_region=None, master_objs=None, mfaces=None,
	medges=None, slave_objs=(), sfaces=None, sedges=None, pair=(), msurface=None, ssurface=None,
	sliding=FINITE, constraint_method='kinematic', add_gap=None,add_interference=None, initial_clearance=None, interference=None,
	step='step1',prop='Friction',friction=None,):
	## VER: 2016-03-30, v2.1
	## first surface: master; second surface: slave
	## 无法处理较大的初始过盈，如果存在的话。例如powder compaction时，ejector与powder可能存在：Resolution of initial overclosure may have caused excessive distortion.
	## 如果存在较大的初始过盈，有可能是网格划分不够密，在曲率变化处不够精细。例如powder compaction时的ejector land处的powder

	## In most cases the kinematic and penalty algorthms will rpoduce nearly the same results.
	## Kinematic contact is always preferred over penalty contact when performing component analysis involving elastic collisions because acceleration signals are less noisy.

##	s2s_interact_explicit('tpunch_powder',mfaces=surf_tpunch, sfaces=powder_top)
##	s2s_interact_explicit('die_powder',mfaces=surf_die, sfaces=powder_right)

	if mfaces == []:
		raise Exception('*** Empty mfaces')

	if sfaces == []:
		raise Exception('*** Empty sfaces')

##	name = formatted_name(_m.interactions.keys(),name)
	name = new_key(_m.interactions.keys(),name)
	step = check_step(step)

	if friction not in empty:
		prop = friction
		friction = None

	if type_of(prop) == 'FLOAT':
		if prop > 0:
			prop = create_contact_friction(friction=prop)
		else:
			prop = 'Frictionless'

	if interference not in empty:
		add_interference = interference

	if is_number(add_gap):
		initial_clearance = abs(add_gap)
	elif is_number(add_interference):
		initial_clearance = -abs(add_interference)

	if is_number(initial_clearance):
		sliding = SMALL	;please_check

	if type_of(sliding) == 'STR':
		sliding = sliding.upper()
		try:
			sliding = eval(sliding)
		except:
			pass
	if sliding not in [FINITE,SMALL]:
		raise Exception('*** sliding should be FINITE or SMALL.')

	if pair not in empty:
		master_region, slave_region = pair

	master_objs = get_real_input(master_objs,mfaces,medges)
	if is_surface(master_objs):
		msurface = check_surface(master_objs)
		master_objs = None

	if master_objs not in empty:
		master_region = create_surface(objs=master_objs,info='int')
	elif msurface not in empty:
		msurface = check_surface(msurface)
		master_region = msurface

	slave_objs = get_real_input(slave_objs,sfaces,sedges)
	if is_surface(slave_objs):
		ssurface = check_surface(slave_objs)
		slave_objs = None

	if slave_objs not in empty:
		slave_region = create_surface(objs=slave_objs,info='int')
	elif ssurface not in empty:
		ssurface = check_surface(ssurface)
		slave_region = ssurface

	if master_region in empty or slave_region in empty:
		raise Exception('**** Contact pair is required, master_region, slave_region, or pair')

	if constraint_method in empty:
		obj = _m.interactionProperties[prop]
		table = obj.tangentialBehavior.table
		if table in empty:
			constraint_method = KINEMATIC
		else:
			fric = table[0][0]
##			print fnln(),'fric=',fric
			if fric > 0.1:
				constraint_method = PENALTY   ## 帮助收敛(摩擦系数比较大时)
			else:
				constraint_method = KINEMATIC
	else:
		constraint_method = totext(constraint_method).upper()
		if 'PENALTY' in constraint_method:
			constraint_method = PENALTY
		else:
			constraint_method = KINEMATIC	## defatult

	print fnln(),'constraint constraint_method=',constraint_method, ', sliding =',sliding
	if constraint_method == PENALTY and sliding == SMALL:
		raise Exception('*** Small sliding cannot used with penalty constraint.')

	if sliding == FINITE:
		_m.SurfaceToSurfaceContactExp(name =name,
		    createStepName=step, master = master_region, slave = slave_region,
		    mechanicalConstraint=constraint_method, sliding=FINITE,   ## small sliding is not allowed if has rigid surface.
		    interactionProperty=prop, initialClearance=OMIT, datumAxis=None, clearanceRegion=None)
		    ## clearance only can use for small sliding

	else:  ## small sliding: 例如shrink fit,几乎可以tie在一起。
		if is_number(initial_clearance) == False:
			initial_clearance=OMIT

		## initial_clearance > 0表示有间隙，initial_clearance < 0表示有过盈。
		_m.SurfaceToSurfaceContactExp(name =name,
		    createStepName=step, master = master_region, slave = slave_region,
		    mechanicalConstraint=constraint_method, sliding=SMALL,   ## small sliding is not allowed if has rigid surface.
		    interactionProperty=prop, initialClearance=initial_clearance, datumAxis=None, clearanceRegion=None)

##	print '---> Interaction',name,'is created.'

	return name

s2s_interact_explicit = s2s_interact_exp

##def s2s_self_standard(faces,name='self_contact',prop='Frictionless', friction=None, step='step1'):
##	## VER: 2013-11-21, v1.1
##	## create_self_contact, s2s_general
##
##	step = check_step(step)
##	name = new_key(_m.interactions.keys(),name)
##
##	if type_of(friction) == 'FLOAT':
##		prop = create_contact_friction(friction = friction)
##
##	region = list2region(faces)
##
##	_m.SelfContactStd(name=name, createStepName=step, surface=region, interactionProperty=prop, enforcement=SURFACE_TO_SURFACE, thickness=ON)
##
##	return

def create_self_contact(name='general_contact',objs=None, faces=None, edges=None, elements=None, surface=None, prop='Frictionless', friction=None, step='Initial'):
	## VER: 2013-12-26, v1.2
	## 只能创建在Initial step

	step = check_step(step)
	name = new_key(_m.interactions.keys(),name)

	if type_of(friction) == 'FLOAT':
		prop = create_contact_friction(friction = friction)

	faces = get_real_input(objs,faces,edges, elements, surface)
	if type_of(faces) == 'STR':
		name = faces
		if faces in a.surfaces.keys():
			faces = a.surfaces[faces]
		else:
			faces = set2objs(name)

##	if type_of(surface) != 'SURFACE':
##		objs = surface
##		surface = create_surface(objs)

	if faces in empty:
		raise Exception('*** faces are required.')

	region = list2region(faces)
	print fnln_fnln(),'type_of(region)=',type_of(region)

	solver = get_solver()
	if solver == 'implicit':
		_m.SelfContactStd(name=name, createStepName=step, surface=region, interactionProperty=prop, enforcement=SURFACE_TO_SURFACE, thickness=ON)
	elif solver == 'explicit':
		_m.SelfContactExp(name=name, createStepName=step, surface=region, mechanicalConstraint=KINEMATIC, interactionProperty=prop)

	return

def create_general_contact_std(pairs=(),friction='Frictionless',all_overclosure=None,interference_pairs=(), clearance_pairs=(),property_pairs=()):
	## VER: 2016-11-12, v1.4   used in standard, not in explicit.
	## 对于解析刚体和离散刚体，由于存在side的问题，所以，不宜使用。
	##  For 2D model, such as wire draw, can use. Note: created in the Initial step, not in other step (at least for 2D model)

	## Example: create_general_contact_std(prop=0.2)
##	create_general_contact_std(interference_pairs=('nib_OD','case_ID','interference_fit'))
##	create_general_contact_std(friction=0.01,interference_pairs=(('nib_OD','case_ID','interfernce_fit')))   ## interference_fit相当于是一个过盈关系的名称。

##	mdb.models['Model-1'].ContactStd(name='Int-1', createStepName='Initial')
##	mdb.models['Model-1'].interactions['Int-1'].includedPairs.setValuesInStep(
##	    stepName='Initial', useAllstar=ON)
##	mdb.models['Model-1'].interactions['Int-1'].contactPropertyAssignments.appendInStep(
##	    stepName='Initial', assignments=((GLOBAL, SELF, 'Frictionless'), ))

	if is_number(friction):
		prop = create_contact_friction(friction = friction)
	elif friction in _m.interactionProperties.keys():
		prop = friction
	elif friction == 'Frictionless':
		prop = create_contact_friction(0)
	else:
		raise Exception('*** Error friction property.')

	_m.ContactStd(name='Int-1', createStepName='Initial')	## general contact (std) can only created in Initial step.
	if pairs in empty:
		_m.interactions['Int-1'].includedPairs.setValuesInStep(stepName='Initial', useAllstar=ON)
	else:
		pairs = totable(pairs)
		newlist = []
		for pair in pairs:
			master_surf, slave_surf = pair
			master_surf = check_surface(master_surf)
			slave_surf = check_surface(slave_surf)
			newlist.append((master_surf, slave_surf))
		pairs = totable(newlist)
		_m.interactions['Int-1'].includedPairs.setValuesInStep(stepName='Initial', useAllstar=OFF, addPairs=pairs)

	_m.interactions['Int-1'].contactPropertyAssignments.appendInStep(
		stepName='Initial', assignments=((GLOBAL, SELF, prop), ))

	if type_of(all_overclosure) in numerics:
		_m.StdInitialization(name='CInit-1', overclosureType=CLEARANCE, clearanceDistance=all_overclosure)
		_m.interactions['Int-1'].initializationAssignments.appendInStep(
		    stepName='Initial', assignments=((GLOBAL, SELF, 'CInit-1'), ))
	elif type_of(all_overclosure) == 'STR' and 'fit' in all_overclosure:
		_m.StdInitialization(name='CInit-1', overclosureType=INTERFERENCE)
		_m.interactions['Int-1'].initializationAssignments.appendInStep(
		    stepName='Initial', assignments=((GLOBAL, SELF, 'CInit-1'), ))

	if interference_pairs not in empty:   ## 在目前接触状态基础上，增加过盈量（例如：模型中界面没有过盈量，实际是有过盈量的）。
		## 指出该接触对之间是有过盈干涉的。如果几何模型中已经有过盈，可不指出过盈量。如果几何模型中没有过盈量，则需要指出实际的过盈量（如果恒定过盈量的话)。
		pairs = totable(interference_pairs)
		for pair in pairs:
			if len(pair) == 3:
				mfaces,sfaces,stabilization = pair
				dist = None
			elif len(pair) == 4:
				mfaces,sfaces,stabilization,dist = pair

			mfaces = create_surface(objs=mfaces)
			sfaces = create_surface(objs=sfaces)
			if stabilization not in _m.contactInitializations.keys():
				if dist == None:
					_m.StdInitialization(name=stabilization, overclosureType=INTERFERENCE)	## 相当于shrink_fit, 即已经有过盈，要shrink_fit
				else:
					_m.StdInitialization(name=stabilization, overclosureType=INTERFERENCE, interferenceDistance=abs(dist))  ## 绝对值，增加一个UNIFORM的过盈量。

			_m.interactions['Int-1'].initializationAssignments.appendInStep(
			    stepName='Initial', assignments=((mfaces, sfaces, stabilization), ))

	if clearance_pairs not in empty:   ## 在目前接触状态基础上，增加间隙量（例如：模型中界面没有间隙量，实际是有间隙量的）。
		pairs = totable(clearance_pairs)
		for pair in pairs:
			if len(pair) == 4:
				mfaces,sfaces,stabilization,gap = pair
			else:
				raise Exception('*** a clearence gap is required.')

			mfaces = create_surface(objs=mfaces)
			sfaces = create_surface(objs=sfaces)
			if stabilization not in _m.contactInitializations.keys():
				_m.StdInitialization(name=stabilization, overclosureType=CLEARANCE, clearanceDistance=abs(gap))  ## 绝对值

			_m.interactions['Int-1'].initializationAssignments.appendInStep(
			    stepName='Initial', assignments=((mfaces, sfaces, stabilization), ))

	if property_pairs not in empty:
		pairs = totable(property_pairs)
		for pair in pairs:
			if len(pair) == 3:
				mfaces,sfaces,prop = pair
			else:
				raise Exception('*** a property pair is required.')

			mfaces = create_surface(objs=mfaces)
			sfaces = create_surface(objs=sfaces)

			if type_of(prop) == 'FLOAT':
				if prop > 0:
					prop = create_contact_friction(friction=prop)
				else:
					prop = 'Frictionless'

			_m.interactions['Int-1'].contactPropertyAssignments.appendInStep(
			    stepName='Initial', assignments=((mfaces, sfaces, prop), ))   ## can be changed to other steps
	return

def create_general_contact_exp(friction='Frictionless',prop=None,property_pairs=()):
	## VER: 2015-04-03, v1.3
	## 对于解析刚体和离散刚体(线条)，由于存在side的问题，所以，无法使用。explicit情况下，wire draw不可以用通用接触。
	##  For 2D model, such as wire draw, can use. Note: created in the Initial step, not in other step (at least for 2D model)

##	*CONTACT cannot be defined on 2D element facets.  If the model contains 2D or axisymmetric elements then *CONTACT INCLUSIONS, ALL EXTERIOR cannot be specified, and the first surface name on each data line under *CONTACT INCLUSIONS or *CONTACT EXCLUSIONS must not be blank.

	## 可以用于自接触，但不能用于内面的接触（例如abaqus的metal cutting)
##  *CONTACT currently does not support the use of 2D surfaces
##	*CONTACT cannot be defined on 2D element facets.  If the model contains 2D or axisymmetric elements then *CONTACT INCLUSIONS, ALL EXTERIOR
##  cannot be specified, and the first surface name on each data line under *CONTACT INCLUSIONS or *CONTACT EXCLUSIONS must not be blank.

	if friction not in empty:
		prop = friction

	if type_of(prop) == 'FLOAT':
		prop = create_contact_friction(friction = prop)
	elif prop not in _m.interactionProperties.keys():
		raise Exception('*** Error friction property.')

	stepname = _m.steps.keys()[1]
	_m.ContactExp(name='Int-1', createStepName=stepname)	## general contact (std) can only created in Initial step.
	_m.interactions['Int-1'].includedPairs.setValuesInStep(stepName=stepname, useAllstar=ON)
	_m.interactions['Int-1'].contactPropertyAssignments.appendInStep(stepName=stepname, assignments=((GLOBAL, SELF, prop), ))

##mdb.models['restart'].ContactExp(name='Int-1', createStepName='draw')
##mdb.models['restart'].interactions['Int-1'].includedPairs.setValuesInStep(
##    stepName='draw', useAllstar=ON)
##mdb.models['restart'].interactions['Int-1'].contactPropertyAssignments.appendInStep(
##    stepName='draw', assignments=((GLOBAL, SELF, 'Friction_01'), ))

	return

def s2s_tie(name='',master_inst=None,slave_inst=None,insts=None,parts=None,x=None,y=None,z=None,mfaces=None,sfaces=None, face_set=None, mregion=None, sregion=None,
	xEdges_m=None, xEdges_s=None, xEdges=None, collect_edges=None, force_create=False, gap=None, fix='_', refined_insts='_', prop='Frictionless',step='step1',
	search_or_find=None, adjust=NONE,interference=None,overclosure=None):

	## VER: ('VER: 2014-06-30, v5.2')	## 要求同时具有master和slave的相关信息。gap是一个无用的占位参数。
	## 本函数几乎不做什么，只是确定action type，然后就转到s2s_contact_std
	## nodes use the set like region, not the surface like region.
	## 适用于standard and explicit

	## Example:
##	faces1 = face_select(shaft_A1,radius=shaft_D4/2)
##	faces2 = face_select(lock_A1,radius=shaft_D4/2)
##	s2s_tie('tie_shaft_lock',mfaces=faces1,sfaces=faces2)  ## thermal analysis

##	edges1 = get_connected_edges('base_A1',loc=(0,y0,0))
##	surf1 = create_surface('base_side',edges=edges1)
##
##	edges2 = _inst('carbide_A1').edges
##	surf2 = create_surface('carbide_side',edges=edges2)
##
##	s2s_tie('tie',mregion=surf2,sregion=surf1)


	global find_process,s2s_process,msfaces_trace

	try:
		find_process.append('s2s_tie')
	except:
		pass

	s2s_process = ['s2s_tie']
	features0 = a.features.values()

	caller = caller_name()
	print fnln_fnln(),'caller=',caller

	if 'find_contacts' not in get_traceback():  ##直接调用s2s_tie()
		msfaces_trace = []
		globals()['collect_edges'] = collect_edges		## local variable to global

	if search_or_find == None:   ##未指定
		search_or_find = 'search'

	msfaces_trace.append(get_traceback()[-4:] + ['mfaces=',objs_num(mfaces), 'sfaces', objs_num(sfaces),'ext=' + refined_insts,'fix=' + fix])

##	print2('master_inst=',master_inst)
##	print2('slave_inst=',slave_inst)
	s2s_contact_std(action='tie',master_inst=master_inst,slave_inst=slave_inst,insts=insts,parts=parts, x=x,y=y,z=z, name=name,mfaces=mfaces,sfaces=sfaces, face_set=face_set, mregion=mregion, sregion=sregion,
		xEdges_m=xEdges_m, xEdges_s=xEdges_s, xEdges=xEdges,force_create=force_create,fix=fix, refined_insts=refined_insts, prop=prop,step=step,search_or_find=search_or_find)

	print ' '
##	print fnln_fnln(),'**s2s_process='
	print_caller_code()
	print '调用过程为:'
	print s2s_process
	print ' '

	features = unselect(a.features.values(),features0)
	for feature in features:
		try:
			a.deleteFeatures((feature.name,))
		except:
			pass
	a.regenerate()

	return

def save_avi(name='',prefix='', postfix='_1',format='.avi',viewports=(),path=None,save_at_work=True,vname='', input_text='', value_loc='',scale=1,unit='',float=2):
	## VER: 2013-11-12, 1.9

	file_name,format,viewports = viewport_to_image(name=name,prefix=prefix,postfix=postfix,format=format,
		viewports=viewports,path=path,save_at_work=save_at_work,avi=True,vname=vname, input_text=input_text, value_loc=value_loc, scale=scale, unit=unit, float=float)

##	set_background('white')
	loc = file_name.rfind('.')
	session.writeImageAnimation(fileName=file_name[:loc], format=AVI, canvasObjects=viewports) ## 并不会把背景颜色也保存
##	set_background('gradient')

##	print "save_avi(name='',prefix='', postfix='_1',format='.avi',viewports=(),path=None,save_at_work=True)"
##	print ' '

##	print ' '
##	print "save_avi(name='',prefix='', postfix='_1',format='.avi',viewports=(),path=None,save_at_work=True,vname='', input_text='', value_loc='',scale=1,unit='',float=2)"
##	print 'Global variable: fontsize =',fontsize,', you can change in in the command line.'
##	print ' '

	loc = file_name.rfind('/')
	dir1 = file_name[:loc]
	name = file_name[loc+1:]
	print 'File name:',name
	print 'Saved in: ',dir1
	print ' '

	return

function_labels['save_res'] = 'result','collect','res2file','global','parameter'
def save_res(var):
	## VER: 2016-11-08, v1.0

	code = get_caller_code()
	loc = code.find('(')
	varname = code[loc+1:-1]
	varname = varname.strip()

	globals()[varname] = var

	file1 = script_path() + '_res.py'

	if len(myglobals) == 1:
		line_print(file1,'## ======================================')

	line_print(file1,varname + ' =',var)
	line_print(file1,'myglobals=',myglobals)
	line_print(file1,'## current inp =',inp_file_title, ', len(myglobals)=',len(myglobals))
	line_print(file1,' ')

	return

function_labels['save_user_data'] = 'variable','save','parameter','user'
def save_user_data(*values):
	## VER: ('VER: 2013-12-31, v1.6')
	## values必须是value list, 变量名从traceback得来。

	## 更改局部变量bearing_D的值。
##	bearing_D = bearing_D + 0.1	;changing
##	save_user_data(bearing_D)

	if len(values) == 0:
		raise Exception('Variable is required for write to file.')

	values = tolist(values)
##	print fnln_fnln(),'input values=',values

	variables = []

	command = get_caller_code()
	command = modify_string(command,' ')
	command = modify_string(command,'"')
	command = modify_string(command,"'")

##	print ' '
##	print fnln_fnln(),'caller_code='
##	print command

##	raise Exception

	locs = []
	for i in range(len(command)):
		char = command[i]
		if char in ['(', ',',')']:
			locs.append(i)

##	print locs
	variables = []
	for i in range(len(locs) - 1):
		loc1 = locs[i]
		loc2 = locs[i+1]
		variables.append(command[loc1+1:loc2])

##	print fnln_fnln(),'variables=',variables
##	raise Exception
	for i in range(len(variables)):
		name = variables[i]

##		if name not in globals().keys():
##			if name_list == False:
##				value1 = values[i]
##				globals()[name] = value1	## 将局部变量另存到全局变量
####				print fnln_fnln(),'**创建了与局部变量名一样的全局变量',name,'，其值=',value1
##			else:
##				raise Exception('name_list=True, 无法获得变量 ' + name + ' 的值，因此无法创建该全局变量。可以改用传值法，或先把该局部变量备份到全局变量表中。')
##
##		else:
##			if name_list == False:
##				globals()[name] = values[i]

		if type_of(values[i]) == 'STR':
			text = name + ' = ' + repr(values[i])
		else:
			text = name + ' = ' + str(values[i])

		please_check
		globals()[name] = values[i]

##		var_file_full = inp_file_title + '.vars'
##		line_print(var_file_full,text)
		add_model_description(text)

	return

def save_dg(name='dg1'):
	## VER: 2014-12-17, v1.0

	dg = dg_now()
	name = new_key(session.displayGroups.keys(),name)
	dg = session.DisplayGroup(name=name, objectToCopy=dg['dg'])

	vpnow = get_vpnow()
	vpnow.odbDisplay.setValues(visibleDisplayGroups=(dg, ))

	return name

function_labels['save_image'] = 'file','photo','path','results'
def save_image(name=1,prefix='', postfix='_1',format='.png',update=True,viewports=(),path=None,save_at_work=True,
	component='', vname='', input_text='', value_loc='',scale=1,unit='',float=2,opendir=True, fitview=False):
	## VER: 2017-08-09, 2.5
	## 本函数可以在import py文件后马上在命令窗口中运行。

	## Example:
	## save_image(name='wall_xmax')

	if name == 'help':
		print "save_image(name='',prefix='', postfix='_1',format='.png',viewports=(),path=None,save_at_work=True,vname='', input_text='', value_loc='',scale=1,unit='',float=2)"
		return

##	print 'value_loc=',value_loc
##	raise Exception
	if name == 0:
		update = False
		name = ''

	if update == True:
		refresh(input_text=input_text,fitview=fitview)

	if vname not in empty and update == True:
		name = ''

	file_name,format,viewports = viewport_to_image(name=name,prefix=prefix,postfix=postfix,format=format,update=update,
		viewports=viewports,path=path,save_at_work=save_at_work,avi=False, vname=vname, input_text=input_text, value_loc=value_loc, scale=scale, unit=unit, float=float)

##	print fnln(),'format=',format
##	print 'viewports=',repr(viewports)
##	raise Exception

	loc = file_name.rfind('.')
	session.printToFile(fileName=file_name[:loc], format=format, canvasObjects=viewports)  ## 并不会把背景颜色也保存

##	print ' '
##	print "save_image(name='',prefix='', postfix='_1',format='.png',viewports=(),path=None,save_at_work=True,vname='', input_text='', value_loc='',scale=1,unit='',float=2)"
##	print 'Global variable: fontsize =',fontsize,', you can change in in the command line.'
##	print ' '

	loc = file_name.rfind('/')
	dir1 = file_name[:loc]
	name = file_name[loc+1:]
	print ' '
	print 'image file: '
	print 'File name:',name
	print 'Saved in: ',dir1
	print ' '

	if opendir == True:
		open_dir(dir1)

	return

def save_imported():
	## VER: 2016-09-06, v1.0

	odb = odb_of_part()
	title = get_cae_file_title()
	print fnln(),'odb=',odb

	if odb != '' and title == 'unnamed':
		name1 = 'imp_' + odb[:-4]
		save_mdb(name1)

	else:
		save_mdb()

	globals()['p1'] = get_p1()

	return

function_labels['save_inp'] = 'inp file','create job','keyword'
def save_inp(jobname=None,model_name=None):
	## VER: 2016-11-20, v1.0
	## 在界面操作后保存inp，可知响应的关键字。
	## reference: create_inp()

	refresh()

	if jobname in empty:
		if 'inp_file_title' in globals().keys():
			jobname = inp_file_title
		else:
			cae_file = get_cae_file_title()
			if '_job' not in cae_file[-6:]:
				jobname = + '_job1'
			else:
				jobname = cae_file

	if type_of(jobname) != 'STR':
		raise Exception('**** jobname is required.')

	jobname = modify_string(jobname,'.','_')
	jobname = modify_string(jobname,'-','_')
	jobname = modify_string(jobname,' ','_')
	jobname = modify_string(jobname,'=')

##	jobname = new_key(mdb.jobs.keys(),jobname)

	if model_name in empty:
		model_name = current_model_name
	else:
		if model_name not in mdb.models.keys():
			raise Exception('*** Error model name')

	mdb.Job(atTime=None, contactPrint=OFF, description=jobname,
	    echoPrint=OFF, explicitPrecision=SINGLE, getMemoryFromAnalysis=True,
	    historyPrint=OFF, memory=85, memoryUnits=PERCENTAGE, model=model_name,
	    modelPrint=OFF, multiprocessingMode=DEFAULT, name=jobname,
	    nodalOutputPrecision=SINGLE, numCpus=4, numDomains=4,
	    parallelizationMethodExplicit=DOMAIN, queue=None, scratch='',
	    type=ANALYSIS, userSubroutine='', waitHours=0, waitMinutes=0)

	mdb.jobs[jobname].writeInput(consistencyChecking=OFF)  ## write inp之前一定要先保存cae。

	print fnln(),'created inp=',jobname,'.inp'

	return jobname

def save_mdb(cae_name=None,description=None):
	## VER: 2016-10-26, v1.4   本程序可能会改变期望的odb_file_title。因为refresh()会改变odb_file_title (批处理时）

	if type_of(cae_name) == 'STR':
		if cae_name[-4:].lower() == '.cae':
			cae_name = cae_name[:-4]

	name1 = get_cae_file_title()

	name2 = get_script_file()
	loc = name2.rfind('/')
	name2 = name2[loc+1:-3]

	if cae_name in empty:	## not provide
		if name1 == 'unnamed':   ## not saved yet
			if imported == False:
				name = name2
			else:
				name = '_temp'

			mdb.saveAs(name)
		else:
			if name1 == '_temp':
				if imported == False:
					name = name2
					mdb.saveAs(name)
			else:
				mdb.save()
	else:
		if name1 != cae_name:   ## not match with current cae file
			mdb.saveAs(cae_name)
			print 'New cae file name=',cae_name
		else:
			mdb.save()

	refresh()   ## update current mdb, and if current viewport is odb, the odb will be also updated.

	return

save_as = save_mdb

def add_model_description(text,save_file=False):
	## VER: 2014-03-07, v1.1

	if type_of(text) != 'STR':
		raise Exception('*** An experesion string is required, such as L=47')

	now = _m.description

	text = modify_string(text,'\n ', '\n')   ## 每行不能以空格开头

	while True:
		text = text.strip()
		if len(text) == 0:
			text = ' '
			break
		else:
			if text[-1] == '\n':
				text = text[:-1]
			else:
				break

	new = now + text + '\n'

	_m.setValues(description=new)

	if save_file == True:
		save_mdb(cae_file_title)

	return

function_labels['attrib'] = 'attribute','readonly','file','write'
def attrib(path=None,filename=None,readonly=False):
	## VER: 2016-10-26, v1.2

	## Example: attrib()
	## attrib('+R')
	## attrib('-R')
	## attrib(readonly=True)

##	>>> path = 'D:\JYQ\A0270-can tooling redraw die_Victor\py\E8_wangyf_frameless_3800.py'
##	>>> path
##	'D:\\JYQ\\A0270-can tooling redraw die_Victor\\py\\E8_wangyf_frameless_3800.py'
##	>>>

	if path in ['+R','+']:
		readonly = True
		path = None
	elif path in ['-R','-']:
		readonly = False
		path = None

	if path == filename == None:
		path = get_script_file()
	else:
		if path not in empty:
			path = real_dir(path)
		else:
			path = 'py/'

		if filename in empty and '.py' not in path:
			filename = inp_file_title + '.py'
			path = path + filename

	path = real_dir(path,tilt='left')	;please_check
##	print fnln(),'*** path =',repr(path)
	path0 = path

	if os.path.isfile(path):
		path = '"' + path + '"'		;please_check  ## 双引号不可省
		if readonly == False:
			command = 'attrib -R ' + path
			os.system(command)
			print fnln(),'--->',path0,': read only = False'
		else:
			command = 'attrib +R ' + path
			result = os.system(command)
			print fnln(),'--->',path0,': read only = True'
##		print fnln(),'command=',command

	else:
		print fnln(),'*** path =',repr(path)
		raise Exception('*** Error file path')

	return

def auto():
	## VER: 2016-12-06, v1.1

	dpo = get_dpo()
	if type_of(dpo) == 'ODB':
		vp = get_vpnow()
		vp.odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

	return

def auto_min():
	## VER: 2016-09-14, v1.0

	vp = get_vpnow()
	vp.odbDisplay.contourOptions.setValues(minAutoCompute=ON)

	return

def auto_max():
	## VER: 2016-09-14, v1.0

	vp = get_vpnow()
	vp.odbDisplay.contourOptions.setValues(maxAutoCompute=ON)

	return

function_labels['AV_shape'] = 'ao_to','ao_tu','shape','concave','convex','AV'
def AV_shape(face,trymore=False):
	## VER: 2015-03-30, v1.6    u代表凹面，法线汇集；n代表凸面，法线发散。

	curvature = get_curvature(face)
	if curvature in empty:
		return 'flat'

	normal_text = 'known'
	if not trymore:
		normal_text = face_ndir(face)
		if normal_text == 'unknown':
			trymore = True

	points = []
	if trymore == True:
		poi = get_poi(face)
		if type_of(poi) == 'PINSTANCE':
			part = poi.part
			face = part.faces[face.index]   ## 转换成part的face
		else:
			part = poi

		temp_part = copy_part(part,'temp_part')
		part = _m.parts[temp_part]

		cross_loc = face.getCentroid()[0]
		faces = divide_faces(faces=face,p=part,cross_loc=cross_loc)
		for face in faces:
			pointOn = face.pointOn[0]
			centroid = face.getCentroid()[0]
			normal = face.getNormal(point=pointOn)
			points.append([centroid,pointOn,normal])

		del_parts(part)

	else:
		pointOn = face.pointOn[0]
		centroid = face.getCentroid()[0]
		normal = face.getNormal(point=pointOn)
		points.append([centroid,pointOn,normal])

	status = []
	for point in points:
		centroid,pointOn,normal = point
		x0,y0,z0 = pointOn
		x1,y1,z1 = centroid
		x2,y2,z2 = x0 + normal[0], y0 + normal[1], z0 + normal[2]

		dx1,dy1,dz1 = x1 - x0, y1 - y0, z1 - z0
		dx2,dy2,dz2 = x2 - x0, y2 - y0, z2 - z0

		xx, yy, zz = dx1*dx2, dy1*dy2, dz1*dz2

		list1 = [xx,yy,zz]
		max1 = max(abs(xx),abs(yy),abs(zz))
		for i in range(3):
			if PK(abs(list1[i]),max1) == 0:
				if list1[i] > 1e-6:
					side = 'u'
				elif list1[i] < -1e-6:
					side = 'n'
				else:
					side = 'NA'

##		print 'xx,yy,zz=',xx,',',yy,',',zz

		status.append(side)

	num_U = status.count('u')
	num_A = status.count('n')   ## n,u

	result = 'NA'
	if num_U > num_A:
		result = 'u'   ## 凹面
	elif num_A > num_U:
		result = 'n'   ## 凸面
	else:
		print fnln_fnln(),'****无法判断凹凸特性，num_U = num_A for normal vectors'

	if normal_text == 'unknown':
		print len(status),'normal vectors analyzed:',status
		print '--->凹凸判断结果:',result

	return result

def sec2str(secs = None):
	## VER: 2011-05-03, v1.0
	""" 将秒转化为描述性字符串 """

	if secs == None:
		secs = time.time()

	return str(time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(secs)))

def section2mat(section):
	## VER: 2014-11-25, v1.0

	if section in _m.sections.keys():
		material = _m.sections[section].material
	elif section in _m.sections.values():
		material = section.material
	else:
		raise Exception('*** No such section.')

	return material

def section_cut(p,ndir,offset,points, depth=None, grow_trend=FORWARD):
	## VER:2013-05-24, v2.3

	## Example:
	## section_cut(p,stack_dir,offset,points, depth, grow_trend=grow_trend)
	## section_cut(part,ndir=ndir,offset=offset,points=points, depth=2*abs(offset), grow_trend=FORWARD)

	p = check_part(p)

	part_space = poi_space(p)

	if grow_trend == REVERSE:
		flip = OFF
	else:
		flip = ON

	print fnln_fnln(),'section ndir=',ndir,', offset=',offset,
	if offset == part_space[2*dir2num(ndir)]:
		print '= ' + ndir +'min of',p.name
	elif offset == part_space[2*dir2num(ndir) + 1]:
		print '= ' + ndir +'max of',p.name
	else:
		print

	sketch1 = create_part_sketch(p,name='temp_sketch1',ndir=ndir,offset=offset)
	sketch = sketch1['sketch']
	datum_plane = sketch1['datum_plane']
	right_edge = sketch1['right_edge']

	print 'before:','points=',points
	draw_lines_in_sketch(sketch,ndir=ndir,points=points,closed=True)

	please_check('如果要观察草图，请在此停止')
##	if debug == True:
##		raise Exception

	if type_of(depth) in numerics:
		depth = abs(depth)
	else:
		depth = 0

	if depth > 0:
		p.CutExtrude(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=SIDE1,
			sketchOrientation=RIGHT, sketch=sketch, depth=depth, flipExtrudeDirection=flip)
	else:
		p.CutExtrude(sketchPlane=datum_plane, sketchUpEdge=right_edge, sketchPlaneSide=SIDE1,
			sketchOrientation=RIGHT, sketch=sketch, flipExtrudeDirection=flip)

	print '--->Performed section delete for',p.name
	vpnow = get_vpnow()
##	vpnow.setValues(displayedObject=p)

	return

def section_grow(p,ndir,offset,section, depth1):
	## VER:2010-01-21

	x = 0;	y = 1;	z = 2
	sec_x = 0;	sec_y = 1

	for i in range(len(section)):
		section[i] = list(section[i])

	if ndir == 'x':
		origin1 = (offset,0,0)
		right_edge1 = right_edge_of_datum_plane(p,'OYZ')
	elif ndir == 'y':
		origin1 = (0,offset,0)
		right_edge1 = right_edge_of_datum_plane(p,'XOZ')
	elif ndir == 'z':
		origin1 = (0,0,offset)
		right_edge1 = right_edge_of_datum_plane(p,'XYO')

	flip = OFF   ## 正轴向生长
	datum_plane1 = create_datum_plane_by_offset(p,ndir,offset)

	for point in section:
		p1 = copy.deepcopy(point)
		if ndir == 'x':
			point[sec_x] = p1[y]
			point[sec_y] = p1[z]

		elif ndir == 'y':
			point[sec_x] = -p1[x]
			point[sec_y] = p1[z]

		elif ndir == 'z':
			point[sec_x] = p1[x]
			point[sec_y] = p1[y]

	for point in section:
		point.pop(z)

	t = p.MakeSketchTransform(sketchPlane=datum_plane1, sketchUpEdge=right_edge1, sketchPlaneSide=SIDE1, sketchOrientation=RIGHT,
	    origin=origin1)
	s = _m.ConstrainedSketch(name='__profile__', sheetSize=3000,
	    gridSpacing=50, transform=t)

	if ndir == 'y':
		side = SIDE2
	else:
		side = SIDE1

	num = len(section)
	for i in range(num - 1):
		s.Line(point1 = tuple(section[i]), point2 = tuple(section[i+1]))
	s.Line(point1 = tuple(section[num-1]), point2 = tuple(section[0]))

	p.SolidExtrude(sketchPlane=datum_plane1, sketchUpEdge=right_edge1, sketchPlaneSide=side,
		sketchOrientation=RIGHT, sketch=s, depth=abs(depth1), flipExtrudeDirection=flip,
		keepInternalBoundaries=ON)

	del s
	del _m.sketches['__profile__']
	print '--->Performed section growth for',p.name

def cross_range_of_objs(objs):
	## VER: 2017-08-01, v1.0

	## create set, pick() to get v1
	## cross_range_of_objs(v1)

	if type_of(objs) not in ['TUPLE','LIST']:
		raise Exception('*** objs list is required.')

	if type_of(objs[0]) not in ['edges','faces','cells','elements']:
		raise Exception('*** gemetry objs are required.')

	if len(objs) < 2:
		raise Exception('*** At lease two objs are required.')

	space1 = objs_space(objs[0])
	space2 = objs_space(objs[1])

	cross = cross_of_spaces(space1,space2)

	return cross

def cross_section_length(part,x=None,y=None,z=None,dir=None):
	## VER: 2014-04-16, v1.0

	part = check_part(part)
	part1 = copy_part(part,'part1')

	x,y,z = real_xyz(part,x,y,z)

	if type_of(x) in numerics:
		divide(part1,x=x)
		vertices = vertice_select(part1,x=x)
		if dir in empty:
			dir = 'y'

	elif type_of(y) in numerics:
		divide(part1,y=y)
		vertices = vertice_select(part1,y=y)
		if dir in empty:
			dir = 'x'

	elif type_of(z) in numerics:
		divide(part1,z=z)
		vertices = vertice_select(part1,z=z)

	if type_of(dir) != 'STR':
		raise Exception('*** dir is required to get the length.')

	dir = dir.lower()
	x1,x2,y1,y2,z1,z2 = objs_space(vertices)
	if dir == 'x':
		length = x2 - x1
	elif dir == 'y':
		length = y2 - y1
	elif dir == 'z':
		length = z2 - z1

	length = round(length,6)

	return length


def section_normal(poi):
	## VER: 2011-04-27, v1.0

	poi = check_pias(poi)

	normal = None

	faces1 = faces_of_cut(poi,y=MIN)
	faces2 = faces_of_cut(poi,y=MAX)

	area1 = get_area(faces1)
	area2 = get_area(faces2)

	if PK(area1,area2) == 0:
		return 'y'

	faces1 = faces_of_cut(poi,x=MIN)
	faces2 = faces_of_cut(poi,x=MAX)

	area1 = get_area(faces1)
	area2 = get_area(faces2)

	if PK(area1,area2) == 0:
		return 'x'

	faces1 = faces_of_cut(poi,z=MIN)
	faces2 = faces_of_cut(poi,z=MAX)

	area1 = get_area(faces1)
	area2 = get_area(faces2)

	if PK(area1,area2) == 0:
		return 'z'

	if normal == None:
		raise Exception('******Faile to get the section_normal for ' + poi.name)

	return

##def section_shell(mat,thick):
##	if thick == 0:
##		thick = 1.0
##	_m.HomogeneousShellSection(material=mat, name=mat+'_shell',thickness=thick)

def seed_part(part, esize=None):
	## VER: 2014-11-12, v1.2
	## reference: seed_edges()

	part = check_part(part)
	status = mesh_status(part)
	if status[0] == True:  ## already have mesh
		return
	else:
		esize0 = part.getPartSeeds(attribute=DEFAULT_SIZE)
		if is_number(esize):
			if esize > esize0:
				esize = esize0
		else:  ## esize not provide
			esize = esize0

		print fnln(),part.name,': Global seeding esize=',esize

		part.seedPart(deviationFactor=0.1, size=esize)  ## 该语句会将part的已经存在的mesh删除。

	return esize

def seed_section(part,x=None,y=None,z=None,esize_long=None,enum_long=None,esize_short=None,enum_short=2,minimum=1.2):
	## VER: 2011-12-11, v1.2

	part = check_part(part)

	if is_empties(x,y,z) == True:
		dir1 = get_beam_dir(part)
		if dir1 == 'x':
			x = _xmin(part)
		elif dir1 == 'y':
			y = _ymin(part)
		elif dir1 == 'z':
			z = _zmin(part)
		else:
			raise Exception('x,y,or z is required.')

	faces = []
	if x not in empty:
		faces = faces_of_cut(part,x=x,exterior=False)
	elif y not in empty:
		faces = faces_of_cut(part,y=y,exterior=False)
	elif z not in empty:
		faces = faces_of_cut(part,z=z,exterior=False)

	print fnln_fnln(),'enum_short=',enum_short
	if faces not in empty:
		seed_edges_of_faces(faces=faces,esize_long=esize_long,enum_long=enum_long,esize_short=esize_short,enum_short=enum_short,minimum=minimum)
	else:
		print fnln_fnln(),'No section was meshed due to empty section faces.'

	return

def seed_circular_edges(p,edges=(),quarter_seed=4, esize=None, enum=None):
	## VER: ('VER: 2012-12-09, v1.7')

	global seeding_seq

	p = check_part(p)

	if p.name not in seeding_seq.keys():
		seeding_seq[p.name] = 1
	else:
		seeding_seq[p.name] += 1
	seq = seeding_seq[p.name]

	edges = real_objs(edges,p)
	if edges in empty:
		edges = find_circular_edges(p)

	if edges in empty:
		print fnln_fnln(),'******Empty circle edges, not seeding at seed_circular_edges(), command#',seq
		return

	full_seed = 4*quarter_seed
	seeds = {}
	seeds['other'] = []

	for edge in edges:
		radius = get_radius(edge)
		if is_number(radius):
			length = edge.getSize(printResults=False)
			circum = 2*pi*radius
			ratio = round(length/circum,5)
			seed_num = int(full_seed*ratio + 0.5)
			if seed_num == 0:
				seed_num = 1

			if seed_num > 1:   ## seed_num = 1时对该edge置之不理。
				if seed_num not in seeds.keys():
					seeds[seed_num] = [edge]
				else:
					seeds[seed_num].append(edge)
		else:
			seeds['other'].append(edge)   ## non-circular edges

	for seed,edges in seeds.items():
		if seed != 'other':
			seed_edges(p,edges,enum=seed)

	if seeds['other']	not in empty:
		create_set(p,edges=seeds['other'],name='_non_circular_edges')
		raise Exception('****Some edges are not seeded. setname = _non_circular_edges.')

	return

def seed_edge(p,info=None,loc=(),x=(),y=(),z=(),edir=None, dx=None,dy=None,dz=None,length=None,esize=None,enum=None,fixed=False):

	## VER: ('VER: 2012-09-11,v3.4')

	global seeding_seq

	p = check_part(p)

	if info in empty:
		info = 'One edge'

	if loc not in empty:
		x0,y0,z0 = loc
		if dx != None:
			x0 = x0 + dx
		if dy != None:
			y0 = y0 + dy
		if dz != None:
			z0 = z0 + dz
		loc = (x0,y0,z0)

	if esize in empty and enum in empty:
		enum = 2

	if esize not in empty:
		if abs(float(esize) - int(esize)) < 1e-6:	## 整数的esize
			esize = int(esize)

	if enum not in empty:
		enum = int(enum)

	if fixed == True:
		fixed = FIXED
	else:
		fixed = FINER		##??****不固定，但取较密的mesh

	if p.name not in seeding_seq.keys():
		seeding_seq[p.name] = 1
	else:
		seeding_seq[p.name] += 1
	seq = seeding_seq[p.name]

	info = get_traceback()
	for i in range(len(info)):
		if type_of(info[i]) == 'STR' and 'seed' in info[i]:
			line_num = info[i - 1]
			break

	edge1 = []
	if (x not in empty) or (y not in empty) or (z not in empty):
		if type_of(x) in ['INT','FLOAT'] or type_of(y) in ['INT','FLOAT'] or type_of(z) not in ['INT','FLOAT']:
			edge1 = edges_of_cut(p,x=x,y=y,z=z,tryone=True)
		else:
			edge1 = edge_select(p,x=x,y=y,z=z,length=length,edir=edir, tryone=True)	## slow

	elif loc not in empty:
		edge1 = p.edges.findAt(coordinates=loc, printWarning=False)
		type1 = type_of(edge1)
		if type1 == 'edges':
			edge1 = [edge1]
		else:
			edge1 = []

	if edge1 in empty:
		print fnln_fnln(),'****No edge was found.'
		return
	else:
		edge1 = edge1[0]   ## 现在type_of(edge1) == 'edges'

	if fixed == FIXED:
		del_edges_seed(edge1)
	edir = edge_dir(edge1)

	if enum not in empty and enum > 1:
		enum0 = get_edge_enum(edge1,p)
		if (fixed == FINER and enum > enum0) or fixed != FINER:
			p.seedEdgeByNumber(edges=(edge1,), number=enum, constraint=fixed)		##??****
			print fnln_fnln(),'--->',p.name,'in',edir,'was fix-seeded mesh enum=',enum

			setname = '_' + str(seq) + '_seed_enum=' + str(enum) + '_' + str(line_num) + '_' + edir
			create_set(p,objs=edge1,name=setname,check_name=True)

	elif esize not in empty:
		len1 = round(edge_length(edge1),4)
		num1 = int(round(len1/esize))
		if num1 == 0:
			num1 = 1

		if num1 > 1:
			enum0 = get_edge_enum(edge1,p)
			if (fixed == FINER and num1 > enum0) or fixed != FINER:
				p.seedEdgeByNumber(edges=(edge1,), number=num1, constraint=fixed)		##??****
				print fnln_fnln(),'--->',p.name,'in',edir,'was fix-seeded mesh esize=',esize

				size1 = str(esize)
				loc1 = size1.find('.')
				if loc1 > 0:
					size1 = size1[:loc1] + 'p' + size1[loc1+1:]

				setname = '_' + str(seq) + '_seed_esize=' + size1 + '_' + str(line_num) + '_' + edir
				create_set(p,objs=edge1,name=setname,check_name=True)

	return

def seed_edges(p,edges=None,esize=None,enum=None,min_num=1,fixed=False, edir=None):
	## VER: ('VER: 2014-03-10,v3.5')     ## edges is obtained by selection, not by find.
	## Example:
##	edges = edge_select(carbide,radius=corner_radius)
##	seed_edges(carbide,edges=edges,enum=1,fixed=True)  ## 倒圆角

##	create_block('plate',x=(0,25),y=(0,25),z=(0,0.5))
##	move_part('plate',x1=MID,x2=0,y1=MID,y2=0,z1=MIN,z2=_zmax('green'))
##	edges = edge_select('plate',z=MID)
##	seed_edges('plate',edges=edges,enum=1)	##厚度方向上只有一层单元
##	hex_mesh('plate',esize=0.2)

##	seed_edges('powder',edges=_part('powder').edges,esize=0.5,min_num=4)  ## 设定esize，同时保证每条线至少有4个单元
##	mesh_region(powder,sweep=True)	;changing1


	global seeding_seq

	p = check_part(p)

	type1 = type_of(edges)
	if type1 == 'edges':
		edges = [edges]
	elif type1 == 'STR':
		edges = set2objs(edges,p)

	if edges in empty and edir in ['x', 'y', 'z']:
		edges = edge_select(p,edir=edir)

	if edges in empty:
		print fnln_fnln(),'****empty parameter edges.'
		return

	if esize in empty and enum in empty:
		enum = 2

	if esize not in empty:
		if abs(float(esize) - int(esize)) < 1e-6:
			esize = int(esize)

	if fixed == True:
		fixed = FIXED
	else:
		fixed = FINER		##??****不固定，但取较密的mesh

	if p.name not in seeding_seq.keys():
		seeding_seq[p.name] = 1
	else:
		seeding_seq[p.name] += 1
	seq = seeding_seq[p.name]

	info = get_traceback()
	for i in range(len(info)):
		if type_of(info[i]) == 'STR' and 'seed' in info[i]:
			line_num = info[i - 1]
			break

	if fixed == FIXED:
		del_edges_seed(edges)

	print fnln_fnln(),'enum=',enum,', esize=',esize, ', fixed=',fixed
##	stop1()

	dirs = []
	for edge in edges:
		edir = edge_dir(edge)
		if edir not in dirs:
			dirs.append(edir)
	dirs1 = ''
	for dir1 in dirs:
		dirs1 = dirs1 + dir1
	dirs = dirs1

	seeded_edges = []
##	if enum not in empty and enum > 1:
	if enum not in empty:   ## 有时当感兴趣的部位刚好是应力集中部位时，此时的倒圆角需要设定enum=1，否则倒圆角后应力更集中，因为单元更密集了。
		enum = int(enum)
		for edge in edges:
			enum0 = get_edge_enum(edge,p)
			if (fixed == FINER and enum > enum0) or fixed != FINER:
##				print fnln(),'fixed=',fixed
				p.seedEdgeByNumber(edges=(edge,), number=enum, constraint=fixed) 	##??****
				seeded_edges.append(edge)

		if seeded_edges not in empty:
			print '--->',len(seeded_edges),'edges fixed seeding number=',enum,'for',p.name
			setname = '_' + str(seq) + '_seeds_enum=' + str(enum) + '_' + str(line_num) + '_' + dirs
##			create_set(p,objs=seeded_edges,name=setname,check_name=True)  ## may cause error in the restart analysis

	elif esize not in empty: ## change to enum
		info1 = ''
		for edge in edges:
			len1 = round(edge_length(edge),4)
			num1 = int(round(len1/esize))
			if num1 == 0:
				num1 = 1
			if min_num > 1 and num1 < min_num:
				num1 = min_num
				info1 = '(min=' + str(min_num) + ')'

			enum0 = get_edge_enum(edge,p)
			if num1 > 1:
				if (fixed == FINER and num1 > enum0) or fixed != FINER:
					p.seedEdgeByNumber(edges=(edge,), number=num1, constraint=fixed)
					seeded_edges.append(edge)

		if seeded_edges not in empty:
			print '--->',len(seeded_edges),'edges fixed seeding esize=',esize,'for',p.name

			size1 = str(esize)
			loc1 = size1.find('.')
			if loc1 > 0:
				size1 = size1[:loc1] + 'p' + size1[loc1+1:]

			setname = '_' + str(seq) + '_seeds_esize=' + size1 + info1 + '_' + str(line_num) + '_' + dirs
##			create_set(p,objs=seeded_edges,name=setname,check_name=True)   ## may cause error in the restart analysis

	return

def seed_edges_of_faces(part=None,faces=None,esize_long=None,enum_long=None,esize_short=None,enum_short=None,x=None,y=None,z=None,ratio=2.5,short_min=1.3,long_min=4,area_min=5):
	## VER: 2014-09-11, v1.5  可以仅对短边seed，也可以仅对长边seed.

	## Example:
##	seed_edges_of_faces(bridge, x=MAX, enum_short=2, esize_long=8)
##	mesh_region(bridge,esize=15)

	if is_part(faces):
		part,faces = faces,part

	if is_poi(part):
		part = check_part(part)

	if type_of(part) == 'PART' and (x,y,z) != (None,None,None):
		faces = face_select(part,x=x,y=y,z=z,exterior=None)
	else:
		faces = tolist(faces)

	if faces in empty:
		raise Exception('*** faces are required.')

	if part in empty:
		part = get_poi(faces)

	if (esize_long,enum_long,esize_short,enum_short) == (None,None,None,None):
		raise Exception('esize or enum for long or short edges are required.')

##	long_edges, short_edges = long_short_edges_of_faces(faces,ratio=ratio,short_min=short_min,long_min=long_min,area_min=area_min)
	long_edges = long_edges_of_faces(faces=faces)
	short_edges = short_edges_of_faces(faces=faces)

	if (esize_short != None or enum_short != None) and short_edges not in empty:
		seed_edges(part,edges=short_edges,enum=enum_short,esize=esize_short,fixed=False)

	if (esize_long != None or enum_long != None) and long_edges not in empty:
		seed_edges(part,edges=long_edges,enum=enum_long,esize=esize_long,fixed=False)

	return

def seeds_of_face(face):
	## 2014-09-14, v1.1, used for mate_faces_in_inst()

	if is_plane(face) == False:
		return []

	locs = []
	x0,y0,z0 = face.getCentroid()[0]
	locs.append((x0,y0,z0))

	locs0 = []
	pts = face.getVertices()
	poi = get_parent(face)
	for pt in pts:
		loc = poi.vertices[pt].pointOn[0]
		if loc not in locs0:
			locs0.append(loc)

	pts = face.getEdges()
	for pt in pts:
		edge = poi.edges[pt]
		loc = mid_of_edge(edge)
		if loc not in locs0:
			locs0.append(loc)

	for loc in locs0:  ## collect two circles and centroid
		x,y,z = loc

		x1 = (x+x0)/2
		y1 = (y+y0)/2
		z1 = (z+z0)/2
		locs.append((x1,y1,z1))

		x2 = x + 0.1*(x0 - x)
		y2 = y + 0.1*(y0 - y)
		z2 = z + 0.1*(z0 - z)
		x2,y2,z2 = round6(x2,y2,z2)
		locs.append((x2,y2,z2))

		x2 = x + 0.9*(x0 - x)
		y2 = y + 0.9*(y0 - y)
		z2 = z + 0.9*(z0 - z)
		x2,y2,z2 = round6(x2,y2,z2)
		locs.append((x2,y2,z2))

	return locs


def select_construction_lines(sketch,H=None,V=None,edir=None):
	## VER: 2014-03-06, v1.1

	sketch = check_sketch(sketch)
	if H not in empty or V not in empty:
		H,V = real_xy_sketch(sketch,H=H,V=V)

	please_check
	if type_of(H) not in ['INT','FLOAT'] and H not in empty:
		raise Exception('*** H should be a value, not a range')

	if type_of(V) not in ['INT','FLOAT'] and V not in empty:
		raise Exception('*** V should be a value, not a range')

	if H in empty and V not in empty:
		dir0 = 'H'
	elif H not in empty and V in empty:
		dir0 = 'V'
	elif H in numerics and V in numerics:
		if type_of(edir) == 'STR':
			dir0 = edir
		else:
			dir0 = 'any'
	else:
		raise Exception('**** H and V are empty, use geometry_select() instead.l')

##	print2('dir0=',dir0)
##	print2('H,V =',(H,V))
	lines = []
	for curve in sketch.geometry.values():
		if type_of(curve) == 'construction_line':
			dir1 = dir_of_sketch_line(curve)
##			print 'dir1=',dir1
			pointOn = curve.pointOn

			vertices = curve.getVertices()
			if vertices not in empty:
				locs = []
				for vertice in vertices:
					locs.append(vertice.coords)
				vertices = locs

			if dir0 != 'any' and dir1 != dir0:
				continue

			if dir0 == 'H' and PK(V,pointOn[1]) == 0:
				lines.append(curve)
			elif dir0 == 'V' and PK(H,pointOn[0]) == 0:
				lines.append(curve)
			elif dir0 == 'slope' or dir0 == 'any':
				if (H,V) in vertices:  ## pass through
					lines.append(curve)

	return lines

def select_regular_lines(sketch,H=None,V=None,edir=None):
	## VER: 2013-06-19, v1.0

	lines = select_lines_in_sketch(sketch=sketch,H=H,V=V,edir=edir,type='regular')

	return lines

##def select_single_obj(p, objectType, xRange, yRange, zRange):
##	myObj = obj_select(p, objectType, xRange, yRange, zRange)
##	return myObj[0]

def set_append(p1,set1name,set2name):
	## VER: 2010-01-20

	list1 = set2objs(set1name,p1)
	if type_of(set2name) == 'STR':
		list2 = set2objs('PVB_gap',p1)
	elif type_of(set2name) == 'LIST':
		list2 = set2name

	list1 = list1 + list2
	create_set(p1,objs=list1,name=set1name,check_name=False)

	print '--->Updated set:',len(list2),type_of_set(p1,set1name),'are added to set named',set1name

	return

function_labels['set_element_shape'] = 'mesh control','technique','hex','sweep','tet','structured'
def set_element_shape(part,objs=None,region=None, cells=None,faces=None, edges=None, eshape=None,technique=None,algorithm=None,allowMapped=None, sizeGrowth=None):
	## VER: 2015-11-04, v1.5. Reference: three_element_types()
	## use together with set_element_type()
	## Note: If cannot mesh with Hex, increase the esize may solve, or use C3D20R, instead of change the element shape.
	## esize is better to >= radius/3
	## esize is better to >= 1, especially when cannot mesh with Hex with esize=0.5
	## ★GUI: Mesh->Controls

##	cells = get_unmeshed_region(anvil)
##	if cells not in empty:
##		set_element_shape(anvil,cells=cells,eshape='TET')
##		mesh_region(anvil,cells=cells)
##
##		cells1 = get_unmeshed_region(anvil)
##		if cells1 not in empty:
##			choose_element_type(anvil,cells=cells1,order=2)
##			mesh_region(anvil,cells=cells)

	## Example: set_element_shape(powder, eshape=QUAD, technique=STRUCTURED)

	## Example
##	set_element_shape(powder, objs=powder.faces, technique=SWEEP)  ## 可能仍然有些区域无法用sweep方法。
##	mesh_part(powder,esize=0.5)  ## origin: 0.2			## 同时使用SWEEP和ALE时，esize不能小于0.5.
##	apply_adaptive_mesh(elements=powder_A1.elements)	;changing

##	set_element_shape(punch,eshape='TET')
##	mesh_part(punch)

	## Example:
	## set_element_shape(powder_s,faces=faces,allowMapped=True,technique=SWEEP)
	## set_element_shape(stamp,eshape=TET)

##	set_sweep_path(powder_s.faces,dir='x',forward=True)  ## 适合少数几个
##	set_element_shape(powder_s, objs=powder_s.faces, technique=SWEEP)

	## eshape:
	##QUAD: Quadrilateral mesh.
	##QUAD_DOMINATED: Quadrilateral-dominated mesh.
	##TRI: Triangular mesh.此时tenique总是FREE
	##HEX: Hexahedral mesh.
	##HEX_DOMINATED: Hex-dominated mesh.
	##TET: Tetrahedral mesh.
	##WEDGE: Wedge mesh

##	technique:
##	FREE: Free mesh technique.
##	STRUCTURED: Structured mesh technique.
##	SWEEP: Sweep mesh technique.
##	BOTTOM-UP: Bottom-up mesh technique. Only applicable for cell regions.
##	SYSTEM_ASSIGN: Allow the system to assign a suitable technique. The actual technique assigned can be STRUCTURED, SWEEP, or “unmeshable

##	algorithm:
##	For free quadrilateral or quadrilateral-dominated meshing. In this case the possible values are MEDIAL_AXIS and ADVANCING_FRONT.
##	For sweep hexahedral or hexahedral-dominated meshing. In this case the possible values are MEDIAL_AXIS and ADVANCING_FRONT.
##	For free tetrahedral meshing. In this case the only possible value is NON_DEFAULT,
## and it indicates that the free tetrahedral-meshing technique available in Abaqus 6.4 or earlier will be used. If algorithm is not specified, the default tetrahedral-meshing technique will be used

##	allowMapped  (True or False)
##	Free quadrilateral or quadrilateral-dominated meshing with algorithm=ADVANCING_FRONT.
##	Hexahedral or hexahedral-dominated sweep meshing with algorithm=ADVANCING_FRONT.
##	Free tetrahedral meshing. allowMapped=True implies that mapped triangular meshing can be used on faces that bound three-dimensional regions.

##sizeGrowth:
##A SymbolicConstant specifying element size growth to be applied when generating the interior of a tetrahedral mesh.
##Possible values are MODERATE and MAXIMUM. If unspecified, the existing value will remain unchanged. This option only applies to the default tetrahedral mesher

	part = check_part(part)

	objs = get_real_input(objs,faces,cells,edges)
	if objs in empty:
		if len(part.cells) > 0:
			objs = part.cells
		elif len(part.faces) > 0:
			objs = part.faces
		elif len(part.edges) > 0:
			objs = part.edges

##	region = list2region(objs,region_type='set')
	region = list2sequence(objs)

	print ' '
	print fnln(),'Applying mesh control for',part.name,':'

	if type_of(eshape) == 'STR':
		eshape = eshape.upper()
		eshape = eval(eshape)

	if type_of(technique) == 'STR':
		technique = technique.upper()
		if 'STRU' in technique:
			technique = 'STRUCTURED'
		technique = eval(technique)

	if eshape in [TET,TRI]:
		technique = FREE
	elif eshape == HEX_DOMINATED:
		technique = SYSTEM_ASSIGN

	if technique not in [None,STRUCTURED,FREE,SWEEP,SYSTEM_ASSIGN]:
		raise Exception('*** Error mesh technique.')

	print fnln(),'eshape=',eshape,', technique=',technique
##	stop1()
	## For powder compaction: eshape=QUAD, technique=STRUCTURED (结构化网格）
	if eshape in [UNKNOWN_SHAPE, LINE, TET, HEX, HEX_DOMINATED, TRI, QUAD, QUAD_DOMINATED, WEDGE]:
		if technique not in empty:
			part.setMeshControls(regions = region, elemShape=eshape,technique=technique)
		else:
			part.setMeshControls(regions = region, elemShape=eshape)

	## technique和eshape在GUI上可以是两个独立的操作。
	else:  ## eshape = None
		if technique not in empty:
			part.setMeshControls(regions = region, technique=technique)

	print fnln(),'algorithm=',	algorithm
	if algorithm not in empty:
		part.setMeshControls(regions = region, algorithm=algorithm)

	print fnln(),'allowMapped=',allowMapped
	if allowMapped in [True,False]:
		part.setMeshControls(regions = region, allowMapped=allowMapped)

	print fnln(),'sizeGrowth=',sizeGrowth
	if sizeGrowth not in empty:
		part.setMeshControls(regions = region, sizeGrowth=sizeGrowth)

	return

def set_mount_options(mount_option,BF=None,gap=None):

	## VER: ('VER: 2012-08-27, v2.1')

	## 比较顺序：topside: BF1000+f(top) => BF2000 + f(top) => BF(2000)+f+dam0.2
	##           backside:f+dam0(back) => f
	## BF1000+f的收敛性比f好 (topside)，也允许有更大的挠度，从而也更准确。

	global brief,has_dam, dam2clamp,has_mount_clamp,clamp_friction,bload,has_bload

##	if load_side == 'bot' and mount_option not in ['other','hole','f']:
##		mount_option = 'f+dam0'			;please_check
##		globals()['mount_option'] = mount_option
##		gap = 0

	if BF == None:
		BF = 1000

	if gap == None:
		gap = 0.2

	if mount_option.endswith('dam0'):
		gap = 0
	elif mount_option.endswith('dam0.2'):
		gap = 0.2

	if mount_option == 'noclm' or mount_option == 'Null' or has_mount_clamp == False:
		print fnln_fnln(),'Condition here:'
		has_dam = False
		dam2clamp = 0

		has_mount_clamp = False
		clamp_friction = False
		bload = 0

	elif mount_option == 'BF':    ## W, DOE模型可预测性好。假如pass，则无clamp时也可能pass。
		print fnln_fnln(),'Condition here:'

		has_dam = False
		dam2clamp = 0

		has_mount_clamp = True
		clamp_friction = False
		bload = BF

	elif mount_option == 'f':  ## 没有预紧力，也没有dam，只靠clamp的摩擦力和clamp的材料变形来限制。可以用来观察不收敛的原因（50倍观察)
		print fnln_fnln(),'Condition here:'
		has_dam = False
		dam2clamp = 0

		has_mount_clamp = True
		clamp_friction = True
		bload = 0

	elif mount_option == 'dam':  ## 没有摩擦力，则易挣脱。收敛性很差。
		print fnln_fnln(),'Condition here:'
		has_dam = True
		dam2clamp = gap

		has_mount_clamp = True
		clamp_friction = False
		bload = 0

	elif mount_option in ['BF+f', 'f+BF']:    ## V, DOE模型可预测性好, 但对于A模型，可能仍然不能避免frame从clamp挣脱(即使BF=4000. 例如outer_wall_thick=1.4, inner_wall_thick=1.6, base_thick=1.4的情形)
										## 如果BF超过3000，结果可能还不如BF2000+f+dam0.2苛刻。
		print fnln_fnln(),'Condition here:'
##		has_dam = False
##		dam2clamp = 0		;please_check

		has_mount_clamp = True
		clamp_friction = True
		bload = BF

	elif mount_option.startswith('BF+f+dam') or mount_option.startswith('f+BF+dam'):   ## 收敛性好，但是DOE模型可预测性差。徐业宇说，R-sq(预测)不重要。
		print fnln_fnln(),'Condition here:'
		has_dam = True
		dam2clamp = gap

		has_mount_clamp = True
		clamp_friction = True
		bload = BF

	elif mount_option.startswith('f+dam'):  ## A, DOE模型可预测性好。可行性
		print fnln_fnln(),'Condition here:'
		has_dam = True
		dam2clamp = gap

		has_mount_clamp = True
		clamp_friction = True
		bload = 0

	elif mount_option == 'other' or mount_option == 'hole':   ## 其他安装方式，没有clamp和rail
		print fnln_fnln(),'Condition here:'
		has_dam = False
		dam2clamp = 0

		has_mount_clamp = False
		clamp_friction = False
##		bload = 0

	if bload > 0:
		has_bload = True
	else:
		has_bload = False

	print fnln_fnln(),'clamp options:'
	print 'has_dam =',has_dam
	print 'dam2clamp =',dam2clamp
	print 'has_mount_clamp =',has_mount_clamp
	print 'clamp_friction =',clamp_friction
	print 'bload =',bload
	print ' '

	return

def set_colormap(mats=()):

	## VER: ('VER: 2012-07-04, v2.3')		## 各种材料的颜色谱
	## 注意：慎重执行，否则有些材料的颜色显示不正确。

	vpnow = get_vpnow()

	## database:
	Red = '#FF0000'
	Green = '#00FF00'
	Blue = '#0000FF'
	Yellow = '#FFFF00'
	SkyBlue = '#00FFFF'
	Purple = '#D200FF'

	print fnln_fnln(),'****setting color map...'
	print_caller_code()

	mycolor = {
			'Al_6063': Green,    	## frame
        	'Al_6061': Blue, 	## clamp, rail, 蓝色，拦住
        	'EVA':	Red,
        	'EVA2':  Red,
        	'Glass':	SkyBlue,
        	'Glass2': 	SkyBlue,
        	'PVB':		'#DEB887',
        	'Rigid':	'#FFFF00',
        	'Rubber':	'#FF00FF',
        	'Rubber2':	'#FF00FF',
        	'Si':		'#E9967A',
        	'Silic':	 Blue,
        	'Silic2': Blue,
        	'Paper':	'#00FF00',
        	'Steel':	Purple,
        	'TPT':	Yellow,
        	'Tape': 	Blue,
        	'FRP':	SkyBlue}

	mats = tolist(mats)
	if mats in empty:
		dpo = vpnow.displayedObject
		if type_of(dpo) in ['PART','ASSEMBLY']:
			mats = get_all_mats(_m)

	if len(mats) > 0 and type_of(vpnow.displayedObject) in ['PART','ASSEMBLY','ODB']:
		vpnow.enableMultipleColors()
		vpnow.setColor(initialColor='#BDBDBD')   ## 当dpo为None时，出现keyword error

		cmap = vpnow.colorMappings['Material']
		colors = cmap.attributeColors		## 如果视图是空的，本行将出错。

		colors_dict = {}
		for color in colors:
			colors_dict[color[0]] = (False,)
		cmap.updateOverrides(overrides=colors_dict)

		for mat in mats:
##				print 'mat=',mat
			if mat in mycolor:
				color = mycolor[mat]
			else:
				color = Red
				print fnln_fnln(),'No such material',mat,'in mycolor'

			value = (True,color,'Default',color)
			cmap.updateOverrides(overrides={mat:value})
			## cmap.setValues(overrides={mat:value})

		vpnow.setColor(colorMapping=cmap)
		vpnow.disableMultipleColors()

		print '--->Color is activated for mats=',mats

	return

def set_decimal(num=0,viewport=None, automatic=True,scale=1):
	## VER: 2013-10-20, v1.6
	## empty input means no decimal
	## legend的边界: bounding box
	## 注意：该函数可能使诸如1e-10的结果显示为0

	if type_of(num) != 'INT':
		raise Exception('**** integer is required.')

	if num < 0:
		raise Exception('**** num should be >= 0')

	if viewport in empty:
		viewport = session.viewports[session.currentViewportName]

	viewport_type, viewport = check_viewport(viewport)
	if viewport_type == 'ODB':
		display = viewport.odbDisplay
		##	print 'Tip: You can get the primary variable by display.primaryVariableLabel'
		max0 = display.contourOptions.autoMaxValue
		min0 = display.contourOptions.autoMinValue

##		print fnln_fnln(),'max0,min0=',(max0, min0)
		max0 = max(abs(max0), abs(min0))
		mag = get_magnitude(max0)
		num = get_decimal_num(max0)

		setting = current_variable_setting()
		main_var0 = setting['main0']
##		print fnln(),'main_var0=',main_var0
##		print fnln(),'mag=',mag
##		raise Exception

		if main_var0 != 'DENSITY':
			if abs(mag) > 5:
				viewport.viewportAnnotationOptions.setValues(legendNumberFormat=SCIENTIFIC,legendDecimalPlaces=2)
			else:
				viewport.viewportAnnotationOptions.setValues(legendNumberFormat=FIXED,legendDecimalPlaces=num)
	##			print fnln_fnln(),'set decimal num =',num
		else:
				viewport.viewportAnnotationOptions.setValues(legendNumberFormat=ENGINEERING,legendDecimalPlaces=2)

		## num for result
##		print fnln_fnln(),'num=',num
		if scale > 1:
			mag = get_magnitude(scale)
##			print fnln_fnln(),'magnitude=',mag
			num = abs(num - mag + 1)
##			print fnln_fnln(),'num=',num

	return num

_set_float_num = set_decimal


def set_sweep_path(faces,dir='x',forward=True):
	## VER: 2013-10-12, v1.1  ## forward代表正向，即有小到大的方向，也就是顺着坐标轴的方向。
	## 如果某个面无法sweeep mesh，该面将被忽略。可以手工操作检查是否有警告。
	## sweep meshing

##	if forward == True:
##		sense = 1
##	else:
##		sense = -1

	part = get_poi(faces)
	faces = tolist(faces)

	set_element_shape(part,faces=faces,technique=SWEEP)

##	print 'dir=',dir
##	raise Exception

	for face in faces:
		edge1 = get_face_edge_in_dir(face,dir=dir)
		dir1 = edge_dir_ends(edge1)

		if dir1 == forward:
			sense1 = FORWARD
		else:
			sense1 = REVERSE

##		if forward == True:
##			if dir == '+':
##				sense1 = REVERSE
##			else:
##				sense1 = FORWARD
##		else:
##			if dir == '+':
##				sense1 = FORWARD
##			else:
##				sense1 = REVERSE

##		if dir1 == sense:
##			sense1 = FORWARD
##		else:
##			sense1 = REVERSE
		part.setSweepPath(region=face, edge=edge1, sense=sense1)

##	if sense == 1:
##		sign = '+'
##	else:
##		sign = '-'
##	print '--->Setted sweep path in',sign+dir,'direction'

	return


def set_temperature_predefined_field(name='field_temperature', objs=None, region=None,insts=None,initial_step=20, initial=None,modifys=[],modify=None):
	## VER: 2016-04-01, v2.2, stress free temperature, no CTE mis-match，该温度通常也就是room temperature，因为材料的CTE是在参考室测试的。
	## Procedure type: Static, General. 也可以用于 thermal_stress类型的分析步。
	## 参考温度是当你实验测量热膨胀系数时候用的初始温度。
	## 从热膨胀系数的定义出发，热膨胀系数不是 "应变vs.温度"曲线 在某个温度点上的切向斜率，而是从原点出发的一条连线的斜率，这个原点就是参考温度
	## 在参考温度点，热胀量为零，不是因为线胀系数为0，而是因为温差是0.

## 1.
## 如果整个分析中某个分析步含有温度自由度（例如thermal_stress)，则modifys无效且会出错（全都为compute, edit键是虚的，不可编辑，必须显式更改)
## 如果整个分析中没有那个分析步含有温度自由度，则modifys有效。
## 2.
## static_general analysis中，没有温度自由度，所以，要修改温度场，只能隐式修改(implicit)，即在pre-defined field的对话框中设置各个载荷步的温度场。
## 在thermal_stress analysis中，有温度自由度。仍然需要设置初始温度场，不过后续各个载荷步的温度场的修改只能显式(explicit)更改，也就是更改temperature BC。

	## 版主：
##	热膨胀系数如果与温度无关，则参考温度对计算无影响。
##	如果设置热膨胀系数为温度的函数，则参考温度对计算有影响。

	## set_temperature_predefined_field(initial=25,modify=24,insts='PART2-1')  ##其中, PART2为orphan mesh part.

	## HPHT
##	create_general_static_step(stepname='heating',initial_inc=0.002,restart=True)	 ;please_check
##	create_general_static_step(stepname='bond',initial_inc=0.002)
##	create_general_static_step(stepname='cool_down',initial_inc=0.002)
##	create_general_static_step(stepname='pressing',initial_inc=0.002)
##	set_temperature_predefined_field(initial_step=20,modifys=[('step1',bonding_temperature),('step3',work_temperature)])
##	set_temperature_predefined_field(initial_step=high_T, modifys=('step1',low_T))	;changing1

	## Example:
##	set_temperature_predefined_field(initial_step=1000,modifys=[('step1',300)])
##  set_temperature_predefined_field(initial_step=20,modifys=[('step1',bonding_temperature),('step3',work_temperature)])

	## 根据用户手册，property直接定义的线膨胀系数是相对于参考温度的平均线膨胀系数，而不是瞬时线膨胀系数。

	print ' '
	print 'Creating region and setting stress free temperature for the whole model...'

	if is_number(initial):
		initial_step = initial

	if modify not in empty:
		modifys = modify

	## 要么是几何region，要么是mesh region，不能二者兼有。
	if insts not in empty:
		objs = insts

	if region in empty:
		if objs not in empty:
			type1 = type_of(objs)
			insts = real_insts(objs)
			if insts not in empty:
				region = insts_to_region(insts)
			else:
				if type1 == 'STR':
					region = set2region(objs)
				elif type1 in ['LIST','SEQUENCE']:
					region = list2region(objs, region_type='set')
				elif type1 not in ['REGION','SET']:
					raise Exception('object region is required.')   ## **********

		else:
			insts = get_cells_insts()   ## 注意，将忽略orphan mesh part
			if insts not in empty:
				region = insts_to_region(insts)
			else:
				insts = get_faces_insts()
				if insts not in empty:
					region = insts_to_region(insts)
				else:
					sequence = None
					for inst in a.instances.values():
						if len(inst.nodes) > 0:
							if sequence == None:
								sequence = inst.nodes   ## prefield 加载在节点上，而不是单元上。
							else:
								sequence = sequence + inst.nodes

					if sequence != None:
						region = Region(nodes=sequence)    ## set like region
					else:
						raise Exception('*** No cells region, faces region or orphan mesh in the model')

	## Temperature pre-defined field, not temperature BC or temperature load.
	## For residual stress calculation, set the reference temperature(参考温度) as room temperature, not -273. Otherwise, the part will be expanded at room temperature.
	## step procedure type = Static, General

	caller_line = str(fnln_fnln()[1])
	name = new_key(_m.predefinedFields.keys(),name + '_' + caller_line)

	## 施加温度类型的pre-defined field，用的却是Temperature命令（GUI也是如此）。类似于ANSYS的均匀温度。
	_m.Temperature(name=name, createStepName='Initial', region=region, distributionType=UNIFORM,
	    crossSectionDistribution=CONSTANT_THROUGH_THICKNESS, magnitudes=(initial_step, ))

	modified = False
	if modifys not in empty:
		print fnln(),'modifys=',modifys
		if is_number(modifys):
			if len(_m.steps) == 1:   ## only initial step
				raise Exception('*** No any step yet.')
			else:
				stepname = _m.steps.keys()[1]
				mag1 = modifys
				_m.predefinedFields[name].setValuesInStep(stepName=stepname, magnitudes=(mag1,))
				modified = True

		else:	## such as: Initial, step1, step2
			modifys = real_modifys(modifys)
			for item in modifys:
				stepname,mag1,amp1 = item
				if amp1 in empty:
					_m.predefinedFields[name].setValuesInStep(stepName=stepname, magnitudes=(mag1,))
				else:
					_m.predefinedFields[name].setValuesInStep(stepName=stepname, magnitudes=(mag1,),amplitude=amp1)
				modified = True

	if modified == False:
		print '--->Set temperature field in predefined field manager(implicit way): initial temp=',initial_step,'degC, only in Initial step. Please make sure model is fixed properly(including symmetry) in Initial step. ****'
	else:
		print '--->Set temperature field in predefined field manager(implicit way): initial temp=',initial_step,'degC, and modified in analysis steps.'
	print ' '

	return name

function_labels['set_modulus'] = 'material property','elastic modulus','Youngs modulus'
def set_modulus(mat,table,poisson=0.3):
	## VER: 2017-10-22, v1.3

##	set_modulus('H10F',200000)	;changing

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	if is_number(table):
		table = (table,poisson)

	table = totable(table)

	if len(table[0]) not in[2,3]:
		raise Exception('*** Incorrect data format, should be: (modulus1, poisson1, temp1),(modulus2, poisson2, temp2)')

	if len(table[0]) == 3:
		_m.materials[mat].Elastic(temperatureDependency=ON, table=table)
	elif len(table[0]) == 2:
		_m.materials[mat].Elastic(temperatureDependency=OFF, table=table)

	return

def set_density(mat,table):
	## VER: 2017-10-22, v1.3

##	Query density:
##	>>> _m.materials['H10pow'].density.table
##	((3.49355e-09,),)
##	>>>

##	if 'PW' in globals().keys():
##		density = smart_round(PW/get_volume(fill_part)*1e-6)
##		set_density(mat,table=density)   ## 3.234
##
##	set_mat(fill_part,mat=mat)   ## 此时get_volume(fill_part) == fill_volume0

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	if is_number(table):
		if 0.2<table<20:
			table = table*1000*KD
		elif 200 < table < 20000:
			table = table*KD

	table = totable(table)
	if len(table[0]) not in[1,2]:
		raise Exception('*** Incorrect data format, should be: (density1, temp1),(density2, temp2)')

	if len(table[0]) == 2:
		_m.materials[mat].Density(temperatureDependency=ON, table=table)
	elif len(table[0]) == 1:
		_m.materials[mat].Density(temperatureDependency=OFF, table=table)

	return

function_labels['set_conductivity'] = 'thermal','heat','temperature','material property','conduction'
def set_conductivity(mat,table):
	## VER: 2017-10-22, v1.2

##	>>> totable(5)
##	((5,),)
##	>>>
	## Example:
##	PCD_expansion = (1.72e-6, 25), (2.39e-6, 200), (3.06e-6, 400),(3.72e-6, 600), (4.39e-6, 800)
##	set_CTE('PCD',PCD_expansion)

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	table = totable(table)
	if len(table[0]) not in [1,2]:
		raise Exception('*** Incorrect data format, should be: (K1, temp1),(K2,temp2)')    ## means: at temp1, such room temperature, K=K1

	if len(table[0]) == 2:
##		exchange = False
##		if len(table) == 1:
##			if table[0][0] != 0 and abs(table[0][0]) > 1:
##				exchange = True
##		else:
##			if abs(table[0][0]) > 1 or abs(table[1][0]) > 1:  ## format: temp,CTE
##				exchange = True
##
##		if exchange == True:
##			newlist = []
##			for v1,v2 in table:
##				newlist.append((v2,v1))
##			table = totable(newlist)

		_m.materials[mat].Conductivity(temperatureDependency=ON, table=table)

	else:
		_m.materials[mat].Conductivity(temperatureDependency=OFF, table=table)

##	if is_number(zero_expand_temp):  ## default to set 20 degC as zero expension temperature.
##		_m.materials[mat].expansion.setValues(zero=zero_expand_temp)		## Reference temperature******** (that is, at zero_expand_temp, no expansion, but if temperature higher than ref_T, there will be expansion.)

	return

function_labels['set_CTE'] = 'thermal expansion','property','material','temperature'
def set_CTE(mat,table,zero_expand_temp=20):
	## VER: 2017-10-21, v1.4

##	>>> totable(5)
##	((5,),)
##	>>>
	## Example:
##	PCD_expansion = (1.72e-6, 25), (2.39e-6, 200), (3.06e-6, 400),(3.72e-6, 600), (4.39e-6, 800)
##	set_CTE('PCD',PCD_expansion)

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	table = totable(table)
	if len(table[0]) not in [1,2]:
		raise Exception('*** Incorrect data format, should be: (CTE1, temp1),(CTE2,temp2)')

	if len(table[0]) == 2:
		exchange = False
		if len(table) == 1:
			if table[0][0] != 0 and abs(table[0][0]) > 1:
				exchange = True
		else:
			if abs(table[0][0]) > 1 or abs(table[1][0]) > 1:  ## format: temp,CTE
				exchange = True

		if exchange == True:
			newlist = []
			for v1,v2 in table:
				newlist.append((v2,v1))
			table = totable(newlist)

		_m.materials[mat].Expansion(temperatureDependency=ON, table=table)

	else:
		_m.materials[mat].Expansion(temperatureDependency=OFF, table=table)

	if is_number(zero_expand_temp):  ## default to set 20 degC as zero expension temperature.
		_m.materials[mat].expansion.setValues(zero=zero_expand_temp)		## Reference temperature******** (that is, at zero_expand_temp, no expansion, but if temperature higher than ref_T, there will be expansion.)

	return

function_labels['set_Cp'] = 'thermal','heat','temperature','material property','conduction','specific heat'
def set_Cp(mat,table):
	## VER: 2017-10-21, v1.2

##	>>> totable(5)
##	((5,),)
##	>>>
	## Example:
##	PCD_expansion = (1.72e-6, 25), (2.39e-6, 200), (3.06e-6, 400),(3.72e-6, 600), (4.39e-6, 800)
##	set_CTE('PCD',PCD_expansion)

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	table = totable(table)
	if len(table[0]) not in [1,2]:
		raise Exception('*** Incorrect data format, should be: (Cp1, temp1),(Cp2,temp2)')    ## means: at temp1, such room temperature, Cp=Cp1

	if len(table[0]) == 2:
##		exchange = False
##		if len(table) == 1:
##			if table[0][0] != 0 and abs(table[0][0]) > 1:
##				exchange = True
##		else:
##			if abs(table[0][0]) > 1 or abs(table[1][0]) > 1:  ## format: temp,CTE
##				exchange = True
##
##		if exchange == True:
##			newlist = []
##			for v1,v2 in table:
##				newlist.append((v2,v1))
##			table = totable(newlist)

		_m.materials[mat].SpecificHeat(temperatureDependency=ON, table=table)

	else:
		_m.materials[mat].SpecificHeat(temperatureDependency=OFF, table=table)

##	if is_number(zero_expand_temp):  ## default to set 20 degC as zero expension temperature.
##		_m.materials[mat].expansion.setValues(zero=zero_expand_temp)		## Reference temperature******** (that is, at zero_expand_temp, no expansion, but if temperature higher than ref_T, there will be expansion.)

	return

function_labels['set_plastic'] = 'material','plastic','stress-strain','yield','strength'
def set_plastic(mat,table,hardening=ISOTROPIC):
	## VER: 2017-10-21, v1.5   (stress1, strain1, temp1),(stress2, strain2, temp2)
	## (Yield strength R0.2, 0), (Tensile strength Rm, elongation)   The plastic strain at first yield must be zero

##	set_plastic('Steel',(200,0))	;changing  ## 在运行此语句之前，已经运行material_database()，但没有设置Steel_plastic的值。
	## 运行此语句之后，Steel_plastic的值将会设置。

##	set_plastic('Steel1',(200,0))	;changing  ## 在运行此语句之前，已经运行material_database()，Steel1_plastic为其他默认值。
	## 运行此语句之后，Steel1_plastic的值被改变。

##	Steel_H13_plastic = (1280, 0, 20), (1420, 0.09, 20), (1000, 0, 400), (600, 0, 600)  ## 室温下提供区服强度和拉伸强度，而高温下仅提供区服强度
##	set_plastic('Steel_H13',table=Steel_H13_plastic)

	## Example:
##	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
##	set_plastic('Steel', wire_plastic)	;changing

##	If hardening=ISOTROPIC, or if hardening=COMBINED and dataType=HALF_CYCLE, the table data specify the following:
##	Yield stress.
##
##	Plastic strain.
##
##	Equivalent plastic strain rate, .
##
##	Temperature, if the data depend on temperature.
##
##	Value of the first field variable, if the data depend on field variables.
##
##	Value of the second field variable.
##
##	Etc.
##
##	If hardening=COMBINED and dataType=STABILIZED, the table data specify the following:
##	Yield stress.
##
##	Plastic strain.
##
##	Strain range, if the data depend on strain range.
##
##	Temperature, if the data depend on temperature.
##
##	Value of the first field variable, if the data depend on field variables.
##
##	Value of the second field variable.
##
##	Etc.
##
##	If hardening=COMBINED and dataType=PARAMETERS, the table data specify the following:
##	Yield stress at zero plastic strain.
##
##	The first kinematic hardening parameter, .
##
##	The first kinematic hardening parameter, .
##
##	If applicable, the second kinematic hardening parameter, .
##
##	If applicable, the second kinematic hardening parameter, .
##
##	Etc.
##
##	Temperature, if the data depend on temperature.
##
##	Value of the first field variable, if the data depend on field variables.
##
##	Value of the second field variable.
##
##	Etc.
##
##	If hardening=KINEMATIC, the table data specify the following:
##	Yield stress.
##
##	Plastic strain.
##
##	Temperature, if the data depend on temperature.
##
##	If hardening=JOHNSON_COOK, the table data specify the following:
##	A.
##
##	B.
##
##	n.
##
##	m.
##
##	Melting temperature.
##
##	Transition temperature.
##
##	If hardening=USER, the table data specify the following:
##	Hardening properties.

##	>>> list1 = ['par1',5]
##	>>> totuples(list1)
##	NameError: name 'totuples' is not defined
##	>>> totuple(list1)
##	('par1', 5)
##	>>> totable(list1)
##	(('par1', 5),)
##	>>>

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	table = totable(table)
	if len(table[0]) not in[2,3]:
		raise Exception('*** Incorrect data format, should be: (stress1, strain1, temp1),(stress2, strain2, temp2)')

	if table[0][1] != 0:
		raise Exception('*** plastic behavior should be (yield, 0, temp)')

	if len(table[0]) == 3:
		_m.materials[mat].Plastic(temperatureDependency=ON, table=table)
	elif len(table[0]) == 2:
		_m.materials[mat].Plastic(temperatureDependency=OFF, table=table)

	return

def set_journal_options(replayGeometry=None,recoverGeometry=None):
	## VER: 2014-10-14, v1.0

## Example:
##>>> set_journal_options('findAt')
##COORDINATE
##>>>

## to create element set:
## if option == COMPRESSEDINDEX:
##	p = mdb.models['Model-1'].parts['powder']
##	e = p.elements
##	elements = e.getSequenceFromMask(mask=('[#0 #1 ]', ), )
##	p.Set(elements=elements, name='Set-5')

## if option == COORDINATE:
##	p = mdb.models['Model-1'].parts['powder']
##	e = p.elements
##	elements = e[31:32]
##	p.Set(elements=elements, name='Set-6')

	if replayGeometry in empty:
		replayGeometry = COMPRESSEDINDEX

	if type_of(replayGeometry) == 'STR':
		replayGeometry = replayGeometry.lower()

		if replayGeometry == 'mask':
			replayGeometry = COMPRESSEDINDEX
		elif replayGeometry == 'index':
			replayGeometry = INDEX
		else:
			replayGeometry = COORDINATE

	if replayGeometry not in [COMPRESSEDINDEX, INDEX, COORDINATE]:
		raise Exception('*** Error replayGeometry')

	if recoverGeometry in empty:
		recoverGeometry = replayGeometry

	if recoverGeometry not in [COMPRESSEDINDEX, INDEX, COORDINATE]:
		raise Exception('*** Error recoverGeometry')

	session.journalOptions.setValues(replayGeometry=replayGeometry, recoverGeometry=recoverGeometry)

	return replayGeometry


def set_length(poi,setname,settype=None):
	## VER: 2010-11-28, v1.2

	if type_of(setname) in ['PART','PINSTANCE'] and type_of(poi) == 'STR':
		poi,setname = setname,poi

	if settype not in empty:
##		return len(eval('poi.sets[' + setname + '].' + settype))
		return len(eval('poi.sets[setname].' + settype))

	len1 = len(poi.sets[setname].edges)
	len2 = len(poi.sets[setname].faces)
	len3 = len(poi.sets[setname].cells)
	len4 = len(poi.sets[setname].vertices)

	return max([len1,len2,len3,len4])

function_labels['set_mat'] = 'material property'
def set_mat(p,mat=None, objs=None, cells=None,faces=None, elements=None, subset=None,bigset=None,type=None,label_dict=None):
	## VER: 2016-10-24, v3.3

##	>>> set_mat('powder',mat='H10pow')
##	'H10pow_sec'
##	>>>

	## Example:
##	>>> set_mat('part2',elements=[10,3,14, 2,6,8, 30,5],mat='Steel')
##	--->Applied as material Steel
##	--->Created new elements set for part2 , setname= Steel , called by ['set_mat', 67]
##	'Steel'
##	>>>

	## Example:给单元赋材料属性
##	for i in range(len(_part('part2').elements)):
##		index = int(random()*len(CTEs))
##		create_simple_material(modulus=400,poisson=0.23, CTE=CTEs[index])
##		set_mat('part2', mat='mat'+str(i+1), elements=i + 1)

	p = check_part(p)

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such mat name ='+ repr(mat))

	if is_numbers(elements):
		if type_of(label_dict) != 'DICT':
			raise Exception('*** label_dict is required to transfer label to index.')

		elements = tolist(elements)
		elements = _sort(elements)
		newlist = []
##		print fnln(),len(p.elements)
		for label in elements:   ## label != index
			index = label_dict[label]
			newlist.append(p.elements[index])

		elements = newlist

	objs = get_real_input(objs, cells, faces, elements)
	if objs in empty:
		if len(p.cells) > 0:
			objs = p.cells
		elif len(p.faces) > 0:
			objs = p.faces
		elif len(p.elements) > 0:
			objs = p.elements
		elif len(p.edges) > 0:
			objs = p.edges

	if objs in empty:
		raise Exception('*** objs region is required to apply material assignment.')

	if type_of(objs) == 'STR':
		objs = set2objs(p,setname=objs)
	else:
		objs = tolist(objs)

	obj_type = type_of(objs[0])

	if obj_type != 'elements':
		region = create_set(objs=objs, setname='mat_' + mat, check_name=True)
	else:
		seq = list2sequence(objs)
		region = regionToolset.Region(elements=seq)

##	if len(p.cells) > 0:
##		sec_name = mat + '_sec'
##	else:
##		sec_name = mat + '_shell'

	sec_name = mat + '_sec'
	if sec_name not in _m.sections.keys():
		_m.HomogeneousSolidSection(name=sec_name, material=mat, thickness=1)

	p.SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE, region=region, sectionName=sec_name, thicknessAssignment=FROM_SECTION)
	p.regenerate()
	a.regenerate()

##	if len(_m.materials) < 50:
####		print '--->Applied as material',mat
##		new_set = True
##	else:
##		new_set = False
##
##	if new_set == True:
##		if mat == p.name:
##			setname = 'mat_' + mat
##		else:
##			setname = mat
##
##		if mat in p.sets.keys():
##			objs1 = objs + set2objs(mat,p)
##		else:
##			objs1 = objs
##		create_set(p, objs=objs1, name=setname,check_name=False)
##
##		if type not in empty and bigset in empty:
##			bigset = type
##
##		if type_of(bigset) == 'STR':
##			if bigset not in p.sets.keys():
##				subset = bigset
##			else:
##				add2set(p,bigset,objs=objs)
##
##		if subset != None and subset != p.name:
##			create_set(p, objs=objs, name=subset,check_name=False)

	return	sec_name

set_material = set_mat

def set_space(p,setname):
	## VER: 2010-10-05, v1.1

	if type_of(p) == 'STR' and type_of(setname) in ['PART','PINSTANCE']:
		p,setname = setname,p

	objs = set2objs(p,setname)
	x1,x2,y1,y2,z1,z2 = objs_space(p,objs)

	return x1,x2,y1,y2,z1,z2

def set_point0(loc):
	## VER: 2016-09-26,v1.0  必须显式地指出哪一个点是起点

	global poly_points,last_point,poly_sketch

	if 'poly_sketch' not in globals().keys():
		raise Exception('*** global poly_sketch is required.')

	s1 = check_sketch(poly_sketch)

	if is_location(loc) == False:
		raise Exception('*** location is required as first point of the poly lines.')
	if len(loc) != 2:
		raise Exception('*** x,y value in the sketch is required.')

	poly_sketch = s1.name
	poly_points = [loc]
	last_point = loc

	return loc

def set_RP(p,x=0,y=0,z=0,loc=()):
	## VER: 2010-02-09

	x0 = RPx(p)
	y0 = RPy(p)
	z0 = RPz(p)
	if loc != ():
		x = loc[0]
		y = loc[1]
		z = loc[2]

	if (x != 0 and x != x0):
		p.features['RP'].setValues(xValue=x)
		x0 = x
	if (y != 0 and y != y0):
		p.features['RP'].setValues(yValue=y)
		y0 = y
	if (z != 0 and z != z0):
		p.features['RP'].setValues(zValue=z)
		z0 = z

	p.regenerate()
	print '--->Move RP of',p.name,'to new location by set_RP:',str((x0,y0,z0))

	return

def set_start_point(loc):
	## VER: 2016-07-27, v1.0
	## start poin in the sketch

	if not is_location(loc):
		raise Exception('*** a location is required.')

	globals()['last_point'] = loc

	return

def set_step_and_frame(step=-1,frame=-1,step_num=None,frame_num=None,stepname=None):
	## VER: 2014-12-17, v1.3
	## frame_num: 0: time=0, so the frame num has started from 0

	## Example:
##	>>> set_step_and_frame(frame=-1)   ## last frame
##	>>> set_step_and_frame(frame=0)		## first frame
##	>>>

	if stepname not in empty:
		step = stepname
	elif step_num not in empty:
		step = step_num

	step = check_odb_step(step)

	if frame_num not in empty:
		frame = frame_num

##	print fnln(),'frame=',frame

	if type_of(frame) != 'INT':
		raise Exception('*** error frame index')
	frame = step.frames[frame]

	## Real num
	step_name = step.name
	step_id = get_sequence_index(odb.steps.keys(),step_name)   ## odb.steps have no initial step. start from zero
##	frame_id = frame.frameId   ## Error for explicit analysis
	frame_id = get_repository_key(frame)
##	frame_time = frame.frameValue
##	print fnln(),'frame_id=',frame_id

	vpnow = get_vpnow()
	vpnow.odbDisplay.setFrame(step=step_id, frame=frame_id)

	return step_id, frame_id

function_labels['set_thermal_prop'] = 'thermal property','material property','conductivity','CTE','Cp'
def set_thermal_prop(mat,zero_expand_temp=20):
	## VER: ('VER: 2016-10-14, v1.5'). zero_expand_temp is called reference temperature in ANSYS, with zero expansion. Also is called reference temperature in abaqus GUI.

##	prop = mat_lib[mat]

##	density = eval(prop + '_D')
##	_m.materials[mat].Density(table=((density, ), ))

	if mat not in _m.materials.keys():
		create_material(mat)

	if mat not in _m.materials.keys():
		raise Exception('*** No such material.')

##	print fnln(),eval(mat + '_CTE')
##	stop1()

	try:
		CTE = eval(mat + '_CTE')
##		print fnln(),'CTE=',CTE
		if is_number(CTE):
			table1 = ((CTE, ), )
			_m.materials[mat].Expansion(table=table1)
		else:
			set_CTE(mat,CTE)

		if zero_expand_temp not in empty:  ## default to set 20 degC as zero expension temperature.
			_m.materials[mat].expansion.setValues(zero=zero_expand_temp)		## Reference temperature******** (that is, at zero_expand_temp, no expansion, but if temperature higher than ref_T, there will be expansion.)
	except:   ## 没有定义
		pass

	try:
		conduct = eval(mat + '_K')
		_m.materials[mat].Conductivity(table=((conduct, ), ))
	except:
		pass

	try:
		Cp = eval(mat + '_Cp')
		_m.materials[mat].SpecificHeat(table=((Cp, ), ))
	except:
		pass

##	print '--->Set thermal property for',mat

	return

def type_of_set(p=None,setname=None):
	## VER: 2017-02-17, v2.1

	## Reference: type_of_set(), name_of_set(), pia_of_set()

	if setname in empty:
		setname = p
		p = None

	elif is_pia(setname) and is_pia(p) == False:
		p,setname = setname,p

	if p not in empty:
		p = check_pias(p)
	else:
		p = a

	if type_of(setname) == 'SET':
		set1 = setname
	else:
		if setname not in p.sets.keys():
##			print fnln(),'setname=',setname
			raise Exception('****** ' + p.name + ' has no setname= ' + setname)

		set1 = p.sets[setname]

	result = 'empty'
	if len(set1.faces.pointsOn) != 0:
		result = 'faces'
	elif len(set1.vertices.pointsOn) != 0:
		result = 'vertices'
	elif len(set1.cells.pointsOn) != 0:
		result = 'cells'
	elif len(set1.edges.pointsOn) != 0:
		result = 'edges'
	elif len(set1.elements) != 0:
		result = 'elements'
	elif len(set1.nodes) != 0:
		result = 'nodes'
	else:
		try:
			if len(set1.referencePoints) != 0:
				result = 'referencePoints'
		except:
			pass

	return result

def set_unselect(set1,set2,inst1='',inst2=''):
	## VER: 2010-05-20
	## e.g., set_unselect(p4,'contact_face1',[bolt_bot1,bolt_bot2],'pin_end')

	print '  '
	list1 = []
##	if inst1 == '':
	if inst1 in empty:
		inst1 = insts_by_set(set1)
		if len(inst1) == 1:
			inst1 = inst1[0]
			list1 = set2objs(set1,inst1)
		else:
			raise Exception('One instance object is needed for inst1. line=4335, set_unselect().')   ## ********
	elif type_of(inst1) != 'PINSTANCE':
		raise Exception('One instance object is needed for inst1. line=4337, set_unselect().')   ## ********

	if inst2 in empty:
		inst2 = insts_by_set(set2)
	elif type_of(inst2) != 'LIST':
		inst2 = [inst2]

	list2 = []
	for inst in inst2:
		x1,x2,y1,y2,z1,z2 = set_space(inst,set2)
		faces2 = face_select(inst1,x=(x1,x2),y=(y1,y2),z=(z1,z2))
		list2 = list2 + faces2
	list1 = unselect(list1,list2)

	print '--->Removed faces by',set2,'for',set1

	return list1

def select_external_elements(poi,x=(),y=(),z=(),nx=None,ny=None,nz=None,angle_err=5):
	## VER: 2015-5-18, v1.0
	## for 3D part

##	>>> f1.getNodes()
##	(mdb.models['BJ_A0242_linefix'].parts['green'].nodes[2650], mdb.models['BJ_A0242_linefix'].parts['green'].nodes[2316], mdb.models['BJ_A0242_linefix'].parts['green'].nodes[221], mdb.models['BJ_A0242_linefix'].parts['green'].nodes[4432])
##	>>> node = f1.getNodes()[0]
##	>>> node
##	mdb.models['BJ_A0242_linefix'].parts['green'].nodes[2650]
##	>>> node.getElements()
##	(mdb.models['BJ_A0242_linefix'].parts['green'].elements[0], mdb.models['BJ_A0242_linefix'].parts['green'].elements[628], mdb.models['BJ_A0242_linefix'].parts['green'].elements[1210], mdb.models['BJ_A0242_linefix'].parts['green'].elements[3095], mdb.models['BJ_A0242_linefix'].parts['green'].elements[3375])
##	>>>

##	>>> list1 = [1,3,3,4,5,5,5,8]
##	>>> list1.count(3)
##	2
##	>>> list1.count(5)
##	3
##	>>>

##	>>> elems = node.getElements()
##	>>> elems.count(mdb.models['BJ_A0242_linefix'].parts['green'].elements[0])
##	1
##	>>>

##	>>> node.coordinates
##	(2.12614607810974, 2.76779198646545, -13.5502738952637)
##	>>>

	poi = check_poi(poi)

	ext_elems = []
	elems = []
	i = 0

	faces = []
	if x not in empty or y not in empty or z not in empty:
		elems0 = element_select(poi,x=x,y=y,z=z)
		for e in elems0:
			faces = faces + tolist(e.getElemFaces())
	else:
		faces = poi.elementFaces

	elems = []
	for face in faces:
		if len(face.getElements()) == 1:
			element = face.getElements()[0]   ## exterior elements
			if element in elems:
				continue

			if (nx,ny,nz) == (None,None,None):
				elems.append(element)
			else:
				center = element_center(element)
				nodes = face.getNodes()
				normal = normal_vector_of_three_points_plane(nodes[0],nodes[1],nodes[2],center)
				vector = vector_in_01(normal,angle_err=angle_err)

				xmeet = ymeet = zmeet = True
				if nx not in empty and nx != vector[0]:
					xmeet = False
				if ny not in empty and ny != vector[1]:
					ymeet = False
				if nz not in empty and nz != vector[2]:
					zmeet = False

				if xmeet and ymeet and zmeet:
					elems.append(element)

	return elems

def select_lines_in_sketch(sketch,H=None,V=None,edir=None,type=None):
	## VER: 2013-06-19, v1.1
	## 不是通过sketch_to_wire的方法，不会陷入死循环。
	## 但是，有如下限制：选择H=5的线，则只能选择竖直的线，且pointOn[0] = 5。没有cut的功能。
	## 参考：geometry_select()

	sketch = check_sketch(sketch)
	if H not in empty or V not in empty:
		H,V = real_xy_sketch(sketch,H=H,V=V)

	if H in empty and V not in empty:
		dir0 = 'H'
	elif H not in empty and V in empty:
		dir0 = 'V'
	elif H in numerics and V in numerics:
		if type_of(edir) == 'STR':
			dir0 = edir
		else:
			dir0 = 'any'
	else:
		raise Exception('**** H and V are empty, use geometry_select() instead.l')

	print fnln_fnln(),'(H,V) =',(H,V)

	print get_traceback()
	print fnln_fnln(),'dir0=',dir0

	type = tolist(type)
	if type in empty:
		type = ['regular_line','construction_line']
	elif type == ['regular']:
		type = ['regular_line']
	elif type == ['construction']:
		type = ['construction_line']

	lines = []
	for curve in sketch.geometry.values():  ## including construction line
		if type_of(curve) in type:
			dir1 = dir_of_sketch_line(curve)
			pointOn = curve.pointOn

			vertices = curve.getVertices()
			if vertices not in empty:
				locs = []
				for vertice in vertices:
					locs.append(vertice.coords)
				vertices = locs

			if dir0 != 'any' and dir1 != dir0:
				continue

			if dir0 == 'H' and PK(V,pointOn[1]) == 0:
				lines.append(curve)
			elif dir0 == 'V' and PK(H,pointOn[0]) == 0:
				lines.append(curve)
			elif dir0 == 'slope' or dir0 == 'any':
				if (H,V) in vertices:  ## pass through
					lines.append(curve)
	consist = {'regular_line':[],'construction_line':[]}
	for line in lines:
		if type_of(line) in consist.keys():
			consist[type_of(line)].append(line)
##	print fnln_fnln(),'print consist of sketch lines:'
##	prettyPrint(consist,2)
##	print ' '

	if len(type) == 1:
		result = lines
	else:
		result = consist['regular_line'],consist['construction_line']  ## 如果不指定类型，则返回tuple
		## 此时结果可能为: ([],[])

##	if lines in empty:
##		results = []
##	else:
##		results = consist['regular_line'],consist['construction_line']

	return result


def self_divide(part,dirs):
	## VER: 2012-09-07, v1.1	## 目的：获得完全都是六面体的cells，为mesh做准备。

	part = check_part(part)

	xlocs=[]
	ylocs=[]
	zlocs=[]

	pointOns = []
	for point in part.vertices:
		pointOns.append(point.pointOn[0])

	for loc in pointOns:
		if loc[0] not in xlocs:
			xlocs.append(loc[0])
		if loc[1] not in ylocs:
			ylocs.append(loc[1])
		if loc[2] not in zlocs:
			zlocs.append(loc[2])

	dirs = tolist(dirs)
	if dirs in empty:
		dirs = ['x','y','z']

	if 'x' in dirs:
		batch_divide(part,x=xlocs)
	if 'y' in dirs:
		batch_divide(part,y=ylocs)
	if 'z' in dirs:
		batch_divide(part,z=zlocs)

	return

def sequence_to_region(sequence,region_type='set', side_num=None):
	## VER: 2013-08-01, v1.0

	if type_of(sequence) in ['TUPLE','LIST'] and type_of(sequence[0]) == 'SEQUENCE':
		list1 = sequence
		sequence0 = list1[0]
		for i in range(len(list1))[1:]:
			if type_of(list1[i]) != 'SEQUENCE':
				raise Exception('*** sequence is required.')

			sequence0 = sequence0 + list1[i]
		sequence = sequence0

	if type_of(sequence) != 'SEQUENCE':
		raise Exception('*** sequence is required.')

	if type_of(side_num) == 'INT':
		region_type == 'surface'

	if region_type == 'surface' and side_num in empty:
		side_num = 1

	if region_type not in ['set','surface']:
		raise Exception('*** region_type should be set or surface.')

	region = None
	if region_type == 'set':
		region = (sequence,)

	else:
		if side_num == 1:
			region = ((sequence,SIDE1),)

		elif side_num == 2:
			region = ((sequence,SIDE2),)

		elif side_num == 3:
			region = ((sequence,SIDE3),)

		elif side_num == 4:
			region == ((sequence,SIDE4),)

	if region in empty:
		raise Exception('*** fail to create the region')

	return region

def set2face_point(poi,setname):
	## VER: 2010-02-24

	faces = set2objs(setname,poi)
	locs = []
	for face in faces:
		locs.append(face.getCentroid()[0])

	locs1 = []
	for loc in locs:
		if loc not in locs1:
			locs1.append(loc)

	print 'Face set',setname,'returns',len(locs1),'face centroid points.'
	return locs1


def set2list_dict(p,setname):
	##ver: 2010-01-22

	len1 = len(p.sets[setname].edges)
	len2 = len(p.sets[setname].faces)
	len3 = len(p.sets[setname].cells)
	len4 = len(p.sets[setname].vertices)

	objs = []
	type1 = ''
	if len1 > 0:
		objs = p.sets[setname].edges
##		type1 = 'edges'
	elif len2 > 0:
		objs = p.sets[setname].faces
##		type1 = 'faces'
	elif len3 > 0:
		objs = p.sets[setname].cells
##		type1 = 'cells'
	elif len4 > 0:
		objs = p.sets[setname].vertices

	return objs

def set2locx(setname,poi=None):
	## VER: 2012-08-31, v1.2

	if poi in empty:
		poi = poi_with_setname(setname)
	else:
		poi = check_pias(poi)

	locs = []
	points = set2pointOns(poi,setname)
	for i in range(len(points)):
		loc = points[i][0]
		if loc not in locs:
			locs.append(loc)

	locs.sort()

	return locs

def set2locy(setname,poi=None):
	## VER: 2012-08-31, v1.2

	if poi in empty:
		poi = poi_with_setname(setname)
	else:
		poi = check_pias(poi)

	locs = []
	points = set2pointOns(poi,setname)
	for i in range(len(points)):
		loc = points[i][1]
		if loc not in locs:
			locs.append(loc)

	locs.sort()

	return locs

def set2locz(setname,poi=None):
	## VER: 2012-08-31, v1.2

	if poi in empty:
		poi = poi_with_setname(setname)
	else:
		poi = check_pias(poi)

	locs = []
	points = set2pointOns(poi,setname)
	for i in range(len(points)):
		loc = points[i][2]
		if loc not in locs:
			locs.append(loc)

	locs.sort()

	return locs

def set2pois(setname,p=None,internal=False):
	## VER: 2014-06-22, v1.0
	## usage: you create a set of insts, then get the inst names by set2pois(), then use plot_insts() to show again this insts.

	objs = set2objs(setname=setname, p=p, internal=internal)
	pois = get_pois(objs)
	names = poi_names(pois)

	return names

def set2objs(p=None,setname=None,name=None,internal=False,poi=None):
	##VER: 2017-06-15, v3.6. 注意：假如调用该函数或得一个变量后，进行了切除操作，则该变量所指的对象可能发生改变了。
	## p1为part, p1_A1为p1的instance。
	## 那么：p1.sets.keys() == p1_A1.sets.keys()，而且这些set都是在part模块下建立的。
	## 如果在Assembly模块下建立的set，属于a.sets.keys()

##>>> nodes = set2objs('_nodeset',p='p1')
##	edges = set2objs('insert',name='set3')

##	nodes = set2objs('inst2',setname='side2') ## setname: inst2.side2, side2在part中建立，没有在assembly中建立。

##	>>> _inst('powder_A1').sets.keys()
##	['H10pow', 'e_hole_1', 'f_powder_hole_1', 'hole1']
##	>>> _part('powder').sets.keys()
##	['H10pow', 'e_hole_1', 'f_powder_hole_1', 'hole1']
##	>>>

	if type_of(name) == 'STR':
		setname = name

	if is_pia(setname) and is_pia(p) == False:
		setname,p = p,setname

	if poi not in empty:
		p = poi

	if p in empty:
		if setname in a.sets.keys():
			p = a
		else:
			p = get_p1()

	if p in empty:
		raise Exception('*** p of objs is required.')

	p = check_pia(p)
	if type_of(p) == 'PINSTANCE' and setname in a.sets.keys():
		p = a

##	print 'p=',p.name
##	print 'setname=',setname

##	if type_of(setname) != 'STR':
##		raise Exception('setname required in set2objs()')		## ********
##
####	print fnln(),'p=',p
##	p = check_pias(p,force_list=True)
####	print fnln(),'p=',p
##
##	if p not in empty:
##		p = p[0]

	if type_of(p) == 'PART':
		if setname in p.allInternalSets.keys():
			internal = True
	else:
		if setname in a.allInternalSets.keys():
			internal = True

	list1 = []
	if internal == True:
		list1 = objs_of_internal_set(setname,poi=p)

	else:
		if p in empty:
			insts = insts_by_set(setname)   ## 假如p缺省，则默认为instance的set
			if insts in empty:
				if setname in a.sets.keys():
					insts = [a]
				else:
					print fnln_fnln(),'******No instance has setname=',setname
					return []

			settype = type_of_set(insts[0],setname)
			for p1 in insts:
				try:
					objs = eval('p1.sets[setname].' + settype)
					list1 = list1 + list(objs)
				except:
					pass

		elif type_of(p) in ['PART','PINSTANCE','ASSEMBLY']:
##			print fnln(),'p.name=',p.name
##			print fnln(),'setname=',setname
##			raise Exception
			type1 = type_of(p)
			if setname not in p.sets.keys():
				if type1 == 'PART':
					raise Exception('*** no such setname= ' + setname + ' exists in the *part ' + p.name)
				elif type1 == 'PINSTANCE':
					if setname in a.sets.keys():
						p = a
					else:
						raise Exception('*** no such setname= ' + setname + ' exists in the *part ' + p.part.name)
				elif type1 == 'ASSEMBLY':
					insts = insts_by_set(setname)
					if len(insts) == 1:
						p = insts[0]
					else:
						raise Exception('*** No such setname= ' + setname + ' exists in the *assembly')

##				if type_of(p) in ['PART','PINSTANCE']:
##					raise Exception('*** No such setname=' + setname
##				if p == a and len(insts_by_set(setname))==1:
##					p = insts_by_set(setname)[0]
##				else:
##					print fnln_fnln(), '******' + p.name + ' has no such setname= ' + setname
##					return []

			settype = type_of_set(p,setname)
			if settype not in empty:   ## 有些set可能只有name，但没有objs
				objs = eval('p.sets[setname].' + settype)
				list1 = tolist(objs)

		else:
			print fnln_fnln(),'******No entities were found by setname=',setname,'. set2objs() failed.'

	return list1

def set2pointOns(poi,setname):
	## VER: 2012-12-11, v1.2, poi maybe part or instance。结果例如：[(496.0, 0.0, 6.5), (496.0, 0.0, -33.5)]

	poi = check_pias(poi)

	objs = []
	points = []

	settype = type_of_set(poi,setname)
	objs = eval('poi.sets[setname].' + settype)

	for obj in objs:
		points.append(obj.pointOn[0])

	return points

def set2region(setname,instances=(),region_type='set',side_num=None):
	## VER: 2013-08-01, v1.5. 只适用于instance，不适用于part

	instances = tolist(instances)
	instances = real_insts(instances)

	if instances in empty:
		instances = insts_by_set(setname)

	if instances in empty:
		raise Exception('No instances was found by setname=',setname)

	inst = instances[0]
	objs = set2objs(setname,inst)

	if len(instances) == 1:
		region = list2region(objs,poi=inst,region_type=region_type,side_num=side_num)

	if len(instances) > 1:
		sequence = list2sequence(objs,inst)
		for inst in instances[1:]:
			objs = set2objs(setname,inst)
			sequence = sequence + list2sequence(objs,inst)

		region = sequence_to_region(sequence, region_type=region_type, side_num=side_num)

##	if obj_type != 'faces':
##		region = eval('Region(' + obj_type + '=sequence)')
##	else:
##		if region_type == 'surface':
##			region = eval('Region(side1Faces = sequence)')	## surface-like region
##		elif region_type == 'set':
##			region = eval('Region(faces = sequence)')			## set-like region

	return region

def set2sequence(setname,*instances):
	## VER: 2012-10-09, v1.1

##	print 'instance=',instances

	if instances in empty:
		instances = insts_by_set(setname)
	else:
		instances = real_insts(instances)
##		print '2. instance=',instances

	if instances in empty:
		raise Exception('No instance with setname=',setname)

	inst = instances[0]
	obj_list = set2objs(setname,inst)
	sequence = list2sequence(obj_list,inst)

	if len(instances) > 1:
		for inst in instances[1:]:
			obj_list = set2objs(setname,inst)
			sequence = sequence + list2sequence(obj_list,inst)

	return sequence

def set2surface(setname,poi='',inst='',name=''):
	## VER: 2010-09-26, v1.1

	if inst in empty:
		type1 = type_of(poi)
		if type1 == 'PART':
			inst = a.instances[poi.name + '_A1']
		elif type1 == 'PINSTANCE':
			inst = a.instance[poi.name]

	if name == '':
		name = setname

	faces = set2objs(setname,poi)

	if len(faces) > 0:
		create_surface(faces,name=name,poi=inst)
		print '--->Created surface',name,'from face set=',setname
		print ' '
	else:
		raise Exception('Surface conversion failed from set. line=7002, set2surface()')   ## ********

	return

def show_datum():
	## VER: 2014-06-26, v1.2

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.geometryOptions.setValues(datumPlanes=ON)
	vpnow.partDisplay.geometryOptions.setValues(datumPlanes=ON)

	vpnow.assemblyDisplay.geometryOptions.setValues(datumAxes=ON)
	vpnow.partDisplay.geometryOptions.setValues(datumAxes=ON)

	vpnow.assemblyDisplay.geometryOptions.setValues(datumPoints=ON)
	vpnow.partDisplay.geometryOptions.setValues(datumPoints=ON)

	return

def show_hiden_insts(insts=None):
	## VER: 2014-06-22, v1.0, status will be change from hiden to show.

	vpnow = get_vpnow()
	if insts in empty:
		hide_insts = get_hiden_insts()
	else:
		insts = real_insts(insts)
		hide_insts = poi_names(insts)
	vpnow.assemblyDisplay.showInstances(instances=totuple(hide_insts))

	return

function_labels['show_in_items'] = 'show','within','list','tuple','item','string','element','name'
def show_in_items(list1,str1,capital=True):
	## VER: ('VER: 2016-12-20, v1.1')		##例如给出了part的某个set的一部分名称。
	## capital=False: 不区分大小写

##	if show_in_items(mats,'H10pow',capital=False):
##		powder = inst

	if type_of(str1) != 'STR':
		raise Exception('******A string is required.')

	if type_of(list1) == 'STR':
		list1 = [list1]

	if type_of(list1) not in ['LIST','TUPLE']:
		raise Exception('******A list or tuple of string is required.')

	inside = False
	for item in list1:
		if capital == True:
			if str1 in item:
				inside = True
				break
		else:
			if str1.lower() in item.lower():
				inside = True
				break

	return inside

def show_mat_props(matname=None):
	## VER: 2013-06-07, v1.0

	global mat_seq

	matnum = len(_m.materials.keys())
	if matnum == 0:
		print '**** No material definition in this model yet.'
		return

	if matnum == 1:
		matname = _m.materials.keys()[0]

	else:
		if matname not in empty:
			if matname not in _m.materials.keys():
				raise Exception('**** Error matname = ' + repr(matname))

		else:	 ## not provide matname
			if 'mat_seq' not in globals().keys():
				mat_seq = 1
			else:
				mat_seq += 1
				if mat_seq > matnum:
					mat_seq = 1
			matname = _m.materials.keys()[mat_seq - 1]


	print ' '
	print 'Material: ',matname
	prettyPrint(_m.materials[matname],5)
	print ' '

	return

def show_parts(*parts):
	## VER: 2010-12-27, v1.4

	parts = real_parts(parts)
	if parts in empty:
		parts = _m.parts.values()

	del_insts(a.instances.keys())

	for i in range(len(parts)):
		new_instance(parts[i])

	plot(a)

	return

def show_loc(p,x=None,y=None,z=None,loc=()):
	## VER: 2013-09-22, v1.4
	## Reference: mark_loc()

	if type_of(p) in ['ASSEMBLY','PINSTANCE']:
		p = a

	if '_1' in p.features.keys():
		del p.features['_1']

	if '_2' in p.features.keys():
		del p.features['_2']

	if '_3' in p.features.keys():
		del p.features['_3']

	if is_location(loc) == False:
		x,y,z = real_xyz(p,x=x,y=y,z=z)

		vars = []
		if type_of(x) in numerics:
			x0 = x
		else:
			x0 = 0
			vars.append('x')

		if type_of(y) in numerics:
			y0 = y
		else:
			y0 = 0
			vars.append('y')

		if type_of(z) in numerics:
			z0 = z
		else:
			z0 = 0
			vars.append('z')

		p.DatumCsysByThreePoints(name='_1', coordSysType=CARTESIAN, origin=(x0,y0,z0),
			line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))

		if 'x' in vars:
			p.DatumCsysByThreePoints(name='_2', coordSysType=CARTESIAN, origin=(x0+15,y0,z0),
				line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))

			p.DatumCsysByThreePoints(name='_3', coordSysType=CARTESIAN, origin=(x0+30,y0,z0),
				line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))

		elif 'y' in vars:
			p.DatumCsysByThreePoints(name='_2', coordSysType=CARTESIAN, origin=(x0,y0+15,z0),
				line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))

			p.DatumCsysByThreePoints(name='_3', coordSysType=CARTESIAN, origin=(x0,y0+30,z0),
				line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))

		elif 'z' in vars:
			p.DatumCsysByThreePoints(name='_2', coordSysType=CARTESIAN, origin=(x0,y0,z0+15),
				line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))

			p.DatumCsysByThreePoints(name='_3', coordSysType=CARTESIAN, origin=(x0,y0,z0+30),
				line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))
	else:
		p.DatumCsysByThreePoints(name='_1', coordSysType=CARTESIAN, origin=loc,
			line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))


	return

def show_sketch(sketch):
	## VER: 2014-09-08, v1.1
	## 执行诸如space_of_sketch()之后要返回sketch界面。

	sketch = check_sketch(sketch)
	sketch.setPrimaryObject(option=STANDALONE)
	sketch.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	return

def show_symm(symmetry):
	## VER: 2010-09-25, v1.2
	global default_plot

	default_plot = a
	symmetry[1] = tuple(symmetry[1])

	vpnow = get_vpnow()

	a.DatumCsysByThreePoints(name='csys1', coordSysType=CARTESIAN,
		origin=symmetry[1], line1=(1.0, 0.0, 0.0), line2=(0.0, 1.0, 0.0))

	if symmetry[0] == ['x'] or symmetry[0] == 'x':
		vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName='csys1',
		   mirrorAboutXzPlane=False, mirrorAboutYzPlane=True)
	elif symmetry[0] == ['y'] or symmetry[0] == 'y':
		vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName='csys1',
		   mirrorAboutXzPlane=True, mirrorAboutYzPlane=False)
	elif symmetry[0] in [['x','y'],['y','x'],'xy','yx']:
		vpnow.odbDisplay.basicOptions.setValues(mirrorCsysName='csys1',
		   mirrorAboutXzPlane=True, mirrorAboutYzPlane=True)

##	vpnow.view.fitView()

	return

def show_time(info='info:'):
	## VER: 2010-03-24
	global _time2,_time21

	_time21 = get_time()
	_time2 = time.time()
	elapse = _time2 - start_time
	minute = round(elapse/60,1)

	print '  '
	print info + ':'
	if elapse >= 60:
		print 'Totally:',minute,'min used.'
	else:
		print 'Totally',round(elapse,1),'sec used till now'

function_labels['fn_silic_dim'] = 'glass','PV','suntech','silicone','mounting','adhesive'
def fn_silic_dim(glass_lenx,glass_leny,pressure,support_edges=4):
	## VER: 2010-10-24, v1.5

	if pressure > 1:
		pressure = pressure*1e-6

	average_L = (glass_lenx + glass_leny)/2
	Silic_strength = 0.2e6*KE

	w0 = pressure*average_L/(2*Silic_strength)

	if support_edges == 4:
		if w0 < 6.5:
			w0 = 6.5
	elif support_edges == 2:
		if w0 < 14:   ##13.5 error
			w0 = 14

	adwidth = round(w0*1.4 + 0.2)
	if adwidth < 9:
		adwidth = 9

	adthick = round(adwidth/1.5)
	if support_edges == 4:
		if adthick < 8:
			adthick = 8
	elif support_edges == 2:
		if adthick < 15:
			adthick = 15

	print '   '
	print 'glass_lenx =',glass_lenx, 'mm, glass_leny =',glass_leny,'mm, pressure =', int(pressure*1e6),'Pa'
	print '--->Dimensions of',support_edges,'sides supporting Silic adhesive:'
	print '--->adwidth =',int(adwidth),'mm'
	print '--->adthick =',int(adthick),'mm'

	return adwidth,adthick

function_labels['facenum_elements_of_nodes'] = 'sides','element surface'
def facenum_elements_of_nodes(nodes):
	## VER: 2016-11-11, v1.0

##	>>> facenum_elements_of_nodes(nodes)
##	{'face3': [mdb.models['Model-1'].rootAssembly.instances['pocket_A1'].elements[637]]}
##	>>>

##	>>> dict1 = facenum_elements_of_nodes(nodes)
##	>>> dict1.keys()
##	['face5', 'face3']
##	>>> list1 = ['face5', 'face3']
##	>>> sort(list1)
##	['face3', 'face5']
##	>>>

	elems = nodes_to_elements(nodes)
	dict1 = {}
	dict2 = {}
	for elem in elems:
		faces = elem.getElemFaces()
		for face in faces:
			if len(face.getElements()) == 1:	## Exterior element face
				nodes1 = face.getNodes()
				nodes1 = sort_nodes(nodes1)
				com_nodes = get_common(nodes,nodes1)
				if com_nodes == nodes1:
					side = face.face
					side = totext(side).lower()
					if side not in dict1.keys():
						dict1[side] = []
					if side not in dict2.keys():
						dict2[side] = []

					dict1[side].append(elem)	## collect element of the face
					dict2[side] = dict2[side] + nodes1	## collect nodes at the face

	for side in dict1.keys():
		elems1 = dict1[side]
		elems1 = remove_repeated_items(elems1)
		dict1[side] = elems1

	for side in dict2.keys():
		nodes2 = dict2[side]
		nodes2 = remove_repeated_items(nodes2)
		dict2[side] = nodes2

	return dict1

function_labels['face_numbers_of_element'] = 'side','element surface','angle'
def face_numbers_of_element(element,angle=30,axis='x',rough_angle=70):
	## VER: 2016-04-11, v1.3
	## reference: element_all_face_nums()不需要指定哪个axis，会得到各个裸露的element face的facenums

##	>>> elements_dict_by_face(e1,axis='z')
##	angle2= 0.1063
##	angle4= 89.7
##	{'face2': mdb.models['Model-1'].parts['p1'].elements[84105:84106]}
##	>>> face_numbers_of_element(e1,axis='z')
##	angle2= 0.1063
##	angle4= 89.7
##	[2]
##	>>> elements_dict_by_face(e1,axis='x')
##	angle2= 89.894
##	angle4= 5.2604
##	{'face4': mdb.models['Model-1'].parts['p1'].elements[84105:84106]}
##	>>> face_numbers_of_element(e1,axis='x')
##	angle2= 89.894
##	angle4= 5.2604
##	[4]
##	>>>

##	>>> elements_dict_by_face(e2,axis='x')
##	{'face6': mdb.models['Model-1'].parts['p1'].elements[73105:73106]}
##	>>> face_numbers_of_element(e2,axis='x')
##	[6]
##	>>> face_numbers_of_element(e2,axis='z')
##	[]
##	>>> elements_dict_by_face(e2,axis='z')
##	{}
##	>>>

	if type_of(element) != 'elements':
		raise Exception('*** An element is required.')

	if is_number(angle) == False:
		angle = rough_angle

	sides = []
	side = -1
	for i in range(len(element.getElemFaces())):
		face = element.getElemFaces()[i]
		elements = face.getElements()
		if element in elements and len(elements) == 1:   ## 可能一个单元有多个侧面外露
			angle1 = face_normal_vector_angle(face,axis=axis)
##			print 'angle' + str(i+1) + '=',angle1  ## 用于检查，勿删
			if angle1 <= angle:
				side = i + 1
				sides.append(side)

	return sides

function_labels['facenum_nodes_of_nodes'] = 'side','element surface'
def facenum_nodes_of_nodes(nodes):
	## VER: 2016-11-11, v1.0

##	>>> facenum_nodes_of_nodes(nodes)
##	{'face3': [mdb.models['Model-1'].rootAssembly.instances['pocket_A1'].nodes[668], mdb.models['Model-1'].rootAssembly.instances['pocket_A1'].nodes[731], mdb.models['Model-1'].rootAssembly.instances['pocket_A1'].nodes[998], mdb.models['Model-1'].rootAssembly.instances['pocket_A1'].nodes[1061]]}

	elems = nodes_to_elements(nodes)
	dict1 = {}
	dict2 = {}
	for elem in elems:
		faces = elem.getElemFaces()
		for face in faces:
			if len(face.getElements()) == 1:	## Exterior element face
				nodes1 = face.getNodes()
				nodes1 = sort_nodes(nodes1)
				com_nodes = get_common(nodes,nodes1)
				if com_nodes == nodes1:
					side = face.face
					side = totext(side).lower()
					if side not in dict1.keys():
						dict1[side] = []
					if side not in dict2.keys():
						dict2[side] = []

					dict1[side].append(elem)	## collect element of the face
					dict2[side] = dict2[side] + nodes1	## collect nodes at the face

	for side in dict1.keys():
		elems1 = dict1[side]
		elems1 = remove_repeated_items(elems1)
		dict1[side] = elems1

	for side in dict2.keys():
		nodes2 = dict2[side]
		nodes2 = remove_repeated_items(nodes2)
		dict2[side] = nodes2

	return dict2

def side_on_area(side_pressure, length, width, lateral_coefficient=0.6):
	## VER: 2014-06-16, v1.0, area is the cavity area that filled powder, side pressure is the pressue of die

	axial_pressure = side_pressure/lateral_coefficient
	area = length*width
	force = area*axial_pressure
	ton = force/9800

	ton = round(ton,2)
	area = round(area,2)
	axial_pressure = round(axial_pressure,2)
	side_pressure = round(side_pressure,2)

	print fnln(),'ton, area, axial_pressure, side_pressure=',ton, area, axial_pressure, side_pressure

	return ton, area, axial_pressure, side_pressure

function_labels['sides_angle'] = 'surface','angle','vector','side','cross line'
def sides_angle(p1,side1,side2,cross_line):
	## VER: 2017-06-15, v1.0

##	>>> sides_angle(p1,'side3','bot','line3')
##	['vector_angle', 81411] angle = 90deg17'
##	['sides_angle', 22] angle1= 90.294338
##	['vector_angle', 81411] angle = 90deg18'
##	['sides_angle', 26] angle2= 90.30171
##
##	['sides_angle', 32] angle = 90deg17'
##	90.298024

	p1 = check_poi(p1)
	if type_of(side1) != 'STR' or type_of(side2) != 'STR' or type_of(cross_line) != 'STR':
		raise Exception('*** setname for side1 or side2 or cross_line is required.')

	nodes1 = set2objs(p1,name=side1)
##	if len(nodes1) == 0:
##		raise Exception('*** No nodes with setname=' + side1)

	nodes2 = set2objs(p1,name=side2)
##	if len(nodes2) == 0:
##		raise Exception('*** No nodes with setname=' + side2)

	line = set2objs(p1,name=cross_line)
	line = exterior_nodes(line)

	line1 = common_objs(nodes1,line)
	line2 = common_objs(nodes2,line)
	if len(line1) in [1,2]:
		raise Exception('*** Please pick more nodes')
	elif len(line1) == 0:
		raise Exception('*** No common nodes between cross line and side face.')

	if len(line2) in [1,2]:
		raise Exception('*** Please pick more nodes')
	elif len(line2) == 0:
		raise Exception('*** No common nodes between cross line and side face.')

	mid1 = int(round(len(line1)/2))
	mid2 = int(round(len(line2)/2))

##	line1 = list2sequence(line1)
##	line2 = list2sequence(line2)

	absolute = False
	vector1,vector2 = two_vectors_of_4points(line1[0],line1[1],line2[0],line2[1])
	angle1 = vector_angle(vector1=vector1,vector2=vector2,absolute=absolute)
	print fnln(),'angle1=',angle1

	vector1,vector2 = two_vectors_of_4points(line1[0],line1[-1],line2[0],line2[-1])
	angle2 = vector_angle(vector1=vector1,vector2=vector2,absolute=absolute)
	print fnln(),'angle2=',angle2

	vector1,vector2 = two_vectors_of_4points(line1[0],line1[mid1],line2[0],line2[mid2])
	angle3 = vector_angle(vector1=vector1,vector2=vector2,absolute=absolute)
	print fnln(),'angle3=',angle3

	angle = (angle1 + angle2 + angle3)/3.0
	angle = round(angle,4)
	minutes = (angle - int(angle))*60
	minutes = int(minutes)
	print ' '
	print fnln(),'angle =',str(int(angle)) + 'deg' + str(minutes) + "'"

	return angle

def sides_of_element(elem):
	## VER: 2016-11-11, v1.0

##	>>> faces_of_element(e1)
##	['face1', 'face2', 'face3', 'face4', 'face5', 'face6']
##	>>>

	## Every element face has this function: 'getElemFacesByFaceAngle()'

	if type_of(elem) != 'elements':
		raise Exception('*** An element is required.')

	faces = elem.getElemFaces()

	sides = []
	for face in faces:
		side = face.face
		side = totext(side).lower()
		if side not in sides:
			sides.append(side)

	return sides

def simple_line(part,dir=None,x=None,y=None,z=None,dx=0,dy=0,dz=0,thx=None,thy=None,thz=None,mat=None,addRP=True):

	## VER: ('VER: 2012-09-03, v1.0')

	part = check_part(part)

	if [x,y,z].count(None) == 2:
		if x not in empty:
			dir = 'x'
		elif y not in empty:
			dir = 'y'
		elif z not in empty:
			dir = 'z'

	if thx not in empty:
		if type_of(y) not in ['TUPLE','LIST'] and type_of(z) not in ['TUPLE','LIST']:		## y,z至少有一个要提供范围。
			raise Exception('please provide the sheet line range.')
		x = (dx, dx + thx)
		thick = thx

	elif thy not in empty:
		if type_of(x) not in ['TUPLE','LIST'] and type_of(z) not in ['TUPLE','LIST']:
			raise Exception('please provide the sheet line range.')
		y = (dy, dy + thy)
		thick = thy

	elif thz not in empty:
		if type_of(x) not in ['TUPLE','LIST'] and type_of(y) not in ['TUPLE','LIST']:
			raise Exception('please provide the sheet line range.')
		z = (dz, dz + thz)
		thick = thz

	if addRP == True:
		x0,y0,z0 = RPxyz(part)
		x1,x2,y1,y2,z1,z2 = poi_space(part)

		if x not in empty:
			x = x[0] + x0, x[1] + x0
		else:
			x = (x1,x2)

		if y not in empty:
			y = y[0] + y0, y[1] + y0
		else:
			y = (y1,y2)

		if z not in empty:
			z = z[0] + z0, z[1] + z0
		else:
			z = (z1,z2)

	x1,x2 = sort(x)
	y1,y2 = sort(y)
	z1,z2 = sort(z)

	print 'dir=',dir
	print 'thick=',thick
	print 'z1,z2=',(z1,z2)

	x = x1,x2
	y = y1,y2
	z = z1,z2
	print 'x,y,z=',x,y,z

	create_block(part,x=x,y=y,z=z,mat=mat,addRP=False)

	return

def bias_seed_single(part,edges,ratio=2,enum=3,minSize=None,maxSize=None,fine_dir=''):
	## VER: 2014-08-07, v1.1

	## Example:
##	edges = edge_select(powder,x=MAX1,exterior=False)
##	bias_seed_single(powder, edges=edges, enum=20,ratio=20,fine_dir='+x')

##	edges = edge_select(ejector,y=MAX1,edir='y')
##	bias_seed_single(ejector,edges=edges, minSize=0.2,maxSize=1.0,fine_dir='+y')


	part = check_part(part)
	if type_of(edges) == 'STR':
		edges = set2objs(part,edges)
	edges = tolist(edges)

	fine_dir = fine_dir.lower()
	v0 = index = None
	if '+' in fine_dir:
		v0 = 1
	elif '-' in fine_dir:
		v0 = -1

	if 'x' in fine_dir:
		index = 0
	elif 'y' in fine_dir:
		index = 1
	elif 'z' in fine_dir:
		index = 2

	if v0 in empty or index in empty:
		raise Exception('*** incorrect fine_dir info, should be such as +x')

	for edge in edges:
		pts = edges_to_vertices(edge)
		loc1 = pts[0].pointOn[0]
		loc2 = pts[1].pointOn[0]

		vector = loc2[0] - loc1[0], loc2[1] - loc1[1], loc2[2] - loc1[2]

		if v0*vector[index] > 0:
			flip = True
		else:
			flip = False

		sequence = obj2sequence(edge)

		if type_of(minSize) in numerics and type_of(maxSize) in numerics:
			if flip == False:
				part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=sequence, minSize=minSize, maxSize=maxSize, constraint=FINER)
			else:
				part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=sequence, minSize=minSize, maxSize=maxSize, constraint=FINER)
		else:
			if flip == False:
				part.seedEdgeByBias(biasMethod=SINGLE, end1Edges=sequence,ratio=ratio,number=enum + 1, constraint=FINER)
			else:
				part.seedEdgeByBias(biasMethod=SINGLE, end2Edges=sequence,ratio=ratio,number=enum + 1, constraint=FINER)

	return


def size_of_objs(objs):
	## VER: 2013-10-07, v1.1

	## example, list1 is a nodes list, then size_of_objs(list1) = 'list'

	objs = tolist(objs)
	size = 0
	try:
		for obj in objs:
			size = size + obj.getSize(printResults=False)
	except:
		size = original_type(objs)   ## e.g, MeshNode object

	return size

def geometry_ids_to_objs(sketch,curves):
	## VER: 2014-10-29, v1.0

	sketch = check_sketch(sketch)

	curves = tolist(curves)
	if curves in empty:
		raise Exception('*** no curves.')

	if type_of(curves[0]) != 'INT':
		raise Exception('*** geometry ids are required.')

	newlist = []
	for id in curves:
		if id in sketch.geometry.keys():
			newlist.append(sketch.geometry[id])

	return newlist


def geometry_select(sketch,curves=None,edir=None,shape=None,type=None,H=None,V=None,x=None,y=None, radius=None,id=None, include_construction=False):
	## VER: 2013-06-18, v1.4
	## shape=line(直线),arc(一段弧线，例如倒角), circle（一个完整的圆弧), ellipse（一个椭圆）,spline(平滑曲线)
	## type=regular(常规线，在长成实体后能看见),construction（构造线),reference(参考线)
	## 采用wirepart的方法。参考:select_lines_in_sketch()

	## select the line and fix it
##	curves = geometry_select(s1,x=MAX1)
##	s1.FixedConstraint(entity=curves[0])  ## fix the line

	## For example:
	## curve = geometry_select(sketch,id=-2)
	## curves = geometry_select('s_die', x=(0,-1))

	sketch = check_sketch(sketch)

	if x not in empty:
		H = x
	if y not in empty:
		V = y

	if type_of(id) in numerics:  ##最后修改的geometry的id为倒数第一个。
		found = True
		if id < 0:
			try:
				curve = sketch.geometry.values()[id]
			except:
				found = False
		elif id > 0:
			try:
				curve = sketch.geometry[id]
			except:
				found = False

		if found:
			return curve
		else:
			raise Exception('*** No such id')

	if curves not in empty:
		cuves = tolist(curves)
	else:
		curves = sketch.geometry.values()  ## including construction line

	if H not in empty or V not in empty:
		H,V = real_xy_sketch(sketch,H=H,V=V)
##		print (H,V)
##		raise Exception

	if shape not in empty:
		shape = totext(shape).lower()

	if type not in empty:
		type = totext(type).lower()

##	if type == 'line':
##		type = 'regular'
##		shape = 'line'

	if type not in empty:
		newlist = []
		for curve in curves:
			type1 = totext(curve.type).lower()
			if type == type1:
				newlist.append(curve)
		curves = newlist

	if shape not in empty:
		newlist = []
		for curve in curves:
			shape1 = totext(curve.curveType).lower()
			if shape == shape1 or (shape == 'circular' and shape1 in ['arc','circle']):
				newlist.append(curve)
		curves = newlist

##	print2(len(curves))
	if is_empties(H,V,edir,radius) == False:
		part1 = sketch_to_wire(sketch)

		curves1 = []
		edges = edge_select(part1,x=H,y=V,edir=edir,radius=radius)	##本质上相当于cut_through
		if edges not in empty:
			newlist = []
			for edge in edges:
				x1,y1,z1 = edge.pointOn[0]
				curve1 = sketch.geometry.findAt((x1,y1),printWarning=False)		## 用findAt()函数来查找geometry，一定要用id来表达该geometry
				if curve1 != None:
					curve1 = sketch.geometry[curve1.id]
					if curve1 in curves:
						newlist.append(curve1)
			curves1 = newlist

		del_parts(part1)

		curves2 = []
		if include_construction == True:
			curves2 = select_construction_lines(sketch,H=H,V=V,edir=edir)
			print fnln(),'len(curves1) =',len(curves1),', real curve'
			print fnln(),'len(curves2) =',len(curves2),', construction'

		newlist = []
		for curve in curves:
			if curve in curves1 or curve in curves2:
				newlist.append(curve)
		curves = newlist

	print fnln(), len(curves),'curves are selected.'
	show_sketch(sketch)

	return curves

def geometry_to_sketch(sketch,geometry,new_sketch='temp1'):
	## VER: 2015-04-19, v1.0
	## can be used to highlight (show) some geometry only in a new sketch
	## 对construction line也适用，例如: show_geometry(sketch,line2)

	## Example:
	## geometry_to_sketch('sk_nib',7)

	sketch = check_sketch(sketch)

	geometry = tolist(geometry)

	ids = []
	if is_numbers(geometry):
		ids = geometry
	else:
		for geom in geometry:
			id = geom.id
			if id not in ids:
				ids.append(id)

	new_sketch = new_key(_m.sketches.keys(),new_sketch)

	copy_sketch(sketch,newname=new_sketch)
	sketch2 = _m.sketches[new_sketch]

	to_del = unselect(sketch2.geometry.keys(),ids)
	del_geometry(sketch2,curves=to_del)

	return	new_sketch

show_geometry = geometry_to_sketch

def geometry_at(sketch,vertex=None,loc=None,H=None,V=None,ID=False,side=None):
	## VER: 2015-04-20, v1.5, 这里的curve其实也就是geometry，包括直线，曲线。
	## if ID=True, will return geometry IDs, otherwise, will return geometry objs.

##	>>> geometry_at('sk_nib',loc=(0.475440597724994, 6.6838046273479))
##	2 curves are found at vertex= ({'coords': (0.475440597724994, 6.6838046273479)})
##	[7, 12]
##	>>>

##	>>> geometry_at('sk_nib',loc=tangent_loc,side='+y')
##	['geometry_at', 87] 1 curves are found.
##	[12]


	sketch = check_sketch(sketch)

	if is_location(vertex):
		loc = vertex
		vertex = None
	elif type_of(vertex) == 'vertices':
		loc = vertex.coords

	if loc in empty:
		if H not in empty and V not in empty:
			H,V = real_xy_sketch(sketch,H=H,V=V)

		if is_numbers(H,V):
			loc = (H,V)

	if is_location(loc) == False:
		raise Exception('*** A vertex or a location is required.')

	x0,y0 = loc
	if vertex in empty:
		vertex = sketch.vertices.findAt(loc,printWarning=False)

	## 1. 有点
	curves = []
	if type_of(vertex) == 'vertices':
		for curve in sketch.geometry.values():
			if 'construction' not in type_of(curve):
				vertices = curve.getVertices()   ## 得到的是一个个的点，而不是各个点的位置。
				if vertex in vertices:
					curves.append(curve)
	else:  ## 2. 无点
		curve = sketch.geometry.findAt(loc,printWarning=False)
		if curve != None:
			curves = [sketch.geometry[curve.id]]

##	print fnln(),'len(curves)=',len(curves)
	if len(curves) >=2 and side in ['+x','-x','+y','-y']:
		sketch2 = geometry_to_sketch(sketch,geometry=curves)
##		print fnln(),'sketch2=',sketch2
		locs0 = vertice_locs_of_geometry(sketch2)
##		locs0 = new_points_of_sketch(sketch2)
##		print fnln(),'locs0=',locs0
		if side == '+x':
			divide_geometry(sketch2,x = x0 + 0.001)
		elif side == '-x':
			divide_geometry(sketch2,x = x0 - 0.001)
		elif side == '+y':
			divide_geometry(sketch2, y = y0 + 0.001)
		elif side == '-y':
			divide_geometry(sketch2, y = y0 - 0.001)
##		raise Exception
		locs1 = new_points_of_sketch(sketch2,locs0)
##		print fnln(),'len(locs1)=',len(locs1)

		newlist = []
		if len(locs1) == 1:
			geom = sketch.geometry.findAt(locs1[0],printWarning=False)
			if geom != None:
				geom = sketch.geometry[geom.id]
				newlist = [geom]
		elif len(locs1) >= 2:
			for item in locs1:
				dist1 = get_distance(item, loc)
##				print fnln(),'dist1=',dist1
				if dist1 < 0.005:
					geom = sketch.geometry.findAt(item,printWarning=False)
					if geom != None:
						geom = sketch.geometry[geom.id]
						if geom not in newlist:
							newlist.append(geom)
		curves = newlist

		show_sketch(sketch)
		del _m.sketches[sketch2]

	print fnln(),len(curves),'curves are found.'

	if ID == True:
		newlist = []
		for curve in curves:
			id1 = curve.id
			if id1 not in newlist:
				newlist.append(id1)
		curves = newlist

	return curves

def sketch_line_dir(line):
	## VER: 2012-11-24, v1.0

	if type_of(line) != 'regular_line':
		raise Exception('regular_line in sketch is required.')

	points = line.getVertices()
	x1,y1 = points[0].coords
	x2,y2 = points[1].coords

	if PK(x1,x2) == 0:
		dir1 = 'y'
	elif PK(y1,y2) == 0:
		dir1 = 'x'
	else:
		dir1 = 'slope'

	return dir1

def sketch_part(sketch,partname='_temp',length=20.1):
	## VER: 2013-05-20, v1.1.  	20.1可以用做一个特征生长长度，表明该长度是草图几乎是按默认生长出来的。

	global _m, a

	sketch = check_sketch(sketch)
	partname = new_key(name=partname,new_part=True)
	_m.Part(dimensionality=THREE_D, name=partname, type=DEFORMABLE_BODY)  ## 生成一个blank part
	_m.parts[partname].BaseSolidExtrude(sketch=sketch, depth=length)  ## 默认的生长长度。无需切换到sketch视图。

##	print '请及时删除该临时part: del _m.parts[partname]'
##	print '** please remember to delete this temperory part by: del _m.parts[partname]'

	return partname

def sketch_vertice_select(sketch,loc=(),H=None,V=None,vertices=(), x=None, y=None, at_geometry=None, partx=None, party=None, partz=None, ndir=None, empty2space=False, tryone=False):
	## VER: ('VER: 2014-09-10, v1.3')

	sketch = check_sketch(sketch)

	if is_numbers(loc):
		x,y = loc

	if x not in empty:
		H = x

	if y not in empty:
		V = y

	H0,V0 = H,V
	H,V = real_xy_sketch(sketch,H=H,V=V,partx=partx,party=party,partz=partz,ndir=ndir,empty2space=empty2space)
	H1,H2,V1,V2 = tospace(H,V)
	print fnln(),'H1,H2,V1,V2=',(H1,H2,V1,V2)

	if vertices not in empty:
		vertices = tolist(vertices)
	else:
		vertices = sketch.vertices.values()

		if at_geometry == True:
			points = []
			for point in vertices:
				g = sketch.geometry.findAt(point.coords,printWarning=False)
				if g in empty or 'construction' in type_of(g):
					continue
				else:
					points.append(point)
	##				print fnln_fnln(),type_of(g)
			vertices = points

	pointOns_all = []
	for pt in vertices:
		pointOns_all.append(pt.coords)

	mypoints = []
	for vertice in vertices:   ## center point of arc is also included
		ptCoords = vertice.coords

		if within_range(ptCoords[0],H1,H2):
			if within_range(ptCoords[1],V1,V2):
				if vertice not in mypoints:
					mypoints.append(vertice)

					if tryone == True:
						break

	print fnln(),len(mypoints)
##	raise Exception

	if mypoints in empty:
		if H0 in [MIN,MAX] and V0 in empty:
			pointOns = sort_tuple_type_elements(pointOns_all,index=0)

			reselect = False
			if H0 == MIN:
				loc = pointOns[0][0]
				if abs(loc - H1) < 1e-3:
					reselect = True
			elif H0 == MAX:
				loc = pointOns[-1][0]
				if abs(loc - H2) < 1e-3:
					reselect = True

			if reselect == True:
				for pt in vertices:
					loc1 = pt.coords[0]
					if abs(loc - loc1) < 1e-4:
						mypoints.append(pt)

		elif V0 in [MIN,MAX] and H0 in empty:
			pointOns = sort_tuple_type_elements(pointOns_all,index=1)

			reselect = False
			if V0 == MIN:
				loc = pointOns[0][1]
				if abs(loc - V1) < 1e-3:
					reselect = True
			elif V0 == MAX:
				loc = pointOns[-1][1]
				if abs(loc - V2) < 1e-3:
					reselect = True

##			raise Exception
			if reselect == True:
				for pt in vertices:
					loc1 = pt.coords[1]
					if abs(loc - loc1) < 1e-4:
						mypoints.append(pt)


	if len(mypoints) == 0:
		print fnln_fnln(),'******Selection of vertices failed.'
	else:
		print len(mypoints),'vertices selected, called by',caller_fnln()

	return mypoints

def dxAx(dx,Ax=None,deg=None):
	## VER: 2016-09-21, v1.0
	## Ax是斜线与x轴的角度。约定dy的正负取决于Ax的正负，与dx的正负无关。即：Ax>0则dy>0(一二象限), Ax<0，则dy<0(三四象限)

	if is_number(deg):
		Ax = deg

	if is_numbers(dx,Ax) == False:
		raise Exception('*** dx and Ax are required.')

	dy = dx*tanD(Ax)
	if Ax>0:
		dy = abs(dy)
	else:
		dy = -abs(dy)

	dict1 = {'DT':(dx,dy)}

	return dict1

def dyAy(dy,Ay=None,deg=None):
	## VER: 2016-09-21, v1.0
	## Ay是斜线与y轴的角度。约定dy的正负取决于Ay的正负，与dy的正负无关。即：Ay>0则dx>0(一四象限), Ay<0，则dx<0(二三象限)

	if is_number(deg):
		Ay = deg

	if is_numbers(dy,Ay) == False:
		raise Exception('*** dy and Ay are required.')

	dx = dy*tanD(Ay)
	if Ay>0:
		dx = abs(dx)
	else:
		dx = -abs(dx)

	dict1 = {'DT':(dx,dy)}

	return dict1


def get_dxdy(dx=None,dy=None,deg=None):
	## VER: 2016-09-21, v1.1, to get the dx, and dy

## Example: dy = -exit_dy, angle with y axis = 45deg, but dx>0, so input deg=45, not -45
##>>> get_dxdy(dy=-exit_dy,deg=45)
##(1.895, -1.895)
##>>>

	if type_of(deg) not in numerics:
		raise Exception('*** slope angle is required in deg.')

	if type_of(dx) in numerics:
		dy = dx*tanD(deg)  ## 知道dx以及x轴的偏转角deg
		if deg > 0:        ## dy的正负取决于偏转角的正负
			dy = abs(dy)
		else:
			dy = -abs(dy)

	elif type_of(dy) in numerics:
		dx = dy*tanD(deg)
		if deg > 0:
			dx = abs(dx)
		else:
			dx = -abs(dx)

	dict1 = {'DT':(dx,dy)}

	return dict1

def slope_construction(sketch,loc=(0,0),angle=30):
	## VER: 2014-06-13, v1.0  ## angle is the angle from X to the construction line, counter clockwise

	sketch = check_sketch(sketch)
	if type_of(loc) == 'vertices':
		pt = loc
		loc = pt.coords

	if is_location(loc) == False:
		raise Exception('*** location is required.')

	line = sketch.ConstructionLine(point1=loc, angle=angle)

	return line

def smart_modify_string(str1):
	## VER: 2014-12-02, v1.0

	str1 = modify_string(str1,',','_')
	str1 = modify_string(str1,' ','_')
	str1 = modify_string(str1,'__','_')
	str1 = modify_string(str1,'.','_')
	str1 = modify_string(str1,'-','_')
	str1 = modify_string(str1,':','_')
	str1 = modify_string(str1,'=')

	return str1


def smart_round(value,width=6):
	## VER: 2014-11-14, v1.2

##	print fnln(),'value=',value
##	print fnln(),'width=',width
	num = get_decimal_num(value,width=width)
##	print fnln(),'num=',num
	value = round(value,num)

	mag = get_magnitude(value)
	if mag > width:
		value = int(value)

	if abs(value) < 1e-15:
		value = 0

	return value

def is_solid_list(list1):
	## VER: 2016-06-15, v1.0

	result = False
	if type_of(list1) in ['TUPLE','LIST','SEQUENCE']:
		if len(list1) > 0:
			result = True

	return result

def solid_sequence(*list1):
	## VER: 2011-11-08, v1.0    判断是否全部非空

	list1 = tolist(list1)
	if type_of(list1) != 'LIST':
		list1 = [list1]

	result = True
	for item in list1:
		if item in empty:
			result = False
			break

	return result

def sort(list1,index1=None,index2=None,reverse=False):
	## VER: 2012-09-02, v1.1	局部排序, 若index1,index2均省略，则对整个列表

	list1 = tolist(list1)

	if index1 in empty:
		index1 = 0
	if index2 in empty:
		index2 = len(list1)

	list2 = list1[index1:index2]
	list2.sort(reverse=reverse)

	list1 = list1[:index1] + list2 + list1[index2:]

	return list1

function_labels['sort_by_key'] = 'lambda','item','sort','map'
def sort_by_key(dict1={},reverse=False):
	## VER: 2011-03-08, v1.2
	## example:
	## dict1 = {}
	## sort_by_key(dict1) = []

	## lambda函数的应用例子：
##	>>> am1
##	mdb.models['Model-1'].amplitudes['top_move']
##	>>> indexs = map(lambda item:item[0], am1.data)  ## map函数需要两个函数。item是am1.data这个列表中的一个元素(item)
##	>>> indexs
##	[0.0, 0.1, 0.5, 1.0]
##	>>>
##	>>> indexs = map(am1.data,lambda item:item[0])
##	TypeError: argument 2 to map() must support iteration
##	>>>

	return sorted(dict1.items(), key=lambda item: item[0],reverse=reverse)

function_labels['sort_by_value'] = 'lambda','item','sort','map'
def sort_by_value(dict1={},reverse=False):
	## VER: 2011-03-08, v1.2
	return sorted(dict1.items(), key=lambda item: item[1],reverse=reverse)

def sort_files_by_time(files):
	## VER: 2014-08-25, v1.0

	files = tolist(files)
	list1 = []
	for file1 in files:
		list1.append((file1, file_time_second(file1)))

	list2 = sort_tuple_type_elements(list1, index=1)

	return list2

def sort_nodes(nodes):
	## VER: 2014-10-13, v1.0
	## sort by node label

	nodes = tolist(nodes)
	if len(nodes) == 1:
		result = nodes
	elif len(nodes) == 2:
		node1,node2 = nodes
		if node1.label > node2.label:
			node1,node2 = node2,node1
		result = [node1,node2]

	else:
		dict1 = {}
		for node in nodes:
			dict1[node.label] = node

		nodes1 = sort_by_key(dict1)
		nodes2 = []
		for label,node in nodes1:
			nodes2.append(node)

		result = nodes2

	return result


def sort_space(space):
	## VER: 2012-08-29, v1.0

	space = tolist(space)
	xx = space[0:2]	;	xx.sort()
	yy = space[2:4]	;	yy.sort()
	zz = space[4:6]	;	zz.sort()

	space = xx + yy + zz

	return space

def sort_dict_type_elements(dicts,key,reverse=False):
	## VER: 2013-10-30, v1.1. index may be 1,2,or 3. Can be used to sort locations, items of dict, etc.
	## dicts can be a list or a tuple

	## example: curves1 = sort_dict_type_elements(curves1,key='size',reverse=reverse)

	if type_of(dicts) not in ['TUPLE','LIST']:
		raise Exception('*** a tuple or list is required.')

	if len(dicts) == 1:
		return dicts
	elif type_of(dicts[0]) != 'DICT' or type_of(dicts[1]) != 'DICT':
		raise Exception('*** element should be a dict.')
	elif key not in dicts[0].keys() or key not in dicts[1].keys():
		raise Exception('*** key is not in the dict')

	dicts = tolist(dicts)	  ## such as: [(-9.98, 0.0), (-9.76, 0.0), (9.76, 0.0), (9.98, 0.0)]
	if dicts not in empty:
		for i in range(len(dicts) - 1):
			flag =dicts[i][key]

			for j in range(len(dicts))[i+1:]:
				flag1 = dicts[j][key]
				if PK(flag1,flag) == '<':
					temp = dicts[i]
					dicts[i] = dicts[j]
					dicts[j] = temp
					flag = flag1

	if reverse == True:
		dicts.reverse()

	return dicts

def sort_locs(locs,index=0,reverse=False):
	## VER:2015-10-29, v1.1

	if index == 'x':
		index = 0
	elif index == 'y':
		index = 1
	elif index == 'z':
		index = 2

	locs = sort_tuple_type_elements(locs=locs,index=index,reverse=reverse)

	return locs

def sort_tuple_type_elements(locs,index=0,reverse=False):
	## VER: 2013-07-25, v1.1. index may be 1,2,or 3. Can be used to sort locations, items of dict, etc.
	## locs can be a list or a tuple
	## element of locs can be a list or a tuple
	## loc可能是一种变相的dict
	## Warning: running will be very slow for a tuple of whole odb nodes or elements.

	## example:
##	>>> list1 = [[2.5,powder_s.edges[4]],(1.0,powder_s.edges[1]),[3.5,powder_s.edges[8]]]
##	>>> sort_tuple_type_elements(list1,index=0)
##	[(1.0, mdb.models['Model-1'].parts['powder_s'].edges.findAt((8.28198, 35.310014, 0.0),)), [2.5, mdb.models['Model-1'].parts['powder_s'].edges.findAt((9.682467, 7.709026, 0.0),)], [3.5, mdb.models['Model-1'].parts['powder_s'].edges.findAt((9.698872, -1.090635, 0.0),)]]
##	>>>

	if type_of(locs) not in ['TUPLE','LIST']:
		raise Exception('*** a tuple or list is required.')

	if len(locs) == 1:
		return locs
	elif type_of(locs[0]) not in ['TUPLE','LIST'] or type_of(locs[1]) not in ['TUPLE','LIST']:
		raise Exception('*** element should be a tuple or a list')

	locs = tolist(locs)	  ## such as: [(-9.98, 0.0), (-9.76, 0.0), (9.76, 0.0), (9.98, 0.0)]
	if locs not in empty:
		index_range = range(len(locs))
		for i in index_range[:-1]:
			flag =locs[i][index]

			for j in index_range[i+1:]:
				flag1 = locs[j][index]
				if PK(flag1,flag) == '<':  ## 升序
					temp = locs[i]
					locs[i] = locs[j]
					locs[j] = temp
					flag = flag1

	if reverse == True:
		locs.reverse()

	return locs


def space_at(poi,x=None,y=None,z=None,irregular=False):
	## VER: 2012-02-09, v1.0

	poi = check_pias(poi)

	faces = []
	if type_of(x) in ['FLOAT','INT']:
		faces = faces_of_cut(poi,x=x)
		ndir = 'x'
	elif type_of(y) in ['FLOAT','INT']:
		faces = faces_of_cut(poi,y=y)
		ndir = 'y'
	elif type_of(z) in ['FLOAT', 'INT']:
		faces = faces_of_cut(poi,z=z)
		ndir = 'z'

	if faces not in empty:
		area = get_area(faces)
		x1,x2,y1,y2,z1,z2 = objs_space(faces)

		if ndir == 'x':
			area1 = (y2 - y1)*(z2-z1)
			if abs(area - area1) > 1e-6 and irregular == False:
				raise Exception('Fail to get the space of irregular or seperate faces')
		elif ndir == 'y':
			area1 = (x2 - x1)*(z2-z1)
			if abs(area - area1) > 1e-6 and irregular == False:
				raise Exception('Fail to get the space of irregular or seperate faces')
		elif ndir == 'z':
			area1 = (y2 - y1)*(x2-x1)
			if abs(area - area1) > 1e-6 and irregular == False:
				raise Exception('Fail to get the space of irregular or seperate faces')

		return x1,x2,y1,y2,z1,z2

	else:
		raise Exception('No faces to get the space.')

	return

def space_by_box(objs):
	## VER: 2015-05-28, v1.0
	## 有getByBoundingBox(), 还有getByBoundingCylinder(),后者需要输入圆柱区域的上底面和下底面的圆心以及该圆柱体的半径。
	## 当然还有getByBoundingSphere()

##	>>> space_by_box(p.elements)
##	(-9.937526, 9.892482, -8.140621, 7.25715, -13.812871, -7.594538)
##	>>> space_by_box(p.nodes)
##	(-9.937526, 9.892482, -8.140621, 7.25715, -13.812871, -7.594538)
##	>>>

	seq = list2sequence(objs)
	if seq in empty:
		raise Exception('*** objs required.')

	if type_of(seq[0]) not in ['cells','faces','edges','vertices','elements','nodes']:
		raise Exception('*** objects are required.')

	box = seq.getBoundingBox()
	x1,y1,z1 = box['low']
	x2,y2,z2 = box['high']
	x1,x2,x3,x4,x5,x6 = round6(x1,x2,y1,y2,z1,z2)

	return x1,x2,x3,x4,x5,x6

def space_of_cell(cell):
	## VER: 2014-08-05, v1.0
	## May be error, may include isolated vertices far away and do not attached to faces.

	if type_of(cell) != 'cells':
		raise Exception('*** a cell is required.')

	poi = get_poi(cell)
	seq = poi.cells[cell.index:cell.index+1]

	space = seq.getBoundingBox()

	x2,y2,z2 = space['high']
	x1,y1,z1 = space['low']

	return x1,x2,y1,y2,z1,z2

def space_of_curved_faces(faces,poi=None):
	## VER: 2012-12-19, v1.0

	temp_part = faces_to_shellpart(faces=faces,poi=poi)
	p1 = _m.parts[temp_part]

	info = p1.queryGeometry(printResults=False)
	x1,y1,z1 = info['boundingBox'][0]
	x2,y2,z2 = info['boundingBox'][1]

	x1,x2,y1,y2,z1,z2 = check_values(x1,x2,y1,y2,z1,z2)

##	del _m.parts[temp_part]
	del_parts(temp_part)

	return x1,x2,y1,y2,z1,z2

def space_of_edges(edges,p=None):
	## VER: 2014-07-29, v1.1

	space = objs_space(objs=edges, poi=p)

##	if type_of(edges) in ['PART','PINSTANCE']:
##		p,edges = edges,p
##
##	if type_of(edges) == 'edges':
##		edges = [edges]
##	elif type_of(edges) == 'STR':
##		edges = set2objs(edges,p)
##
##	if type_of(edges) == 'SEQUENCE':
##		seq = edges
##	else:
##		edges = tolist(edges)
##		seq = list2sequence(edges)
##
##	space = seq.getBoundingBox()   ;please_check	  ## 注意，getBoundingBox()有时候获得的结果是错误的，由此可能引起问题。
##	x2,y2,z2 = space['high']
##	x1,y1,z1 = space['low']
##
##	float = 6
##	x1 = round(x1,float)
##	x2 = round(x2,float)
##	y1 = round(y1,float)
##	y2 = round(y2,float)
##	z1 = round(z1,float)
##	z2 = round(z2,float)

	return space

def space_of_element(element):
	## VER: 2015-05-21, v1.1
	## 注意：下面的方法很可能是错误的，原因是getBoundingBox()本身有问题。
##	poi = get_poi(element)
##	seq = poi.elements[element.label:element.label+1]
##	space = seq.getBoundingBox()

	if type_of(element) != 'elements':
		raise Exception('*** a element is required.')

	nodes = element.getNodes()

	x1,y1,z1 = nodes[0].coordinates
	x2,y2,z2 = nodes[0].coordinates

	for node in nodes:
		x,y,z = node.coordinates
		x1 = min(x1,x)
		x2 = max(x2,x)
		y1 = min(y1,y)
		y2 = max(y2,y)
		z1 = min(z1,z)
		z2 = max(z2,z)

	return x1,x2,y1,y2,z1,z2

def space_of_insts(insts,double_check=None):
	## 2014-04-28, v1.0

	insts = real_insts(insts)

	if double_check in empty:
		if len(insts) > 20:
			double_check = False

	i = 0
	for inst in insts:
		i = i + 1
		x1,x2,y1,y2,z1,z2 = poi_space(inst)
		if i == 1:
			x_min = x1;	x_max = x2
			y_min = y1; y_max = y2
			z_min = z1; z_max = z2

		else:
			x_min = min(x_min,x1)
			x_max = max(x_max,x2)
			y_min = min(y_min,y1)
			y_max = max(y_max,y2)
			z_min = min(z_min,z1)
			z_max = max(z_max,z2)

	space = (x_min, x_max, y_min, y_max, z_min, z_max)

	return space

def space_of_points(*points):
	## VER: ('VER: 2012-08-09, v1.3')   ## 该函数也可以获得一些objs的pointsOn的范围。

	points = tolist(points)

	if points in empty:
		raise Exception('******Empty points.')

	locs = points
	type1 = type_of(points[0])

	if type1 == 'DATUMPOINT':
		locs = []
		for pt in points:
			locs.append(pt.pointOn)
	elif type1 == 'vertices':
		locs = []
		for pt in points:
			locs.append(pt.pointOn[0])

	if locs in empty:
		raise Exception('******Points or locations of points are needed')

	if len(locs) == 3 and type_of(locs[0]) in ['FLOAT','INT']:
		locs = (locs,)

	xlocs = []
	ylocs = []
	zlocs = []

	for loc in locs:
##		print fnln(),'loc=',loc
		x0,y0,z0 = loc
		xlocs.append(x0)
		ylocs.append(y0)
		zlocs.append(z0)

	xlocs.sort()
	ylocs.sort()
	zlocs.sort()
	x1 = xlocs[0];	x2 = xlocs[-1]
	y1 = ylocs[0]; y2 = ylocs[-1]
	z1 = zlocs[0]; z2 = zlocs[-1]

	return check_values(x1,x2,y1,y2,z1,z2)

def space_of_sequence(seq):
	## VER: 2014-05-05, v1.3
	## applicable to faces,edges,vertices
	## 注意，该函数可能有误差。即使是对vertices.

	if type_of(seq) != 'SEQUENCE':
		raise Exception('*** an objs sequence is required.')

	if type_of(seq[0]) == 'vertices':
		space = space_of_points(seq)
		x1,x2,y1,y2,z1,z2 = space
	else:
		space = seq.getBoundingBox()

		x2,y2,z2 = space['high']
		x1,y1,z1 = space['low']

##	print ' '
##	print fnln(),'before check_values(), space=',(x1,x2,y1,y2,z1,z2)
	x1,x2,y1,y2,z1,z2 = check_values(x1,x2,y1,y2,z1,z2)
##	print fnln(),'after check_values(), space=',(x1,x2,y1,y2,z1,z2)

## Example:
##['space_of_sequence', 191] before check_values(), space= (-8.9355, 8.9355, 0.0, 40.001330285114, -8.9355, 0.00059568918288333)
##['space_of_sequence', 193] after check_values(), space= (-8.9355, 8.9355, 0.0, 40.00133, -8.9355, 0.0006)

	return x1,x2,y1,y2,z1,z2

def space_of_sketch(sketch):
	## VER: 2014-09-09, v1.7. Only 2D sketch
	## space will not include the space of construction lines
	## 在本函数中不能del part，否则异常错误。

	if sketch in _m.sketches.values():
		sketch = sketch.name    ## use name, better than use variable, especially under GUI.

	part = sketch_to_wire(sketch,del_temp=True)
	x1,x2,y1,y2,z1,z2 = poi_space(part)

	del _m.parts[part]
	show_sketch(sketch)

	return x1,x2,y1,y2   ## please_check

def fn_speed2pressure(mph=None,kph=None,ms=None, unit='US', factor=3):
	## VER: 2012-01-21, v1.3  参考windload. unit缺省为3秒的瞬时风速，不是平均速度。ms600属于平均速度。
	## factor为阵风安全系数。
	## 相反的换算函数: fn_pressure2speed()

	print "****usage: fn_speed2pressure(mph=None,kph=None,ms=None, unit='US', factor=3)"
	print "benchmark：对于阵风安全系数3，2400Pa对应于130km/hr风速的压力(约±800Pa)。"
	print ' '

	if mph not in empty:
		ms = round(mph*1609.3/3600, 2)
	elif kph not in empty:
		ms = round(kph*1000/3600,2)

	if ms in empty:
		raise Exception('speed is required: mph, kph or ms')

	if unit == 'US':
		ms3 = ms
		ms600 = round(ms3*0.703,2)
		unit1 = '(为3秒风速)'
	elif unit == 'China':
		ms600 = ms
		ms3 = round(ms600/0.703, 2)
		unit1 = '(为600秒风速)'

	if kph in empty:
		kph = ms3*3.6

	P3 = round(ms3*ms3/1.6, 2)
	P600 = round(ms600*ms600/1.6, 2)

	print '---> ms= ' + str(ms) + ' m/s',unit1,', ms3 =',ms3,'m/s(对应kph=',kph,'km/hr), ms600 =', ms600, 'm/s, 基本风压：P3=',P3,'Pa, P600=',P600,'Pa,',factor,'倍基本风压=',P3*factor,'Pa'
	print '参考：ms3*ms3*2=',round(2*ms3*ms3,2),'Pa, 比3倍风压大',round(2*ms3*ms3,2) - P3*3,'Pa'
	print ' '

	print 'Remark:'
	print 'ms3=3秒平均最大阵风速度(单位:m/s)，ms600=10分钟(600秒)平均最大阵风风速(单位:m/s)。ms600=ms3*0.703。'
	print '美国用ms3计算基本风压(P3)，中国用ms600计算基本风压(P600)。'
	print ' '
	print '风级换算(以ms600为准): 10级狂风=24.5~28.4m/s(可拔起树来，损坏建筑物), 11级暴风=28.5~32.6m/s(陆上少见，有则必有广泛破坏), 12级飓风=32.7~36.9m/s(陆上极少见,摧毁力极大)'
	print '****注意：12级风的风速接近40m/s，这是10分钟的平均风速ms600，不是3秒的瞬时风速ms3.'

	return P3*factor

def space_volume_of_poi(poi):
	## VER: 2013-06-14, v1.0

	x1,x2,y1,y2,z1,z2 = poi_space(poi)
	volume = abs(x2-x1)*abs(y2-y1)*abs(z2-z1)
	volume = round(volume,3)

	return volume

def divide_geometry(sketch,curves=None, H=None,V=None,x=None,y=None,cutter=None):
	## VER: 2015-04-20, v1.6
	## id will change after divide for the same vertice

	## sketch.geometry is a repository, such as: prettyPrint(sketch,1)
	##{2: 'ConstrainedSketchGeometry object',
	## 3: 'ConstrainedSketchGeometry object',
	## 4: 'ConstrainedSketchGeometry object',
	## 6: 'ConstrainedSketchGeometry object',
	## 7: 'ConstrainedSketchGeometry object',
	## 8: 'ConstrainedSketchGeometry object',
	## 9: 'ConstrainedSketchGeometry object',
	## 10: 'ConstrainedSketchGeometry object',
	## 11: 'ConstrainedSketchGeometry object'}

	sketch = check_sketch(sketch)

##	print fnln_fnln(),'H,V=',(H,V)
##	print fnln_fnln(),'x=',x

	if x not in empty:
		H = x

	if y not in empty:
		V = y

	H,V = real_xy_sketch(sketch,H=H,V=V)
##	print fnln(),'H,V=',(H,V)

	curves = tolist(curves)
	if curves in empty:
		curves = all_regular_geometry(sketch)

	if is_numbers(curves):
		curves = geometry_ids_to_objs(sketch,curves)

	if cutter not in sketch.geometry.values():   ## create construction line as cutter
		if type_of(H) in numerics:
			cutter = sketch.ConstructionLine(point1=(H,0), angle=90)   ## If failed, cutter = None
		elif type_of(V) in numerics:
			cutter = sketch.ConstructionLine(point1=(0,V), angle=0)   ## If failed, cutter = None
		del_cutter = True
	else:
		del_cutter = False

	if cutter not in sketch.geometry.values():
		raise Exception('**** cutter line or construction is required.')

	cutter_id = cutter.id
	broken = False

	curves0 = totuple(sketch.geometry.keys())
	locs0 = locs_of_sketch_vertices(sketch)   ## only point loc at geometry

	num = len(curves)

	if num > 0:
		num1 = 0
		while True:
			num1 += 1
			broken =False
			for curve in curves:
				if curve  != cutter:  ## construction line or construction arc can also be divided.
					pt1 = curve.pointOn
					pt2 = cutter.pointOn
					if type_of(H) in numerics:
						point = (H,pt1[1])
					elif type_of(V) in numerics:
						point = (pt1[0],V)
					else:
						point = pt1

##					print fnln(),'--after: len(sketch.vertices)=',len(sketch.vertices.values())
					try:
##						print fnln(),'--after: len(sketch.vertices)=',len(sketch.vertices.values())
						sketch.breakCurve(curve1=curve, point1=point, curve2=cutter, point2=point)
						broken = True
##						print fnln(),'--after: len(sketch.vertices)=',len(sketch.vertices.values())
					except:
						pass

			if broken == False:
				break
			else:
				curves = all_regular_geometry(sketch)

			if num1 >= 2*num:
				break

	if del_cutter == True:
		sketch.delete(objectList=(cutter, ))
		sketch.setPrimaryObject(option=STANDALONE)
		sketch.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)

	new_locs = new_points_of_sketch(sketch,locs0)
	curves = new_geometry_of_sketch(sketch,curves0)

	return new_locs, curves   ## new created locs and geometry

def start_func(func):
	##VER: 2011-05-09, v1.0

	print ' '
	print '============================**** start function: ' + func + '() ****=================================='
	print ' '

	return

def step_name_to_id(step1):
	## VER: 2014-11-17, v1.0
	## for mdb. step0 is Initial

##	>>> step_name_to_id('heating')
##	1
##	>>> step_name_to_id('cooling')
##	3

	id = None
	if is_INT(step1):
		id = step1
	else:
		try:
			step = check_step(step1)
			for i in range(len(_m.steps.keys())):
				if _m.steps.keys()[i] == step:
					id = i
					break
		except:
			pass

	return id

def stop(debug=None):
	## VER: ('VER: 2012-08-14, v3.3')

	global _time2,_time21, default_plot, _m, a

	get_current_model()

	raise Exception

	if debug == True:
		print ' '
		print '****Please run print_traceback() for the calling history.'
		raise Exception
	elif debug == False:
		return

	cmd = 'start EmEditor.exe ' + work_dir + var_file_full
##	os.system(cmd)

	print ' '
	print '============================**** Change to Stop operation ****=================================='
	print ' '

	vpnow = get_vpnow()
	vpnow.assemblyDisplay.setValues(mesh=ON, loads=OFF, bcs=OFF, predefinedFields=OFF, connectors=OFF)

	part = real_parts(default_plot)
	if part not in empty:
		part = part[0]
	elif len(_m.parts) > 0:
		part = _m.parts.values()[0]
	else:
		part = None

	if len(a.instances.values()) > 0:
		plot(a)
##		fine_display()  ;please_check
	else:
		plot(part)


	if len(_m.constraints) > 0 or len(_m.interactions) > 0:
		list_contacts()

	if type_of(part) == 'PART':
		x1,x2,y1,y2,z1,z2 = poi_space(part)
		print ' '
		print 'Space of ' + part.name + ': x=',(x1,x2),', y=',(y1,y2),', z=',(z1,z2),', dimension in x,y,z=',(x2 - x1,y2 - y1,z2 - z1)

	_time21 = get_time()
	_time2 = time.time()
	elapse = _time2 - start_time
	minute = round(elapse/60,1)

	time1 = ''
	if elapse >= 60:
		time1 = ' Totally ' + str(minute) + ' min used.'
	else:
		time1 = ' Totally ' + str(round(elapse,1)) + ' sec used.'

	if len(_err_info) > 0:
		print '  '
		print '********There are',len(_err_info),'warnings as below.'
		print _err_info

	if len(_function_error) > 0:
		print ' '
		print '******_function_errors:'
		myprint(_function_error)

##	print '  '
##	print '******Model options, please confirm...'
##	print options

##	try:
	a.regenerate()   ## 要经常执行，否则可能异常退出。

	print ' '
	stats = a.getMeshStats(totuple(a.instances.values()))  ## GUI is OK, but code may be error.
##	raise Exception
	print '**Mesh status: Hex elements=',stats.numHexElems,
	if stats.numTetElems > 0:
		print ',Quard elements=',stats.numTetElems,
	print ', total nodes=',stats.numNodes
##	except:
##		pass

##	try:
##		module_summary()
##	except:
##		pass

	show_csys()   ## show also reference point and label

	info = get_traceback(collect_code=True)
	print ' '
	print 'Program reaches the **stop()** at line ' + str(info[-3]) + '. ' + time1
	print 'Traceback:',info[:-1]
	print '****To show local csys, run show_csys(). To hide local csys for fitview at screen center, run hide_csys().'
	print 'For model checking: module_summary(), cshow(), print BCs, list_mats(), list_element_type(part).'
	print ' '
	print 'run set_colormap() to see materials.'

##	vpnow.maximize()
##	vpnow.view.fitView()
##	vpnow.view.setProjection(projection=PARALLEL)
##	fine_display()

	if len(a.instances) > 0:
		mdb.save()

	raise Exception

	return

def s2b_flux(sur_flux,thick):
	## 2010-12-01, v1.0 sur_flux为标准单位制: W/m^2

	thick = thick/1000	## mm -> m
	return sur_flux/thick*K_bflux    ## mm单位制

def swap_interact_tie(part1='',part2='',inst1='',inst2='',name='',convert_to='interact', prop='Frictionless'):
	## 2010-08-18, v1.2

	global contact_pairs

	convert_to = convert_to.lower()

	if type_of(part1) != type_of(part2):
		raise Exception('part1 and part2 must be the same kind of object. line=3332, swap_master_slave()')	## ********

	if type_of(inst1) != type_of(inst2):
		raise Exception('inst1 and inst2 must be the same kind of object. line=3335, swap_master_slave()')	## ********

	if type_of(part1) == 'PART':
		part1 = part1.name

	if type_of(part2) == 'PART':
		part2 = part2.name

	if type_of(part1) == type_of(part2) == 'PINSTANCE':
		inst1 = part1
		inst2 = part2

	if type_of(inst1) == 'PINSTANCE':
		inst1 = inst1.name

	if type_of(inst2) == 'PINSTANCE':
		inst2 = inst2.name

	if convert_to == 'tie':
		con_func = s2s_tie
		dict0 = _m.interactions
		origin = 'interact'
	elif convert_to == 'interact':
		con_func = s2s_interact_std
		dict0 = _m.constraints
		origin = 'tie'

	swapped = False
	if name != '':
		for i in range(len(contact_pairs)):
			pair = contact_pairs[i]
			if pair not in empty:
				if name == pair['name'] and convert_to != pair['type']:
					master_inst = a.instances[pair['master']]
					mfaces = pair['mfaces']
					slave_inst = a.instances[pair['slave']]
					sfaces = pair['sfaces']

					if pair['type'] == 'interact':
						name1 = 'tie_' + name[4:]
					elif pair['type'] == 'tie':
						name1 = 'int_' + name[4:]

					backup = eval(str(pair))
					contact_pairs[i] = {}
					created = con_func(master_inst, slave_inst, name=name1, mfaces=mfaces, sfaces=sfaces, prop=prop)

					if created:
						del dict0[name]
						del a.sets['_' + name + '(master)']
						del a.sets['_' + name + '(slave)']

						swapped = True
						print '--->',name,'was successfully converted to',name1
						break

					else:
						contact_pairs[i] = eval(str(backup))

		contact_pairs1 = []
		for pair in contact_pairs:
			if pair != {}:
				contact_pairs1.append(pair)

		contact_pairs = contact_pairs1

		if not swapped:
			print fnln_fnln(),'No such contact name in contact_pairs, or',name,'has existed in',convert_to + 's. ********'


	elif inst1 != '' and inst2 != '':
		num = 0
		for i in range(len(contact_pairs)):
			pair = contact_pairs[i]
			if pair not in ['', [], {}]:
				if (inst1 in pair['instances']) and (inst2 in pair['instances']) and (pair['type'] != convert_to):
					name = pair['name']

					master_inst = a.instances[pair['master']]
					mfaces = pair['mfaces']
					slave_inst = a.instances[pair['slave']]
					sfaces = pair['sfaces']

					if pair['type'] == 'interact':
						name1 = 'tie_' + name[4:]
					elif pair['type'] == 'tie':
						name1 = 'int_' + name[4:]

					backup = eval(str(pair))
					contact_pairs[i] = {}
					print ' '
					created = con_func(master_inst, slave_inst, name=name1, mfaces=mfaces, sfaces=sfaces, prop=prop)

					if created:
						del dict0[name]
						del a.sets['_' + name + '(master)']
						del a.sets['_' + name + '(slave)']

						swapped = True
						num += 1
						print '--->',name,'was successfully converted to',name1
						print 'num = ',num

					else:
						contact_pairs[i] = eval(str(backup))

		contact_pairs1 = []
		for pair in contact_pairs:
			if pair != {}:
				contact_pairs1.append(pair)

		contact_pairs = contact_pairs1

		if not swapped:
			print fnln_fnln(),'No contact pair was converted to type=',convert_to, '. ********'


	elif part1 != '' and part2 != '':
		num = 0
		for i in range(len(contact_pairs)):
			pair = contact_pairs[i]
			if pair not in ['', [], {}]:
				if (part1 in pair['parts']) and (part2 in pair['parts']) and (pair['type'] != convert_to):
					name = pair['name']

					master_inst = a.instances[pair['master']]
					mfaces = pair['mfaces']
					slave_inst = a.instances[pair['slave']]
					sfaces = pair['sfaces']

					if pair['type'] == 'interact':
						name1 = 'tie_' + name[4:]
					elif pair['type'] == 'tie':
						name1 = 'int_' + name[4:]

					backup = eval(str(pair))
					contact_pairs[i] = {}
					print ' '
					created = con_func(master_inst, slave_inst, name=name1, mfaces=mfaces, sfaces=sfaces, prop=prop)

					if created:
						del dict0[name]
						del a.sets['_' + name + '(master)']
						del a.sets['_' + name + '(slave)']

						swapped = True
						num += 1
						print '--->',name,'was successfully converted to',name1
						print 'num = ',num

					else:
						contact_pairs[i] = eval(str(backup))

		contact_pairs1 = []
		for pair in contact_pairs:
			if pair != {}:
				contact_pairs1.append(pair)

		contact_pairs = contact_pairs1

		if not swapped:
			print fnln_fnln(),'No contact pair was converted to type=',convert_to, '. ********'

	return

def stress_vols(*dict1):
	## VER: 2014-12-05, v1.0
	## 当前视图可以不是S1视图。

##	stress_vols('PCD',200)
##	stress_vols(('PCD',200),('H11N',600))

	dict1 = totable(dict1)

	refresh()
	values = {}
	for set1,value in dict1:
		plotset(set1)
		vals = get_stress_volume(value,label='S1')
		values[set1] = vals

	print ' '

	return values

def stress_volume_vs_time(value,step=None, sign=1, inst=None,setname=None,count=False):
	## VER: 2014-12-30, v1.1
	## 注意，如果统计单元数，且单元数小于5，此时，用edel()结合比较。取edel()和get_stress_volume()中num相对较小者。
	## 也可以获得剪切应力的应力体积。例如powder compaction中观察剪切应力。

	## Example: stress_volume_vs_time(1.0, count=True)
	## stress_volume_vs_time(3)   ## 对于2D axisymmetric powder compaction模型也适用。可发现，时间达到80%时，stress volume迅速提高。

	refresh()
	vpnow = get_vpnow()
	if get_plot_state() != CONTOURS_ON_DEF:
		raise Exception('*** a odb contour is required.')

	if step in empty:
		step = -1

	if sign not in [1,-1]:
		raise Exception('*** sign should be 1 or -1')

	setting = current_variable_setting()
	label = setting['label']
	if label == 'PEEQ':
		variable = 'PEEQ'
	elif label == 'S, Mises':
		variable = 'mises'
	elif label == 'S, Max. Principal':
		variable = 'maxPrincipal'
	elif label == 'S, S11':
		variable = 'S11'
	elif label == 'S, S22':
		variable = 'S22'
	elif label == 'S, S33':
		variable = 'S33'
	elif label == 'S, S12':
		variable = 'S12'    ## for powder compaction, 2D model, crack checking
	elif label == 'S, S13':
		variable = 'S13'
	elif variable == 'S, S23':
		variable = 'S23'
	else:
		raise Exception('*** Error stress variable shown in the viewport.')

	results = []
	step = check_odb_step(step)
##	variable = variable.upper()
	if variable == 'PEEQ':
		value = value/100

	objs = get_real_input(inst,setname)
	if objs in empty:
		objs = objs_of_dg()

	if objs in empty:
		raise Exception('*** Fail to get the objs, please switch to the contour plot and use REPLACE function.')

	print fnln(),'objs=',objs

	if len(objs) == 1 and objs[0] in oa.instances.keys():
		inst = objs[0]
		ids = element_ids_in_odb(inst)
	else:
		ids = None

	for id in range(len(step.frames)):
		set_step_and_frame(step=step,frame=id)
##		if id == 2:
##			raise Exception
		min0, max0 = minmax_value_of_viewport()
		time1 = step.frames[id].frameValue

		found = False
		value1 = None
		if sign == 1 and max0[-1] >= value:
			found = True
			value1 = max0
		elif sign == -1 and min0[-1] <= value:
			found = True
			value1 = min0

		if found:
			print 'Getting stress volume for frame:',id,', time=',smart_round(time1),', value=',value1[-1]
			dict1 = get_stress_volume(value=value,variable=variable,ids=ids,sign=sign)
			if count == False:
				vol = dict1['vol']
			else:
				vol = dict1['num']
		else:
			vol = 0

		results.append((time1,vol))

	screen()
	filename = '_xydata_' + variable + '_' + odb_file_title + '_1.txt'
	filename = check_file_name(filename,format='TXT')
	print 'xydata filename=',filename	##  D:/JYQ/A0212/_xydata_S_C6_A0212_rotary_initialV150_10_4.txt
	sys.stdout = open(filename,'w')  ## save 1

	for time1, data1 in results:
		print time1, '   ', data1
	screen()

	if count == False:
		data_type = VOLUME
	else:
		data_type = NUMBER

	name = new_key(session.xyPlots.keys(),'xyplot-1')
	xyp = session.XYPlot(name)
	chartName = xyp.charts.keys()[0]
	chart = xyp.charts[chartName]
	xQuantity = visualization.QuantityType(type=TIME)
	yQuantity = visualization.QuantityType(type=data_type)

	print 'xQuantity=',xQuantity
	print 'yQuantity=',yQuantity
##	print 'Y axis type=',yQuantity.type

##	raise Exception
	xy1 = xyPlot.XYDataFromFile(fileName=filename, xField=1,
	    yField=2, contentDescription=variable, yValuesLabel=variable, axis1QuantityType=xQuantity, axis2QuantityType=yQuantity, )
	c1 = session.Curve(xyData=xy1)
	chart.setValues(curvesToPlot=(c1, ), )
	vpnow.setValues(displayedObject=xyp)

##	raise Exception

## GUI:
##>>> chart = session.charts.values()[-1]
##>>> axis_data = chart.axes2[0].axisData

	chart = get_current_chart()

##	print fnln(),'variable=',variable

	if variable == 'PEEQ':
		value = value * 100
		text2 = variable + ' ( >= ' + repr(value) + ' %)'
	else:
		if sign == 1:
			text2 = variable + ' ( >= ' + repr(value) + ' MPa)'
		else:
			text2 = variable + ' ( <= ' + repr(value) + ' MPa)'

##	print fnln(),'text2=',text2
	update_axis2(chart,text2)

	refresh()
	save_image()

	return results

def submit(jobname=None):
	## VER: 2016-09-18, v1.0

	if jobname in mdb.jobs.keys():
		job1 = mdb.jobs[jobname]
	else:
		if len(mdb.jobs) > 0:
			job1 = mdb.jobs.values()[-1]
		else:
			raise Exception('*** No job for submission.')

	if job1.status not in [RUNNING,SUBMITTED]:
		job1.submit()
	else:
		print 'job is already submitted.'

	return

function_labels['suggested_analysis_step'] = 'problem type','procedure type','antype','analysis type','step type','DOF','solver'
def suggested_analysis_step(solver,*DOFs):
	## VER: 2015-04-01, v1.1  很有局限

	if type_of(solver) in ['LIST','TUPLE']:
		DOFs,solver = solver, DOFs

	DOFs = tolist(DOFs)
	for i in range(len(DOFs)):
		DOFs[i] = DOFs[i].lower()

	solver = solver.lower()
	if solver == 'standard':
		solver = 'implicit'

	DOF = []
	for dof in DOFs:
		if 'temp' in dof and 'temp' not in DOF:
			DOF.append('temp')
		elif ('stress' in dof or 'stress' in dof) and 'stress' not in DOF:
			DOF.append('stress')
		elif ('freq' in dof or 'modal' in dof) and 'freq' not in DOF:
			DOF.append('freq')

	## 不管是temp，还是stress，都有隐式和显式之分。
	suggested = []
	if len(DOF) == 1:
		dof = DOF[0]
		if dof == 'temp':
			suggested = 'create_heat_transfer_step'
		elif dof == 'stress':
			if solver == 'implicit':
				suggested = ['create_general_static_step','create_dynamic_implicit_step']
			elif solver == 'explicit':
				suggested = 'create_dynamic_explicit_step'
		elif dof == 'freq':
			suggested = ['frequency_and_mode_shapes_step', 'time_response_modal_dynamics_step', 'frequency_response_modal_dynamics_step']

	elif 'temp' in DOF and 'stress' in DOF:
		suggested = 'create_coupled_temp_displacement_step'
		## 隐式调用的是CoupledTempDisplacementStep(), 显式调用的是TempDisplacementDynamicsStep()。
		## 现在都整合到create_coupled_temp_displacement_step()中

	return suggested


def suppress_hiden_insts():
	## VER: 2014-04-28, v1.0

	global _m, a

	refresh()
	hide_insts = get_hiden_insts()
	a.suppressFeatures(totuple(hide_insts))

	return

def swap_dict_key(dict1,key,str1='',str2=''):
	## VER: 2010-08-17, v1.1

	mark = ''
	loc = -1
	str0 = ''
	if str1 in key:
		str0 = str1
		loc = key.find(str1)
		mark = str2
	elif str2 in key:
		str0 = str2
		loc = key.find(str2)
		mark = str1

	key1 = ''
	if loc != -1:
		key1 = key[:loc] + mark + key[loc + len(str0):]
		try:
			dict1.changeKey(fromName = key, toName = key1)
		except:
			if key1 not in dict1.keys():
				dict1[key1] = copy.deepcopy(dict1[key])
				del dict1[key]
			else:
				raise Exception('key1= '+ key1 +' has existed, and cannot overwrite. line=6635, swap_dict_key()')	## ********

	return dict1, key1

def swap_master_slave(con_type='interact',part1=None,part2=None,inst1=None,inst2=None,name=None,master=None):
	## 2010-11-09, v1.6
	## part and inst, master are all strings.

	global contact_pairs

	con_type = con_type.lower()

	if type_of(part1) == 'PART':
		part1 = part1.name
	elif type_of(part1) == 'PINSTANCE':
		inst1 = part1.name

	if type_of(part2) == 'PART':
		part2 = part2.name
	elif type_of(part2) == 'PINSTANCE':
		inst2 = part2.name

	if type_of(inst1) == 'PINSTANCE':
		inst1 = inst1.name

	if type_of(inst2) == 'PINSTANCE':
		inst2 = inst2.name

	if master not in empty:
		if type_of(master) in ['PART','PINSTANCE']:
			master = master.name

	if con_type == 'tie':
		dict1 = _m.constraints
	elif con_type == 'interact':
		dict1 = _m.interactions

	swapped = False
	found = False

##	print 'part1,part2,inst1,inst2,master=',part1,part2,inst1,inst2,master

	num = 0
	if name not in empty:
		for pair in contact_pairs:
			if name == pair['name']:
				found = True

				dict1,name1 = swap_dict_key(dict1,name,'(m)','(s)')
				pair['name'] = name1
				pair['master'], pair['slave'] = pair['slave'], pair['master']
				pair['mfaces'], pair['sfaces'] = pair['sfaces'], pair['mfaces']
				pair['parts'] = [pair['parts'][1],pair['parts'][0]]
				pair['instances'] = [pair['instances'][1],pair['instances'][0]]
				dict1[name1].swapSurfaces()

				swapped = True
				num += 1
				print 'Contact pair swapped: new name=',name1,', master inst=',pair['master'],', slave inst=',pair['slave']
				break

		if not swapped:
			print 'No such contact name in contact_pairs.'

	elif inst1 not in empty and inst2 not in empty:
		for pair in contact_pairs:
			if (inst1 in pair['instances']) and (inst2 in pair['instances']) and (con_type == pair['type']):
				name = pair['name']
				found = True

				swap = False
				if master in empty:
					swap = True
				elif pair['slave'] == master:
					swap = True

				if swap:
					dict1,name1 = swap_dict_key(dict1,name,'(m)','(s)')
					pair['name'] = name1
					pair['master'], pair['slave'] = pair['slave'], pair['master']
					pair['mfaces'], pair['sfaces'] = pair['sfaces'], pair['mfaces']
					pair['parts'] = [pair['parts'][1],pair['parts'][0]]
					pair['instances'] = [pair['instances'][1],pair['instances'][0]]
					dict1[name1].swapSurfaces()

					swapped = True
					num += 1
					print 'Contact pair swapped: master inst=',pair['master'],', slave inst=',pair['slave']

		if not swapped:
			print 'swapped= False'


	elif part1 not in empty and part2 not in empty:
		num = 0
		for pair in contact_pairs:
			if (part1 in pair['parts']) and (part2 in pair['parts']) and (con_type == pair['type']):
				name = pair['name']
				found = True

				print 'Found',name
				swap = False
				if master in empty:
					swap = True
				elif a.instances[pair['slave']].partName == master:
					swap = True

				if swap:
					dict1,name1 = swap_dict_key(dict1,name,'(m)','(s)')
					pair['name'] = name1
					pair['master'], pair['slave'] = pair['slave'], pair['master']
					pair['mfaces'], pair['sfaces'] = pair['sfaces'], pair['mfaces']
					pair['parts'] = [pair['parts'][1],pair['parts'][0]]
					pair['instances'] = [pair['instances'][1],pair['instances'][0]]
					dict1[name1].swapSurfaces()

					num += 1
					swapped = True

		if swapped:
			print 'Master and slave swapped successfully for',num,'contact pairs.'
		else:
			print 'Not swapped.',
			if not found:
				print 'The contact pair(s) were not found in',repr(dict1)
			else:
				print

	return

def rename(obj,newname):
	## VER: 2014-07-30, v1.1
	## reference: get_parent(), get_repository, get_repository_key(), type_of_repository()

##	del_parts('nib')
##	rename('nib2','nib')

##>>> get_repository(p1)
##mdb.models['Model-1'].parts
##>>>

##>>> p1 = a.instances['carbide_A1']
##>>> get_repository(p1)
##mdb.models['Model-1'].rootAssembly.features
##>>>
	if is_poi(obj):
		obj = check_poi(obj)

##	if type_of(obj) == 'STR':
##		obj = check_poi(obj)

	type1 = type_of(obj)
	house = get_repository(obj)

	get_current_model()
	if newname in house.keys():
		if house == _m.parts:
			del _m.parts[newname]
		elif house == a.features:
			del a.features[newname]
		else:
			raise Exception('*** ' + newname + ' has been existed.')

	try:
		current_name = obj.name
	except:
		try:
			current_name = get_key_name(obj,type1.lower())
		except:
			raise Except('*** fail to get current_name')

	exec(repr(house) + '.changeKey(fromName=' + repr(current_name) + ', toName=' + repr(newname) + ')')

	get_current_model()

	return

change_name = rename

def change_part_name(part,newname):
	## VER: 2014-07-30, v1.1
	## reference: rename(obj, newname)

	part = check_part(part)
	oldname = part.name

	if newname in _m.parts.keys():	## replace
		del_parts(newname)

	copy_part(oldname,newname)
	del_parts(oldname)

	return

def change_part_setname(part,str1,str2):
	## VER: 2011-09-27, v1.1		## from str1 to str2

	set_list = part.sets.keys()
	num = len(set_list)
	for i in range(num):
		setname = set_list[i]
		new_set1 = modify_string(setname,str1,str2)

		if new_set1 != setname and new_set1 not in set_list:
			part.sets.changeKey(fromName=setname, toName=new_set1)
			set_list[i] = new_set1

	part.regenerate()

	return

def fn_tape_width_dynamic(short_length,windload):
	## 2010-08-30,v1.0
	## Unit: short_length in mm, windload in Pa
	## Tape design strength = 85kPa for dynamic load

	width = 0.5*short_length*windload/85000
	num1 = ceil(width/5)
	width = num1*5

	print 'Windload=',windload,'Pa'
	print 'VHB tape width=',width,'mm (dynamic load)'

	return width

function_labels['fn_tape_width_static'] = 'PV','suntech','glass','mounting','3M','VHB'
def fn_tape_width_static(glass_lenx=0, glass_leny=0, glass_thick=0, glass_weight=0):
	## 2010-11-22,v1.1, 尤其适用于玻璃被悬挂的情形(只靠胶的支撑力)
	## Unit: glass_lenx in mm, glass_leny in mm, glass_thick in mm, glass_weigth in kg
	## Tape design strength = 1.75e-4 kg/mm^2 for static load
	## 动态强度0.7MPa, 计算时用1.7kPa，设计强度83kPa

	if glass_weight == 0:
		glass_weight = glass_lenx*glass_leny*glass_thick*1e-9*2.5e3

	width = 0.5*glass_weight/(2*(glass_lenx + glass_leny)*1.75e-4)
	num1 = ceil(width/5)
	width = num1*5

	width2 = glass_weight*5500/(2*glass_lenx + 2*glass_leny)
	width2 = int(width2)

	print 'glass weight=',glass_weight,'kg'
	print '按照Tape design strength = 1.75e-4 kg/mm^2, VHB tape width=',width,'mm (static load)'
	print '按照55cm^2/kg 负载的原则，VHB tape width=',width2,'mm (static load)'

	return width

function_labels['vsweep'] = 'viewport','angle','axisymmetric','post-processing','rotate','sweep'
def vsweep(angle=270):
	## VER: 2013-11-04, v1.0

	vpnow = get_vpnow()

	if angle > 0:
		vpnow.odbDisplay.basicOptions.setValues(sweepElem=ON, sweepEndAngleElem=angle, numSweepSegmentsElem=int(angle))
	else:
		vpnow.odbDisplay.basicOptions.setValues(sweepElem=OFF)  ## 2D display

	return

def sweep_solid_through_wire(wire, section, datum_plane, datum_axis, axis_orintation=None, profileNormal=OFF):
	## VER: 2014-07-09, v1.0, 在样条曲线的基础上扫掠出solid, 螺旋线
	## You may need to mirror the sketch or translate the sketch before that, especially for a polyline section.

	## Example:
##	blank_part('p1')
##	points = get_wire_points()
##	wires = create_spline_wire('p1', points=points)
##	wires = list2sequence(wires)
##
##	plane, axis = datum_plane_and_right_axis(p1)
##	s1 = create_base_sketch('s1')
##	create_circle('s1',center=points[0], radius=5, ndir='z')
##
##	sweep_solid_through_wire(wires, section=s1, datum_plane=plane, datum_axis=axis)

	wires = tolist(wire)
	part = get_poi(wires)

	section = check_sketch(section)

	if type_of(datum_plane) != 'DATUMPLANE':
		raise Exception('*** a datum plane is required.')

	if type_of(datum_axis) not in ['DATUMAXIS', 'edges']:
		raise Exception('*** a right edge or datum axis is required.')

	wires = list2sequence(wires)

	part.SolidSweep(path=wires, sketchPlane=datum_plane, sketchUpEdge=datum_axis,
	    sketchOrientation=RIGHT, profile=section, profileNormal=profileNormal)

	return

def switch_model(model_name=None,index=None):
	## VER: 2013-06-10, v1.3

	global model_seq, part_seq

	if index == 0:
		index = 1

	name = None
	if type_of(model_name) == 'STR' and model_name in mdb.models.keys():
		name = model_name
	elif type_of(index) == 'INT' and index in range(1, len(mdb.models) + 1):
		name = mdb.models.values()[index - 1].name
	else:
		if 'model_seq' not in globals().keys():
			model_seq = 1
		else:
			model_seq += 1
			if model_seq > len(mdb.models):
				model_seq = 1
		name = mdb.models.values()[model_seq - 1].name

	if name not in empty:
		a = mdb.models[name].rootAssembly
		vpnow = get_vpnow()
		vpnow.setValues(displayedObject=a)
##		update_cae_model()
		get_current_model()
		part_seq = 0

	return name

def switch_part(index=None,part_name=None):
	## VER: 2013-05-27, v1.1

	global part_seq

	if index == 0:
		index = 1

	refresh()

	name = None
	if type_of(part_name) == 'STR' and part_name in _m.parts.keys():
		name = part_name
	elif type_of(index) == 'INT' and index in range(1, len(mdb.models) + 1):
		name = _m.parts.values()[index - 1].name
	else:
		if 'part_seq' not in globals().keys():
			part_seq = 1
		else:
			part_seq += 1
			if part_seq > len(_m.parts):
				part_seq = 1
		name = _m.parts.values()[part_seq - 1].name

	if name not in empty:
		p = _m.parts[name]
		vpnow = get_vpnow()
		vpnow.setValues(displayedObject=p)

		mats = get_all_mats(p)
		if len(mats) > 1:
			mats = str(mats)[1:-1]
		elif len(mats) == 1:
			mats = str(mats)[2:-2]
		else:
			mats = 'unset material'
		text = mats + '@' + name + ', ' + p.modelName
		create_mdb_annotation(name='Title1',text=text)

	return 	name



def tangent_datum_axis_of_edge(edge,point):
	## VER: 2014-07-10, v1.0

	if type_of(edge) != 'edges':
		raise Exception('*** an edge is required.')

	if type_of(point) == 'vertices':
		point = point.pointOn[0]
	elif type_of(point) == 'referencePoints':
		point = RPxyz(point)

	if is_location(point) == False:
		raise Exception('*** a point location at the edge is required.')

	x0,y0,z0 = point
	vector = tangent_vector_of_edge(edge,point)
	x1,y1,z1 = vector
	x1 = x0 + x1
	y1 = y0 + y1
	z1 = z0 + z1

	poi = get_poi(edge)
	axis = create_datum_axis_by_2points(poi, start=(x0,y0,z0), end=(x1,y1,z1))

	return axis


def tangent_vector_of_edge(edge,point):
	## VER: 2016-06-20, v1.1
	## This vector will be the normal vector of datum plane.

	## e1 and e3 connected at vertice v1, e1 is a line, and e3 is an arc
	# >>> tangent_vector_of_edge(e3,v1)
	# (1.0, 0.0, 0.0)
	# >>> tangent_vector_of_edge(e1,v1)
	# (1.0, 0.0, 0.0)
	# >>>

##>>> tangent_vector_of_edge(e1,p1)
##(0.072827184316877, -0.727074880892728, 0.682684640811042)
##>>>

	if type_of(edge) != 'edges':
		raise Exception('*** an edge is required.')

	try:
		curvature = edge.getCurvature(point=edge.pointOn[0])
		shape = 'curve'
	except:
		shape = 'line'

	if shape == 'line':
		vector = edge_to_vector(edge)
	else:
		curvature = get_curvature(edge,pointOn=point)
		vector = curvature['tangent']

	return vector

def temp_part_from_inst(inst,name='',del_old_part=None,keep_old_inst=None):
	## VER: ('VER: 2016-12-21, v1.5')  本函数不将inst删除。
	## such as needed in selection for the objs in instances.
	## if del_old_part == True, the created part will replace the part of the provided inst.

	if del_old_part == None and keep_old_inst == None: ## assembly不改变
		del_old_part=False
		keep_old_inst=True
	elif del_old_part == True:
		keep_old_inst = False
	elif keep_old_inst == True:
		del_old_part = False

	get_current_model()

	inst = check_inst(inst)
	part = inst.part
	instname = inst.name
	partname = part.name

	if del_old_part == True and keep_old_inst == True:
		raise Exception('*** Confused request: keep_old_inst=True and del_old_part=True.')

	if del_old_part == True:
		newpart_name = partname
	else:
		if name in empty or type_of(name) != 'STR':
			newpart_name = partname + '_temp'
		else:
			newpart_name = name
	newpart_name = new_key(newpart_name,new_part=True)

	position = get_poi_position(inst)
	if position['eqv_action'] == 'stay':
		newpart_name = copy_part(part, newpart_name)
	elif position['eqv_action'] == 'translation':
		dx,dy,dz = position['translation']
		newpart_name = copy_part(part, newpart_name,dx=dx,dy=dy,dz=dz)
	else:
		inst_name1 = part.name + '_temp_A1'
		inst_name2 = part.name + '_temp_A2'
		inst_name1 = duplicate_inst(inst,inst_name1)
		inst_name2 = duplicate_inst(inst,inst_name2)

		## 注意：merge可能需要很长时间, 且对于复杂曲面，merge不一定成功。
		insts = (a.instances[inst_name1],a.instances[inst_name2])
		a.InstanceFromBooleanMerge(name=newpart_name, instances=insts,
		    keepIntersections=ON, originalInstances=DELETE, domain=GEOMETRY)

		del a.features[newpart_name + '-1']
		a.regenerate()	   ## assembly changed.

##	print fnln(),'--->**Created temp_part from inst',inst.name,', part name=',newpart_name,', 别忘了及时将其删除。'
##	print 'trace_back=',get_traceback()

	if del_old_part == True:
		del_parts(partname)  ## the provided part will also be deleted.
		rename(newpart_name,partname)

	if keep_old_inst == False:
		del_insts(instname)

	get_current_model()

	return newpart_name

inst2part = temp_part_from_inst  ;please_check

def fnln():
	## VER: ('VER: 2012-06-29, v1.1')	## 也适用于主程序，此时的结果诸如：['<module>',24056]
	## reference: fn()

	## 参考：line info的格式为['face_select',xxxx]
	## get_traceback()
	## fnln_fnln()[共4个元素], ln()[返回行号], caller_fnln()[两个元素],
	## fnln()[两个元素], caller_name()[返回函数名], caller_names(),
	## get_caller_code(), print_caller_code()

	here = get_traceback()[:-2][-2:]   ## 得到本行的所在的函数名和行号，如['face_select',xxxx]

	return here

function_labels['fix_hole_and_create_job'] = 'fix','hole','insert','sintering'
def fix_hole_and_create_job(hole_set='hole'):
	## VER: 2017-06-06, v1.2

	nodes = []
	if type_of(hole_set) == 'STR':
		print fnln(),'hole_set=',hole_set
		print fnln(),a.sets.keys()

	##	if hole_set not in a.sets.keys():
	##		raise Exception('*** Please create the node set in Assembly, not in part.')

		nodes = set2objs(a,setname=hole_set)

	elif type_of(hole_set) in ['LIST','SEQUENCE','TUPLE'] and type_of(hole_set[0]) == 'nodes':
		nodes = hole_set

	if len(nodes) == 0:
		raise Exception('*** Nodes from instance green part is required.')

	nodesy = nodes_sort_byy(nodes)
	nodesx = nodes_sort_byx(nodes)

	xnodes = [nodesx[0],nodesx[-1]]
	ynodes = [nodesy[0],nodesy[-1]]

	apply_disp_fix(name='BC_x',nodes=ynodes,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix(name='BC_y',nodes=xnodes,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

	find = False
	if len(_m.predefinedFields) == 1:
		f1 = _m.predefinedFields.values()[0]
		if f1.suppressed == True:
			f1.resume()
		find = True
	elif len(_m.predefinedFields) > 1:
		for key1 in _m.predefinedFields.keys():
			field1 = _m.predefinedFields[key1]
			if field1.suppressed == True and type_of(field1) == 'TEMPERATURE':
				field1.resume()
				find = True
				break

	if find == False:
		raise Exception('*** No TEMPERATURE predefined field defined yet.')

	create_job()

	return

function_labels['fix_nodes_of_insert'] = 'fix','hole','insert','sintering'
def fix_nodes_of_insert(p1,axis_side=MIN,angle=40,return_label=False):
	## VER: 2016-09-07, v1.1
	## hole_axis = 'z'
	## applicable for full model
	## reference: fix_hole_and_create_job()

##	nodes = fix_nodes_of_insert(p1,axis_side=MAX,return_label=False)
##	light(nodes)

	p1 = check_pia(p1)

	if axis_side == MIN:
		face_nodes = nodes_by_face(p1,z=MIN,nz=-1,angle=angle)
	else:
		face_nodes = nodes_by_face(p1,z=MAX,nz=1,angle=angle)

	edge_nodes = get_edge_nodes(face_nodes)

	nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MAX),groupY=(MID,MIN))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MAX),groupY=(MID,MAX))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byx(nodes2,absolute=True)
	node_x01 = nodes3[0]

	nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MIN),groupY=(MID,MAX))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,x=0,err=0.3,y=(MID,MIN),groupY=(MID,MIN))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byx(nodes2,absolute=True)
	node_x02 = nodes3[0]

	nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MAX),groupX=(MID,MIN))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MAX),groupX=(MID,MAX))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byy(nodes2,absolute=True)
	node_y01 = nodes3[0]

	nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MIN),groupX=(MID,MAX))
	nodes2 = get_common(nodes1,edge_nodes)
	if nodes2 in empty:
		nodes1 = node_select(p1,y=0,err=0.3,x=(MID,MIN),groupX=(MID,MIN))
		nodes2 = get_common(nodes1,edge_nodes)
	nodes3 = nodes_sort_byy(nodes2,absolute=True)
	node_y02 = nodes3[0]

	nodes = [node_x01,node_x02,node_y01,node_y02]   ## x=0: node_x01,node_x02;  y=0:node_y01,node_y02]
	light(nodes)

	if return_label == True:
		nodes = [node_x01.label, node_x02.label,node_y01.label,node_y02.label]

	return nodes

def fn():
	## VER: 2015-04-01, v1.0
	## reference: fnln()

	func_name = get_traceback()[-4]

	return func_name

def through_points_in_x(poi,x=None,y=0,z=0):
	## VER: 2016-08-11, v1.4
	## the wire will pass through the poi and create vertices.

	part = temp_part_of_poi(poi)
	part = _m.parts[part]

	x,y,z = real_xyz(poi,x,y,z,empty2space=True)

	if is_number(y) == False:
		y = 0
	if is_number(z) == False:
		z = 0

	if type_of(x) not in ['TUPLE','LIST']:
		raise Exception('*** x range is required.')

	x1,x2 = x
	if x2 < x1:
		x1,x2 = x2,x1

	x1 = x1 - 1
	x2 = x2 + 1

	p1 = create_datum_point(part,loc=(x1,y,z))
	p2 = create_datum_point(part,loc=(x2,y,z))
##	feature = part.WirePolyLine(points=((p1, p2), ), mergeWire=ON, meshable=ON)
	feature = part.WirePolyLine(points=((p1, p2), ), meshable=ON)   ## No keyword mergeWire now.

	vertices = vertice_select(part,x=x,y=y,z=z,onEdge=False)
	pointOns = []
	for pt in vertices:
		loc = pt.pointOn[0]
		if loc not in pointOns:
			pointOns.append(loc)

	if pointOns not in empty:
		pointOns = sort_tuple_type_elements(pointOns,index=0)

	del_parts(part)

	return pointOns

def through_points_in_y(poi,y=None,x=0,z=0):
	## VER: 2016-08-11, v1.4
	## the wire will pass through the poi and create vertices.

	part = temp_part_of_poi(poi)
	part = _m.parts[part]

	if is_number(x) == False:
		x = 0
	if is_number(z) == False:
		z = 0

	x,y,z = real_xyz(poi,x,y,z,empty2space=True)

	if type_of(y) not in ['TUPLE','LIST']:
		raise Exception('*** y range is required.')

	y1,y2 = y
	y1,y2 = _sort(y1,y2)
	y1 = y1 - 1
	y2 = y2 + 1

	p1 = create_datum_point(part,loc=(x,y1 - 0.1,z))
	p2 = create_datum_point(part,loc=(x,y2 + 0.1,z))
##	feature = part.WirePolyLine(points=((p1, p2), ), mergeWire=ON, meshable=ON)
	feature = part.WirePolyLine(points=((p1, p2), ), meshable=ON)   ## No keyword mergeWire now.

	vertices = vertice_select(part,x=x,y=y,z=z,onEdge=False)
	pointOns = []
	for pt in vertices:
		loc = pt.pointOn[0]
		if loc not in pointOns:
			pointOns.append(loc)

	if pointOns not in empty:
		pointOns = sort_tuple_type_elements(pointOns,index=1)

	del_parts(part)

	return pointOns

def through_points_in_z(poi,z=None,x=0,y=0):
	## VER: 2016-08-11, v1.4
	## the wire will pass through the poi and create vertices.

##	>>> through_points_in_z('powder0')
##	2 vertices selected.
##	[(0.0, 0.0, 19.623967), (0.0, 0.0, 26.043887)]
##	>>>

	part = temp_part_of_poi(poi)
	part = _m.parts[part]

	if is_number(x) == False:
		x = 0
	if is_number(y) == False:
		y = 0

	x,y,z = real_xyz(poi,x,y,z,empty2space=True)

	if type_of(z) not in ['TUPLE','LIST']:
		raise Exception('*** z range is required.')

	z1,z2 = z
	if z2 < z1:
		z1,z2 = z2,z1

	z1 = z1 - 1
	z2 = z2 + 1
	p1 = create_datum_point(part,loc=(x,y,z1))
	p2 = create_datum_point(part,loc=(x,y,z2))
##	feature = part.WirePolyLine(points=((p1, p2), ), mergeWire=ON, meshable=ON)
	feature = part.WirePolyLine(points=((p1, p2), ), meshable=ON)   ## No keyword mergeWire now.

	vertices = vertice_select(part,x=x,y=y,z=z,onEdge=False)
	pointOns = []
	for pt in vertices:
		loc = pt.pointOn[0]
		if loc not in pointOns:
			pointOns.append(loc)

	if pointOns not in empty:
		pointOns = sort_tuple_type_elements(pointOns,index=2)

	del_parts(part)

	return pointOns  ## Maybe empty if the wire do not through the part

function_labels['UTC'] = 'time zone','UTC','Beijing','GMT','China'
def UTC(time1):
	## VER: 2017-08-10, v1.0
	## 协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC。Universal Time Coordinated，协调世界时
	## UTC就是0时区的区时，即0度经线的地方时，比北京时间（东八区的区时，即东经120度的地方时）晚8小时
	## 东经120度 = 360/3 = 24/3 = 8

	if is_number(time1) == False:
		raise Exception('*** time1 should be a number.')

	Beijing_time = time1 + 8
	if Beijing_time > 24:
		Beijing_time = Beijing_time - 24
		print 'Beijing: This date +1'
	else:
		print 'Beijing: This date'

	if type_of(Beijing_time) == 'INT' or Beijing_time - int(Beijing_time) == 0:
		Beijing_time = str(Beijing_time) + ':00'
	elif Beijing_time - int(Beijing_time) == 0.5:
		Beijing_time = str(int(Beijing_time)) + ':30'

	return Beijing_time

UTC_to_Beijing = GMT = UTC

function_labels['Beijing'] = 'time zone','UTC','Beijing','GMT','China'
def Beijing(time1):
	## VER: 2017-08-10, v1.0
	## 协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC。Universal Time Coordinated，协调世界时
	## UTC就是0时区的区时，即0度经线的地方时，比北京时间（东八区的区时，即东经120度的地方时）晚8小时
	## 东经120度 = 360/3 = 24/3 = 8

	if is_number(time1) == False:
		raise Exception('*** time1 should be a number.')

	UTC_time = time1 - 8
	if UTC_time < 0:
		UTC_time = UTC_time + 24
		print 'UTC: This date -1,',
	else:
		print 'UTC: This date,',

	if type_of(UTC_time) == 'INT' or UTC_time - int(UTC_time) == 0:
		UTC_time = str(UTC_time) + ':00'
	elif UTC_time - int(UTC_time) == 0.5:
		UTC_time = str(int(UTC_time)) + ':30'
	print UTC_time

	return

China = Beijing
Beijing_to_UTC = Beijing

function_labels['IST'] = 'time zone','UTC','Beijing','GMT','China'
def IST(time1):
	## VER: 2017-08-10, v1.0
	## 协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC。Universal Time Coordinated，协调世界时
	## UTC就是0时区的区时，即0度经线的地方时，比北京时间（东八区的区时，即东经120度的地方时）晚8小时
	## 东经120度 = 360/3 = 24/3 = 8
	## IST - India Standard Time    UTC +5:30

	if is_number(time1) == False:
		raise Exception('*** time1 should be a number.')

	UTC_time = time1 - 5.5
	if UTC_time < 0:
		UTC_time = UTC_time + 24
		print 'UTC: This date -1,',
	else:
		print 'UTC: This date,',

	time3 = UTC_time
	if type_of(UTC_time) == 'INT' or UTC_time - int(UTC_time) == 0:
		UTC_time = str(UTC_time) + ':00'
	elif UTC_time - int(UTC_time) == 0.5:
		UTC_time = str(int(UTC_time)) + ':30'
	print UTC_time

	print UTC_to_Beijing(time3)

	return

function_labels['CEST'] = 'time zone','UTC','Beijing','GMT','China'
def CEST(time1):  ## CEST - Central European Summer Time
	## VER: 2017-08-10, v1.0
	## 协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC。Universal Time Coordinated，协调世界时
	## UTC就是0时区的区时，即0度经线的地方时，比北京时间（东八区的区时，即东经120度的地方时）晚8小时
	## 东经120度 = 360/3 = 24/3 = 8
	## IST - India Standard Time    UTC +5:30

	if is_number(time1) == False:
		raise Exception('*** time1 should be a number.')

	## UTC
	UTC_time = time1 - 2
	if UTC_time < 0:
		UTC_time = UTC_time + 24
		print 'UTC: This date -1,',
	else:
		print 'UTC: This date,',

	time3 = UTC_time
	if type_of(UTC_time) == 'INT' or UTC_time - int(UTC_time) == 0:
		UTC_time = str(UTC_time) + ':00'
	elif UTC_time - int(UTC_time) == 0.5:
		UTC_time = str(int(UTC_time)) + ':30'
	print UTC_time

	print UTC_to_Beijing(time3)

	return

function_labels['CET'] = 'time zone','UTC','Beijing','GMT','China'
def CET(time1):  ## CEST - Central European Time
	## VER: 2017-08-10, v1.0
	## 协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC。Universal Time Coordinated，协调世界时
	## UTC就是0时区的区时，即0度经线的地方时，比北京时间（东八区的区时，即东经120度的地方时）晚8小时
	## 东经120度 = 360/3 = 24/3 = 8
	## IST - India Standard Time    UTC +5:30

	if is_number(time1) == False:
		raise Exception('*** time1 should be a number.')

	## UTC
	UTC_time = time1 - 1
	if UTC_time < 0:
		UTC_time = UTC_time + 24
		print 'UTC: This date -1,',
	else:
		print 'UTC: This date,',

	time3 = UTC_time
	if type_of(UTC_time) == 'INT' or UTC_time - int(UTC_time) == 0:
		UTC_time = str(UTC_time) + ':00'
	elif UTC_time - int(UTC_time) == 0.5:
		UTC_time = str(int(UTC_time)) + ':30'
	print UTC_time

	print UTC_to_Beijing(time3)

	return

function_labels['EST'] = 'time zone','UTC','Beijing','GMT','China'
def EST(time1):  ## EST-美国东部标准时间  Eastern Standard Time(EST)。
	## VER: 2017-08-10, v1.0
	## 协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC。Universal Time Coordinated，协调世界时
	## UTC就是0时区的区时，即0度经线的地方时，比北京时间（东八区的区时，即东经120度的地方时）晚8小时
	## 东经120度 = 360/3 = 24/3 = 8
	## IST - India Standard Time    UTC +5:30

	if is_number(time1) == False:
		raise Exception('*** time1 should be a number.')

	## UTC
	UTC_time = time1 + 5
	if UTC_time < 0:
		UTC_time = UTC_time + 24
		print 'UTC: This date -1,',
	else:
		print 'UTC: This date,',

	time3 = UTC_time
	if type_of(UTC_time) == 'INT' or UTC_time - int(UTC_time) == 0:
		UTC_time = str(UTC_time) + ':00'
	elif UTC_time - int(UTC_time) == 0.5:
		UTC_time = str(int(UTC_time)) + ':30'
	print UTC_time

	print UTC_to_Beijing(time3)

	return

def timetuple2sec(timetuple=None):
	""" 将9元时间列表转化为秒 """
	## VER: 2011-05-03, v1.0

	if timetuple == None:
		timetuple = time.localtime()

	if type_of(timetuple) != 'TUPLE':
		raise Exception('******A time tuple is required, default=localtime()')

	return time.mktime(timetuple)

def temp_part_of_poi(poi,name=''):
	## VER: 2015-11-13, v1.4

	global image_parts, _m, a  ## instance的影子part

	poi = check_poi(poi)

	if name in empty:
		name = poi.name + '_temp'
	name = new_key(name,new_part=True)

	if type_of(poi) == 'PART':
		temp_part = copy_part(poi,name)
	else:
		temp_part = temp_part_from_inst(poi,name,keep_old_inst=True)

	return temp_part  ## part name

def three_points_of_face(face):
	## VER: 2015-07-06, v1.0
	## 通过收集点线面的pointOn，获得3个点，以便建立这三个点的datum plane，可能用于另外的part
	## Reference: create_datum_plane_by_3points()

	if type_of(face) != 'faces':
		raise Exception('*** A plane face is required.')

	shape1 = face_shape(face)
	if shape1 != 'plane':
		raise Exception('*** A plane face is required.')

	poi = get_poi(face)
	v_ids = face.getVertices()
	e_ids = face.getEdges()

	loc1 = poi.vertices[v_ids[0]].pointOn[0]
	loc2 = poi.edges[e_ids[0]].pointOn[0]
	loc3 = face.pointOn[0]

	return loc1,loc2,loc3

def threeD_to_sketch_points(locs,ndir):
	## VER: 2014-07-14, v1.4
	## 在viewports上(GUI上，
	## 看按钮方向可知，ndir='y'时，草图的Y方向就是视图的y方向，草图的X方向就是视图的Z方向
	## refresh: create_part_sketch(), 定义了datum_plane, right_edge, 及side

	if type_of(locs) in ['x', 'y', 'z', 'X', 'Y', 'Z']:
		locs, ndir = ndir, locs

	x=0; y=1; z=2
	ndir = ndir.lower()
##	print 'skech ndir =',ndir,
##	if 'x' in ndir:
##		print ', loc2 = (loc3[y], loc3[z])'
##	elif 'y' in ndir:
##		print ', loc2 = (loc3[x], -loc3[z])'		## ndir=y时，z3 = -z2
##	elif 'z' in ndir:
##		print ', loc2 = (loc3[x], loc3[y])'

	type0 = type_of(locs)
	if type0 in ['TUPLE','LIST'] and type_of(locs[0]) in ['INT', 'FLOAT']:
		if len(locs) == 3:
			locs = [locs]
		elif len(locs) == 2:
			locs = locs
			return locs

	elif type0 == 'vertices':
		locs = [locs.pointOn[0]]
	elif type0 == 'DATUMPOINT':
		locs = [locs.pointOn]
	elif type0 in ['LIST', 'TUPLE'] and type_of(locs[0]) in ['vertices', 'DATUMPOINT']:
		type1 = type_of(locs[0])
		locs1 = []
		if type1 == 'DATUMPOINT':
			for pt in locs:
				locs1.append(pt.pointOn)
		elif type1 == 'vertices':
			for pt in locs:
				locs1.append(pt.pointOn[0])
		locs = eval(repr(locs1))
	elif type0 == 'FEATURE':
		if locs.name == 'RP' and 'xValue' in locs.__members__:
			locs = [(locs.xValue, locs.yValue, locs.zValue)]

	if type_of(locs[0]) not in ['TUPLE', 'LIST']:
		raise Exception('locations or points are required.')

	if type_of(locs[0][0]) not in ['INT', 'FLOAT']:
		raise Exception('locations or points are required.')

	num = len(locs)
	locs1 = []
	for i in range(len(locs)):
		locs1.append(tolist(locs[i]))
	locs = eval(repr(locs1))

	print 'Before: locs=',locs,
	for loc in locs:
		p1 = copy.deepcopy(loc)
		if 'x' in ndir:
			loc[x] = p1[y]
			loc[y] = p1[z]

		elif 'y' in ndir:
			loc[x] = p1[x]
			loc[y] = -p1[z]	## ndir=y时，z3 = -z2

		elif 'z' in ndir:
			loc[x] = p1[x]
			loc[y] = p1[y]

	for i in range(num):
		locs[i].pop(2)
		locs[i] = tuple(locs[i])

	if len(locs) == 1:  ## 只有一个点，例如：[(-20.9, 0.0)]
		locs = locs[0]
	print 'After: locs=',locs

	return locs

def fn_time_zone(now=None,know='CHINA',querry='USA',differ=None):
	## 2010-11-10, v1.0，时差换算

	know = know.upper()
	querry = querry.upper()
	if know == 'USA' and querry == 'CHINA':
		differ = 16		## 冬令时
	elif querry == 'USA' and know == 'CHINA':
		differ = -16
	elif know == 'GERMANY' and querry == 'CHINA':
		differ = 7
	elif know == 'CHINA' and querry == 'GERMANY':
		differ = -7

	minute = ''
	if now == None:
		time1 = get_time()
		loc1 = time1.find(':')
		now = int(time1[:loc1])
		minute = time1[loc1:]

	time2 = now + differ
	if time2 > 24:
		time2 = time2 - 24
	elif time2 < 0:
		time2 = time2 + 24

	print 'Time now in',querry,'is',str(time2) + minute,"O'clock"

	return

def to_str8(*nums):
	## VER: 2015-06-25, v1.0

	results = []
	for num in nums:
		str1 = str(num).ljust(8)
		results.append(str1)

	return results

function_labels['tk_message'] = 'windows','info','GUI','Tkinter','tkMessageBox'
def tk_message(message='Hellow world',title='tk message'):
	## VER: 2016-09-29, v1.0
	## 在tk中，message box一定附属于某一个窗体(frame)，虽然显示上message box可能弹出在窗体范围之外。不能简单运行tk_message()

##	>>> tk_message()
##	>>>

	import Tkinter
	import tkMessageBox

	root = Tkinter.Tk()   ## create the frame window（主窗口)
	msg_obj = tkMessageBox.showinfo(title=title, message=message)

	button = Tkinter.Button(root, text="my button",command=msg_obj)   ## 把message box装入frame window中(关联对象)
	button.pack()

##	print type_of(button)  ## instance

	## roo.mainloop()的意图是等待用户手动关闭主窗口，且必须关闭主窗口。
	root.mainloop()  ## Abaqus中一直循环，不能进一步操作。
	## 如果没有本行语句，虽然abaqus不再一直循环，但是tk窗口（主窗口）关不掉了。

	return

def to_str10(*nums):
	## VER: 2015-06-25, v1.0

	results = []
	for num in nums:
		str1 = str(num).ljust(10)
		results.append(str1)

	return results

def to_str20(*nums):
	## VER: 2015-06-25, v1.0

	results = []
	for num in nums:
		str1 = str(num).ljust(20)
		results.append(str1)

	return results

def to_symbol(*pars):
	## VER: 2014-03-07, v1.0

	pars = tolist(pars)
	for i in range(len(pars)):
		par = pars[i]
		if par in empty:
			par = NONE
		elif type_of(par) == 'STR':
			par = eval(par.upper())
		pars[i] = par

	return pars


def tolist(var,open_element=True):
	## 注意，对于empty类型的参数，把它变成一个列表是没有意义的，所以会把该参数退回，不做改动。
	## VER: ('2015-12-02, v2.1')		## 注意：list1=[[5]], 则tolist(list1) = [5]
	## 注意：list(dict1)的结果是dict1.keys()
	## 该函数的意义在于，可以将一个可变参数*var1的值变成一个列表，也可以直接接受一个tuple，也可以接受一个列表，效果一样。例如：
	## 函数is_empties(*list1)，下面的调用结果是一样的：均有list1=[None, [], []]
	## 方法1: is_empties([None, [], []])
	## 方法2: is_empties(None,[],[])		例如：is_empties(x,y,z)
	## 如果函数原型为: is_empties(list1)，此时list1不再是可变参数，那么就没有那么大的灵活性了。

##	>>> list1 = [(1,2),(2,3)]
##	>>> tolist(list1)
##	[(1, 2), (2, 3)]
##	>>> tolist((list1,))  ## 例如: list1被赋予*var参数，结果为: var=(list1,)
##	[(1, 2), (2, 3)]
##	>>>

	## tuple1 = ((),)
	## tolist(tuple1) = []

	## tuple1 = ([],)
	## tolist(tuple1) = []

	## tuple1 = ({},)
	## tolist(tuple1) = [{}]

##	>>> list1=[]
##	>>> tolist(list1)
##	[]

	if 'ARRAY' in type_of(var):
##		print 'a num array: type=NUMPY.NDARRAY, such loc of an odb node'
		list11 = []
		for item in var:
			list11.append(item)
		var = list11

	find = False
	list1 = var

	if var == ():
		return []

	if var in empty:	## 例如: tolist(None) = None。也就是说，tolist()的结果不一定是一个list。
		find = True
		list1 = var    ## e.g., tolist({}) = {}

	else:
		if type_of(var) in ['TUPLE','LIST','SEQUENCE'] or 'ARRAY' in type_of(var):
			if len(var) == 1:
				num0 = len_num(var[0])
##				print fnln_fnln(),'num0=',num0
				if num0 > 0:
					if open_element == True:
						list1 = tolist(var[0],open_element=False)		;please_check
##						print fnln(),'list1=',list1
					else:
						find = True
						list1 = [var[0]]
##						print fnln(),'var[0]=',var[0]
##						print fnln(),'list1=',list1

				else:   ## num = 0
					type1 = type_of(var[0])
					if type1 in ['TUPLE','LIST','SEQUENCE'] or 'ARRAY' in type1:
##						find = True		;please_check
						list1 = var[0]    ## e.g, [[]] => [], [()]
##						print fnln(),'list1=',list1

		elif type_of(var) == 'DICT':
			find = True
			list1 = [var]

		elif type_of(var) == 'STR':   ## 可以把一个含','的字符窜分割成多个字符窜。其实可以用split()函数来实现的
			list1 = []
			if open_element == False:
				list1 = [var]
			else:
				if "," not in var:
					list1 = [var]
				else:
					string1 = var.strip()
	##				print fnln_fnln(),'string1=',string1
					while "," in string1:
						if string1[0] not in ['[','(']:
							loc = string1.find(',')
						elif string1[0] == '[':
							left = 1
							right = 0
							loc = 0
							while right < left:
								loc = loc + 1
								if string1[loc] == '[':
									left = left + 1
								elif string1[loc] == ']':
									right = right + 1
							loc = loc + 1

						elif string1[0] == '(':
							left = 1
							right = 0
							loc = 0
							while right < left:
								loc = loc + 1
								if string1[loc] == '(':
									left = left + 1
								elif string1[loc] == ')':
									right = right + 1
							loc = loc + 1

						substring = string1[:loc].strip()
						list1.append(substring)

						string1 = string1[loc+1:].strip()

					if string1 not in empty:
						list1.append(string1)

			find = True

	if find == False:
		try:
			list1 = list(list1)
		except:
			list1 = [list1]

	return list1


def zmax_faces(poi, x=None, y=None):

	## VER: ('VER: 2012-06-20, v1.1')

	poi = check_pias(poi)
	faces = faces_of_cut(poi, z=MAX, x=x, y=y)

	return faces

def ton_on_area(ton,length,width,lateral_coefficient=0.6):
	## VER: 2014-06-16, v1.0

	force = ton*9800
	area = length*width
	axial_pressure = force/area
	side_pressure = axial_pressure*lateral_coefficient

	area = round(area,2)
	axial_pressure = round(axial_pressure,2)
	side_pressure = round(side_pressure,2)

	print fnln(),'ton, area, axial_pressure, side_pressure=',ton, area, axial_pressure, side_pressure

	return ton, area, axial_pressure, side_pressure


def tospace(*space):
	## VER: 2013-05-20, v2.0

	num = len(space)
	if num == 0 or num > 3:
		raise Exception('**** Error space input.')

	x = y = z = None
	if num == 1:
		x = space[0]
	elif num == 2:
		x,y = space
	elif num == 3:
		x,y,z = space

	if x in empty: x = (_min,_max)
	if y in empty: y = (_min,_max)
	if z in empty: z = (_min,_max)

	x = tolist(x)
	y = tolist(y)
	z = tolist(z)

	## 精确到小数点5位可能是错的，应该到6位。
	if len(x) == 1:
		x = [round(x[0],6),round(x[0],6)]
	if len(y) == 1:
		y = [round(y[0],6),round(y[0],6)]
	if len(z) == 1:
		z = [round(z[0],6),round(z[0],6)]

	x1 = x[0];	x2 = x[1]
	y1 = y[0];	y2 = y[1]
	z1 = z[0];	z2 = z[1]

	if x1 > x2: x1,x2 = x2,x1
	if y1 > y2: y1,y2 = y2,y1
	if z1 > z2: z1,z2 = z2,z1

	if num == 1:
		result = (x1,x2)
	elif num == 2:
		result = (x1,x2,y1,y2)
	elif num == 3:
		result = x1,x2,y1,y2,z1,z2

	return result

def totext(obj):
	## VER: ('VER: 2013-04-24, v1.3'), similia to get_text

	text1 = ''
	if type_of(obj) == 'STR':
		text1 = get_text(obj)
	else:
		type1 = type_of(obj)
		if type1 in ['TUPLE','LIST'] and obj not in empty:
			try:
				text1 = text_of_sequence(obj)
			except:
				try:
					text1 = repr(obj)
				except:
					text1 = 'access error'
		else:
			try:
				text1 = repr(obj)
			except:
				text1 = 'access error'

	return text1

def totuple(var,open_element=False):
	## VER: ('2015-11-20, v2.0')

##	>>> list1 = [(1,2),(3,4),(5,6)]
##	>>> totuple(list1)
##	((1, 2), (3, 4), (5, 6))
##	>>> totable(list1)
##	((1, 2), (3, 4), (5, 6))
##	>>>

	if 'ARRAY' in type_of(var):
##		print 'a num array: type=NUMPY.NDARRAY, such loc of an odb node'
		list1 = []
		for item in var:
			list1.append(item)
		var = list1

	if type_of(var) in ['TUPLE','LIST'] and len(var) == 1:
		if type_of(var[0]) in ['TUPLE','LIST']:
			if open_element == False:
				return (var[0],)
			else:
				var = tolist(var[0],open_element=False)

	if var == []:
		return ()

	elif var in empty:
		return var

	elif type_of(var) == 'STR':
		return (var,)

	try:
		tuple1 = tuple(var)
	except:
		tuple1 = (var,)

	return tuple1

def translate_instances(insts=(),dx=0, dy=0, dz=0, x1=None, x2=None, y1=None, y2=None, z1=None, z2=None, vector=None, ref_inst=None):
	## VER: 2011-11-05, v1.2

	global _m, a

	insts = real_insts(insts)
	if insts in empty:
		insts = a.instances.values()

	inst_names = poi_names(insts)
	inst_names = tuple(inst_names)

	vector = totuple(vector)
	if vector in empty:
		if x1 != None and x2 != None:
			dx = x2 - x1

		if y1 != None and y2 != None:
			dy = y2 - y1

		if z1 != None and z2 != None:
			dz = z2 - z1

		if ref_inst not in empty:
			ref_inst = check_inst(ref_inst)
			dx1,dy1,dz1 = ref_inst.getTranslation()
			dx += dx1
			dy += dy1
			dz += dz1

		vector = (dx,dy,dz)

	a.translate(instanceList=inst_names, vector=vector)

	if len(inst_names) == 1:
		inst_names = inst_names[0]

	if 'temp' not in inst_names:
		print '--->',inst_names,'are translated, vector=',vector
		print ' '

	return

def treat_curve(p,edgelist,remain = ''):
	## VER: 2010-03-19

	x = 0;	y = 1;	z = 2
	newlist = []
	print 'Refine edge selection...'
	for edge in edgelist:
		shape = edge_shape(edge)
		if shape == remain:
			newlist.append(edge)

	print '--->',len(newlist),'edges remained, type=',remain

	return newlist

def treat_face(p,faces='',ndir='NA',exterior='NA',shape='NA',radius='NA', nx='NA',ny='NA',nz='NA'):
	## VER: 2011-04-01, v1.5

	if type_of(faces) == 'STR':
		faces = set2objs(faces,p)

	if radius != 'NA':
		ndir = 'circular'

	if exterior == True:
		faces2 = []
		for face in faces:
			if len(face.getCells()) == 1:
				faces2.append(face)
		faces = faces2

	elif exterior == False:
		faces2 = []
		for face in faces:
			if len(face.getCells()) > 1:
				faces2.append(face)
		faces = faces2

	if radius != 'NA':
		faces2 = []
		for face in faces:
			if get_radius(face) == radius:
				faces2.append(face)
		faces = faces2

	if nx != 'NA' or ny != 'NA' or nz != 'NA':
		faces2 = []
		for face in faces:
			nx0,ny0,nz0 = facing_dir(face)
			if nx != 'NA' and nx != nx0:
				continue
			if ny != 'NA' and ny != ny0:
				continue
			if nz != 'NA' and nz != nz0:
				continue
			faces2.append(face)

		faces = faces2

	print len(faces),'faces selected. exterior=',exterior, ', ndir=',ndir, ', radius=',radius, ', (nx,ny,nz)=',(nx,ny,nz)

	return faces

def treat_line(p,edgelist,dir1 = 'x'):
	## VER: 2010-01-01

	x = 0;	y = 1;	z = 2
	newlist = []
	print 'Refine selection...'
	for edge in edgelist:
		x01,x02,y01,y02,z01,z02 = space_of_edges(edge)
		edge_range = (x01,x02),(y01,y02),(z01,z02)
		if abs(edge_range[eval(dir1)][1] - edge_range[eval(dir1)][0]) > 1e-6:
			newlist.append(edge)

	print '--->',len(newlist),'edges remained'

	return newlist

def trend(*list1):
	## VER: 2011-05-21, v2.5

	list1 = tolist(list1)

	if list1 in empty or len(list1) != 2:
		raise Exception('******a list of two values are required.')

	value1,value2 = list1

	if abs(value1 - value2) < 1e-6:
		result = 0
	elif value2 - value1 > 1e-6:
		result = 1		## 升序
	elif value1 - value2 > 1e-6:
		result = -1		## 降序

	return result

def triad_csys(xratio=10,yratio=30):
	## VER: 2016-09-14, v1.0
	## reference origin at left bottom corner

	vp = get_vpnow()
	vp.viewportAnnotationOptions.setValues(triadPosition=(xratio, yratio))

	print fnln(),'triad annotation locatio =',(xratio,yratio)

	return

def trim_geometry(sketch,loc=(),x=None,y=None,groupX=None,groupY=None):
	## VER: 2014-09-10, v1.1
	## 注意:trim_geometry()可能把整条curve都给删除了，如果没有一条曲线与之相交且把其分成两部分的话。
	## reference: divide_geometry()
	## trim = partial delete

	## Example: trim_geometry('s_powder',(MAX,0))

## 圆与直线相切，然后autotrim的例子。
##	connect_points(s1,(ejector_OD/2 + 0.5, 0), (ejector_OD/2.0, 0), (ejector_OD/2.0 - ejector_land), xtilt(-ejector_OD/2.0,  ejector_tangent_angle - 90))
##	id1 = s1.geometry.values()[-1].id
##	s1.FixedConstraint(entity=s1.geometry[id1])
##
##	create_arc(s1,center=(0,2*ejector_R),radius=ejector_R,quarter=4)
##	id2 = s1.geometry.values()[-1].id
##	arc_constraint(s1.geometry[id2],fix_x=True)
##
##	tangent_constraint(s1,id1,id2)
##
##	trim_geometry(s1,y=MAX1)
##	trim_geometry(s1,y=MIN1)
##	trim_geometry(s1,x=corepin_OD/2.0,groupY=MIN1)


	sketch = check_sketch(sketch)
	sketch_name = sketch.name

	if loc not in empty:
		loc = real_xy_sketch(sketch,loc=loc)

	if is_numbers(loc) == False:
		loc = find_loc(sketch,x=x,y=y,groupX=groupX,groupY=groupY)

	if is_numbers(loc) == False:
		raise Exception('*** Fail to get the loc.')

##	print fnln(),'loc=',loc

	curves = geometry_at(sketch,loc=loc,ID=False)
	if curves in empty:
		curve1 = sketch.geometry.findAt(coordinates=loc,printWarning=False)
		if curve1 not in empty:
			curve1 = sketch.geometry[curve1.id]
			curves = [curve1]

	for curve in curves:
		curve1 = sketch.geometry[curve.id]
		sketch.autoTrimCurve(curve1=curve1, point1=loc)

	return

def trim_sketch(sketch,top_cut=None, bot_cut=None, left_cut=None, right_cut=None, top_loc=None, bot_loc=None, left_loc=None, right_loc=None):
	## VER: 2014-10-29, v1.2

	s1 = check_sketch(sketch)
	x1,x2,y1,y2 = space_of_sketch(s1)

	if type_of(top_cut) in numerics:
		top_loc = y2 - top_cut
	elif type_of(bot_cut) in numerics:
		bot_loc = y1 + bot_cut
	elif type_of(left_cut) in numerics:
		left_loc = x1 + left_cut
	elif type_of(right_cut) in numerics:
		right_loc = x2 - right_cut

##	print 'right_loc=',right_loc

	geometry = []
	new_vertices = []
	if type_of(top_loc) in numerics:
		new_vertices,new_curves = divide_geometry(s1,y=top_loc)
		geometry = geometry_select(s1,y=(top_loc + 0.1,y2))
		cut_side = 'top'

	elif type_of(bot_loc) in numerics:
		new_vertices,new_curves = divide_geometry(s1,y=bot_loc)
		geometry = geometry_select(s1,y=(y1,bot_loc - 0.1))
		cut_side = 'bot'

	elif type_of(left_loc) in numerics:
		new_vertices,new_curves = divide_geometry(s1,x=left_loc)
		geometry = geometry_select(s1,x=(x1,left_loc - 0.1))
		cut_side = 'left'

	elif type_of(right_loc) in numerics:
		new_vertices,new_curves = divide_geometry(s1,x=right_loc)
		print fnln(),'new_vertices=',new_vertices

		geometry = geometry_select(s1,x=(right_loc + 0.1,x2))
		cut_side = 'right'

	if geometry not in empty:
		del_sketch_objs(s1,geometry)
		print fnln(),'---> sketch',s1.name,'is trimmed from',cut_side,'side'

##	print fnln(),new_vertices
##	raise Exception

	return new_vertices


def ttl(text1='',xloc=10,yloc=140,fontsize = 18):
	## 2013-08-20, v2.2

	if text1 not in empty:
		create_mdb_annotation(name = 'Title1', text=text1, xloc=xloc, yloc=yloc, fontsize = fontsize)

	else:
		print 'Empty text input, title in current viewport will not change'

	return

function_labels['totable'] = 'totuples','list'
def totable(table):
	## VER: 2017-03-13, v1.7

##	>>> list1
##	[1, 3, 3]
##	>>> totable(list1)
##	((1, 3, 3),)
##	>>>

##	>>> list1 = [('pressing axis','z'),'finish step without ejection']
##	>>> totable(list1)
##	(('pressing axis', 'z'), ('finish step without ejection',))
##	>>>

##	>>> totable(5)
##	((5,),)
##	>>>

##	>>> list1 = ['par1',5]
##	>>> totuple(list1)
##	('par1', 5)
##	>>> totable(list1)
##	(('par1', 5),)
##	>>>

##	>>> list1 = [(1,2),(3,4),(5,6)]
##	>>> totuple(list1)
##	((1, 2), (3, 4), (5, 6))
##	>>> totable(list1)
##	((1, 2), (3, 4), (5, 6))
##	>>>

##	>>> num = [5]
##	>>> totable(num)
##	((5,),)
##	>>> num = (5,)
##	>>> totable(num)
##	((5,),)
##	>>>
##	>>> num = 5
##	>>> totable(5)
##	((5,),)
##	>>>

	## Example:
	## list1 = (3,5)
	## totable(list1) = ((3,5),)

	## list1 = [3,5]
	## totable(list1) = ((3,5),)
##
##	>>> list1 = (3,5), (6,8)
##	>>> totable(list1)
##	((3, 5), (6, 8))
##	>>> list1 = [3,5], [6,8]
##	>>> totable(list1)
##	((3, 5), (6, 8))
##	>>>

##	>>> dict1 = {'par1':5}
##	>>> dict1.items()
##	[('par1', 5)]
##	>>>

##	>>> dict1 = {'par1':5}
##	>>> totable(dict1)
##	(('par1', 5),)
##	>>>

##	print fnln(),'table=',table

	if is_number(table):
		table = (table,)
	elif is_string(table):
		table = (table,)
	elif type_of(table) == 'DICT':
		table = table.items()
	else:
		if type_of(table) in ['TUPLE','LIST']:

			simple = True
			for item in table:
				if type_of(item) in ['TUPLE','LIST']:
					simple = False

			if simple == True:
				table = tuple(table)
				return (table,)

	if type_of(table) not in ['TUPLE','LIST']:
		raise Exception('*** tuples are required.')

	newlist = []
	for item in table:
		if type_of(item) == 'LIST':
			newlist.append(tuple(item))
		elif type_of(item) == 'TUPLE':
			newlist.append(item)
		else:
			newlist.append(totuple(item))

	table = tuple(newlist)

##	print fnln(),'table=',table
	if type_of(table[0]) != 'TUPLE':
		table = (table,)
##	print fnln(),'table=',table

##	lens = []
##	for tuple1 in table:
##		num = len(tuple1)
##		if num not in lens:
##			lens.append(num)
##
##	if len(lens) > 1:
##		raise Exception('*** table is not regular, data quantiy should be the same for each row.')

	return table

totuples = totable

def two_points_of_datum_axis(datum_axis):
	## VER: 2014-01-11, v1.1

	if type_of(datum_axis) != 'DATUMAXIS':
		raise Exception('*** datum axis is required.')

	x1,y1,z1 = datum_axis.pointOn    ## vector start
	x2,y2,z2 = datum_axis.direction  ## vector end

	return (x1,y1,z1), (x1+x2*10, y1+y2*10, z1+z2*10)

def two_points_of_edge(edge):
	## VER: 2014-01-13, v1.0，返回两个坐标位置
	## reference: end_locs_of_edge()

	if type_of(edge) == 'DATUMAXIS':
		loc1, loc2 = two_points_of_datum_axis(edge)

	elif type_of(edge) == 'edges':
		poi = get_poi(edge)
		ids = edge.getVertices()
		loc1 = poi.vertices[ids[0]].pointOn[0]
##		loc2 = poi.vertices[ids[1]].pointOn[0]
		loc2 = edge.pointOn[0]

	else:
		raise Exception('*** an edge or datum axis is required.')

	return loc1,loc2

function_labels['two_vectors_of_4points'] = 'node','angle','vector','point'
def two_vectors_of_4points(*points):
	## VER: 2016-11-21, v1.0
	## 用于判明组成两条边的四个点的起始点，以便求角度。

	points = tolist(points)
	if len(points) == 1 and type_of(points[0]) in ['LIST','TUPLE']:
		points = points[0]

	if len(points) < 4:
		raise Exception('*** 4 points/nodes are required.')

	loc1 = point_loc(points[0])
	loc2 = point_loc(points[1])
	loc3 = point_loc(points[2])
	loc4 = point_loc(points[3])

	dist1 = point_to_line_distance(loc1,loc3,loc4)
	dist2 = point_to_line_distance(loc2,loc3,loc4)

	if dist2 < dist1:
		loc1,loc2 = loc2,loc1

	dist3 = point_to_line_distance(loc3,loc1,loc2)
	dist4 = point_to_line_distance(loc4,loc1,loc2)

	if dist4 < dist3:
		loc3,loc4 = loc4,loc3

	vector1 = vector_of_two_points(loc1,loc2)   	## line1: start=points[0],end=points[1]
	vector2 = vector_of_two_points(loc3,loc4)	 	## line2: start=points[2],end=points[3]

	return vector1,vector2


def type_and_shape_of_sketch_geometry(curve):
	## VER: 2013-06-18, v1.1
	## similar result: type_of(curve) = 'regular_arc'
	## for a construction line, will have only pointOn, but no vertices.
	## result: ('construction', 'line') for a construction line

## For a construction line curve1:
##>>> prettyPrint(curve1)
##({'curveType': LINE,
##  'id': 2,
##  'pointOn': 'tuple object',
##  'type': CONSTRUCTION})
##>>>

##>>> type_and_shape_of_sketch_geometry(s1.geometry.values()[0])
##('regular', 'arc')

##	sketch = check_sketch(sketch)
##	if obj not in sketch.geometry.values():
##		raise Exception('**** Invalid sketch geometry object.')

##	text = totext(curve)
	type1 = totext(curve.type).lower()
	shape1 = totext(curve.curveType).lower()

	return type1,shape1

function_labels['settings_of_BC'] = 'dof','BC'
def settings_of_BC(BC):
	## VER: 2016-12-23, v1.2

##	>>> settings_of_BC('fix_RP_bpunch_A1')
##	---in step 1, name= move , action= CREATED
##	** settings = {'ur3': 0.0, 'u1': 0.0, 'u2': 0.0}
##	{'move': {'ur3': 0.0, 'u1': 0.0, 'u2': 0.0}}
##	>>> settings_of_BC('fix_RP_tpunch_A2')
##	---in step 1, name= move , action= CREATED
##	** settings = {'amplitude': 'top_move', 'u2': 1.0}
##	{'move': {'amplitude': 'top_move', 'u2': 1.0}}
##	>>>

	if BC in _m.boundaryConditions.keys():
		BC = _m.boundaryConditions[BC]

	if BC not in _m.boundaryConditions.values():
		raise Exception('*** BC is required.')

	dict1 = {}
	for step in _m.steps.values():
		if BC.name in step.boundaryConditionStates.keys():
			BC_obj = step.boundaryConditionStates[BC.name]
			if 'status' in BC_obj.__members__:
				if BC_obj.status not in [NOT_YET_ACTIVE,PROPAGATED]:
					if 'typeNameState' in BC_obj.__members__ and BC_obj.typeNameState == UNCHANGED:
						continue

					step_num = get_sequence_index(_m.steps.keys(),step.name)
##					print '---in step '+ str(step_num) + ', step name=',step.name,', action=',BC_obj.status, ', BC name=',BC.name
					if BC_obj.status != DEACTIVATED:
						settings = {}
						for prop in BC_obj.__members__:
							if prop.endswith('State') and BC_obj.__getattribute__(prop) != UNSET:
								loc = prop.find('State')
								dof = prop[:loc]
								settings[dof] = BC_obj.__getattribute__(dof)
##						print '** settings =',settings  ## 只记录created和modify step，propogate不记录
##						print ' '
						index = get_sequence_index(_m.steps,step)   ## index=0代表Initial step
						dict1[index] = settings

	insts = instances_of_BC(BC)
	names = map(lambda x:x.name, insts)
	dict1['insts'] = names

	return	dict1

def shape_of_geometry(geometry):
	## VER: 2014-03-11, v1.0

	shape1 = totext(geometry.curveType).lower()
	return shape1

def type_of_geometry(geometry):
	## VER: 2014-03-11, v1.0

	type1 = totext(geometry.type).lower()
	return type1

def original_type(obj):
	## VER: 2013-08-19, v1.0

	type1 = repr(type(obj))
	loc1 = type1.find("'")
	loc2 = type1.find('"')
	if loc2 > 0:
		if loc1 == -1:
			loc1 = loc2
		elif loc2 < loc1:
			loc2 = loc1

	type1 = type1[loc1 + 1:-2]

	return type1

def type_of(obj):
##	VER: 2017-10-11, 4.1

	## 对于sketch geometry, type_of(obj)的结果如：regular_line, regular_arc

	if type(obj) == type('') and len(obj) == 0:
		return ''		##???****

	text1 = repr(obj)
	if 'Word' in text1 and 'Selection instance' in text1:
		return 'SELECT'
	elif 'Word' in text1 and 'Range instance' in text1:
		return 'RANGE'
	elif '<COMObject Range>' in text1:
		return 'RANGE'

	type1 = repr(type(obj))
##	print 'type1=',type1

	loc1 = type1.find("'")
	loc2 = type1.find('"')
	if loc2 > 0:
		if loc1 == -1:
			loc1 = loc2
		elif loc2 < loc1:
			loc2 = loc1

##	type1 = repr(type(obj))[7:-2]

	type1 = type1[loc1 + 1:-2]
##	print 'type1=',type1

	if 'Step' in type1:
		return type1
	else:
		type1 = type1.upper()

##	print 'type1=',type1
	if type1 == 'FACE':
		type1 = 'faces'
	elif type1 == 'EDGE':
		type1 = 'edges'
	elif type1 == 'CELL':
		type1 = 'cells'
	elif type1 == 'VERTEX':
		type1 = 'vertices'
	elif type1 == 'REFERENCEPOINT':
		type1 = 'referencePoints'
	elif type1 == 'NONETYPE':
		type1 = 'None'
	elif type1 == 'PARTINSTANCE':   ##对于ODBINSTANCE，不作改变
		type1 = 'PINSTANCE'
	elif type1 == 'MESHNODE':
		type1 = 'nodes'
	elif type1 == 'MESHEDGE':
		type1 = 'elemEdges'  ## mdb.models['Model-1'].parts['powder'].elemEdges[16640]
	elif type1 == 'MESHFACE':
		type1 = 'elemFaces'
	elif type1 == 'MESHELEMENT':
		type1 = 'elements'
	elif type1 == 'ODBMESHELEMENT':
		type1 = 'elements'
	elif type1 == 'DISPLAYGROUPKNOT':
		type1 = 'dgKnot'    ## Knot: 打结
	elif type1 == 'CONSTRAINEDSKETCHGEOMETRY':   ## a geometry in sketch is a line or curve
		type1 = repr(obj.type) + '_' + repr(obj.curveType)   ## 注意: repr不可省。 Example: construction_line
		type1 = type1.lower()
	elif type1 == 'CONSTRAINEDSKETCHVERTEX':
		type1 = 'vertices'
	elif type1 == 'CONSTRAINEDSKETCH':
		if obj in _m.sketches.values():
			type1 = 'sketch'
		else:
			type1 = ''
##	print 'type1=',type1

	return type1

def unlight():
	## VER: ('VER: 2013-08-02, v2.3')

	if 'dg' in globals().keys():
		if type_of(dg) == 'DISPLAYGROUP':
			try:
				name1 = dg.name
				try:
					unhighlight(dg)
				except:
					del session.displayGroups[name1]
					del globals()['dg']
					print line_info(),'dg is deleted'
			except:
				if 'dg' in globals().keys():
					del globals()['dg']
					print line_info(),'dg is deleted.'

	for item in session.displayGroups.values():
##		print 'item.name=',item.name
		if item.name != 'All':
			unhighlight(item)

##	raise Exception

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject
	type1 = type_of(dpo)

	if type1 == 'ASSEMBLY':
		for inst in a.instances.values():
			unhighlight(inst)      ## highlight(inst)只能用unhighlight(inst)来灭掉。

	elif type1 == 'PART':
		unhighlight(dpo)

	return

def unlock():
	## 2011-01-07, v1.2

	vpnow = get_vpnow()
	display = vpnow.odbDisplay
	esets = display.displayGroup.root.leaf.elementSets
	leaf = dgo.LeafFromElementSets(elementSets=esets)
	print 'esets=',esets

##	leaf = session.viewports['Viewport: 1'].odbDisplay.displayGroup.root.leaf
	display.contourOptions.setValues(maxAutoCompute=OFF,minAutoCompute=OFF)
##	display.displayGroup.replace(leaf=leaf)
##	replot()

	return

def unmesh_region(part,objs=None, region=None,faces=None,cells=None,edges=None):
	## VER: 2013-10-10, v1.0

	part = check_part(part)

	objs = get_real_input(objs,faces,cells,edges)
	if objs not in empty:
		region = list2sequence(objs)

	else:
		if is_empty(region):
			pshape = part_shape(part)[1]
			if '3D' in pshape:
				region = part.cells
			elif '2D' in pshape:
				region = part.faces
			elif '1D' in pshape:
				region = part.edges

	if type_of(region) != 'SEQUENCE':
		raise Exception('*** faces, cells, or edges are required for unmesh.')

	part.deleteMesh(regions=region)
	part.regenerate()

	return

def unselect(base,list2):
	## VER: 2016-12-01, v3.3
	## 注意：对于locations unselect, 一定要用loc_unselect() !!!!

##	>>> list1 = [1,1,2,3]
##	>>> remove_item(list1,1)
##	[2, 3]
##	>>>
##	>>> list1 = [1,1,2,3]
##	>>> unselect(list1,1)
##	[2, 3]
##	>>>

	if list2 in empty:
		list2 = []

##	print type_of(list2)
	if type_of(list2) not in ['TUPLE','LIST']:
		list2 = tolist(list2)

##	print fnln(),'list2=',list2
	if list2 not in empty and is_poi(base):
		base = check_poi(base)
		obj_type = type_of(list2[0])
		if obj_type == 'cells':
			base = base.cells
		elif obj_type == 'faces':
			base = base.faces
		elif obj_type == 'edges':
			base = base.edges
		elif obj_type == 'vertices':
			base = base.vertices
		else:
			raise Exception('*** error base, should be a list.')

	if base in empty:
		return []

	if type_of(base) not in ['TUPLE','LIST']:
		base = tolist(base)

	if len(base) < 1.1*len(list2):
		base1 = []
		for item in base:   ## 有时base很长，而list2很短
			if item not in list2 and item not in base1:
				base1.append(item)
		base = base1
	else:
		for item in list2:
			base = remove_item(base,item)

	return base

def update_csys(part,match_RP=True):
	## VER: 2012-12-11, v1.5

	part = check_part(part)

	for setname in part.sets.keys():
		type1 = type_of_set(setname,part)
		if type1 == 'vertices':
			if set_length(part,setname,settype='vertices') == 1 and setname[-4:-1] != 'dir':
				loc = KPxyz(part,setname)
##				if setname not in part.features.keys():
##				if setname == 'O1' and setname not in part.features.keys():
##					create_csys(part,loc=loc,name=setname,match_RP=match_RP)   ## default to match_RP

		elif type1 == 'NA':
			print 'deleted empty setname=',setname
			del part.sets[setname]
			try:
				del part.features[setname]
			except:
				pass

	return

def update_axis2(chart=None,text2=''):
	## VER: 2014-12-18, v1.2

	if chart in empty:
		vpnow = get_vpnow()
		dpo = vpnow.displayedObject
		if type_of(dpo) != 'XYPLOT':
			raise Exception('*** An xyplot is required.')
		elif len(dpo.charts.values()) > 1:
			raise Exception('*** More than one chart in the current viewport.')
		chart = dpo.charts.values()[0]

	chart = check_obj(chart,session.charts)

	for i in range(len(chart.axes2)):
		data_type = chart.axes2[i].axisData.title
		print fnln(),'data_type=',data_type
		print fnln(),'text2=',text2
		if data_type[-1] != ')' or (text2 != '' and text2 not in data_type):  ## no unit
			if text2 not in empty:
				title = data_type + ' - ' + text2
			else:
				title = data_type

			data_type = data_type.lower()
			if data_type == 'stress':
				title = title + ' (MPa)'
			elif data_type in ['displacement','position']:
				title = title + ' (mm)'
			elif data_type == 'strain':
				title = title + ' (x100%)'    ## note: not x100%
			elif data_type == 'temperature':
				title = title + ' (degC)'
			elif data_type == 'force':
				title = title + ' (N)'
			elif data_type == 'pressure':   ## for CPRESS: on the contact area at slave region, such as with a plate.
				title = title + ' (MPa)'
			chart.axes2[i].axisData.setValues(useSystemTitle=False, title=title)

		chart.axes2[i].labelStyle.setValues(font='-*-verdana-medium-r-normal-*-*-120-*-*-p-*-*-*')
		axis_data = chart.axes2[i].axisData

		chart.axes2[i].axisData.setValues(maxAutoCompute=True)
		chart.axes2[i].axisData.setValues(minAutoCompute=True)

##		print fnln(),'tickIncrement =',axis_data.tickIncrement
##		print fnln(),'maxAutoValue =',axis_data.maxAutoValue
		chart.axes2[i].axisData.setValues(maxAutoCompute=False, maxValue=axis_data.maxAutoValue + axis_data.tickIncrement,
			minAutoCompute=False, minValue=axis_data.minAutoValue - axis_data.tickIncrement, tickMode=TOTAL_NUMBER, tickCount=10)
		chart.fitCurves(fitAxes1=False, fitAxes2=False)

	return

def update_cae_model(model_name=None,force_show=False,del_empty=True):
	## VER: 2014-04-08, v1.2. 脚本程序中用。
	## will make current mdb model the current viewport
	## make the mdb viewport as the current viewport;

	## Reference: get_current_model()

	global current_model_name, _m, a, cae_file_title

	mdb_viewports = get_mdb_viewports()
##	print fnln(),'len(mdb_viewports)=',len(mdb_viewports)

	print fnln_fnln(),'Updating cae model...'
	if mdb_viewports not in empty:  ## has mdb viewports
		list1 = sort_by_key(mdb_viewports)

		if model_name !=None:
			if model_name not in mdb.models.keys():
				raise Exception('******Error model_name: ' + repr(model_name))

			current_model_name = model_name
			_m = mdb.models[model_name]
			a = _m.rootAssembly   ## force to show model_name

			if model_name in mdb_viewports.values():
				for vp, model in list1:
					if model_name == model:
						session.viewports[vp].makeCurrent()   ## 变为active viewport
						current_viewport = vp
						break
			else:  ## the model is not displayed in one of the viewports.
##				if session.currentViewportName not in mdb_viewports.keys():  ## current viewport is not a mdb type viewport
##					current_viewport = list1[0][0]
##					session.viewports[current_viewport].makeCurrent()  ## switch to a mdb viewport
##				else:
##					current_viewport = session.currentViewportName

				vpnow = get_vpnow()
				vpnow.setValues(displayedObject=a)

		else: ## model_name not provided
			get_current_model()

		update_mdb_viewport(current_viewport, make_current=True)

	else:  ## no mdb viewports, 只是后台更新，viewport不变。
		get_current_model()
		current_model_name = globals()['current_model_name']

##		if len(mdb.models.keys()) > 1 and del_empty == True:
##			for name1 in mdb.models.keys():
##				if name1 == 'Model-1':
##					m0 = mdb.models[name1]
##					if len(m0.parts) == 0 and len(m0.sketches) == 0:  ## empty
##						del mdb.models['Model-1']
##						break
##
##		if len(mdb.models.keys()) == 1:  ## Current cae file has only one model
##			current_model_name = mdb.models.keys()[0]
##
##		else:
##			if 'current_model_name' not in globals().keys():
##				raise Exception('**** current_model_name is not specified. Please switch to assembly module')
##
##		_m = mdb.models[current_model_name]
##		a = _m.rootAssembly
##		try:
##			a.unlock()
##			a.regenerate()
##		except:
##			pass
##
##		if force_show == True:
##			vpnow = get_vpnow()
##			vpnow.setValues(displayedObject=a)
##
##			if type_of(vpnow.displayedObject) in ['ASSEMBLY','PART']:
##				create_csys(a,loc=(0,0,0))
##
##		create_poi_vars()
##		if part_vars not in empty:
##			print 'Parts:'
##			myprint(part_vars)
##			print 'Instances:'
##			myprint(inst_vars)

		cae_file_title = get_cae_file_title()

##	read_vars_from_model_description()

	return current_model_name


def update_current_viewport(vname='', input_text='', value_loc='',scale=1,unit='',float=2):
	## VER: 2013-06-09, v1.0

	viewport_type, vpnow = check_viewport(session.currentViewportName)
	result = None
##	print fnln(),'input_text=',input_text
##	raise Exception
##	print fnln(),viewport_type
##	raise Exception

	if viewport_type == 'MDB':
		update_mdb_viewport(vpnow,make_current=True)
		result = 'MDB'
	elif viewport_type == 'ODB':
		result = update_odb_viewport(vpnow, vname=vname, input_text=input_text, value_loc=value_loc, scale=scale, unit=unit, float=float)

	return result

##def update_inst(inst):
##	## VER: 2010-12-27, v1.1
##
##	global _m, a
##
##	inst = check_inst(inst)
##
##	type1 = type_of(inst)
##	if type1 == 'PINSTANCE':
##		globals()[text2varname(inst.name,poi_type='instance')] = a.instances[inst.name]
##	elif type1 == 'STR':
##		globals()[text2varname(inst,poi_type='instance')] = a.instances[inst]
##
##	return

def update_insts_space(renew=False):

	## VER: ('VER: 2012-03-30, v2.1')

	global insts_space, default_plot, cae_file_title, odb_insts_space

	vpnow = get_vpnow()
	if renew == True:
		obj = vpnow.displayedObject

##		cae_file_title = get_cae_file_title()
		refresh()

		insts_space = {}
		insts_space['cae_file_title'] = cae_file_title
		for inst in a.instances.values():
			insts_space[inst.name] = poi_space(inst)

##		plot(obj)

		print fnln_fnln(),'--->Updated spaces for all mdb instances.'
		myprint(insts_space)

	return

def update_odb_viewport(viewport=None,vname='', value_loc='', input_text='', component='', scale=1,unit='',float=2,print_result=True,
	th=14.44,C1=2.505,ask=None):
	## VER: 2016-05-16, v3.5. 默认不清除已存在的annotations，因为别的viewport可能存在annotations，且属于同一个odb

	global odb, oa, all_odb_nodes, all_odb_elements, odb_file_path, odb_file_title, odb_file_full_name
	global current_step

	## odb_file_path 该变量允许odb可以不用存放在当前工作目录，例如:
##	o1 = session.openOdb(name='E:/FEM/A0242_sintering_simple/odb/DM_A0242_H0235_comp_test2_E400_shift.odb')

##	print fnln_fnln(),'vname=',vname
	fontsize = get_fontsize()
##	print fnln(),'fontsize=',fontsize

	if viewport in empty:
		viewport = get_vpnow()
	else:
		viewport_type, viewport = check_viewport(viewport)

##	print fnln(),'viewport name=',viewport.name
	delete_viewport_annotations(viewport)  ## delete the annotations for this viewport only

	dpo = viewport.displayedObject
	viewport_type = type_of(dpo)

##	raise Exception

##	print fnln(),'viewport_type=',viewport_type
	if viewport_type != 'ODB':
		raise Exception('*** an odb viewport is required.')

##	viewport.odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)
##	print fnln(),'fontsize=',fontsize

	set_annotation()

##	print fnln(),'fontsize=',fontsize

	show_result = False
	if viewport.odbDisplay.display.plotState[0] in [CONTOURS_ON_DEF, SYMBOLS_ON_DEF]:
		if input_text != None:
			show_result = True
	if value_loc == None:
		show_result = False

	odb = dpo
	display = viewport.odbDisplay
	oa = odb.rootAssembly
	try:
		all_odb_nodes = oa.nodeSets[' ALL NODES'].nodes   ## for implicit
		all_odb_elements = oa.elementSets[' ALL ELEMENTS'].elements
	except:
		pass

	odb_file_path = odb.path  ## such as: 'E:/FEM/A0212/DD_A0212_rotary_initialV200_test.odb'
	## this is one key in session.odbs.keys()

	loc = odb_file_path.rfind('/')
	odb_file_title = odb_file_path[loc+1:-4]   ## 改变odb_file_title

	odb_file_full_name = odb_file_title + '.odb'
	var_file_full = odb_file_title + '.vars'

##	create_poi_vars(post=True)
##	if part_vars not in empty:
##		myprint(part_vars)
##		myprint(inst_vars)

	please_check   ## Need to move to begining ?
	check_mm_unit()  ## objs will be fitview

	vpnow = get_vpnow()
	file_info = odb_file_title + '.odb'

##	raise Exception
##	print fnln(),'viewport name=',viewport.name

	frame_info = vpnow.odbDisplay.fieldFrame
	if len(frame_info) == 2:
		current_step, frame_id = vpnow.odbDisplay.fieldFrame   ## current_step id start from 0
		current_step = odb.steps.values()[current_step]
		step_name = current_step.name
		frame_time = current_step.frames[frame_id].frameValue
		frame_time = smart_round(frame_time)
		procedure = current_step.procedure

		index = get_sequence_index(odb.steps.keys(),step_name)
		index = str(index + 1) + '/' + str(len(odb.steps))
		step_info = 'Step ' + index + ' = ' + step_name + ', frame = ' + str(frame_id) + '/' + str(len(current_step.frames) - 1) 	\
			+ ', step time = ' + str(frame_time)

	else:
		if frame_info == ('Session Step', 'Session Frame', 0, 0):
			odbname = odb.name
			current_step = session.scratchOdbs[odbname].steps['Session Step']
##			current_step = odb.steps['Session Step']
			step_name = 'Session Step'
			frame_id = 0
			step_info = 'Customized output variable'
			procedure = ''

	font_height = int(fontsize*0.40)  ## greater font height lead to greater line space.
	clearance_bot = 2		;please_check   ## anchor from bottom

	yloc_step2 = clearance_bot + font_height*3
	yloc_step = clearance_bot + font_height*2
	yloc_data = clearance_bot + font_height
	yloc_file = clearance_bot

	create_odb_annotation(odb=odb, yloc=yloc_file, viewport=viewport.name, annotation_name='file_info',text=file_info)

	contour_max = display.contourOptions.autoMaxValue
	contour_min = display.contourOptions.autoMinValue
	if contour_max > 1e15 or contour_min < -1e15:   ## not a contour state
		return

##		raise Exception

##	print fnln(),'input_text=',input_text
	locs = vpnow.getPrimVarMinMaxLoc()
	if locs in empty:  ## not contour state
		show_result = False
		results = None
	else:

		results = value_of_current_viewport(value_loc=value_loc, scale=scale, print_result=print_result)
		data = results['data']
		value_loc = results['scope']
		unit = results['unit']
		refinement = results['refinement']
		var = results['main']

		if type_of(vname) != 'STR':	## not provide vname
			vname = results['vname']

		if component in empty:
			component = results['component']

##	print fnln(),'show_result=',show_result
	if show_result == True:
		setting = current_variable_setting()
		data_type = setting['data_type']
		create_odb_annotation(odb=odb, viewport=viewport.name, annotation_name='step_info',text=step_info, yloc = yloc_step )


##		print fnln(),'input_text=',input_text
		if type_of(input_text) == 'STR':  ## 48
			create_odb_annotation(odb=odb, viewport=viewport.name,annotation_name='Result',text=input_text, yloc=yloc_data)
		else:  ## most often
##			if data_type != 'Density':
####				raise Exception
##				create_odb_annotation(odb=odb, viewport=viewport.name,annotation_name='Result',text=component + ':   ' + vname + ' = ' + str(data) + ' ' + unit, yloc=yloc_data)
####				if vpnow.odbDisplay.contourOptions.maxAutoCompute == OFF and abs(vpnow.odbDisplay.contourOptions.autoMaxValue) > 2e-8:
####					vpnow.odbDisplay.contourOptions.setValues(maxAutoCompute=ON)
####				if vpnow.odbDisplay.contourOptions.minAutoCompute == OFF and abs(vpnow.odbDisplay.contourOptions.autoMinValue) > 2e-8:
####					vpnow.odbDisplay.contourOptions.setValues(minAutoCompute=ON)

			if data_type == 'Density':  ## for powder compaction results review
				data = density_distribution(th=th,ask=ask)['summary']
##				raise Exception
				create_odb_annotation(odb=odb, viewport=viewport.name,annotation_name='Result',text=data, yloc=yloc_data)
			elif var == 'LE':  ## for sintering results results review  (不准，与宏观尺寸的收缩比例不符)
				result_min,result_max = minmax_value_of_viewport() ## current frame
				result_min = result_min[2]
				result_max = result_max[2]

				if result_max < 0:
					create_odb_annotation(odb=odb,viewport=viewport.name,annotation_name='Result',text='Shrinkage contour')
				elif result_min > 0:
					create_odb_annotation(odb=odb,viewport=viewport.name,annotation_name='Result',text='Expansion contour')
				else:
					create_odb_annotation(odb=odb,viewport=viewport.name,annotation_name='Result',text='True strain contour')

##				if result_min > -0.35 and result_max < -0.05:  ## shrinkage
##					shrinkage,th,C1 = average_shrinkage(th=th,C1=C1)
##					txt_shrinkage = str(shrinkage*100) + '%, th=' + str(th) + ', C1=' + str(C1)
####					shrinkage = str(shrinkage*100) + '%'
##					create_odb_annotation(odb=odb, viewport=viewport.name,annotation_name='Result',text='Average shrinkage = ' + txt_shrinkage, yloc=yloc_data)
##					print ' '
##					print fnln(),'****** Please ensure that th and C1 are correct: th=',th,', C1=', C1, '******'
##					print ' '
##				else:
##					create_odb_annotation(odb=odb, viewport=viewport.name,annotation_name='Result',text=component + ':   ' + vname + ' = ' + str(data) + ' ' + unit, yloc=yloc_data)
			else:
##				print fnln(),'viewport.name=',viewport.name
				create_odb_annotation(odb=odb, viewport=viewport.name,annotation_name='Result',text=component + ':   ' + vname + ' = ' + str(data) + ' ' + unit, yloc=yloc_data)

##	>>> odb.steps.keys()
##	['shrink_fit', 'draw']

		if procedure not in empty:
			procedure = procedure.lower()
			if procedure[0] == '*':
				procedure = procedure[1:]
			if procedure == 'dynamic':
				procedure = 'Implicit dynamic analysis'
			elif procedure == 'static':
				procedure = 'General static analysis'
			elif procedure == 'dynamic temperature-displacement, explict':
				procedure = 'Explicit dynamic temp-disp analysis'

			procedure = modify_string(procedure,'temperature','temp')
			procedure = modify_string(procedure,'displacement','stress')
	##		procedure =  'Analysis = ' + procedure

			spaces = odb_shape()
			spaces = repr(spaces)[1:-1]
			procedure = procedure + '.  ' + spaces

			if data_type == 'Density':
				procedure = 'Powder compaction simulation'
			elif var == 'LE':
				result_min,result_max = minmax_value_of_viewport() ## current frame
				result_min = result_min[2]
				result_max = result_max[2]
				if result_max < 0:
					procedure = 'Sintering simulation'
				elif result_min > 0:
					procedure = 'Expansion'

			create_odb_annotation(odb=odb, viewport=viewport.name,annotation_name='procedure',text=procedure, yloc=yloc_step2)

		if data_type == 'Density':
			print ' '
			print 'To update density limits: density_distribution(low=1,high=99)'
			print 'To save image with this limits: save_image(0)'
			print ' '

	return results

function_labels['get_mid_flatness'] = 'surface','mid','profile','straightness','flatness','insert'
def get_mid_flatness(p1,nodes,ignore,end_remove=0,detail=False):
	## VER: 2017-06-02, v1.0

##	>>> get_mid_flatness(p1,nodes='side3', ignore='z')
##	profile is reported to _profile.txt
##	0.0243
##	>>>

	if type_of(ignore) == 'STR':
		ignore = ignore.lower()
	if ignore not in ['x','y','z']:
		raise Exception('*** ignore axis should be x,y or z')

	p1 = check_poi(p1)
	if type_of(nodes) == 'STR':
		nodes = set2objs(p1,name=nodes)
	nodes = tolist(nodes)
	if type_of(nodes[0]) != 'nodes':
		raise Exception('*** surface nodes are required.')

	if ignore == 'z':
		nodes1 = node_select(p1,nodes=nodes,z=MID,err=0.15)
	elif ignore == 'y':
		nodes1 = node_select(p1,nodes=nodes,y=MID,err=0.15)
	else:
		nodes1 = node_select(p1,nodes=nodes,x=MID,err=0.15)

	flatness = get_flatness(nodes1,ignore=ignore,end_remove=end_remove,detail=detail)

	return flatness

function_labels['get_flatness'] = 'flatness','straightness','distortion','distance','insert'
def get_flatness(nodes,ignore,reference_locs=None,reference_axis=None,end_remove=0,postfix='',detail=False):
	## VER: 2017-04-24, v1.1

##	>>> nodes = set2objs(p1,'side2')
##	>>> nodes1 = node_select(p1,nodes=nodes,z=MID)
##	['cliCommand', 1, 'node_select', 57323] 43 nodes are selected by node_select().
##	>>> get_flatness(nodes1,ignore='z')
##	profile is reported to _profile.txt
##	0.0239
##	>>>

## get_flatness(nodes=nodes1,ignore='z',end_remove=1) ## side3: flatness=0.0261, side2:flatness=0.0213, side1:flatness=0.0273 (未经旋转)
##	>>> get_flatness(nodes1,ignore='z')
##	0.0277607
##	>>>

	if type_of(ignore) == 'STR':
		ignore = ignore.lower()
	if ignore not in ['x','y','z']:
		raise Exception('*** Please provide the ignore axis.')

	if type_of(reference_axis) == 'STR':
		reference_axis = reference_axis.lower()

	if reference_axis == 'x':
		reference_locs = (0,0,0),(1,0,0)
	elif reference_axis == 'y':
		reference_locs = (0,0,0),(0,1,0)
	elif reference_axis == 'z':
		reference_locs = (0,0,0),(0,0,1)

	dx,dy,dz = objs_span(nodes)
	if ignore == 'x':
		dx = 0
	elif ignore == 'y':
		dy = 0
	elif ignore == 'z':
		dz = 0
	max0 = max(dx,dy,dz)

	if dx == max0:
		nodes = nodes_sort_byx(nodes)
		index = 0
	elif dy == max0:
		nodes = nodes_sort_byy(nodes)
		index = 1
	elif dz == max0:
		nodes = nodes_sort_byz(nodes)
		index = 2

	if end_remove == 1:
		nodes = nodes[1:-1]
	elif end_remove == 2:
		nodes = nodes[2:-2]

##	light(nodes)
##	print 'ignore=',ignore
##	raise Exception

	if reference_locs in empty:
		reference_locs = nodes[0],nodes[-1]
##		raise Exception('*** reference_locs are required to get the reference line.')

	if len(reference_locs) != 2:
		raise Exception('*** 2 locs or 2 nodes are required.')

	dists = []
	axis = []
	for node in nodes:
		dist = point_to_line_distance(node,reference_locs[0],reference_locs[1],ignore=ignore)
		dists.append(round(dist,4)*1000)  ## 单位：um
		axis.append(round(node.coordinates[index],4))

	print ' '
	if postfix in empty:
		file1 = new_file('_profile.txt')
	else:
		file1 = new_file('_profile' + postfix + '.txt')
##	print type_of(file1)
	for i in range(len(dists)):
		line_print(file1, axis[i], '   ', dists[i])

	print 'profile is reported to _profile.txt'

	dists = _sort(dists)
	result = dists[-1]

	if detail == False:
		dists = _sort(dists)
		result = dists[-1]
	else:
		result = dists
		print fnln(),'max flatness=',dists[-1]

	return result

function_labels['get_flatness'] = 'flatness','straightness','distortion','distance','insert'
def get_surface_flatness(poi,nodes,ignore,offset=0,end_remove=0,incs=()):
	## VER: 2017-02-21, v1.0

	## Triangle insert: A0279
##	>>> get_surface_flatness(p1,nodes='side3',ignore='z',offset=-0.3,end_remove=1,incs=(-1.5,-0.75,0,0.75,1.5))
##	['get_surface_flatness', 85, 'node_select', 56730] 44 nodes are selected by node_select().
##	['get_surface_flatness', 85, 'node_select', 56730] 43 nodes are selected by node_select().
##	['get_surface_flatness', 85, 'node_select', 56730] 38 nodes are selected by node_select().
##	['get_surface_flatness', 85, 'node_select', 56730] 41 nodes are selected by node_select().
##	['get_surface_flatness', 85, 'node_select', 56730] 45 nodes are selected by node_select().
##
##	dists= [0.021806, 0.029533, 0.027761, 0.026608, 0.012533]
##	avg= 0.023648
##	>>>

	## Carmex insert: A0262
##	>>> get_surface_flatness(p1,nodes='side1',ignore='z',offset=0,end_remove=0,incs=(-1.2,-0.6,0,0.6,1.2))
##	['get_surface_flatness', 78586, 'node_select', 56730] 172 nodes are selected by node_select().
##	['get_surface_flatness', 78586, 'node_select', 56730] 163 nodes are selected by node_select().
##	['get_surface_flatness', 78586, 'node_select', 56730] 155 nodes are selected by node_select().
##	['get_surface_flatness', 78586, 'node_select', 56730] 154 nodes are selected by node_select().
##	['get_surface_flatness', 78586, 'node_select', 56730] 134 nodes are selected by node_select().
##
##	dists= [0.089957, 0.074507, 0.060084, 0.042237, 0.02269]
##	avg= 0.057895
##	>>>

	poi = check_poi(poi)
	if type_of(nodes) == 'STR':
		nodes = set2objs(poi,name=nodes)

	if type_of(ignore) == 'STR':
		ignore = ignore.lower()
	if ignore not in ['x','y','z']:
		raise Exception('*** ignore axis should be in x, y, z')

	incs = tolist(incs)
	if incs in empty:
		incs = [-1.5,0,1.5]

	dists = []
	if ignore == 'z':
		mid0 = _zmid(nodes) + offset
		for inc in incs:
			nodes1 = node_select(poi,nodes=nodes,z=mid0 + inc)
			dist1 = get_flatness(nodes1,ignore=ignore,end_remove=end_remove)
			dist1 = round(dist1,6)
			dists.append(dist1)

	elif ignore == 'y':
		mid0 = _ymid(nodes) + offset
		for inc in incs:
			nodes1 = node_select(poi,nodes=nodes,y=mid0 + inc)
			dist1 = get_flatness(nodes1,ignore=ignore,end_remove=end_remove)
			dist1 = round(dist1,6)
			dists.append(dist1)

	elif ignore == 'x':
		mid0 = _xmid(nodes) + offset
		for inc in incs:
			nodes1 = node_select(poi,nodes=nodes,x=mid0 + inc)
			dist1 = get_flatness(nodes1,ignore=ignore,end_remove=end_remove)
			dist1 = round(dist1,6)
			dists.append(dist1)

	avg = sum(dists)/len(dists)
	avg = round(avg,6)

	print ' '
	print 'dists=',dists
	print 'avg=',avg

	return

def get_float_num(value):
	## VER: 2014-05-05, v1.1
	## 获得小数点后有几位数，如:4.74，小数点后有两位；4.740001，小数点后有6位。

	value = float(value)
##	value = round(value,6)   ## 不能四舍五入，会改变原始面貌
	value = str(value)

	while True:
		if value[-1] == '.':
			break
		else:
			if value[-1] == '0':
				value = value[:-1]
			else:
				break

	loc = value.find('.')
	value1 = value[loc + 1:]

	num = len(value1)

	return num


def check_float_num(value,float):
	## VER: 2013-10-30, v1.0

	float = abs(float)
	num = get_magnitude(value)
	if num < -float:
		float1 = abs(num) + float - 1
	elif num >= 4:
		float1 = 0
	else:
		float1 = float

	return float1

def update_part(part):
	## VER: 2016-05-24, v1.6

	get_current_model()
	part = check_part(part)

	part.regenerate()
##	if len(part.referencePoints) == 0:
##		create_RP(part.name)

	return

def update_all_viewports(component='', vname='', input_text='',  path1='', value_loc='',scale=1,unit='',float=2,print_result=True,th=14.44,C1=2.505,ask=None):
	## VER: 2016-05-18, v1.5
	## Don't change the display content of the viewport

	global current_model_name, cae_file_title

##	cae_file_title = get_cae_file_title()
	delete_all_annotations()

	vpnow = get_vpnow()
	current_viewport = vpnow.name

##	print fnln(),objs_of_dg()

	for viewport_name in session.viewports.keys():
		viewport_type, viewport = check_viewport(viewport_name)
##		print fnln(),'viewport name=',viewport.name
##		print fnln(),'viewport_type=',viewport_type

		if type_of(viewport.displayedObject) != 'sketch':
			viewport.makeCurrent()
##		print fnln(),objs_of_dg()
##		raise Exception

		if viewport_type == 'MDB':
			update_mdb_viewport(viewport)
		elif viewport_type == 'empty':  ## such as just enter abaqus and then refresh()
			get_current_model()
		elif viewport_type == 'ODB':
			update_odb_viewport(viewport,vname=vname, input_text=input_text, component=component, value_loc=value_loc,
				scale=scale, unit=unit, float=float,print_result=print_result, th=th, C1=C1,ask=ask)
		elif viewport_type == 'XYPLOT':
			update_xyplot_viewport(viewport=vpnow,text=input_text,ask=ask,path1=path1)

	session.viewports[current_viewport].makeCurrent()

	models = opened_models()
	if len(models) > 1:
		get_current_model()

	return

def update_xyplot_viewport(viewport=None, text='xyplot1',path1='',ask=None):
	## VER: 2017-06-12, v2.0
	## refresh() -> update_all_viewports() -> update_xyplot_viewport
	## path1: 结果可能来自某个part(与odb无关)，或来自某个当前的odb(与part无关)

	global odb, oa, odb_file_path, odb_file_title, odb_file_full_name

	if viewport in empty:
		viewport = get_vpnow()
	else:
		viewport_type, viewport = check_viewport(viewport)

	xyp = viewport.displayedObject
	viewport_type = type_of(xyp)
	if viewport_type != 'XYPLOT':
		raise Exception('*** XYPLOT is required.')

	if text == '':
		text = 'xyplot1'

	viewport.setValues(displayedObject=xyp)
	chart,curves,axis1,axis2 = chart_curves_axis_of_xyplot(xyp)

	for i in range(len(chart.axes2)):
		chart.axes2[i].axisData.setValues(maxAutoCompute=True)
		chart.axes2[i].axisData.setValues(minAutoCompute=True)

	for i in range(len(chart.axes1)):
		chart.axes1[i].axisData.setValues(maxAutoCompute=True)
		chart.axes1[i].axisData.setValues(minAutoCompute=True)

##	session.charts['Chart-2'].axes2[0].axisData.setValues(maxAutoCompute=True)
##	session.charts['Chart-2'].axes2[0].axisData.setValues(minAutoCompute=True)

##	session.charts['Chart-2'].axes1[0].axisData.setValues(maxAutoCompute=True)
##	session.charts['Chart-2'].axes1[0].axisData.setValues(minAutoCompute=True)

	delete_viewport_annotations(viewport)

##	print get_traceback()
##	raise Exception

	## annotation
	fontsize = get_fontsize()
	font_height = int(fontsize*0.4)  ## greater font height lead to greater line space.
	xloc = 6
	yloc = 2

	if path1 == '':
		if 'name' in vpnow.odbDisplay.__members__:  ## 有odb打开
			odb_file_path = viewport.odbDisplay.name    ## such as: 'E:/FEM/A0212/DD_A0212_rotary_initialV200_test.odb'
			## odb_file_path is one key in the session.odbs.keys()

			if odb_file_path not in session.odbs.keys():	## not open yet
				open_odb(odb_file_path)

			odb = session.odbs[odb_file_path]
			oa = odb.rootAssembly

			loc = odb_file_path.rfind('/')
			odb_file_full_name = odb_file_path[loc+1:]
			odb_file_title = odb_file_full_name[:-4]
			print fnln(),'odb_file_full_name =',odb_file_full_name  ## DD_A0212_rotary_initialV200_test.odb
			path1 = odb_file_full_name

	note1 = text
	if ask != False:
		path1,note1 = GUI_inputs([('file path',path1),('note',text)],title='Create xyplot annotations',info='Text to show in the xyplot:')

	font = '-*-arial-medium-r-normal-*-*-180-*-*-p-*-*-*'
	if len(path1) > 0:
		create_xyplot_annotation(viewport=viewport,name='text1',text=path1, xloc=40, yloc=20, font=font)
	if len(note1) > 0 and note1 != ' ':
		create_xyplot_annotation(viewport=viewport,name='text2',text=note1, xloc=40, yloc =10, font=font)

	## legend
	chart.gridArea.style.setValues(color='#FFFFFF')  ## white
	chart.legend.area.setValues(inset=True, positionMethod=MANUAL,originOffset=(0.15, 0.8))
	chart.legend.textStyle.setValues(font='-*-verdana-medium-r-normal-*-*-120-*-*-p-*-*-*')
	chart.legend.area.border.setValues(show=False)

	## axis1
	axis1.labelStyle.setValues(font='-*-verdana-medium-r-normal-*-*-120-*-*-p-*-*-*')
	axis1_data = axis1.axisData

##	axis1.axisData.setValues(minAutoCompute=False, minValue=axis1_data.minAutoValue - axis1_data.tickIncrement/4.0,
##		maxAutoCompute=False, maxValue=axis1_data.maxAutoValue + axis1_data.tickIncrement/4.0)

	axis1.axisData.setValues(minAutoCompute=True, maxAutoCompute=False, maxValue=axis1_data.maxAutoValue + axis1_data.tickIncrement/4.0)

## GUI:
##>>> chart = session.charts.values()[-1]
##>>> axis_data = chart.axes2[0].axisData

	## axis2
	for axis in axis2:
		axis.labelStyle.setValues(font='-*-verdana-medium-r-normal-*-*-120-*-*-p-*-*-*')
		axis_data = axis.axisData
###		axis.axisData.setValues(maxAutoCompute=False, maxValue=axis_data.maxAutoValue + axis_data.tickIncrement/2.0,
###			minAutoCompute=False, minValue=axis_data.minAutoValue - axis_data.tickIncrement/2.0, tickMode=TOTAL_NUMBER, tickCount=10)

		axis.axisData.setValues(maxAutoCompute=False, maxValue=axis_data.maxAutoValue + axis_data.tickIncrement/2.0,
			minAutoCompute=False, minValue=axis_data.minAutoValue, tickMode=TOTAL_NUMBER, tickCount=10)

##	>>> xyp = session.xyPlots['XYPlot-1']
##	>>> curve = xyp.curves.values()[-1]
##	>>> curve.name
##	'_temp_9'
##	>>>

	## curves
	colors = [RED,BLUE,BLACK,BROWN,GREEN,RED,BLUE,BLACK,BROWN]
	for i in range(len(curves)):
		curve = xyp.curves.values()[i]
		curve.lineStyle.setValues(color = colors[i],thickness=0.5)

	curve_num = len(curves)
##	print fnln(),'curve_num=',curve_num
	for curve in curves:
		label = curve.legendLabel
		name = curve.name
		min1,max1 = minmax_of_curve(curve)
		start1,end1 = start_end_of_curve(curve)
		gap = smart_round(max1 - min1)

		label0 = name + ': min=' + str(min1) + ', max=' + str(max1) + ', gap=' + str(gap)

		label1 = ''
		if ' NSET' in label:
			loc = label.find(' NSET')
			label1 = label[loc + 6:]
		else:
			if ' PI:' in label:
				loc = label.find(' PI:')
				label1 = label[loc+4:]
				label1 = modify_string(label1,'N:','node')

		if name in label1:
			loc = label1.find(name)
			label1 = label1[:loc]

		label2 = label0 + ' ' + label1
##		print fnln(),'label1=',label1

####		if 'Y: min_max' not in label:
##		range0 = minmax_of_curve(curve)
##		data_type = curve.data.axis2QuantityType.label
##		label0 = data_type + 'Y: min_max= ' + str(range0)
##
##		gap = range0[-1] - range0[0]
##		label0 = label0+ ', gap= ' + str(gap)
##
####		if 'X: start_end' not in label:
##		range1 = start_end_of_curve(curve)
##		label0 = label0+ ', X: start_end= ' + str(range1)
##
####		print fnln(),'label0 =',label0
##		if label.startswith('_temp'):
##			if curve_num > 1:
##				label = 'curve' + label[5:]
##			else:
##				label = ''
##		elif label[0] == '_':
##			label = label[1:]
##
##		if ' NSET' in label:
##			loc = label.find(' NSET')
##			label = label[loc + 6:]
##		else:
##			if ' PI:' in label:
##				loc = label.find(' PI:')
##				label = label[loc+4:]
##				label = modify_string(label,'N:','node')
##
##		if label0 not in empty and label not in empty:
##			label = label + ', ' + label0
##		elif label0 not in empty:
##			label = label0

		session.curves[name].setValues(useDefault=False, legendLabel=label2)

	chart.fitCurves(fitAxes1=False, fitAxes2=True)

	return

def use_part(part,global_name):
	## VER: 2012-02-10, v1.0

	if type_of(global_name) == 'PART':
		part,global_name = global_name,part

	part = check_part(part)

	_m.parts.changeKey(fromName=part.name, toName=global_name)	## 可以考虑用copy_part的方法来change_partname

##	globals()[global_name] = _m.parts[global_name]

	new_instance(global_name)

	return

def update_mdb_vars(model_name=None):
	## VER: 2013-06-06, v1.3.  To get current model name, so as to refresh()
	## please switch to assembly module or part module to update_mdb_vars
	## mdb is updated every time of refresh()

	global _m, a, current_model_name, cae_file_title

	##>>> mdb.models.keys()
	##['11', 'WC', 'four parts', 'solid', 'x1']   ## sorted by name
	##>>>

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject

	_m = mdb.models[current_model_name]
	a = _m.rootAssembly
	a.unlock()
	a.regenerate()

	if type_of(vpnow.displayedObject) in ['ASSEMBLY','PART']:
		create_csys(a,loc=(0,0,0))

	get_current_model()
##	create_poi_vars()

##	if part_vars not in empty:
##		myprint(part_vars)
##		myprint(inst_vars)

	cae_file_title = get_cae_file_title()
	viewport_text = current_model_name + '@' + cae_file_title + '.cae'

	for name in mdb.annotations.keys():
		del mdb.annotations[name]

	create_mdb_annotation(name='Title1',text=viewport_text)

	return current_model_name

def update_mdb_viewport(viewport=None,make_current=False):
	## VER: 2015-05-26, v2.1

	global _m, a, cae_file_title, current_model_name

	if viewport in empty:
		viewport = get_vpnow()

	viewport_type, viewport = check_viewport(viewport)
	delete_viewport_annotations(viewport)

##	print fnln(),objs_of_dg()
##	raise Exception

	if viewport_type == 'MDB':
		dpo = viewport.displayedObject
		dpo_text = totext(dpo)
##		model_name = get_repository_key(dpo_text,'model')
##		print fnln(),objs_of_dg()
		get_current_model(viewport)
		model_name = current_model_name

##		print fnln(),objs_of_dg()
##		raise Exception

		if model_name not in mdb.models.keys():
			raise Exception('**** Fail to get the model name')

		file_title = get_cae_file_title()
		line1_text = model_name + ' @ ' + file_title + '.cae'

		fontsize = get_fontsize()
		font_height = int(fontsize*0.42)
		clearance_bot = 2		;please_check   ## anchor from bottom

##		print fnln(),'font_height=',font_height
		yloc3 = clearance_bot + font_height*2
		yloc2 = clearance_bot + font_height
		yloc_file = clearance_bot

		line1_name = new_key(mdb.annotations.keys(),'line1_info')
		create_mdb_annotation(name=line1_name,text=line1_text, viewport=viewport, yloc=yloc_file)

		if type_of(dpo) == 'PART':
			partname = dpo.name
			part = _m.parts[partname]

			if len(part.cells) > 0:
				objs0 = part.cells[:]
			elif len(part.faces) > 0:
				objs0 = part.faces[:]
			elif len(part.edges) > 0:
				objs0 = part.edges[:]

			dg = dg_now()
			leaf = dg['leaf']

##			print fnln(),type_of(leaf)
##			raise Exception

			if type_of(leaf) == 'SETSLEAF':
				objs1 = leaf2sets(leaf)

				name1 = 'Part = ' + objs1.keys()[0]
				name2 = 'Set = ' + repr(objs1.values())
				obj_info = name1 + ', ' + name2

##				obj_info = repr(objs1)[1:-1]
				obj_info = modify_string(obj_info,'[')
				obj_info = modify_string(obj_info,']')

				annotation_name = new_key(mdb.annotations.keys(),'line2_info')
				create_mdb_annotation(name=annotation_name,text=obj_info, viewport=viewport, yloc=yloc3)

			else:
				if len(_m.materials) < 40:
					dict1 = get_mats(partname)
					mats = dict1[partname].keys()
					if mats in empty:
						mats = ''
					elif len(mats) > 5:
						mats = str(len(mats)) + ' mats'
					else:
						mats = repr(mats)[1:-1]
				else:
					mats = ''

##				print fnln(),'obj_info=',obj_info
##				raise Exception

				elem = repr(get_element_type(partname))[1:-1]
				if elem in empty:
					elem = 'None'

				line2_name = new_key(mdb.annotations.keys(),'line2_info')
##				obj_info = 'part = ' + partname + ', mats = ' + mats
				obj_info = ', elements = ' + elem
##				poi_info = partname + ', elements = ' + elem

				if mats not in empty:
					poi_info = partname + ', mats = ' + mats
				else:
					poi_info = partname

				shape1 = part_shape(partname)[1]
##				print fnln(),'shape1=',shape1
				if part_type(partname) != DEFORMABLE_BODY:
					type1 = totext(part_type(partname)).lower()
					if 'discrete' in type1:
						type1 = 'discrete rigid'
					elif 'analytical' in type1:
						type1 = 'analytical rigid'

##					print fnln(),'type1=',type1
					shape1 = shape1 + ' ' + type1

				obj_info = shape1 + ' ' + obj_info
##				print fnln(),'obj_info=',obj_info


				if len(_m.parts) == 1:
					obj_info= 'Model, ' + obj_info

##				print fnln(),'obj_info=',obj_info
##				print fnln(),'yloc=',yloc3
##				print fnln(),'poi_info=',poi_info
##				print fnln(),'yloc2=',yloc2

				create_mdb_annotation(name='line2_info',text=obj_info, viewport=viewport, yloc=yloc2)
				create_mdb_annotation(name='line3_info',text=poi_info, viewport=viewport, yloc=yloc3)

		elif type_of(dpo) == 'ASSEMBLY':
			dg = dg_now()
			objs = dg['objs']   ## get by objs_of_dg()
##			print fnln(),'objs=',objs
			insts = real_insts(objs)
			names = poi_names(insts)
			mats = []
			if len(_m.materials) < 30:
				for inst in insts:
					dict1 = get_mats(inst)
					mats1 = dict1[inst.name].keys()
					mats = mats + mats1

			if mats not in empty:
				mats = remove_repeated_items(mats)

			step_info = str(get_model_antypes0())[1:-1]
			if step_info not in empty:
				step_info = str(len(_m.steps) - 1) + ' steps = ' + step_info
			else:
				step_info = 'Steps=None'

			obj_info = ''
			if names not in empty:
				insts = real_insts(names)
				if insts not in empty:
					if mats in empty:
##						mats = 'mats=None'
##						obj_info = ', mats = None'
						obj_info = ''
					elif len(mats) <= 3:
						mats = repr(mats)[1:-1]
						obj_info = ', (' + mats + ')'
					else:
						mats = str(len(mats)) + ' mats'
						obj_info = ', ' + mats
##						mats = repr(mats)[1:-1] + '...'
##						obj_info = ', (' + mats + ')'

					elems = []
					for inst in insts:
						if len(inst.elements) > 0:
							type1 = repr(inst.elements[0].type)
							if type1 not in elems:
								elems.append(type1)

					if elems not in empty:
						step_info = step_info + ', elements = ' + repr(elems)[1:-1]
					else:
						step_info = step_info + ', elements = None'

				if len(names) > 4:
					obj_info = str(len(names)) + ' instances' + obj_info
##					obj_info = str(len(names))
				else:
					for i in range(len(names)):
						name1 = names[i]
						if name1[-3:] in ['_A1','_A2','_A3','_A4']:
							name1 = name1[:-3]
						names[i] = name1
					names = remove_repeated_items(names)

##					print fnln(),repr(names)[1:-1]
					if len(names) > 1:
						obj_info = '(' + repr(names)[1:-1] + ')' + obj_info
					else:
						obj_info = repr(names)[1:-1] + obj_info

				line2_name = new_key(mdb.annotations.keys(),'obj_info')
				if len(all_valid_insts()) == len(names):
					obj_info= 'Model,  ' + obj_info

##				print fnln(),'obj_info=',obj_info

				add = ''
				shape1 = part_shape(insts[0])[1]
				if '2D' in shape1:
					add = '2D '

				if 'AXISYM' in shape1 or 'axisym' in shape1:
					add = add + 'axisymmetric '

				if add != '' and obj_info.startswith('Model'):
					obj_info = 'model' + obj_info[5:]

				obj_info = add + obj_info
				create_mdb_annotation(name='line3_info',text=obj_info, viewport=viewport, yloc=yloc3)
				create_mdb_annotation(name='line2_info',text=step_info, viewport=viewport, yloc=yloc2)

			else:
				leaf = dg['leaf']
				objs1 = []
				if type_of(leaf) == 'INSTANCELEAF':
					objs1 = leaf2insts(leaf)
				elif type_of(leaf) == 'SETSLEAF':
					objs1 = leaf2sets(leaf)

				if objs1 not in empty:
					if len(objs1) == 1:
						name1 = 'Instance = ' + objs1.keys()[0]
						name2 = 'Set = ' + repr(objs1.values())
						viewport_text = name1 + ', ' + name2

					else:
						viewport_text = repr(objs1)[1:-1]

					viewport_text = modify_string(viewport_text,'[')
					viewport_text = modify_string(viewport_text,']')

					annotation_name = new_key(mdb.annotations.keys(),'leaf_info')
					create_mdb_annotation(name=annotation_name,text=viewport_text, viewport=viewport, yloc=yloc3)

					if len(_m.steps) > 1:
						antype_info = get_antype()[0]
						create_mdb_annotation(name='step_info',text=antype_info, viewport=viewport, yloc=yloc2)
	return

def update_odb_vars():
	## VER: 2013-06-10, v1.2
	## odb is updated only when dpo is ODB

	global odb, oa, all_odb_nodes, all_odb_elements, odb_file_path, odb_file_title, odb_file_full_name
	global current_step

	vpnow = get_vpnow()
	dpo = vpnow.displayedObject

	if type_of(dpo) == 'ODB':
		odb = vpnow.displayedObject
		display = vpnow.odbDisplay
		oa = odb.rootAssembly
		all_odb_nodes = oa.nodeSets[' ALL NODES'].nodes
		all_odb_elements = oa.elementSets[' ALL ELEMENTS'].elements
		odb_file_path = odb.path

		loc = odb_file_path.rfind('/')
		odb_file_title = odb_file_path[loc+1:]

		odb_file_full_name = odb_file_title + '.odb'
		var_file_full = odb_file_title + '.vars'

##		create_poi_vars(post=True)
##		if part_vars not in empty:
##			myprint(part_vars)
##			myprint(inst_vars)

		viewport_text1 = odb_file_title

		current_step, frame = vpnow.odbDisplay.fieldFrame
		step_name = odb.steps.values()[current_step].name
		step_info = str(current_step) + 'step = ' + step_name + ', frame = ' + str(frame)

##		for name in odb.userData.annotations.keys():
##			del odb.userData.annotations[name]

		delete_viewport_annotations(vpnow)

		create_odb_annotation(name='Title1',viewport=vpnow,text=viewport_text1)
		create_odb_annotation(name='Title2',viewport=vpnow,text=step_info, yloc = annotation_yloc - 6 )

	return

def use_poi_var_name(string1):
	## VER: 2014-08-20, v1.6, 缩短findAt的表达串等。
	## only applicable to mdb
	## dont' create the poi obj as a global variable, use the name instead.

	if type_of(string1) != 'STR':
		raise Exception('******one string is required.')

	vpnow = get_vpnow()
##	create_poi_vars()
	dpo = vpnow.displayedObject
	if type_of(dpo) in ['PART','ASSEMBLY']:
		for part in _m.parts.values():
##			name1 = part_vars[part.name]
			name1 = part.name
			string1 = modify_string(string1, repr(part),name1)

		for inst in a.instances.values():
##			name1 = inst_vars[inst.name]
			name1 = inst.name
			string1 = modify_string(string1, repr(inst), name1)

		string1 = modify_string(string1,'33333','3')
		string1 = modify_string(string1,'66667','7')

	return string1

def text2varname(name,poi_type,cutshort=True):

	## VER: ('VER: 2013-09-17, v1.4')

	poi_type = poi_type.lower()
	if poi_type in ['inst','instance']:
		poi_type = 'pinstance'
	elif poi_type in ['cells','faces','edges','vertices','obj']:
		poi_type = 'object'

	if poi_type not in ['part','pinstance','odbinstance','odbpart', 'object','other']:
		raise Exception('*** poi_type should be PART or PINSTANCE or OBJECT')

	if type_of(name) != 'STR':
		raise Exception('**A name of poi is required.')

	name1 = modify_string(name,' ','_')
	name1 = modify_string(name1,'-','_')
	name1 = modify_string(name1,'.','_')
	name1 = modify_string(name1,'/','_')

	while name1.find('__') > 0:		##将所有的连续的下划线合并成一个下划线字符
		name1 = modify_string(name1,'__','_')

	locs = locs_of_substring(name1,'_')
	name2 = name1
	if len(locs) >=3:
		name2 = name1[:locs[0] + 1] + name1[locs[-2] + 1:]

	if poi_type == 'part' and name in a.instances.keys():
		name2 = name2 + '_prt'
	elif poi_type == 'pinstance' and name in _m.parts.keys():
		name2 = name2 + '_ins'
	elif poi_type == 'obj' and name in _m.parts.keys() + a.instances.keys():
		name2 = name2 + '_obj'
	elif poi_type == 'odbpart' and name in oa.instances.keys():
		name2 = name2 + '_prt'
	elif poi_type == 'odbinstance' and name in odb.parts.keys():
		name2 = name2 + '_ins'

	return name2

def contour_values_vs_time(value_loc='',setname='',scale=1):
	## VER: 2014-12-03, v1.2
	## plot xydata from field contour
	## 对于诸如EVOL视图也是适用的。如果可能，可以用pick elements然后REPLACE的方法来减少显示的单元数量。

	refresh()
	vpnow = get_vpnow()
	if get_plot_state() != CONTOURS_ON_DEF:
		raise Exception('*** a odb contour is required.')

##	variable = vpnow.odbDisplay.primaryVariableLabel

##	refresh(print_result=False)

	if value_loc in empty:
		value_loc = 'max'

	if type_of(value_loc) == 'STR':
		value_loc = value_loc.lower()

	if value_loc not in ['min', 'max', 'gap']:
		raise Exception('*** value_loc is required, such as: min, max, gap')

	setting = current_variable_setting()
	data_type = setting['data_type']
	main = setting['main']
	sub = setting['sub']
	variable = main
	if sub not in empty:
		variable = main + ', ' + sub

	print fnln(), 'main_var =',main
	print fnln(), 'sub_var  =', sub

	print fnln(),'value_loc=',value_loc
##	raise Exception

	results = []
	step_times = []
	for i in range(len(odb.steps)):
		step = odb.steps.values()[i]
		step_time = step.frames[-1].frameValue
		step_times.append(step_time)
		for j in range(len(step.frames)):
			if main in step.frames[j].fieldOutputs.keys():
				vpnow.odbDisplay.setFrame(step=i, frame=j)

				result_min,result_max = minmax_value_of_viewport() ## current frame
				result_min = result_min[2]
				result_max = result_max[2]
				if value_loc == 'max':
					data1 = result_max
				elif value_loc == 'min':
					data1 = result_min
				elif value_loc == 'gap':
					data1 = result_max - result_min

				data1 = data1*scale

				time1 = current_step_frame_time()[-1]
				sum0 = sum(step_times[:-1])
				time1 = time1 + sum0

				results.append((time1, data1))

	screen()
	filename = '_xydata_' + main + '_' + odb_file_title + '_1.txt'
	filename = check_file_name(filename,format='TXT')
	print 'xydata filename=',filename	##  D:/JYQ/A0212/_xydata_S_C6_A0212_rotary_initialV150_10_4.txt
	sys.stdout = open(filename,'w')  ## save 1

	for time1, data1 in results:
		print time1, '   ', data1
	screen()

	## 内容例如：（没有head line)
##	0.0     33.316
##	1.005e-06     33.316
##	3.006e-06     33.316
##	5.001e-06     33.316
##	1e-05     33.316
##	2.001e-05     33.316
##	3e-05     33.316

##	raise Exception
	print ' '
	data_type = data_type.upper()
	try:
		data_type = eval(data_type)
	except:
		data_type = NUMBER	## 78
##		raise Exception('*** Cannot find the data_type, please correct the data_type in current_variable_setting().')

	print fnln(), 'data_type =',data_type
##	raise Exception

##	Permissible data type: {NONE: 2, TIME: 3, LENGTH: 6, PRESSURE_GRADIENT: 68, DISPLACEMENT: 9, PATH: 11, BIMOMENT: 70, TIME_INCREMENT: 80,
##     POSITION: 7, PATH_X: 12, PATH_Z: 14, VELOCITY_SQUARED: 24, VOLUME_FLUX: 37, ROTATIONAL_ACCELERATION: 28, DENSITY_ROTATIONAL_ACCELERATION: 72,
##     VOLUME_FRACTION: 78, NUMBER: 22, TIME_VOLUME_FLUX: 39, HEAT_FLUX: 61, TIME_HEAT_FLUX: 65, LUMIN: 53, TWIST: 75, ACOUSTIC_INTENSITY: 69,
##     DAMAGE_CRITERION: 74, TEMPERATURE: 5, FREQUENCY: 20, PRESSURE: 33, THICKNESS: 10, PHASE: 18, RATE: 19, VELOCITY: 23, MASS_FLOW_AREA: 55,
##     DENSITY: 41, ROTATIONAL_VELOCITY: 26, LINEAR_PRESSURE: 34, HEAT_FLUX_RATE: 60, FORCE: 29, VOLUME: 36, PATH_Y: 13, VOLUME_FLUX_AREA: 38,
##     ROTARY_INERTIA: 45, FORCE_VOLUME: 30, TIME_VOLUME: 40, HEAT_FLUX_AREA: 62, TIME_HEAT_FLUX_AREA: 64, HEAT_FLUX_VOLUME: 63, DAMAGE: 73,
##     ARC_LENGTH: 8, AREA_VELOCITY_SQUARED: 25, ELECTRIC_CURRENT: 46, EPOTENTIAL_GRADIENT: 51, ELECTRIC_POTENTIAL: 50, STRAIN: 57,
##     MODE_NUMBER: 21, MOMENT: 31, ACCELERATION: 27, CORIOLIS_LOAD: 71, STRESS: 32, AREA: 35, ANGLE: 17, STRAIN_RATE: 59, MASS: 4,
##     ENERGY_DENSITY: 43, ENERGY_RELEASE_RATE: 66, ENERGY: 42, ANGULAR_MOMENTUM: 44, ELECTRIC_CHARGE: 47, STATUS: 58, STRESS_INTENS_FACTOR: 67,
##     ELECTRIC_CURRENT_AREA: 48, STEP_TIME: 79, CURVATURE: 16, MASS_FLOW_RATE: 54, MASS_FLOW_AREA_RATE: 56, ECURRENT_AREA_TIME: 49, SUBSTANCE: 52, }

	## session.xyPlots['xyplot-5']
	## session.charts['Chart-5']

	name = new_key(session.xyPlots.keys(),'xyplot-1')
	xyp = session.XYPlot(name)
	chartName = xyp.charts.keys()[0]
	chart = xyp.charts[chartName]
	xQuantity = visualization.QuantityType(type=TIME)
	yQuantity = visualization.QuantityType(type=data_type)

	print 'xQuantity=',xQuantity
	print 'yQuantity=',yQuantity
	print 'Y axis type=',yQuantity.type

##	raise Exception
	xy1 = xyPlot.XYDataFromFile(fileName=filename, xField=1,
	    yField=2, contentDescription=variable, yValuesLabel=variable, axis1QuantityType=xQuantity, axis2QuantityType=yQuantity, )
	c1 = session.Curve(xyData=xy1)
	chart.setValues(curvesToPlot=(c1, ), )
	vpnow.setValues(displayedObject=xyp)

##	raise Exception

## GUI:
##>>> chart = session.charts.values()[-1]
##>>> axis_data = chart.axes2[0].axisData

	chart = get_current_chart()
	update_axis2(chart,variable)
	refresh()

	if setname in empty:
		save_image(postfix=value_loc)   ## save 2
	else:
		save_image(postfix=value_loc + '_' + setname)

	return results

def vector_angle(vector1=None,vector2=None,line1=None,line2=None,start1=None,end1=None,start2=None,end2=None,axis=None,start=None,end=None,
	absolute=True,print_info = True):
	## VER: 2017-05-03, v2.1
	## 两个矢量的夹角是指：让这两个矢量的起点重合，然后从一个矢量旋转到另外一个矢量所需的最小角度（不规定顺时针还是逆时针)
	## 这样的夹角可能是锐角，也可能是钝角，但不可能大于180度
	## 所以，观察两个面的夹角时，两个矢量的起点都要相对终点更靠近两个面的交线
	## absolute=True表示取锐角。absolute=False表示真实的夹角，可能锐角，也可能是钝角。

	## CAE中query两个节点，得到位置信息。
##	Coordinates of node 12002 :4.736046,7.866698,-2.768127
##	Coordinates of node 10604 :4.726763,-7.889249,-2.762093
##	>>> vector_angle(start=(4.736046,7.866698,-2.768127),end=(4.726763,-7.889249,-2.762093),axis='x')
##	89.966
##	>>>

	## create node set line1 of two nodes, line2 of another two nodes:
##	>>> vector_angle(line1='line1',line2='line2')
##	['get_p1', 38973] Created global var p1. You can use in GUI command.
##	['get_p1', 38974] p1.name= OB01
##
##	['get_p1', 38973] Created global var p1. You can use in GUI command.
##	['get_p1', 38974] p1.name= OB01
##
##	angle = 90deg12'
##	90.214
##	>>>

##	>>> vector_angle((0,-1),(1,1))
##	135.0
##	>>> vector_angle((1,1),(0,-1))
##	135.0
##	>>> vector_angle((1,-1),(1,1))
##	90.0
##	>>> vector_angle((1,1),(1,-1))
##	90.0
##	>>> vector_angle((-1,0),(1,1))
##	135.0
##	>>> vector_angle((-1,0),(1,1))
##	135.0
##	>>> vector_angle((1,1),(-1,0))
##	135.0
##	>>>

##	>>> normal_vector_of_three_points_plane(n11,n12,n13,n14)
##	(0.999932, 0.011605, 0.001439)
##	>>> dir1 = normal_vector_of_three_points_plane(n11,n12,n13,n14)
##	>>> vector_angle(vector=dir1,axis='x')
##	0.670024785169899
##	>>> vector_angle(vector=dir1,axis='y')
##	89.3350678029209   ## 几乎垂直
##	>>> vector_angle(vector=dir1,axis='z')
##	89.9175513758007
##	>>>

	if start not in empty:
		start1 = start

	if end not in empty:
		end1 = end

	if line1 not in empty and line2 not in empty:
		if type_of(line1) == 'STR':
			line1 = set2objs(get_p1(),line1)
		line1 = tolist(line1)

		if type_of(line1[0]) == 'edges':
			vertices = edges_to_vertices(line1[0])
			loc1 = vertices[0]
			loc2 = vertices[1]
		elif type_of(line1[0]) in ['vertices','nodes']:
			loc1 = line1[0]
			loc2 = line1[1]
		else:
			if is_location(line1[0]) and is_location(line1[1]):
				loc1 = line1[0]
				loc2 = line1[1]
			else:
				raise Exception('*** incorect line1.')

		loc1 = point_loc(loc1)
		loc2 = point_loc(loc2)

		## line2
		if type_of(line2) == 'STR':
			line2 = set2objs(get_p1(),line2)
		line2 = tolist(line2)

		if type_of(line2[0]) == 'edges':
			vertices = edges_to_vertices(line2[0])
			loc3 = vertices[0]
			loc4 = vertices[1]
		elif type_of(line2[0]) in ['vertices','nodes']:
			loc3 = line2[0]
			loc4 = line2[1]
		else:
			if is_location(line2[0]) and is_location(line2[1]):
				loc3 = line2[0]
				loc4 = line2[1]
			else:
				raise Exception('*** incorect line2.')

		loc3 = point_loc(loc3)
		loc4 = point_loc(loc4)

		dist1 = point_to_line_distance(loc1,loc3,loc4)
		dist2 = point_to_line_distance(loc2,loc3,loc4)

		if dist2 < dist1:
			loc1,loc2 = loc2,loc1

		dist3 = point_to_line_distance(loc3,loc1,loc2)
		dist4 = point_to_line_distance(loc4,loc1,loc2)

		if dist4 < dist3:
			loc3,loc4 = loc4,loc3

		start1 = loc1
		end1 = loc2
		start2 = loc3
		end2 = loc4

	if start1 not in empty:
		start1 = point_loc(start1)
	if end1 not in empty:
		end1 = point_loc(end1)

	if start2 not in empty:
		start2 = point_loc(start2)
	if end2 not in empty:
		end2 = point_loc(end2)

	if is_location(end1):
		if is_location(start1) == False:
			vector1 = end1
		else:
			vector1 = end1[0]-start1[0], end1[1]-start1[1], end1[2]-start1[2]

	if is_location(end2):
		if is_location(start2) == False:
			vector2 = end2
		else:
			vector2 = end2[0]-start2[0], end2[1]-start2[1], end2[2]-start2[2]

	elif axis in ['x',0]:
		vector2 = (1,0,0)
	elif axis in ['y',1]:
		vector2 = (0,1,0)
	elif axis in ['z',2]:
		vector2 = (0,0,1)

	if is_location(vector1) == False:
		raise Exception('*** vector1 is required.')

	if is_location(vector2) == False:
		raise Exception('*** vector2 is required.')

	vector1 = normalized_vector(vector1)
	x1,y1,z1 = vector1

	vector2 = normalized_vector(vector2)
	x2,y2,z2 = vector2

##	print fnln(),'vector1=',vector1
##	print fnln(),'vector2=',vector2

	if len(vector1) == 3:
		x1,y1,z1 = vector1
	elif len(vector1) == 2:
		x1,y1 = vector1;	z1=0

	if len(vector1) == 3:
		x2,y2,z2 = vector2
	elif len(vector1) == 2:
		x2,y2 = vector2;	z2 = 0

	length1 = sqrt(x1*x1 + y1*y1 + z1*z1)  ## 单位矢量：length1 = 1
	length2 = sqrt(x2*x2 + y2*y2 + z2*z2)  ## 单位矢量：length2 = 1
	if absolute == True:  ## 仅取锐角，不取钝角，如一条线与坐标轴的夹角。
		inner_product = abs(x1*x2 + y1*y2 + z1*z2)
	else:
		inner_product = x1*x2 + y1*y2 + z1*z2		##向量的内积（叉积），如果inner_product为负数，表示这是一个钝角。

	value = inner_product/(length1*length2)    ## cos(0) = 1, acos(1) = 0
##	print fnln(),'value=',repr(value)
##	print fnln(),'type=',type_of(value)
	try:
		angle = acos(value)
	except:
		if abs(abs(value)-1.0) < 1e-6:
			angle = 0
		else:
			if value > 1.0:
				print 'big'

	angle = angle*180.0/pi
	angle = round(angle,6)

	if abs(angle)<1e-4:
		angle = 0
##	print fnln(),'angle=',angle

	minutes = (angle - int(angle))*60
	minutes = int(minutes)
	if absolute == False and print_info == True:
		print fnln(),'angle =',str(int(angle)) + 'deg' + str(minutes) + "'"

	return angle  ## deg

function_labels['vector_angle_of_4nodes'] = 'nodes','line','angle','point','pick'
def vector_angle_of_4nodes(points=None,sort=''):
	## VER: 2017-06-21, v1.1 在界面上选择4个点,建立set。选择节点时，选项为选择外部的节点Select from exterior entities
	## 如果在几何模型下，可以直接query两条edge之间的夹角。
	## 对于网格模型，选择两个节点（可以相距很远），就想象地组成一条line。类似地选择另外两个节点组成另外一条line。求这两条line之间的夹角。
	## 方法：create display group->nodes->pick from viewport->edit selection->pick one or two nodes->Done->add selection->pick another one or two points->Done ->Save selection as->OK->查rpy文件，有编号。
	## or query 4 nodes to write down the labels, line1=node1,node2; line2=node3,node4. node1,node2不受起始点和终点的困扰。node3,node4也是。
	## 该函数比较适合比较模型网格相同，但其他参数比如摩擦系数，材料属性改变的情形。也适用于相同的初始模型，只是PV,OB,不同的powder compaction网格。

	## create set of 4 nodes,then
	## angle_of_4nodes(sort='z')

	## left+shift to select 4 nodes in GUI to create a set(name=n1), then light(n1[0]),light(n1[1]),light(n1[2]),light(n1[3]) to confirm locations
##	>>> n1
##	[mdb.models['Model-1'].parts['carmex_1'].nodes[6014], mdb.models['Model-1'].parts['carmex_1'].nodes[6273], mdb.models['Model-1'].parts['carmex_1'].nodes[7608], mdb.models['Model-1'].parts['carmex_1'].nodes[7948]]
##	>>>
##	vector_angle_of_4nodes(labels_to_nodes(get_p1(),labels=[6014,6273,7608,7948]))  ## 好处，可以同时比较多个模型，假如号码位置不变的话。

##	>>> vector_angle_of_4nodes(labels_to_nodes(get_p1(),labels=[2197,1875,6901, 6679]))
##	angle = 90deg20'
##	>>> vector_angle_of_4nodes(labels_to_nodes(get_p1(),labels=[1875,2197,6901, 6679]))
##	angle = 90deg20'
##	>>> vector_angle_of_4nodes(labels_to_nodes(get_p1(),labels=[1875,2197,6679,6901]))
##	angle = 90deg20'
##	>>>

	if points == None:
		points = globals()[pick()]
	elif type_of(points) == 'STR':
		points = set2objs(get_p1(),name=points)

##	sort = GUI_inputs(keys=['nodes sort by x,y or z ?'])
	str1 = ''
	if type_of(sort) == 'STR' and sort.lower() in ['x','y','z']:
		if sort == 'x':
			points = nodes_sort_byx(points)
		elif sort == 'y':
			points = nodes_sort_byy(points)
		else:
			points = nodes_sort_byz(points)

		labels = labels_of_nodes(points)
		print fnln(),'labels=',labels
		str1 = 'angle_of_4nodes(labels_to_nodes(get_p1(),labels=' + str(labels) + '))'

	vector1,vector2 = two_vectors_of_4points(points)
	angle = vector_angle(vector1=vector1,vector2=vector2,absolute=False)
	angle = smart_round(angle)

	minutes = (angle - int(angle))*60
	minutes = int(minutes)
	print fnln(),'angle =',str(int(angle)) + 'deg' + str(minutes) + "'"

	if str1 != '':
		print ' '
		print str1

	return angle

angle_of_4nodes = vector_angle_of_4nodes

def vector_directions(vector):
	## VER: 2014-10-17, v1.0
	## reference: edir_of_vector(), 确定的是最倾向的某个方向

	if is_location(vector) == False:
		raise Exception('*** numeric vector is required.')

	x1,y1,z1 = vector

	nx = 0
	ny = 0
	nz = 0

	if x1 > 0:
		nx = 1
	elif x1 < 0:
		nx = -1

	if y1 > 0:
		ny = 1
	elif y1 < 0:
		ny = -1

	if z1 > 0:
		nz = 1
	elif z1 < 0:
		nz = -1

	dirs = [nx,ny,nz]

	return dirs

def vector_in_01(vector,angle_err=8):
	## VER: 2015-05-26, v1.1
	## reference: face_normal_in_num(),
	## 角度大于85度认为是0度。

	if is_location(vector) == False:
		raise Exception('*** a location type vector is requird.')

	vector = normalized_vector(vector)
	angle_x = vector_angle(vector,axis='x')
##	print fnln(),'angle_x=',angle_x
	if angle_x > 90 - angle_err:   ## 例如:>85deg
		x0 = 0
	else:
		if vector[0] > 0:
			x0 = 1
		else:
			x0 = -1

	angle_y = vector_angle(vector,axis='y')
##	print fnln(),'angle_y=',angle_y
	if angle_y > 90 - angle_err:
		y0 = 0
	else:
		if vector[1] > 0:
			y0 = 1
		else:
			y0 = -1

	angle_z = vector_angle(vector,axis='z')
##	print fnln(),'angle_z=',angle_z
	if angle_z > 90 - angle_err:
		z0 = 0
	else:
		if vector[2] > 0:
			z0 = 1
		else:
			z0 = -1

	dir1 = [x0,y0,z0]

	return dir1

function_labels['vector_of_2nodes'] = 'points','nodes','vector angle'
def vector_of_2nodes(nodes):
	## VER: 2016-11-21, v1.0

	nodes = tolist(nodes)
	x1,y1,z1 = point_loc(nodes[0])
	x2,y2,z2 = point_loc(nodes[1])

	vector = normalized_vector((x2-x1,y2-y1,z2-z1))

	return vector


function_labels['vector_of_two_points'] = 'vector','angle','nodes','points','loc'
def vector_of_two_points(loc1,loc2=None):
	## VER: 2016-11-21, v1.5, 获得从起点到终点方向的矢量，是一组平方和为1的数值。可能指向正方向，也可能指向负方向。

##>>> vector_of_two_points((0,0,0),(2,0,0))
##(1.0, 0.0, 0.0)
##>>>
##>>> vector_of_two_points((2,0,0))
##(1.0, 0.0, 0.0)
##>>>

	## applicable for vertice, node, datumpoint and loc
##	print fnln(),'loc1=',loc1
	if loc2 in empty and len(loc1) == 2 and not is_number(loc1[0]):
		loc2 = loc1[1]
		loc1 = loc1[0]

##	print fnln(),'loc1=',loc1
	loc1 = point_loc(loc1)
	if loc2 not in empty:
		loc2 = point_loc(loc2)

	if is_location(loc1) == False:
		raise Exception('*** loc1 should be a location.')

	if loc2 in empty:
		loc2 = loc1
		loc1 = (0,0,0)

	if is_location(loc2) == False:
		raise Exception('*** loc2 should be a location.')

##	print fnln(),'loc1=',loc1
	if len(loc1) == 3:
		x1,y1,z1 = loc1
	elif len(loc1) == 2:
		x1,y1 = loc1;	z1=0

	if len(loc2) == 3:
		x2,y2,z2 = loc2
	elif len(loc2) == 2:
		x2,y2 = loc2;	z2 = 0

	L = sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)
	vector = (x2-x1)/L, (y2-y1)/L, (z2-z1)/L
##	vector = totuple(round_loc(vector,num=8))
##	vector = totuple(vector)  ## 已经是normalized vector，无需再归一化。
	vector = positive_vector(vector)

	return vector

def vertical_construction(sketch,loc=(0,0),x=None):
	## VER: 2014-10-29, v1.1

	sketch = check_sketch(sketch)
	if is_number(x):
		loc = (x,0)

	if type_of(loc) == 'vertices':
		pt = loc
		loc = pt.coords

	if is_location(loc) == False:
		raise Exception('*** location is required.')

	Vline = sketch.ConstructionLine(point1=loc, angle=90)
	sketch.FixedConstraint(entity=Vline)
	sketch.VerticalConstraint(entity=Vline, addUndoState=False)   ## 不能省略

	return Vline

def vertice_select(p,x=(),y=(),z=(), space=(), xpoint=None,ypoint=None,zpoint=None,vertices=None, nx=None,ny=None,nz=None,
	edges=None, faces=None, groupX=None, groupY=None, groupZ=None, thenY=None, include_mid_points=False, tryone=False, onEdge=True):
	## VER: ('VER: 2016-08-11, v3.0')
	## xpoint, ypoint, zpoint表示x, y, z方向的点中最大的位置或最小的位置。
	## Reference: box_select()

##	>>> p = _inst('Cap_A1')
##	>>> vertices = box_select(p.vertices,x=MIN)  ## 有时，比vertice_select()更高效准确,当点的位置精细到小数点6位时，vertice_select()可能选不中
##	---> 1 vertices are selected by box_select(), err= 0.1

	## Example: vertice_select(powder,x=MAX1,groupY=MIN)  ## land处的edge

##	>>> edges = edge_select(powder,ny=-1)   ## 3 edges selected.
##	>>> vertice = vertice_select(powder, edges=edges, xpoint=MAX1)
##	>>> vertice
##	[mdb.models['Model-1'].parts['powder'].vertices.findAt((11.110957, -0.035381, 0.0),)]
##	>>>

	p = check_poi(p)

	if (nx,ny,nz) != (None,None,None):
		edges = edge_select(p,nx=nx,ny=ny,nz=nz)

	if edges not in empty:
		vertices = edges_to_vertices(edges)

	if faces not in empty:
		vertices = faces_to_vertices(faces)

	if vertices in empty:
		vertices = p.vertices[:]

	vertices = tolist(vertices)

	_x, _y, _z = x,y,z
	if is_numbers(xpoint) or xpoint in ['MIN',MIN,'MAX',MAX,MIN1,MAX1]:
		coords = locs_of_poi(p,vertices=vertices, axis='x',pointOn=False)
		if is_numbers(xpoint):
			nums = tolist(xpoint)
			xcoords = []
			for num in nums:
				if num > 0:
					xcoords.append(coords[num-1])
				else:
					xcoords.append(coords[num])
			x = min(xcoords),max(xcoords)

		elif xpoint in ['MIN',MIN]:
			x = coords[0]
		elif xpoint == MIN1:
			x = coords[1]
		elif xpoint in ['MAX',MAX]:
			x = coords[-1]
		elif xpoint in MAX1:
			x = coords[-2]

##	print fnln(),'x=',x
##	raise Exception

	if is_numbers(ypoint) or ypoint in ['MIN',MIN,'MAX',MAX,MIN1,MAX1]:
		coords = locs_of_poi(p,vertices=vertices, axis='y',pointOn=False)
		if is_numbers(ypoint):
			nums = tolist(ypoint)
			ycoords = []
			for num in nums:
				if num > 0:
					ycoords.append(coords[num-1])
				else:
					ycoords.append(coords[num])
			y = min(ycoords),max(ycoords)

		elif ypoint in ['MIN',MIN]:
			y = coords[0]
		elif ypoint == MIN1:
			y = coords[1]
		elif ypoint in ['MAX',MAX]:
			y = coords[-1]
		elif ypoint == MAX1:
			y = coords[-2]

##	print fnln(),'y=',y
##	raise Exception

	if is_numbers(zpoint) or zpoint in ['MIN',MIN,'MAX',MAX,MIN1,MAX1]:
		coords = locs_of_poi(p,vertices=vertices, axis='z',pointOn=False)
		if is_numbers(zpoint):
			nums = tolist(zpoint)
			zcoords = []
			for num in nums:
				if num > 0:
					zcoords.append(coords[num-1])
				else:
					zcoords.append(coords[num])
			z = min(zcoords),max(zcoords)

		elif zpoint in ['MIN',MIN]:
			z = coords[0]
		elif zpoint == MIN1:
			z = coords[1]
		elif zpoint in ['MAX',MAX]:
			z = coords[-1]
		elif zpoint == MAX1:
			z = coords[-2]

	x,y,z = real_xyz(p,x,y,z)
	x1,x2,y1,y2,z1,z2 = tospace(x,y,z)
	x10,x20,y10,y20,z10,z20 = poi_space(p)
##	print fnln(),'x1,x2,y1,y2,z1,z2=',(x1,x2,y1,y2,z1,z2)

	x0,y0,z0 = x,y,z
	if type_of(x0) in numerics and _x not in ['MIN1','MAX1']:
		if abs(x0 - x10) < 1e-3:
			x0 = MIN
		elif abs(x0 - x20) < 1e-3:
			x0 = MAX

	if type_of(z0) in numerics and _y not in ['MIN1','MAX1']:
		if abs(z0 - z10) < 1e-3:
			z0 = MIN
		elif abs(z0 - z20) < 1e-3:
			z0 = MAX

	if type_of(y0) in numerics and _z not in ['MIN1','MAX1']:
		if abs(y0 - y10) < 1e-3:
			y0 = MIN
		elif abs(y0 - y20) < 1e-3:
			y0 = MAX

##	print fnln(),len(vertices)
##	create_set(p,vertices=vertices,name='_points')

	pointOns_all = []
	for pt in vertices:
		pointOns_all.append(pt.pointOn[0])

	mypoints = []
	for vertice in vertices:
		ptCoords = vertice.pointOn[0]   ## Below can use within_space() function also
		if meet_search_range(ptCoords[0],(x1,x2),include_ends=True):
			if meet_search_range(ptCoords[1],(y1,y2),include_ends=True):
				if meet_search_range(ptCoords[2],(z1,z2),include_ends=True):
					if vertice not in mypoints:
						mypoints.append(vertice)

						if tryone == True:
							break

##	print fnln(),len(mypoints)
##	create_set(p,vertices=mypoints,name='_points1')
##	raise Exception

##	print fnln(),'len(mypoints)=',len(mypoints)

	## 如果找不到，参考sketch_vertice_select()处理，针对min max情形。
	if mypoints in empty:
		if x0 in [MIN,MAX] and y0 in empty and z0 in empty:
			pointOns = sort_tuple_type_elements(pointOns_all,index=0)

			reselect = False
			if x0 == MIN:
				loc = pointOns[0][0]
				if abs(loc - x10) < 1e-3:
					reselect = True
			elif x0 == MAX:
				loc = pointOns[-1][0]
				if abs(loc - x20) < 1e-3:
					reselect = True

			if reselect == True:
				for pt in vertices:
					loc1 = pt.pointOn[0][0]
					if abs(loc - loc1) < 1e-4:
						mypoints.append(pt)

		elif y0 in [MIN,MAX] and x0 in empty and z0 in empty:
			pointOns = sort_tuple_type_elements(pointOns_all,index=1)

			reselect = False
			if y0 == MIN:
				loc = pointOns[0][1]
				if abs(loc - y10) < 1e-3:
					reselect = True
			elif y0 == MAX:
				loc = pointOns[-1][1]
				if abs(loc - y20) < 1e-3:
					reselect = True

			if reselect == True:
				for pt in vertices:
					loc1 = pt.pointOn[0][1]
					if abs(loc - loc1) < 1e-4:
						mypoints.append(pt)

		elif z0 in [MIN,MAX] and x0 in empty and y0 in empty:
			pointOns = sort_tuple_type_elements(pointOns_all,index=2)

			reselect = False
			if z0 == MIN:
				loc = pointOns[0][2]
				if abs(loc - z10) < 1e-3:
					reselect = True
			elif z0 == MAX:
				loc = pointOns[-1][2]
				if abs(loc - z20) < 1e-3:
					reselect = True

			if reselect == True:
				for pt in vertices:
					loc1 = pt.pointOn[0][2]
					if abs(loc - loc1) < 1e-4:
						mypoints.append(pt)

	callers = caller_names()
	if 'through_points_in_z' in callers or 'through_points_in_x' in callers or 'through_points_in_y' in callers:
		onEdge = False

	if onEdge == True:  # 例如圆弧的弧心将不被选入。face_select_by_wire_though
		newlist = []
		for pt in mypoints:
			if len(pt.getEdges()) > 0:
				newlist.append(pt)
		mypoints = newlist

##	print fnln(),len(mypoints)
##	print fnln(),'callers',caller_names()
##	create_set(p,vertices=mypoints,name='_points2')
##	raise Exception

	if mypoints not in empty and (groupX not in empty or groupY not in empty or groupZ not in empty):
		space = objs_space(mypoints)
		if groupX not in empty:
			groupX = real_xyz_in_space(space,x=groupX)
			mypoints = vertice_select(p=p, vertices=mypoints, x=groupX)
		elif groupY not in empty:
			groupY = real_xyz_in_space(space,y=groupY)
			mypoints = vertice_select(p=p, vertices=mypoints, y=groupY)
		elif groupZ not in empty:
			groupZ = real_xyz_in_space(space, z=groupZ)
			mypoints = vertice_select(p=p, vertices=mypoints, z=groupZ)

	if len(mypoints) == 0:
		print fnln_fnln(),'*** No vertice selected.'
	else:
		print len(mypoints),'vertices selected.'

	return mypoints

def vertice_ids_to_objs(sketch,vertices):
	## VER: 2014-10-29, v1.0

	sketch = check_sketch(sketch)

	vertices = tolist(vertices)
	if vertices in empty:
		raise Exception('*** no vertices.')

	if type_of(vertices[0]) != 'INT':
		raise Exception('*** vertices ids are required.')

	newlist = []
	for id in vertices:
		if id in sketch.vertices.keys():
			newlist.append(sketch.vertices[id])

	return newlist

def vertices_of_objs(objs):

	## VER: ('VER: 2013-09-01, v1.1')		## 收集的是vertice。

	objs = tolist(objs)

	vertices = []
	for obj in objs:
		poi = get_poi(obj)
		for index1 in obj.getVertices():
			vertice = poi.vertices[index1]
			if vertice not in vertices:
				vertices.append(vertice)

	return vertices

def vertices_to_faces(vertices):
	## VER: 2015-07-06, v1.0
	## Reference: face_at()

	vertices = tolist(vertices)
	ids = []
	for point in vertices:
		ids.append(point.index)

	poi = get_poi(vertices)

	faces = []
	for face in poi.faces:
		pts = face.getVertices()
		if have_common(ids,pts):
			faces.append(face)

	return faces

def vertices_to_ids(vertices):
	## VER: 2014-10-29, v1.0

	vertices = tolist(vertices)
	newlist = []
	for pt in vertices:
		id = id_of_sketch_vertice(pt)
		newlist.append(id)

	return newlist

def vertices_to_pointOns(vertices):
	## VER: 2014-12-29, v1.0

	vertices = tolist(vertices)
	locs = []
	for vertice in vertices:
		loc = vertice.pointOn[0]
		if loc not in locs:
			locs.append(loc)

	return locs

def view_group(viewlist):

	print viewlist
	for mat in viewlist:
		mat1 = mat
		mat1.upper()
		leaf = dgo.LeafFromOdbElementMaterials(elementMaterials=(mat1, ))
		dg = session.DisplayGroup(leaf=leaf, name=mat1)

	a.regenerate()

	return

def common_objs(list1,list2):
	## VER: 2015-06-19, v1.0

## 获取两个侧面的交界线的节点
##	nodes = nodes_by_face(p1,ny=-1,y=MIN)
##	nodes2 = nodes_by_face(p1,z=MIN,nz=-1)
##	nodes3 = common_objs(nodes,nodes2)

	if len(list1) > 100 and len(list2) > 100:
		space1 = space_by_box(list1)
		space2 = space_by_box(list2)
		cross = cross_of_spaces(space1,space2)

		space = cross['cross_space']
		if space in empty:
			return []

		list1 = box_select(list1,space=space)
		list2 = box_select(list2,space=space)

	lists = tolist(list1) + tolist(list2)

	objs = []
	for obj in lists:
		if obj in list1 and obj in list2 and obj not in objs:
			objs.append(obj)

	return objs

def compensated_dimension(target_dim,real_dim,design_shrinkage=0.19,shrinkage_factor=None):
	## VER: 2016-05-09, v1.0, target_dim is the nominal dimension in the product specification
	## shrinkage factor = before/after, such as: 1->0.81, then shrinkage=0.19, and shrinkage factor=1/0.81=1.2346
	## design_shrinkage is the shrinkage used for engineering design, it may differ from the shrinkage of powder in the certificate
	## 公式: (green radius*SPEC)/(test result)
	## if FEM/test = 1.07, then test=FEM/1.07, 即: greenR*SPEC*1.07/FEM, 可能有greenR=SPEC*1.2346，也可能不是（例如经过补偿)

##	Tool design compensations are given for all 4 inserts,  by nominal*nominal*1.2346/sintered, where 1.2346 is the shrinkage factor.
##	>>> 80*80*1.2346/66.81    ## SPEC=80, FEM sintering result=66.81
##	118.267325250711
##	>>>
##	>>> compensated_dimension(60, 62.8, design_shrinkage=0.19)
##	70.77
##	>>> compensated_dimension(60, 62.8, shrinkage_factor=1.2346)
##	70.77
##	>>>

	if design_shrinkage > 1:
		design_shrinkage = design_shrinkage/100

	if design_shrinkage > 0.7:	## such as, sometimes people say shrinkage = 0.81, it is actually 0.19
		design_shrinkage = 1 - design_shrinkage

	if is_number(shrinkage_factor):
		if shrinkage_factor < 1:
			raise Exception('*** shrinkage factor should be > 1')

	else:
		shrinkage_factor = 1/(1-design_shrinkage)   ## 1/(1-0.19) = 1.2346

	new_dim = target_dim*target_dim*shrinkage_factor/real_dim
	new_dim = round(new_dim,2)

	return new_dim

function_labels['compensated_dimension'] = 'insert','tool design','sintering','powder compaction'

def compress_ratio():
	## VER: 2013-11-15, v1.0

	refresh()
	if 'fill_part' not in _m.parts.keys():
		raise Exception('*** No such part named fill_part')

	if 'green' not in _m.parts.keys():
		raise Exception('*** No such part named green part')

	n = get_volume(fill_part)/get_volume(green)
	n = round(n, 4)   ## 压缩比 = before/after

	ratio = (n - 1)/n*100
	ratio = round(ratio,3) ## 压缩率 = (前-后)/前

	return n, ratio

function_labels['compress_ratio'] = 'tool design','sintering','powder compaction'

def volume_to_mass(insts=None,density=None):
	## VER: 2014-07-02, v1.0

	if density == None:
		density = 7.9e3*KD   ## steel

	if insts in empty:
		insts = objs_of_dg()

	if insts in empty:
		raise Exception('*** fail to get the insts list.')

	volume = get_volume(insts=insts)
	mass = density*volume*1000

	mass = round(mass,2)
	print 'mass =', mass, 'kg'

	return mass

def vplot(insts,variable='S1'):
	## VER: 2015-03-28, v1.0

	## Example:
	## vplot('carbide','U1')
	## vplot('car')  ## carbide

	plot_insts(insts)
	plot_variable(variable)
	refresh()

	return
plot_contour = vplot

def vrotate(angle=0):
	## 2011-02-25, v1.0.

	"""Usage:
   vrotate(-90)      -->绕着屏幕法线旋转，顺时针，角度为90度。
   vrotate(90)       -->绕着屏幕法线旋转，逆时针，角度为90度。
	"""

	pars = get_inputs(locals(),xValues=0)
	if pars in empty:
		print vrotate.__doc__

	vpnow = get_vpnow()
	vpnow.view.rotate(xAngle=0, yAngle=0, zAngle=angle, mode=SCREEN)

	return

function_labels['viewport_to_image'] = 'print','file','save'
def viewport_to_image(name='',prefix='', postfix='_1', format='.png', viewports=(), path=None, update=True,
	save_at_work=True,avi=False, vname='', input_text='', value_loc='',scale=1,unit='',float=2):
	## VER: 2016-05-16, v2.5
	## GUI: File->Print...

##	>>> viewport_to_image()
##	['viewport_to_image', 74960] vname=
##	['update_all_viewports', 73483] viewport name= Viewport: 1
##	['update_all_viewports', 73484] viewport_type= MDB
##	['update_mdb_viewport', 73814] obj_info= 3D_shell_mesh discrete rigid , elements = 'R3D4'
##	('Z:/A0271-A0274-USM_insert_B106_B109/sintering/images/model/_B105_expansion_model_3.png', PNG, (session.viewports['Viewport: 1'],))
##	>>>

	global odb_file_title

	if update == True:
		delete_all_annotations()   ## Otherwise, anotations will only show on one of the odb viewports
		keep_anotation = False
	else:
		keep_anotation = True

	vpnow = get_vpnow()

	if getpass.getuser() == ME:
		save_at_work = False

	if viewports in empty:
		viewports = tuple(session.viewports.values())

	if avi == False:
		subfold = '/images'
		format = totext(format)
		format = format.upper()
		if format[0] == '.':
			format = format[1:]
		format = eval(format)

	else:
		subfold = '/avi'
		format = AVI

	if path in empty:
		dpo = viewports[0].displayedObject
		type1 = type_of(dpo)
		if type1 in ['PART','ASSEMBLY','sketch']:
			path = mdb.pathName
			loc=path.rfind('\\')
			path = real_dir(path[:loc])
		elif type1 == 'ODB':
			path = dpo.path
			loc = path.rfind('/')
			path = real_dir(path[:loc])
		elif type1 == 'XYPLOT':
			path0 = viewports[0].odbDisplay.name   ## use the odb directory as the base directory.
			loc = path0.rfind('/')
			path = real_dir(path0[:loc])
			odb_file_title = path0[loc + 1:]
			if odb_file_title.endswith('.odb'):
				odb_file_title = odb_file_title[:-4]   ## remove: '.odb'

		else:
			if save_at_work == False:
				loc1 = locs_of_substring(script_file_dir,'/')[-2]
##				path = script_file_dir[:loc1] + subfold
				path = script_file_dir[:loc1]
			else:
##				path = work_dir + subfold
				path = work_dir

		path = path + subfold
	path = real_dir(path)

	if path in empty:
		raise Exception('**** Error path to save avi.')
	else:
		if not os.path.isdir(path):
			os.makedirs(path)

##	print 'value_loc=',value_loc
##	raise Exception

	print fnln(),'vname=',vname
##	raise Exception

	if update == True:   ## save the image of setting in refresh() for name = 1
		update_all_viewports(vname=vname, input_text=input_text, value_loc=value_loc, scale=scale, unit=unit, float=float)
	else:
		name = ''
##	raise Exception

	file_name = ''

	if type_of(name) == 'STR':
		file_name = name   ## manualy provide the file name
		file_name = modify_string(file_name,'.','p')

	if len(viewports) == 1:
		vpnow = session.viewports.values()[0]
		type1 = type_of(vpnow.displayedObject)

##		print fnln(),'type1=',type1
		if type1 in ['PART','ASSEMBLY','sketch']:
			get_cae_file_title()
			sub_folder = 'model'
			if file_name in empty:
				file_name = prefix + brief_file_name(cae_file_title) + '_model' + postfix
		elif type1 == 'ODB':
			odb_file_title = get_odb_file_title()
			state = get_plot_state()
			print fnln(),'plot state=',state
			if state == UNDEFORMED:
				label = 'undeformed'
			elif state == DEFORMED:
				label = 'deformed'
			else:
				setting = current_variable_setting()
##				refinement = setting['refinement']
##				print fnln(),'refinement=',refinement
				if setting['sub'] not in empty and setting['sub'] != 'Magnitude':
					label = setting['sub']
				else:
					label = setting['main']
				label = modify_string(label,'.')

			print fnln(),'label=',label
##			raise Exception
			sub_folder = label
			if file_name in empty:
				file_name = prefix + brief_file_name(odb_file_title) + '_' + label + postfix
		elif type1 == 'XYPLOT':
			sub_folder = 'xyplot'
			variables = get_xyplot_variables()
			file_name = prefix + brief_file_name(odb_file_title) + '_xyplot_' + variables + '_' + postfix
			file_name = modify_string(file_name, '__', '_')
			file_name = xyplot_curves_to_file(file_name,update=update)
##			file_name = file_name + '_TXT'

	else:
		sub_folder = 'mix'
		if prefix not in empty:
			if prefix[-1] == '_':
				prefix = prefix[:-1]
		else:
			prefix = ''

		file_name = prefix
		print fnln(),'file_name=',file_name
##		raise Exception

		viewports0 = session.viewports.keys()
		viewports0.sort()
		i = 0
		for viewport_name in viewports0:
			vpnow = session.viewports[viewport_name]
			vpnow.makeCurrent()
			i = i + 1

			type1 = type_of(vpnow.displayedObject)
			if type1 in ['PART','ASSEMBLY','sketch']:
				cae_name = get_cae_file_title()

				file_title = modify_string(cae_name, ' ','_')
				file_title = modify_string(file_title, '-','_')

				loc = file_title.find('_')
				if loc == -1:
					loc = len(file_title)

				name1 = file_title[:loc] + '_model'
				if name1 in file_name:
					name1 = ''

				file_name = file_name + name1 + '_'

			elif type1 == 'ODB':
				odb_name = get_odb_file_title()

				file_title = modify_string(odb_name, ' ','_')
				file_title = modify_string(file_title, '-','_')

				loc = file_title.find('_')
				if loc == -1:
					loc = len(file_title)

				state = get_plot_state()
				if state == UNDEFORMED:
					label = 'undeformed'
				elif state == DEFORMED:
					label = 'deformed'
				else:
					setting = current_variable_setting()
					refinement = setting['refinement']
					if refinement not in empty:
						label = refinement[1]
					else:
						label = setting['main']
					label = modify_string(label,'.')

				name1 = file_title[:loc] + '_' + label
				if name1 in file_name:
					name1 = ''

				file_name = file_name + name1 + '_'

		file_name = file_name[:-1] + postfix

	path = path + '/' + sub_folder
	if not os.path.exists(path):
		os.makedirs(path)

	exist_files = get_files_in_dir(path,extension=format)

	file_name = new_key(exist_files,file_name)
	file_name = path + '/' + file_name

	file_name = real_dir(file_name)
	file_name = file_name + '.' + totext(format).lower()

	return file_name, format, viewports

##def vol_of(cells=[],poi=''):
##	## VER: 2010-03-03
##
##	vol = 0
##	a=mdb.models[_m.name].rootAssembly
##	setname = ''
##	if type_of(cells) == 'STR':
##		setname = cells
##		cells = set2objs(setname,p=poi)
##	if len(cells) > 0:
##		for cell in cells:
##			vol = vol + cell.getSize(printResults=False)
##	vol = int(round(vol/1000))
##	if setname != '':
##		print '  '
##		print '--->Volume =',vol,'cm3 for',setname
##
##	return vol

def fn_water2pressure(depth):
	## 2010-11-16, v1.0, lab水压荷载测试

	if depth > 10:
		depth = depth/1000		## unit: m

	press1 = int(1000*9.8*depth)
	press2 = int(1000*10*depth)

	print 'water depth=',int(depth*1000),'mm, pressure=', press1,'Pa, approx.=',press2,'Pa (g=10)'

	return

def fn_wind_load(land_location='sea_side',H=10,wall_location = 'wall_corner', basic_press='',wind_speed='',mph='',slope = 25, length=2000, width = 1000):
	## VER: 2011-04-28, v1.6
	##height: 标高
	##Uf: 阵风脉动系数
	##KK: 地面粗糙度调整系数
	##Uz: 风压高度变化系数
	##Bgz: 瞬时风压的阵风系数
	##Us: 局部风压体型系数, shape_factor
	##W0: 基本风压, basic_press
	##Wk: 风荷载标准值

	## Example
##	fn_wind_load('sea_side',wall_location = 'wall_corner',H=20,basic_press=450,slope=25)
##	print '   '
##	fn_wind_load('sea_side',wall_location = 'wall_corner',H=10,wind_speed=28.4,slope=35)

	##场地类型：
	land_location = land_location.lower()
	if land_location == 'sea' or land_location == 'sea_side':
		roughness = 'A'
	elif land_location == 'country':
		roughness = 'B'
	elif land_location == 'city':
		roughness = 'C'
	elif land_location == 'citycenter' or land_location == 'city_center':
		roughness = 'D'

	V3 = V600 = ''
	if mph != '':
		V3,V600 = fn_mph2ms(mph)
		wind_speed = V600

##	roughness = 'C'		##A-海岸/湖岸/沙漠地带,B-田野/乡村/小镇,C-城市（非市中心）,D-市中心（高楼林立）
##	print wind_speed, basic_press
	text_s = ''
	text_p = ''
	if (wind_speed != '' and basic_press == ''):
		basic_press = wind_speed*wind_speed/1.6
		text_p = '(由风速计算而得)'
	elif (wind_speed == basic_press == ''):
		wind_speed = 28.4
		basic_press = wind_speed*wind_speed/1.6
		text_p = '(由风速计算而得)'
	elif (wind_speed == '' and basic_press != ''):
		wind_speed = sqrt(basic_press*1.6)
		text_s = '(由风压计算而得)'
	elif (wind_speed != '' and basic_press != ''):
		wind_speed = sqrt(basic_press*1.6)
		text_s = '(由风压计算而得)'

	if V3 == V600 == '':
		V600 = wind_speed
		V3 = round(V600/0.703,2)

	P3 = round(V3*V3/1.6, 2)

	if within_range(wind_speed,24.5,28.4):
		text1 = '(10级狂风, 可拔起树来，损坏建筑物)'
	elif within_range(wind_speed,28.5,32.6):
		text1 = '(11级暴风, 陆上少见，有则必有广泛破坏)'
	elif wind_speed > 32.6:
		text1 = '(12级飓风, 陆上极少见,摧毁力极大)'
	elif wind_speed < 24.5:
		text1 = '(10级以下大风)'

	if roughness == 'A':
		Uf = 0.387*(H/10)**(-0.12)
		KK = 0.92
	elif roughness == 'B':
		Uf = 0.5*(H/10)(-0.16)
		KK = 0.89
	elif roughness == 'C':
		Uf = 0.734*(H/10)**(-0.22)
		KK = 0.85
	elif roughness == 'D':
		Uf = 1.2248*(H/10)**(-0.3)
		KK = 0.8

	Bgz = KK*(1 + 2*Uf)

	H0 = H
	if roughness == 'A':
		if H > 300:
			H0 = 300
		elif H < 5:
			H0 = 5

		Uz = 1.379*(H0/10)**(0.24)		##**改为exp或e都是错误的
	elif roughness == 'B':
		if H > 350:
			H0 = 350
		elif H < 10:
			H0 = 10

		Uz = (H0/10)**(0.32)
	elif roughness == 'C':
		if H > 400:
			H0 = 400
		elif H < 15:
			H0 = 15

		Uz = 0.616*(H0/10)**(0.44)
	elif roughness == 'D':
		if H > 450:
			H0 = 450
		elif H < 30:
			H0 = 30

		Uz = 0.318*(H0/10)**(0.6)

	##局部风压体型系数
	Area = length*width*1e-6
	if wall_location == 'wall_center':
		shape_factor = 1.2 - 0.2*log10(Area)
	elif wall_location == 'wall_corner':
		shape_factor = 2 - 0.36*log10(Area)
	elif wall_location == 'door_hang':
		shape_factor = 2 - 0.4*log10(Area)
	##elif usage == 'barwall':
	##	shape_factor = 1.0

	shape_factor = round(shape_factor,2)

	if wall_location == 'wall_center':
		shape_factor = 1.2
	elif wall_location == 'wall_turn' or wall_location == 'wall_corner':
		shape_factor = 1.8


	##风荷载标准值
	Wk = Bgz*shape_factor*Uz*basic_press

	if Wk < 1e-3:
		Wk = 1e-3

	design_load = round(Wk*1.5,2)

	print '  '
	print '风荷载计算(根据中国GB50009-2001<<建筑结构荷载规范>>进行计算，仅供参考):'
	print '  '
	str1 = '    安装地点: ' + land_location + ', H=' + str(H) + 'm。' + '风速V600=' + str(round(wind_speed,1)) + 'm/s' + text1 + text_s + ', 基本风压P3=' + str(int(P3)) + 'Pa, P600=' + str(int(basic_press)) + 'Pa' + text_p + ', 风压体型系数=' + str(shape_factor)
	print str1
	try:
		print '--->根据V3, 三倍基本风压(3*P3)=',int(P3*3),'Pa'
	except:
		print '--->根据V600, 三倍基本风压P600=',int(basic_press),'Pa'
	print '--->根据V600和P600, 风荷载标准值=',int(Wk),'Pa'
	print '--->风荷载设计值(标准值*1.5)=',int(design_load),'Pa'
##	str2 = '--->理想情况下，风平吹，在倾斜角为' + str(slope) + '度的组件表面上产生的法向风荷载=' + str(int(design_load)) + '*sin(' + str(slope) + ') = ' + str(int(slope_load)) + 'Pa'
##	print str2

	print '  '
	print '    Remark: 10级狂风=24.5~28.4m/s(可拔起树来，损坏建筑物), 11级暴风=28.5~32.6m/s(陆上少见，有则必有广泛破坏), 12级飓风=32.7~36.9m/s(陆上极少见,摧毁力极大)'
	print '   '

	return design_load

def is_sketch(obj):
	## VER: 2014-09-09, v1.0

	result = False
	get_current_model()

	if obj in _m.sketches.keys() or obj in _m.sketches.values():
		result = True

	return result

def sketch_to_shell(sketch, partname='part1',pshape='2D', ptype='deformable',symmetric=False):
	## VER: 2014-09-08, v2.1, sketch_to_shell.
	## Can only use sym in y
	## reference: sketch_to_shellpart()

	## sketch_to_shell(s1,partname='nib',symmetric=True)

	sketch = check_obj(sketch,_m.sketches)
	partname = new_key(partname,_m.parts)
	temp_sketch = new_key('bag_sketch_shell',_m.sketches)

	if len(sketch.geometry) == 0:  ## no geometry
		raise Exception('*** sketch ' + sketch.name + ' is empty.')

	pshape, ptype = real_pshape_and_ptype(pshape=pshape, ptype=ptype,symmetric=symmetric)

	s = _m.ConstrainedSketch(name=temp_sketch, sheetSize=200.0)
	g, v, d, c = s.geometry, s.vertices, s.dimensions, s.constraints
	s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
	s.setPrimaryObject(option=STANDALONE)

##	print 'pshape=',pshape
	if pshape == AXISYMMETRIC:
		s.ConstructionLine(point1=(0.0, -100.0), point2=(0.0, 100.0))
		s.FixedConstraint(entity=g[2])

	num0 = len(s.geometry)
	s.retrieveSketch(sketch=sketch)
##	num1 = len(s.geometry)
##	print fnln(),num1-num0,'geometry are copied from sketch',sketch.name

	_m.Part(name=partname, dimensionality=pshape, type=ptype)
	p = _m.parts[partname]
	p.BaseShell(sketch=s)
	s.unsetPrimaryObject()

	p = _m.parts[partname]
	vpnow = get_vpnow()
	vpnow.setValues(displayedObject=p)

	return partname

def sketch_to_shellpart(sketch,partname='shellpart',ndir=None,pshape='2D',ptype='deformable',symmetric=False, sym_axis='V', depth=5):
	## VER: 2014-04-20, v1.6, may have problem for symmetric part.
	## a shell part is always deformable in part type, but it can be constrained as rigid body.
	## pshape = 2D, 3D, axisymmetric
	## reference: extrude_sketch_to_part()

	## Example:
##	sketch_to_shellpart(s,partname='ejector_s')
##sketch_to_shellpart(s1,partname='crack', pshape='3D', depth=1.0)

	global _m, a

	simple_sketch = True
	if type_of(sketch) != 'DICT' or 'ndir' not in sketch.keys():
		if ndir != 'z':
			simple_sketch = True
		sketch = check_sketch(sketch)
	else:
		sketch = check_sketch(sketch,dict_sketch=True)

	name = sketch.name
	pshape, ptype = real_pshape_and_ptype(pshape=pshape, ptype=ptype,symmetric=symmetric)

	if pshape == AXISYMMETRIC:
		if sym_axis == 'H':
			curve = select_construction_lines(sketch,V=0)
			if curve in empty:
				create_construction(sketch,point1=(0,0),angle=0)

		elif sym_axis == 'V':
			curve = select_construction_lines(sketch,H=0)
			if curve in empty:
				create_construction(sketch,point1=(0,0),angle=90)

	show_sketch(name)
	hide_grid()

	partname = new_key(_m.parts.keys(),partname)
	_m.Part(name=partname, dimensionality=pshape, type=ptype)
	p = _m.parts[partname]

	if pshape in [TWO_D_PLANAR, AXISYMMETRIC]:
		if simple_sketch == True:
			p.BaseShell(sketch=_m.sketches[name])
			print '--->Created shell part',partname,'by simple sketch method'

		else:
			sketch2 = create_part_sketch(p, name='s_temp',ndir=sketch['ndir'],offset=sketch['offset'])

			p.Shell(sketchPlane=sketch2['datum_plane'], sketchUpEdge=sketch2['right_edge'], sketchPlaneSide=sketch2['side'],    ## 使用sketch2的datum，但是使用sketch的sketch
				sketchOrientation=RIGHT, sketch=sketch['sketch'])
			print '--->Created shell part',partname,'by datum sketch method'

	elif pshape == THREE_D:
		p.BaseShellExtrude(sketch=_m.sketches[name], depth=abs(depth))

	update_part(partname)

	return partname

def sketch_to_wire(sketch,partname='wirepart',ndir=None,pshape='2D',ptype='deformable',symmetric=False,del_temp=True):
	## VER: 2014-12-27, v1.9
	## An analytic rigid part sketch cannot have entities which lie on the centerline.
	## caller = geometry_select, so there should no geometry_select() in this function
	## ★reference: sketch_to_wirepart1()
	## 注意，这里的sketch是simple sketch, offset=0, ndir='z'

	## Example:
##	sketch_to_wire('sk_tpunch',partname='tpunch',symmetric=True, ptype='analy')
##	sketch_to_wire('sk_bpunch',partname='bpunch',symmetric=True, ptype='analy')
##	sketch_to_wire('sk_ejector',partname='corepin',symmetric=True, ptype='analy')
##	sketch_to_wire('sk_die',partname='die',symmetric=True, ptype='analy')

	## Example:
##	edges = edge_select(powder,ny=-1)
##	s1 = edges_to_sketch(edges,sketchname='sk_bpunch', ndir='z',offset=0)
##	connect_points(s1,'xmax',('dx',0.5))
##	sketch_to_wire(s1,partname='bpunch',symmetric=True,ptype='discrete')
##	new_instance(bpunch)

	sketch = check_sketch(sketch)
	partname = new_key(partname,_m.parts)
	caller = caller_lineno()
	temp_sketch = new_key('bag_sketch_wire',_m.sketches)  ## temp_sketch is a sketch name

	if len(sketch.geometry) == 0:  ## no geometry
		raise Exception('*** sketch ' + sketch.name + ' is empty.')

	sketch_name = sketch.name
##	print fnln(),'pshape=',pshape,', ptype=',ptype,', symmetric=',symmetric
	pshape, ptype = real_pshape_and_ptype(pshape=pshape, ptype=ptype,symmetric=symmetric)
##	print fnln(),'pshape=',pshape,', ptype=',ptype

##	stop1()

	s = _m.ConstrainedSketch(name=temp_sketch, sheetSize=200.0)
##	g, v, d, c = s.geometry, s.vertices, s.dimensions, s.constraints
	s.sketchOptions.setValues(decimalPlaces=4, viewStyle=AXISYM)
	s.setPrimaryObject(option=STANDALONE)

	if pshape == AXISYMMETRIC:
		s.ConstructionLine(point1=(0.0, -100.0), point2=(0.0, 100.0))
		s.FixedConstraint(entity=s.geometry[2])

	num0 = len(s.geometry)
	s.retrieveSketch(sketch=sketch)  ## important
##	num1 = len(s.geometry)
##	print fnln(),num1-num0,'geometry are copied from sketch',sketch.name

	_m.Part(name=partname, dimensionality=pshape, type=ptype)
	p = _m.parts[partname]

	if ptype == ANALYTIC_RIGID_SURFACE:
		if pshape == THREE_D:
			raise Exception('*** No such wire, use analytical shell instead.')
		p.AnalyticRigidSurf2DPlanar(sketch=s)   ## such as for: tpunch, die, bpunch
	else:
		p.BaseWire(sketch=s)   ## 对discrete regid, axisymmetric也是适用的。

	s.unsetPrimaryObject()

	p = _m.parts[partname]
	p.regenerate()

	if del_temp == True:
		del _m.sketches[temp_sketch]
##	vpnow = get_vpnow()
##	vpnow.setValues(displayedObject=p)

	return partname


def sketch_to_wirepart1(sketch,partname='wirepart',ndir=None,pshape='3D',ptype='deformable',symmetric=False,sym_axis='V'):
	## VER: 2013-11-19, v1.7
	## An analytic rigid part sketch cannot have entities which lie on the centerline.
	## caller = geometry_select, so there should no geometry_select() in this function
	## reference: sketch_to_wire()

	global _m, a

	simple_sketch = True
	if type_of(sketch) != 'DICT' or 'ndir' not in sketch.keys():
		if ndir != 'z':
			simple_sketch = True
		sketch = check_sketch(sketch)
	else:
		sketch = check_sketch(sketch,dict_sketch=True)

	if len(sketch.geometry) == 0:  ## no geometry
		raise Exception('*** sketch ' + sketch.name + ' is empty.')

	name = sketch.name
	pshape, ptype = real_pshape_and_ptype(pshape=pshape, ptype=ptype,symmetric=symmetric)

	if pshape == AXISYMMETRIC:
		if sym_axis == 'H':
			regular_lines,construction_lines = select_lines_in_sketch(sketch,V=0)
			if regular_lines not in empty:
				name1 = copy_sketch(sketch,name)
				sketch = _m.sketches[name1]
				name = name1
				regular_lines,construction_lines = select_lines_in_sketch(sketch,V=0)

				del_sketch_objs(sketch,regular_lines)
				del_sketch_objs(sketch,construction_lines)

			create_construction(sketch,point1=(0,0),angle=0)

		elif sym_axis == 'V':
			regular_lines,construction_lines = select_lines_in_sketch(sketch,H=0)
			if regular_lines not in empty:
				name1 = copy_sketch(sketch,name)
				sketch = _m.sketches[name1]
				name = name1
				regular_lines,construction_lines = select_lines_in_sketch(sketch,H=0)

				del_sketch_objs(sketch,regular_lines)
				del_sketch_objs(sketch,construction_lines)

			create_construction(sketch,point1=(0,0),angle=90)

	show_sketch(name)
	hide_grid()

	partname = new_key(_m.parts.keys(),partname)
	_m.Part(name=partname, dimensionality=pshape, type=ptype)
	p = _m.parts[partname]

	if simple_sketch == True:
		if pshape != AXISYMMETRIC:
			p.BaseWire(sketch=sketch)
		else:
			p.AnalyticRigidSurf2DPlanar(sketch=sketch)  ## construction line is required.

		print fnln_fnln(),'--->Created wire part',partname,'by simple sketch method'

	else:
		sketch2 = create_part_sketch(p, name='s_temp',ndir=sketch['ndir'],offset=sketch['offset'])

		p.Wire(sketchPlane=sketch2['datum_plane'], sketchUpEdge=sketch2['right_edge'], sketchPlaneSide=SIDE1,    ## 使用sketch2的datum，但是使用sketch的sketch
			sketchOrientation=RIGHT, sketch=sketch['sketch'])
		print '--->Created wire part',partname,'by datum sketch method'

	update_part(partname)

	return partname

def within_list(value1,list1):
	## VER: 2010-12-22, v1.0. 看看value1是否in list1, 数值类型

	list1 = tolist(list1)
	if list1 in empty:
		raise Exception('****** list1 is empty.')

	if type_of(value1) not in ['FLOAT','INT']:
		raise Exception('****** A float or integer number is required.')

	within = False
	for item in list1:   ## 每个item就是一个list
		if within_range(value1,item):
			return True

	return False

function_labels['within_range'] = 'range','space','within','cross'
def within_range(value1,end1,end2=''):
	## VER: 2013-12-30, v1.7 看看value1是否位于(end1,end2)中
	## reference: within_space()

##	>>> within_range(5,3,8)
##	True
##	>>> within_range(5,5)
##	True
##	>>> within_range(5,5,6)
##	True
##	>>> within_range(5,5,4)
##	True
##	>>> within_range(5,4,5)
##	True
##	>>>

	if type_of(value1) not in ['INT','FLOAT']:
		raise Exception('******value1 should be one INT or FLOAT data for within_range() function')

	if end2 in empty:
		type1 = type_of(end1)
		if type1 in ['INT','FLOAT']:
			end2 = end1
		elif type1 in ['LIST','TUPLE']:
			len1 = len(end1)
			if len1 == 0:
				return False
			elif len1 == 1:
				temp = end1
				end1 = end2 = temp[0]
			elif len1 == 2:
				temp = end1
				end1 = temp[0]
				end2 = temp[1]

	please_check
	err = 2e-6  ## Cannot be 1e-5, 因为cae的精度是1e-6。

	if end1 > end2:
		end1,end2 = end2,end1

	match1 = False
	pk1 = PK(end1,value1)
	pk2 = PK(value1,end2)

	if pk1 == 0 or pk2 == 0:
		match1 = True
	else:
		if pk1 == '<' and pk2 == '<':
			match1 = True

	return match1

function_labels['within_space'] = 'range','space','within','cross'
def within_space(space,loc,include_ends=True):
	## VER: 2017-11-12, v1.3
	## Reference: within_range()

##	>>> space = (0,5,1,2,-1,3)
##	>>> loc1=(1,3)
##	>>> within_space(space,loc1)
##	False
##	>>> within_space(loc1,space)
##	False
##	>>>

	if len(loc) == 6:
		space,loc = loc,space

	if is_location(space):
		space,loc = loc,space

	if len(space) != 6:
		raise Exception('*** a space is required showing x,y,z range')
	x1,x2,y1,y2,z1,z2 = space

	if is_location(loc) == False:
		raise Exception('*** location point is required.')

	if len(loc) == 2:
		loc = loc[0],loc[1],0
	x0,y0,z0 = loc

	inside = False
	if meet_search_range(x0,(x1,x2),include_ends=include_ends):
		if meet_search_range(y0,(y1,y2),include_ends=include_ends):
			if meet_search_range(z0,(z1,z2),include_ends=include_ends):
				inside = True

	return inside


def find_powder_inst():
	## VER: 2015-06-01, v1.0
	## find the powder instant in the compaction odb, not the sintering odb

	instname = ''
	for inst in oa.instances.values():
		if inst.type == DEFORMABLE_BODY:
			if 'H10POW' in inst.elements[0].sectionCategory.name:
				instname = inst.name
				break

	if instname in empty:
		print fnln(), '*** A compaction odb is required.'

	return instname

def write_density_and_element_labels(filename='_output_density.txt', step_name=None,step_id=None, instname=None,
	ranges=(0.5, 0.3, 0.3, 0.5),step_in=0.0003,step_out=0.001,reference=None,low=2,high=98,th=14.44,density_vol=None):
	## VER: 2016-09-05, v2.4, 慎用step_num
	## ranges means offset from reference
	## first density: low, average and high. offset = reference - average. All densities of element between this range
	## second density: offseted density, i.e.,  element density = density + offset   (move average)
	## third density: compressed density.
	## n1=reference-n1, n2=reference-n2, n3=reference+n3, n4=reference+n4


	## Example:
##	write_density_and_element_labels(step_num=-2)
##	density_distribution(low=1,high=98,th=th)

	## step_in = 0.0005
##	Output results:
##	663 elements with density < 7
##	122469 elements with density between (7, 9)
##	27558 elements with density > 9
##	Totally 150690 elements are output.
##	Totally (5801, 5801) density levels

	## step_in = 0.0004
##	Output results:
##	663 elements with density < 7
##	122469 elements with density between (7, 9)
##	27558 elements with density > 9
##	Totally 150690 elements are outputed with 6758 density levels

	## step_in = 0.0003
##	Output results:
##	663 elements with density < 7
##	122469 elements with density between (7, 9)
##	27558 elements with density > 9
##	Totally 150690 elements are outputed with 8324 density levels

##	step = check_odb_step(step_name=step_name,step_num=step_num, step_id=step_id)

	if density_vol in empty:
		step = check_odb_step(step_name=step_name, step_id=step_id)
		print 'step=',step
		print 'step name=',step.name
	##	raise Exception
		frame_id = len(step.frames) - 1

		## here: low, high in percentage
		distribution = density_distribution(low=low,high=high,th=th)	;changing    ## reference: 上下各去掉5%也是可以考虑的。或上下各去掉2%
		average = distribution['average']   ## calculated average from compaction modelling

		## here: low, high in g/cc

		print fnln(),'(low,high)=',(low,high),', in volume percentage'
		low = distribution['low_density']   ## now low in g/cc
		high = distribution['high_density'] ## now high in g/cc

		print fnln(),'(low,high)=',(low,high),', in g/cc'

		offset = 0
		if is_number(reference):
			offset = reference - average	;changing
		else:
			reference = average

		n1,n2,n3,n4 = ranges
		n1 = reference - abs(n1)   ## e.g, 7.5 - 0.5 = 7.0
		n2 = reference - abs(n2)   ## e.g, 7.5 - 0.3 = 7.2
		n3 = reference + n3   ## e.g, 7.5 + 0.3 = 7.8
		n4 = reference + n4   ## e.g, 7.5 + 0.5 = 8.0

		if instname not in empty:
			inst = check_odb_inst(instname)
			instname = inst.name
		else:
			instname = find_powder_inst()

		if instname not in oa.instances.keys():
			raise Exception('*** instname is required for density output.')

		insts = [oa.instances[instname]]

		elems = get_odb_elements(instname)
		elem_num = len(elems.values()[0])

		vpnow = get_vpnow()
		dpo = get_dpo()
		if type_of(dpo) !='ODB':
			raise Exception('*** An odb viewport is required.')

	##	levels = create_density_levels(ranges=ranges, int=step_in, out=step_out)
		vpnow.odbDisplay.setFrame(step=step.name, frame=-1)

		densities = step.frames[frame_id].fieldOutputs['DENSITY'].values

		print ' '
		print fnln(),'Collecting first density from compaction odb based on (low,high) ...'

		dict1 = {}
		elements = []
		for value in densities:
			if value.instance in insts:  	## value.instance is object,not instance name
				density = value.data
				density = density*1e9   ## density unit in g/cc

				## first density
				changing
				if density > high:  ## 97%
					density = high
				elif density < low: ## 3%
					density = low

				density = density + offset	;changing   ## second density

				if density <n2:  ## log10(100) = 2
					K1 = (density - n1)/(n2 - n1)*100
					if K1 > 0:
						K2 = log10(K1)
						K = K2/2.0
					else:
						K = 0
					density = n1 + (n2-n1)*K
				elif density > n3:
					K1 = (density - n3)/(n4 - n3)*100
					if K1 > 0:
						K2 = log10(K1)
						K = K2/2.0
					else:
						K = 0
					density = n3 + (n4-n3)*K

				## round to be 4 floats will be very slow in creating the materials.
				density = round(density,3)  ;changing  ## third density  ## ignore the step_in, step_out

				label = value.elementLabel

				if density not in dict1.keys():
					dict1[density] = []

				if label not in elements:
					dict1[density].append(label)
					elements.append(label)

		if len(elements) != elem_num:
			print fnln(),'len(elements)=',len(elements)
			print fnln(),'elem_num=',elem_num
			raise Exception('*** Some element data are not output or output twice.')

		print 'Totally',elem_num,'elements need to be output.'
		print ' '

	else:
		density_vol = sorted(density_vol, key=lambda item: item[0])   ## lambda:声明临时变量
##		density_vol = sort_tuple_type_elements(density_vol,index=0)

		dict1 = {}
		elements = []
		num = len(density_vol)
		for i in range(num):  ## low, high, mid就代表了体积分数
			density_e, vol_e, label = density_vol[i]
			density_e = round(density_e*1e9,3)

			if density_e not in dict1.keys():
				dict1[density_e] = []

			if label not in elements:
				dict1[density_e].append(label)
				elements.append(label)

	min0 = min(dict1.keys())
	max0 = max(dict1.keys())
	den_range = myrange(min0-0.5,max0+0.5,0.001)

	print ' '
	print 'Writing density and element labels...'
	print ' '

	file1 = open(filename,'w')
	print >> file1,'## density and corresponding element labels for ' + odb_file_title + '.odb'
	print >> file1,'## min density = ',min0,', with',len(dict1[min0]),'elements, max density =',max0,', with',len(dict1[max0]),'elements'
	print >> file1,' '

	for i in range(len(den_range)):
		density1 = den_range[i]
		if density1 in dict1.keys():
			print >> file1,'density  = ' + str(density1)
			print >> file1,'elements = ' + str(dict1[density1])
			print >> file1, ' '

	file1.close()

##	print ' '
##	print 'Output results:'
##	print num1,'elements with density <',n2
##	print num2,'elements with density between',(n2,n3)
##	print num3,'elements with density >',n3
##	print 'Total elements:',elem_num
##	print 'Totally',num1 + num2 + num3,'elements are outputed with',len(dict1),'density levels'
##	print 'ranges=',(n1,n2,n3,n4), ', reference =',reference
##	print ' '
##	print elem_num
##	print num1 + num2 + num3
##	if elem_num != num1 + num2 + num3:
##		raise Exception('*** Unmatched element numbers in the odb inst and in the output file.')

	return

def write_global_variables(file_name,*vars):

	## VER: ('VER: 2012-06-21, v1.9')	## 一个变量名的列表变量和其他单独变量不要同时出现在参数中。
	## vars可能是name list，也可能是value list。

	if type_of(file_name) == 'FILE':
		temp = file_name.name
		file_name.close()
		file_name = temp
	elif type_of(file_name) != 'STR':
		raise Exception('file name is required.')

	if len(vars) == 0:
		raise Exception('Variable is required for write to file.')

	vars = tolist(vars)

	name_list = True
	for item in vars:
		if type_of(item) != 'STR' or item not in globals().keys():
			name_list = False		##传值，不是传名
			break

	if name_list == True:
		variables = vars
##		print fnln_fnln(),'name_list = True, input variables='
##		print fnln_fnln(),vars
	else:
		print fnln_fnln(),'input values=',vars
##		print 'name_list = False, write_global_variables()接受到的是变量值的列表，而不是变量名的列表。若全局变量不存在，将把局部变量转变成全局变量。'
		print 'name_list = False, write_global_variables() receives a value list, not a variable names list. It will be converted to global variable if the global variable not exists.'
		values = vars
		variables = []

	if variables in empty:
		command = get_caller_code()
		command = modify_string(command,' ')
		command = modify_string(command,'"')
		command = modify_string(command,"'")

		print ' '
		print fnln_fnln(),'caller_code='
		print command

		locs = []
		for i in range(len(command)):
			char = command[i]
			if char in [',', ')']:
				locs.append(i)

		variables = []
		for i in range(len(locs) - 1):
			loc1 = locs[i]
			loc2 = locs[i+1]
			variables.append(command[loc1+1:loc2])

##		print fnln_fnln(), '通过get_caller_code()，得知要写的variables=',variables

	for i in range(len(variables)):
		name = variables[i]

		if name not in globals().keys():
			if name_list == False:
				value1 = values[i]
				globals()[name] = value1	## 将局部变量另存到全局变量
##				print fnln_fnln(),'**创建了与局部变量名一样的全局变量',name,'，其值=',value1
			else:
				raise Exception('name_list=True, 无法获得变量 ' + name + ' 的值，因此无法创建该全局变量。可以改用传值法，或先把该局部变量备份到全局变量表中。')

		else:
			if name_list == False:
				globals()[name] = values[i]
##			else:
##				print fnln_fnln(),'所要写的变量',name,'已经存在globals()中，且name_list=True，将不对该全局变量的值作任何改变。'

##		if file_name == var_file_full and name in level_of_this_run.keys() and treat_written == True:
##			continue

##		print 'name=',name
##		if file_name == var_file_full and name in level_of_this_run.keys():
##			continue

		if type_of(globals()[name]) == 'STR':
			line_print(file_name, '%s = "%s"' %(name,globals()[name]))
		else:
			line_print(file_name,name,'=',globals()[name])
##			if name_list == False:
##				print ' '
##				print name,'=',globals()[name]

	return

function_labels['list_to_txt_line'] = 'print','txt','parameters','output','var','write','data'
def list_to_txt_line(text_file,*list1):
	## VER: 2017-08-14, v3.1   单行输出
	## reference: list_to_txt_lines()  ## 多行输出

##	list1 = ['a1',5,'b1',6]
##	list_to_txt_line('_test.txt',list1)
##	a1   5    b1  6

##	computer_name = os.environ['COMPUTERNAME']
##	result_file = '_' + jobnum + '_results' + '_' + computer_name[:3] + '.txt'
##	result_file = script_path() + result_file
##	list_to_txt_line(result_file,output_list)

##	result_file = '_' + jobnum + '_results' + '_' + computer_name[:3] + '.txt'
##	result_file = make_dir('results') + '/' + result_file
##	list_to_txt_line(result_file,output_list)

	list1 = tolist(list1)
	newlist = []
	for item in list1:
		if item != '':
			newlist.append(item)
	list1 = tuple(newlist)

	## 给list1匹配相应的format
	format = ''
	for i in range(len(list1)):
		item = list1[i]
		if type_of(item) not in numerics:
			item = str(item)

		if type_of(item) in ['STR','']:
			if i == 0:   ## job title, 但也不一定
				len1 = len(item)
				if len1 > 15 and len1 <= 30:
					len1 = 30
				elif len1 > 30:
					len1 = 50
				elif len1 > 10 and len1 <= 15:
					len1 = 15
				else:
					len1 = len1 + 2

##				if len1 <= 50:
##					len1 = 50
				len1 = str(len1)
				format = format + '%-' + len1 + '.' + len1 + 's '
			else:
				try:
					item1 = int(item)
					if i == 1:
						format = format + '%-3.3s '	## job_index
					else:
						format = format + '%-5.5s '
				except:
					L = str(len(item) + 2)
					format = format + '%-' + L + '.' + L + 's'

		elif type_of(item) == 'INT':
			width = len(str(item).ljust(4))
			width = str(width)
			format = format + '%-' + width + '.0f '

		elif type_of(item) == 'FLOAT' :
			format = format + '%-9.4f '

	## try to get the jobnum
##	filename = odb.analysisTitle   ## 需要odb 存在
##	loc = filename.find('_')
##	jobnum = ''
##	while True:
##		loc = loc + 1
##		char = filename[loc:loc+1]
##		if char.isdigit():
##			jobnum = jobnum + char
##		else:
##			break

	file1 = open(text_file,'a')
	print >> file1,format % list1   ## 单行输出，且添加的方式
	file1.close()

##	raise Exception

##	print ' '
##	print 'jobnum =',jobnum, ', then result_file =',text_file,', please correct the jobnum if needed.'
##	if '/' not in result_file:
##		print 'default to save in current work dirctory:',work_dir

##	raise Exception

	return

def write_results(outputs):

	## VER: ('VER: 2012-07-03, v1.2')
	## Example:
	## write_results("brief, 'text1', angle, FRPE, [LAM_A1, 'U3'], ['Si','Mises']")
	## write_results("brief, angle, EVAE, FRPE, [LAM_A1, 'U3'], ['Si','Mises'], ['Si','S22'], ['Si','S3']")

	check_odb()

	if type_of(outputs) != 'STR':
		raise Exception('A sequence in string is required.')

	outputs = tolist(outputs,open_element=True)
	output_list = []

	print fnln_fnln(),'outputs=',outputs

	for item in outputs:
		if item[0] in ['"', "'"]:	## 真正的字符串
			output_list.append(item[1:-1])
		elif item[0] in ['[','(']:
			item1 = item[1:-1].strip()
			if item1.count(',') != 1:
				raise Exception('Error output format.')
			loc = item1.find(',')

			setname=None
			instance=None
			variable=None

			if item1[0] in ['"', "'"]:
				setname = item1[:loc].strip()
				setname = setname[1:-1]
			else:
				instance = item1[:loc].strip()

			variable = item1[loc+1:].strip()
			if variable[0] in ['"',"'"]:
				variable = variable[1:-1]

			if setname not in empty:
				list1 = get_result(setname=setname,variable=variable,text = setname + '_' + variable)
			elif instance not in empty:
				list1 = get_result(instance=instance, variable=variable, text = instance + '_' + variable)

			output_list = output_list + list1

		else:
			item_value = eval(item.strip())
			if item_value != inp_file_title:
				output_list = output_list + [item,item_value]

	output_list = [inp_file_title] + output_list

	print fnln_fnln(),'output_list=',output_list

	line_print(var_file_full,' ')
	list_to_txt_line(var_file_full,output_list)

	return

def write_user_parameters(var_file_full,parameters=()):
	## VER: 2013-04-30, v1.0

	## Example (create_inp())
##	parameters = get_user_parameters()
##	write_user_parameters(jobname + '.vars',parameters=parameters)   ## will create the var file


	parameters = tolist(parameters)
	print ' '

##	open(var_file_full,'w').close()    ## 有什么用?
	file1 = open(var_file_full,'a')    ## 确保有该文件存在。但要及时关闭。
	file1.close()

	line_print(var_file_full,' ')
	line_print(var_file_full,'## var_panel:',len(parameters),'variables:')
	write_global_variables(var_file_full,parameters)
	line_print(var_file_full,' ')

##	raise Exception
	keys = level_of_this_run.keys()
	if keys not in empty:
		line_print(var_file_full,' ')
		line_print(var_file_full,'##**** level_of_this_run: written at',ln())
		write_global_variables(var_file_full,level_of_this_run)
		write_global_variables(var_file_full,keys)
		line_print(var_file_full,' ')

	print ' '

	return var_file_full

##def x_at(p,point_setname,index=0,dx=0):
##	## VER: 2010-02-06
##	return loc_at(point_setname,p,index,dx=dx)[0]

def _xlength(poi):
	## VER: 2012-03-04, v1.0

	try:
		poi = check_pias(poi)
		x1,x2,y1,y2,z1,z2 = poi_space(poi)
		result = round(x2-x1,6)
	except:
		sketch = check_sketch(poi)
		result = _xspan_sketch(sketch)

	return result

def xlist_of_sketch_points(sketch,y=None):
	## VER: 2013-11-01, v1.0

	sketch = check_sketch(sketch)
	locs = vertice_locs_of_geometry(sketch)

	if y not in empty:
		y = real_xy_sketch(sketch,y=y,Yonly=True)

	xs = []
	for loc in locs:
		x1,y1 = loc
		if x1 in xs:
			continue
		else:
			if type_of(y) in numerics:
				if PK(y1,y) == 0:
					xs.append(x1)
			else:
				xs.append(x1)

	xs.sort()

	return xs


##def xmove(start_kp,refer_kp,dx=0):
##	## VER: 2010-02-06
##	return vector('x',start_kp,refer_kp,dx)

##def y_at(p,point_setname,index=0,dy=0):
##	## VER: 2010-02-06
##	return loc_at(point_setname,p,index,dy=dy)[1]

def _ylength(poi):
	## VER: 2012-03-04, v1.0

	try:
		poi = check_pias(poi)
		x1,x2,y1,y2,z1,z2 = poi_space(poi)
		result = round(y2-y1,6)
	except:
		sketch = check_sketch(poi)
		result = _yspan_sketch(sketch)

	return result

def ylist_of_sketch_points(sketch,x=None):
	## VER: 2013-11-01, v1.0

	sketch = check_sketch(sketch)
	locs = vertice_locs_of_geometry(sketch)

	if x not in empty:
		x = real_xy_sketch(sketch,x=x,Xonly=True)

	ys = []
	for loc in locs:
		x1,y1 = loc
		if y1 in ys:
			continue
		else:
			if type_of(x) in numerics:
				if PK(x1,x) == 0:
					ys.append(y1)
			else:
				ys.append(y1)

	ys.sort()

	return ys


##def ymove(start_kp,refer_kp,dy=0):
##	## VER: 2010-02-06
##	return vector('y',start_kp,refer_kp,dy)
##
##def z_at(p,point_setname,index=0,dz=0):
##	## VER: 2010-02-06
##	return loc_at(point_setname,p,index,dz=dz)[2]

def _zlength(poi):
	## VER: 2012-03-04, v1.0

	poi = check_pias(poi)
	x1,x2,y1,y2,z1,z2 = poi_space(poi)

	return round(z2-z1,6)

def global_var_initiate():
	## VER: 2016-10-23, v2.1
	## 即使readonly，也要执行初始化。

	global empty, variable_dict, myglobals

	if 'myglobals' not in globals().keys():
		myglobals = {}

	keys0 = locals().keys()

##	## time
##	start_time = time.time();		_time11 = get_time()
##	_time2 = '';					_time21 = ''
##	run_times = []

	## string
	_ = '_'
	ME = 'vm7515'
	help = 'help'
	this = 'this'

	developed_by = 'Yuqi Jiang'

	## debug
	debug = False
	debug1 = False
	debug2 = False
	log = [];						_function_error = {}
	_err_info = []
	plot_history = []
	additional_datum = False
	function_start = {}
	slow_call = []
	screen = sys.stdout

	## Geometry
	bending_dirs = ['circular','arc','circle','ellipse','spline', 'cylindrical','conical', 'sphere','unknown',]
	bending_surface = ['unknown_surface','cylindrical_surface','conical_surface','sphere_surface']
	part_holes = {}
	_DH = 'DH'
	_DV = 'DV'
	_DT = 'DT'
	_H = 'H'
	_V = 'V'
	_T = 'T'

	## space
	insts_space = {}
	parts_space = {}
	odb_insts_space = {}
	fdict_space = {}
	fdict_collected = False
	image_parts = {}

	## step
	my_steps = {}
##	restart = False

	## interact
	contact_pairs =[]
	find_contact_com = 0
	msfaces_trace = []
	msfaces_determined = False

	## BCs
	BCs = {}
	BC_status = {}
	all_DOFs = ['x','y','z','UR1','UR2','UR3']

	## mesh
	seeded_edges = {}
	seeding_seq = {}

	## odb
	mm_unit = {}

	## csys
	local_csys = {}
	symmetry = {'dir':[], 'loc':[0,0,0]}
	O1 = 'O1';	O2 = 'O2';	O3 = 'O3';	O4 = 'O4'
	xdir = [(1,0,0),(-1,0,0),[1,0,0],[-1,0,0]]
	ydir = [(0,1,0),(0,-1,0),[0,1,0],[0,-1,0]]
	zdir = [(0,0,1),(0,0,-1),[0,0,1],[0,0,-1]]

	## colors:
	RED = '#FF0000'
	BLUE = '#0000FF'
	BLACK = '#000000'
	BROWN = '#800000'
	GREEN = '#00FF00'

	## design
##	level_of_this_run = {}
	options = []
	output_vars = {}
	powder_compaction = False

	## part
	_divide_num = 0
	default_plot = ''

	## min, max
	_max = 1e6; 	_min = -1e6; 	err = 1e-6;
	MID = 'MID'
	MIN1 = 'MIN1'
	MAX1 = 'MAX1'
	MAXp = 'MAXp'
	MINp = 'MINp'
	_nearby = 0.0005  ## 0.5um  ## 1um太大了，有时可能会有1um的间距。
	limits = [MAX,'MAX',MIN,'MIN']
	near_limits = [MAX1,MIN1]

	## holes
	M5 = 5
	M6 = 6
	M8 = 8
	M9 = 9
	M10 = 10

	## units

	room_temperature = 20   ## 20degC
	inch = 25.4    ## 1 inch = 25.4 mm
	Kin = 25.4
	m2inch = 25.4
	ksi = '1 ksi = 6.895 MPa'
	psi = '1 psi = 6.895 kPa'
	cur_mod = get_mod()

	## 膨胀系数转换(CTE): a 1/F 对应的标准单位为: a*9/5 = 1.8*a 1/degC   因为：degF = 9/5(degC + 32)   华氏温度与摄氏温度转换
	unit_system = 'mm'	;please_check
	K_inch = 25.4  ## 英寸inch: '', flange: '
	if unit_system == 'mm':  ## mm, N, sec
		KL = 1000
		KE = 1e-6	## pressure, stress, modulus
		KD = 1e-12	## density, tonne/mm3
		KF = 1		## Force, N
		K_accel = 1000		;	g = 9.8*K_accel
		K_mass = 1e-3	## mass
		K_current = 1   ## 电流
		K_energy = 1000	## 能量的单位是焦耳(J).  1 J = 1 W.sec = 1 N.m. mm单位制下为mJ(毫焦)
		K_power = 1000;  	## power, 瓦(w)的系数是1000。 mm单位制下为mW(毫瓦)
		K_Cp = 1e6		## specific heat, 比热，标准单位J/(kg.K)
		K_K = 1     	## thermal conductivity, 热导率，标准单位W/(m.K)    1W/m/K = 1mW/mm/K

		K_sflux = 1e-3	## 面热流率,heat flux，标准单位W/m^2。mm单位制下为mW/mm2
		K_flux = 1e-3	## 面热流率,heat flux，标准单位W/m^2
		K_hc = 1e-3		## 对流膜换热系数，convection coefficient, 标准单位：W/(m^2.K)
		K_bflux = 1e-6 ## 体热流率，标准单位W/m^3
		K_diff = 1e6   ## mm unit=mm2/s, SI unit=1m2/s

##　　对流换热系数的大致量级：
##　　空气自然对流 5 ～ 25
##　　气体强制对流 20 ～ 100
##　　水的自然对流 200 ～1000
##　　水的强制对流 1000 ～ 1500
##　　油类的强制对流 50 ～ 1500
##　　水蒸气的冷凝 5000 ～ 15000
##　　有机蒸汽的冷凝 500 ～ 2000
##　　水的沸腾 2500 ～ 25000

	elif unit_system == 'inch':  ## English, inch-pound force, s
		KL = 39.37
		K_accel = KL	;	g = 9.8*K_accel
		K_mass = 5.71e-3   ## lbf.s2/in
		KF = 0.22481  ## pound force (lbf)
		KE = 1.4504e-4  ## lbf/inch2, for stress, pressure
		KD = 9.3572e-8  ## lbf.s2/in4
		K_current = 1
		K_energy = 8.8507   ## lbf.in
		K_power = 8.8507  ## power(heat rate), SI=1W = 1J/s, now is: lbf.in/s
		K_Cp = 2.385e-4  ## Btu.in/lbf/s2/degF, SI=J/kg/K
		K_K = 1.33878e-5  ## Btu/in/sec/degF, SI=1W/m/K, conductivity

		K_sflux = 0.00571  ## lbf/s/in,  power per unit area (heat flux), SI=W/mm2
		K_hc = 0.00571   ## 对流膜换热系数，convection coefficient, 标准单位：W/(m^2.K)
		K_diff = 1549.9969   ## in2/s, thermal diffusivity(热扩散速率), alpha

	empty = ['',[],(),{},'NA','NULL',None,NONE,UNSET]  ## UNSET is for BCs
	numerics = ['INT','FLOAT','LONG']	## numerical value type
	basic_types = ['INT','FLOAT','LONG','STR','TUPLE','LIST','DICT','BOOL','NONE','']
	geometry_types = ['cells','faces','edges','vertices']

	part_members = ['allInternalSets', 'allInternalSurfaces', 'allSets', 'allSurfaces', 'beamSectionOrientations', 'cells', 'compositeLayups', 'datum', 'datums', 'edges', 'elemEdges', 'elemFaces', 'elementEdges', 'elementFaces', 'elements', 'engineeringFeatures', 'faces', 'features', 'featuresById', 'geometryPrecision', 'geometryRefinement', 'geometryValidity', 'ignoredEdges', 'ignoredVertices', 'ips', 'isOutOfDate', 'materialOrientations', 'modelName', 'name', 'nodes', 'rebarOrientations', 'referencePoints', 'reinforcements', 'sectionAssignments', 'sets', 'skins', 'space', 'stringers', 'surfaces', 'twist', 'type', 'vertices']
	assembly_members = ['allCompositeLayups', 'allInternalSets', 'allInternalSurfaces', 'allSets', 'allSurfaces', 'connectorOrientations', 'datum', 'datums', 'edges', 'elements', 'engineeringFeatures', 'features', 'featuresById', 'instances', 'isLocked', 'isOutOfDate', 'modelName', 'name', 'nodes', 'referencePoints', 'regenerateConstraintsTogether', 'sectionAssignments', 'sets', 'skins', 'stringers', 'surfaces', 'vertices']
	dpo_members = ['analysisTitle', 'closed', 'customData', 'description', 'diagnosticData', 'isReadOnly', 'jobData', 'materials', 'name', 'parts', 'path', 'profiles', 'rootAssembly', 'sectionCategories', 'sections', 'sectorDefinition', 'steps', 'userData']

	locals2globals(keys0,locals())

	## material
	get_current_model()
	material_database()
##	create_contact_props(friction=0.2)				;changing

	if len(cur_mod) < 5:
		make_dir('abaqus_plugins/'+cur_mod)

	## 注意：Avg: 75%表示相邻单元之间的云图变得圆滑过渡处理。
	variable_dict = {'LE': 'LE, Max. Principal (Avg: 75%)',
				'LE1': 'LE, Max. Principal (Avg: 75%)',
				'LE2': 'LE, Mid. Principal (Avg: 75%)',
				'LE3': 'LE, Min. Principal (Avg: 75%)',
				'LE11': 'LE, LE11 (Avg: 75%)',
				'LE22': 'LE, LE22 (Avg: 75%)',
				'LE33': 'LE, LE33 (Avg: 75%)',
				'LE12': 'LE, LE12 (Avg: 75%)',
				'LE13': 'LE, LE13 (Avg: 75%)',
				'LE23': 'LE, LE23 (Avg: 75%)',

				'PE': 'PE, Max. Principal (Avg: 75%)',
				'PE1': 'PE, Max. Principal (Avg: 75%)',
				'PE2': 'PE, Mid. Principal (Avg: 75%)',
				'PE3': 'PE, Min. Principal (Avg: 75%)',
				'PE11': 'PE, PE11 (Avg: 75%)',
				'PE22': 'PE, PE22 (Avg: 75%)',
				'PE33': 'PE, PE33 (Avg: 75%)',
				'PE12': 'PE, PE12 (Avg: 75%)',
				'PE13': 'PE, PE13 (Avg: 75%)',
				'PE23': 'PE, PE23 (Avg: 75%)',

				'PEEQ': 'PEEQ (Avg: 75%)',
				'PEMAG': 'PEMAG (Avg: 75%)',
				'RF': 'RF, Magnitude',
				'RF1': 'RF, RF1',
				'RF2': 'RF, RF2',
				'RF3': 'RF, RF3',
				'NT11': 'NT11',
				'TEMP': 'TEMP',
				'HFL': 'HFL, Magnitude',

				'Mises': 'S, Mises (Avg: 75%)',
				'S1': 'S, Max. Principal (Avg: 75%)',
				'S2': 'S, Mid. Principal (Avg: 75%)',
				'S3': 'S, Min. Principal (Avg: 75%)',
				'Tresca': 'S, Tresca (Avg: 75%)',
				'Pressure': 'S, Pressure (Avg: 75%)',
				'Third': 'S, Third Invariant (Avg: 75%)',
				'S11': 'S, S11 (Avg: 75%)',
				'S12': 'S, S12 (Avg: 75%)',
				'S13': 'S, S13 (Avg: 75%)',
				'S22': 'S, S22 (Avg: 75%)',
				'S23': 'S, S23 (Avg: 75%)',
				'S33': 'S, S33 (Avg: 75%)',

				'U': 'U, Magnitude',
				'U1': 'U, U1',
				'U2': 'U, U2',
				'U3': 'U, U3',
				'CF': 'CF, Magnitude',
				'CF1': 'CF, CF1',
				'CF2': 'CF, CF2',
				'CF3': 'CF, CF3',
				'AC': 'AC YIELD (Avg: 75%)' }

	all_variables = ('S', 'MISES', 'MISESMAX', 'TSHR', 'CTSHR', 'ALPHA', 'TRIAX', 'VS', 'PS',
    'CS11', 'ALPHAN', 'SSAVG', 'MISESONLY', 'PRESSONLY', 'E', 'VE', 'PE',
    'VEEQ', 'PEEQ', 'PEEQT', 'PEEQMAX', 'PEMAG', 'PEQC', 'EE', 'IE', 'THE',
    'NE', 'LE', 'ER', 'SE', 'SPE', 'SEPE', 'SEE', 'SEP', 'SALPHA', 'U', 'UT',
    'UR', 'V', 'VT', 'VR', 'RBANG', 'RBROT', 'RF', 'RT', 'RM', 'CF', 'SF',
    'TF', 'VF', 'ESF1', 'NFORC', 'NFORCSO', 'RBFOR', 'BF', 'CORIOMAG',
    'ROTAMAG', 'CENTMAG', 'CENTRIFMAG', 'GRAV', 'P', 'HP', 'TRSHR', 'TRNOR',
    'CSTRESS', 'CSTRESSETOS', 'CDSTRESS', 'CDISP', 'CDISPETOS', 'CFORCE',
    'CNAREA', 'CSTATUS', 'PPRESS', 'ENER', 'ELEN', 'ELEDEN', 'DAMAGEC',
    'DAMAGET', 'DAMAGEFT', 'DAMAGEFC', 'DAMAGEMT', 'DAMAGEMC', 'DAMAGESHR',
    'SDEG', 'JK', 'CFAILURE', 'DBS', 'DBT', 'DBSF', 'OPENBC', 'CRSTS', 'ENRRT',
    'EFENRRTR', 'BDSTAT', 'DMICRT', 'HSNFTCRT', 'HSNFCCRT', 'HSNMTCRT',
    'HSNMCCRT', 'ERPRATIO', 'SHRRATIO', 'CSDMG', 'CSMAXSCRT', 'CSMAXUCRT',
    'CSQUADSCRT', 'CSQUADUCRT', 'PHILSM', 'PSILSM', 'NT', 'TEMP', 'SJD',
    'SJDA', 'SJDT', 'SJDTA', 'CVOL', 'SVOL', 'EVOL', 'ESOL', 'IVOL', 'STH',
    'COORD', 'CSTRESSERI', 'SDV', 'FV', 'MFR', 'UVARM', 'STATUS',
    'STATUSXFEM')

    ## SDV: solution dependent state variables
    ## STATUS: status (Some failure and plasticity models; VUMAT)
    ## STATUSXFEM: status of xfem element
    ## UVARM: user defined output variables


	return

##if get_mod() == 'ASSEMBLY':
global_var_initiate()

##def zmove(start_kp,refer_kp,dz=0):
##	## VER: 2010-02-06
##	return vector('z',start_kp,refer_kp,dz)

def main_lap_joint():
	## VER: 2012-11-27, v1.0

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')


	create_plate('plate',length=30,width=10,thick=1.5)
	drill_hole(plate,x=7.5,y=MIN,radius=2.5)
	set_mat(plate,mat='Steel')

	new_instance(plate)
	rotate_instances(plate_A2,angle_y=180)

##	face2face(zmax_faces(plate_A2),zmin_faces(plate_A1))
	face2face(zmin_faces(plate_A1),zmax_faces(plate_A2))

##	stop()

	faces1 = face_select(plate_A1,ndir='cylindrical')
	faces2 = face_select(plate_A2,ndir='cylindrical')

	coaxial(faces2,faces1)  ## 最佳
##	coaxial(faces2,faces1)

##	stop()

	## sketch and part
	sketch1 = create_base_sketch('temp_sketch1',ndir='z', return_sketch=True)
##	print type_of(sketch1)
##	raise Exception

##	poly_lines_in_sketch(sketch1,expression='H=4,V=-1.5,H=-1.5,V=-3,H=1.5,V=-1.5,H=-4',closed=True)
	connect_points(sketch1,(0,0),{_DH:4},{_DV:-1.5}, {_DH:-1.5}, {_DV:-3}, {_DH:1.5}, {_DV:-1.5}, {_DH:-4},(0,0))
	create_construction(sketch1,point1=(0,0),angle=90)	## 不可或缺

	blank_part('rivet')  ##
	revolve_sketch_to_part(rivet,sketch1,angle=180,counter_clock=True)

##	stop()

	edges = edge_select(rivet,edir='circular',y=MAX)
	round_edges(rivet,edges,radius=0.75)

	edges = edge_select(rivet,edir='circular',y=MIN)
	chamfer_edges(rivet,edges,length=0.75)

	rotate_part(rivet,angle_x=90)
	new_instance(rivet)

	faces = face_select(rivet_A1,nz=-1)
	faces = reselect_by_pointOn(faces,zmax=True)
	face2face(move_face=faces,fix_face=zmax_faces(plate_A1))

	face1 = face_select(rivet_A1,ndir='circular')
	face2 = face_select(plate_A1,ndir='circular')
	coaxial(face1,face2,flip=OFF)

	raise Exception

	return

 ## ******************************************************************==========================================================================

def main_australia_die():

	## mold
	mold_length = 190
	mold_W = 172
	mold_H = 115

	wall_top = 25
	wall_right = 28
	wall_bot = 25
	wall_left = 28
	punch_bot_H = 25
	green_H = 75

	radius1 = 1
	radius3 = 3

	## drill
	drill_W = mold_length - wall_left - wall_right
	drill_H = mold_H - wall_top - wall_bot
	drill_length = mold_length + 5
	drill_H1 = 34
	drill_width1 = 82

	## load,jobname
	pressure = 70e6  ## 70MPa
	jobname = 'job_pressing_die'

	blank_part('mold')
	create_block(mold,x=(0,mold_W),y=(0,mold_length),z=(0,mold_H),mat='Steel')
	new_instance(mold)

	blank_part('drill')
	create_block(drill,x=(0,drill_W),y=(0,drill_length),z=(0,drill_H))

	hex_cut(drill,x=(0,drill_W - drill_width1),z=(0,drill_H - drill_H1))

	chamfer_edges(drill,tilt=8.41,x=MAX,z=MAX)   ## top right
	chamfer_edges(drill,tilt=8.41,x=MAX,z=MIN)   ## bot right
	chamfer_edges(drill,tilt=5.4,x=MIN,z=MAX)    ## top left

	chamfer_edges(drill,tilt=16.41,x=_xmin(drill,z=MIN),z=MIN)
	chamfer_edges(drill,tilt=3.41,x=MIN,z=_zmin(drill,x=MIN))

	round_edges(drill,x=drill_W - drill_width1, z=drill_H - drill_H1,radius=radius3)
	round_edges(drill,x=_xmin(drill,z=MAX),z=MAX,radius=radius1)
	round_edges(drill,x=MIN,z=_zmax(drill,x=MIN),radius=radius1)

	move_part(drill,x1=MAX,x2=_xmax(mold) - wall_right,z1=MAX,z2=_zmax(mold) - wall_top,y1=MID,y2=_ymid(mold))
	new_instance(drill)

	## cut and divide
	boolean_cut(mold,cutters=drill)
	batch_divide(mold,y=[punch_bot_H,punch_bot_H + green_H])

	faces = face_select(mold,poiRefX=(MIN,1,mold_W - 2), through_y=green_H + 10, poiRefZ=(MIN,1,mold_H - 2))
	create_set(mold,faces=faces,name='green_section')

	## load
	apply_pressure('load_press',magnitude=pressure,faces='green_section')

	## BC
	apply_disp_fix(name='fix_left', faces=xmin_faces(mold_A1),Ux=0)
	apply_disp_fix(name='fix_top', faces=zmax_faces(mold_A1),Uz=0)
	apply_disp_fix(name='fix_back', faces=ymax_faces(mold_A1),Uy=0)

	## mesh
	edges = edge_select(mold,poiRefX=(MIN,1,mold_W - 2), y=MIN, poiRefZ=(MIN,1,mold_H - 2))
	seed_edges(mold,edges=edges,esize=2)
	create_set(mold,edges=edges,name='edge_internal')

	mesh_part(mold,esize=5)

##	jobname = new_key(mdb.jobs,jobname)
##	create_inp(jobname)
##	mdb.jobs[jobname].submit()

	return


def main_A0192_press_tool():

##	create_general_static_step(stepname='high_temp',initial_inc=0.002)
##	create_general_static_step(stepname='pressing',initial_inc=0.002)

	##
##	create_coupled_temp_displacement_step(stepname=heat_step)
##	create_coupled_temp_displacement_step(stepname=shrink_step)
##	create_coupled_temp_displacement_step(stepname=shrink_step)

	## import
	stp_path = 'D:\JYQ\source\A0192_pressing_die_Matthew\stp\die_holder_2_asm.stp'
	import_stp(stp_path,part_names = {1:'steel',38:'carbide1',40:'carbide2'})

	cut_instances(x=_xmid(steel),side=-1)
	cut_instances(y=_ymid(steel),side=-1)

	del_parts_without_instance()

##	stop()

	## set mat
	set_mat(steel,mat='Steel_EN24T',type='Steel')
	set_mat(carbide1,mat='H15F',type='Carbide')
	set_mat(carbide2,mat='H15F',type='Carbide')

	## divide
	divide(steel,z=38.1)
	divide(steel,x=21.541/2 + 88.259)
##	divide(steel,poiRefX=(steel_length - steel_wall_x, (hole2cavity - hole_R)/2))

	## sets
	faces = face_select(carbide1,ny=1)
	create_set(carbide1,faces=faces,name='f_carbide1_contact')

	faces = face_select(carbide2,nx=1)
	create_set(carbide2,faces=faces,name='f_carbide2_contact')


	raise Exception


	global intx, inty, pressure,land_height

	pressure = 200  ## MPa
	land_height = 10

	## steel
	steel_length = 435.356
	steel_width = 83.16
	steel_H = 82.499

	if four_parts == True:
		steel_hole_L = 176.518
		steel_hole_W = 43.92
	else:
##		steel_hole_L = 199.92    ## longer than four part option
		steel_hole_L = 176.518   ## same as four part option

		steel_hole_W = 43.92

	steel_wall_y = (steel_width - steel_hole_W)/2
	steel_wall_x = (steel_length - steel_hole_L)/2

	edge_cut = 5.08
	cut_H = 38.1

	hole2hole = 57.15
	hole2edge = 46.228
	hole_depth = 15
	hole2cavity = steel_wall_x - hole2edge - hole2hole

	hole_H = 57.15
	hole_R = 4.5
	hole2top = steel_H - hole_H

	if four_parts == False:
		steel_R = 3	## cavity, original
##		steel_R = 0  ## modified
	else:
		steel_R = 0

##	steel_R = 0

	## control dimension
	WC_hole_L = 157.905  				 ## shorter edge of long edges   (error: 157.985)
	WC_hole_W = 25.387

	intx = 0
	inty = 0.04

##	Tcc = 9.3065   ## original
##	Tcc = 9.0
	WC_wall_x = Tcc
	WC_wall_y = WC_wall_x

	steel_wall_x = (steel_length - WC_hole_L)/2 - (WC_wall_x - intx)
	steel_wall_y = (steel_width - WC_hole_W)/2 - (WC_wall_y - inty)
	print 'steel_wall_y=',steel_wall_y

	steel_hole_L = steel_length - 2*steel_wall_x
	steel_hole_W = steel_width - 2*steel_wall_y

	hole2cavity = steel_wall_x - hole2edge - hole2hole

	WC_length = steel_hole_L + 2*intx    ## 200mm
	WC_width = steel_hole_W + 2*inty     ## 44mm

##	raise Exception

	## WC
	if four_parts == True:
		intx = 0      ## original
##		intx = 0.06
		inty = 0.04   ## original, so interference = 80/2 = 40um, not 80 um.
##		inty = 0.06

#		WC_length = 176.518   ## longer edge of long edges. zero tolerance in x dir
		WC_length = steel_hole_L + 2*intx
		WC_width = steel_hole_W + 2*inty    ## 44mm, tolerance = 80um in y dir

		WC_wall_x = 9.3065
		WC_wall_y = 9.3065

##		WC_hole_L = 157.905  				 ## shorter edge of long edges   (error: 157.985)
##		WC_hole_W = 25.387
		WC_hole_L = WC_length - 2*WC_wall_x		## 157.905
		WC_hole_W = WC_width - 2*WC_wall_y		## 25.387

		print 'WC_hole_L=',WC_hole_L
		print 'WC_hole_W=',WC_hole_W

##		raise Exception

		WC_R_in = 0
		WC_R_out = 0

	else:
		intx = 0.04	## original,
##		intx = 0		## modified, same as four part option
##		inty = 0.04   ## original, WC_hole_W= 25.387 = original of four part option, with overclosure in the geometry model of solid part
		inty = 0      ## modified, WC_hole_W= 25.307 = original of solid part option, but will no overclosure in the geometry model of solid part (but mesh is well fit)

		WC_length = steel_hole_L + 2*intx    ## 200mm
		WC_width = steel_hole_W + 2*inty     ## 44mm

		## control
##		WC_hole_L = 157.905    ## same as four part option
####		WC_hole_W = 25.307     ## (original) smaller than four part option (25.387)
##		WC_hole_W = 25.387  ## modified

		WC_wall_x = 9.3065
		WC_wall_y = 9.3065

		WC_hole_L = WC_length - 2*WC_wall_x
		WC_hole_W = WC_width - 2*WC_wall_y

		WC_R_in = 1.0   ## original
		WC_R_out = 3    ## original

		## modified
##		WC_R_in = 0
##		WC_R_out = 0

		if WC_R_in == WC_R_out == 0:
			rounded = False
		else:
			rounded = True

		## original
##		WC_wall_x = (WC_length - WC_hole_L)/2
##		WC_wall_y = (WC_width - WC_hole_W)/2
	## if four_parts = True, WC_wall_x = WC_wall_y, otherwise, WC_wall_x > WC_wall_y

		print 'WC_hole_L=',WC_hole_L		## 157.905 (same as four part option)
		print 'WC_hole_W=',WC_hole_W		## 25.387 is original of 4 parts, 25.307 is original of solid part)


##	stop()

##
##
##	## punch
##	punch_R = WC_R_in
##	punch_length = WC_hole_L
##	punch_width = WC_hole_W

	## steel
	blank_part('steel')
	create_block(steel, x=(0,steel_length),y=(0,steel_width),z=(0,steel_H), mat='Steel_EN24T',subset='Steel')
	new_instance(steel)

	hex_cut(steel, y=(0,edge_cut),z = (0,cut_H))
	hex_cut(steel, poiRefY=(MAX,-edge_cut), z=(0,cut_H))
##	hex_cut(steel, x=(steel_wall_x, steel_length - steel_wall_x), y=(steel_wall_y, steel_width - steel_wall_y))

	drill_hole(steel, ndir='y', x=steel_wall_x - hole2cavity, z=hole_H, radius=hole_R)
	drill_hole(steel, ndir='y', x=steel_wall_x - hole2cavity - hole2hole, z=hole_H, radius=hole_R)
	drill_hole(steel, ndir='y', x=steel_wall_x + steel_hole_L + hole2cavity, z=hole_H, radius=hole_R)
	drill_hole(steel, ndir='y', x=steel_wall_x + steel_hole_L + hole2cavity + hole2hole, z=hole_H, radius=hole_R)
	divide(steel,z=cut_H)
##	divide(steel,z=steel_H - (hole2top - hole_R)/2)
	divide(steel,poiRefX=(steel_wall_x,-(hole2cavity - hole_R)/2))
	divide(steel,poiRefX=(steel_length - steel_wall_x, (hole2cavity - hole_R)/2))

	##drill_steel
	create_round_block('drill_steel',steel_hole_L,steel_hole_W,steel_H,radius=steel_R)
	move_part(drill_steel,x1=MID,x2=_xmid(steel),y1=MID,y2=_ymid(steel),z1=MID,z2=_zmid(steel))
##	new_instance(drill_steel)

	boolean_cut(steel,cutters=drill_steel)
	move_part(steel,x1=MID,x2=0,y1=MID,y2=0)

	new_instance(steel)

##	stop()
	if four_parts == False:
		## carbides
		blank_part('carbide1')
		create_block(carbide1,x=(0,WC_length),y=(0,WC_width),z=(0,steel_H),mat='H15F',subset='carbide')
		round_edges(carbide1,x=MAX,y=MAX,radius=WC_R_out)
		new_instance(carbide1)

		## drill_carbide
		create_round_block('drill_carbide',WC_hole_L,WC_hole_W,steel_H,radius=WC_R_in)
		move_part(drill_carbide,x1=MID,x2=_xmid(carbide1),y1=MID,y2=_ymid(carbide1),z1=MID,z2=_zmid(carbide1))

		boolean_cut(carbide1,cutters=drill_carbide)

		move_part(carbide1,x1=MID,x2=_xmid(steel),y1=MID,y2=_ymid(steel),z1=MID,z2=_zmid(steel))
		new_instance(carbide1)

		bias_cut(steel,x=MID,cut_sides=['-x'])
		bias_cut(steel,y=MID,cut_sides=['-y'])

		bias_cut(carbide1,x=MID,cut_sides=['-x'])
		bias_cut(carbide1,y=MID,cut_sides=['-y'])

		batch_divide(carbide1,poiRefZ=(MID,-land_height/2,land_height))
		divide(steel,poiRefY=(MAX,-hole_depth))

		faces = face_select(carbide1,nx=1) + face_select(carbide1,ny=1)
		create_set(carbide1,faces=faces,name='f_carbide1_contact')

		faces = face_select(carbide1,nx=1)
		create_set(carbide1,faces=faces,name='f_carbide1_contact_x')

		faces = face_select(carbide1,ny=1)
		create_set(carbide1,faces=faces,name='f_carbide1_contact_y')

		faces = face_select(steel,x=(MIN,_xmin(steel,y=MIN)),y=(MIN,_ymin(steel,x=MIN)),inbound=True)
		create_set(steel,faces=faces,name='f_steel_contact')

		faces = face_select(carbide1,x=(MIN,_xmin(carbide1,y=MIN)),y=(MIN,_ymin(carbide1,x=MIN)),z=(_zmid(carbide1) - land_height/2 + _nearby, _zmid(carbide1) + land_height/2 - _nearby), inbound=True)
		create_set(carbide1,faces=faces,name='f_carbide1_loading')

##		stop()

		## divide
		divided = False
##		copy_part(carbide1,'carbide2',change_setname=True)
##		new_instance(carbide2)
##
##		bias_cut(carbide1,cut_sides=['+x','-y'],angle_with_X=45,x=MAX,y=MAX)
##		bias_cut(carbide2,cut_sides=['-x','+y'],angle_with_X=45,x=MAX,y=MAX)
##
##		divide(carbide1,x=_xmax(carbide1) - WC_wall_x - 5)
##		divide(carbide2,y=_ymax(carbide2) - WC_wall_y - 5)
##
##		stop()

	else:
		blank_part('carbide1')
		create_block(carbide1,x=(0,WC_length/2),y=(0,WC_wall_y),z=(0,steel_H),mat='H15F',subset='carbide')
		chamfer_edges(carbide1,length=WC_wall_y,x=MAX,y=MIN)

		blank_part('carbide2')
		create_block(carbide2,x=(0,WC_wall_x),y=(0,WC_width/2),z=(0,steel_H),mat='H15F',subset='carbide')
		chamfer_edges(carbide2,length=WC_wall_x,x=MIN,y=MAX)

		bias_cut(steel,x=MID,cut_sides=['-x'])
		bias_cut(steel,y=MID,cut_sides=['-y'])

		move_part(carbide1,x1=MIN,x2=_xmin(steel))
		move_part(carbide2,y1=MIN,y2=_ymin(steel))

		move_part(carbide1,y1=MAX,y2=_ymax(carbide2))
		move_part(carbide2,x1=MAX,x2=_xmax(carbide1))

		new_instance(carbide1)
		new_instance(carbide2)

		batch_divide([carbide1,carbide2],poiRefZ=(MID,-land_height/2,land_height))
		divide(steel,poiRefY=(MAX,-hole_depth))

		faces = face_select(carbide1,ndir='-y',poiRefZ=(MID,-land_height/2,land_height))
		create_set(carbide1,faces = faces, name='f_carbide1_loading')

		faces = face_select(carbide2,ndir='-x',poiRefZ=(MID,-land_height/2,land_height))
		create_set(carbide2,faces = faces, name='f_carbide2_loading')

		faces = face_select(carbide1,ny=1)
		create_set(carbide1,faces=faces,name='f_carbide1_contact')

		faces = face_select(carbide2,nx=1)
		create_set(carbide2,faces=faces,name='f_carbide2_contact')

		faces = face_select(steel,ny=-1,x=MIN1,mark_select=True,poiRefZ=(MID,-land_height/2,land_height)) + face_select(steel,nx=-1,y=MIN1,mark_select=True,poiRefZ=(MID,-land_height/2,land_height))
		create_set(steel,faces=faces,name='f_loading_area')

		divide(carbide1,x=_xmax(carbide1) - WC_wall_x - 5)
		divide(carbide2,y=_ymax(carbide2) - WC_wall_y - 5)

##	stop()

	## load/BC
	set_temperature_predefined_field(temp=room_temperature)
	name = set_temperature_BC('high_temp',temp=300,step=heat_step);	please_check
	_m.boundaryConditions[name].deactivate(shrink_step)
	set_temperature_BC('room_temp',temp=room_temperature,step=shrink_step)


	## Interaction
	if four_parts == False:
		if rounded == True:
			s2s_interact_std(sfaces='f_steel_contact',mfaces='f_carbide1_contact',force_create=True,step='step1',interference=SHRINK_FIT,prop='Friction')		;please_check
		else:
			s2s_interact_std(sfaces='f_steel_contact',mfaces='f_carbide1_contact_x',force_create=True,step='step1',interference=SHRINK_FIT,prop='Friction')		;please_check
			s2s_interact_std(sfaces='f_steel_contact',mfaces='f_carbide1_contact_y',force_create=True,step='step1',interference=SHRINK_FIT,prop='Friction')		;please_check


##		s2s_interact_std(sfaces='f_steel_contact',mfaces='f_carbide2_contact',force_create=True,step='step1',interference=SHRINK_FIT)		;please_check
##
##		faces1 = face_select(carbide1_A1,ndir='slope')
##		faces2 = face_select(carbide2_A1,ndir='slope')
##		s2s_interact_std(mfaces=faces2,sfaces=faces1,step='step1',interference=SHRINK_FIT)

	else:
		faces1 = face_select(carbide1_A1,ndir='slope')
		faces2 = face_select(carbide2_A1,ndir='slope')
		s2s_interact_std(mfaces=faces2,sfaces=faces1,step='step1',prop='Frictionless')

		faces = face_select(steel_A1,ny=-1,x=MIN1,mark_select=True)
		s2s_interact_std(sfaces=faces,mfaces='f_carbide1_contact',force_create=True,step=heat_step,prop='Frictionless')

		faces = face_select(steel_A1,nx=-1,y=MIN1,mark_select=True)
		s2s_interact_std(sfaces=faces,mfaces='f_carbide2_contact',force_create=True,step=heat_step,prop='Frictionless')

	apply_pressure('load_carbide1',MPa=pressure,faces='f_carbide1_loading', step=press_step)
	if four_parts == True:
		apply_pressure('load_carbide2',MPa=pressure,faces='f_carbide2_loading',step=press_step)

	faces = face_select(steel_A1,faces='f_steel_hole_3',poiRefY=(MAX,-hole_depth))
	apply_disp_fix('fix_hole_3',faces=faces,Ux=0,Uy=0,Uz=0,step=press_step)

	faces = face_select(steel_A1,faces='f_steel_hole_4',poiRefY=(MAX,-hole_depth))
	apply_disp_fix('fix_hole_4',faces=faces,Ux=0,Uy=0,Uz=0,step=press_step)

	apply_disp_fix('fix_right',faces=xmax_faces(steel_A1),Ux=0,Uy=0,Uz=0,step=press_step)

	faces = faces_of_insts(x=_xmin(steel))
##	apply_disp_fix('fix_x',faces=faces,Ux=0,UR1=0,UR2=0,UR3=0)
##	apply_disp_symm('x',faces=faces)
	fix_no_rotate('symm_x',faces=faces)


	apply_disp_fix('fix_carbide_bot',faces=faces_of_insts(z=_zmin(steel)),Uz=0,step=heat_step)

##	stop()

	faces = faces_of_insts(y=_ymin(steel))
##	apply_disp_symm('y',faces=faces)
	fix_no_rotate('symm_y',faces=faces)
##	apply_disp_fix('fix_y',faces=faces,Uy=0,UR1=0,UR2=0,UR3=0)


##	faces = faces_of_insts(z=_zmin(steel))
##	apply_disp_fix('fix_z',Uz=0,faces=faces)

	please_check('Only for directly shrink fit')
##	edges = edge_select(steel_A1,x=MAX,y=MAX,edir='z')
##	name1 = apply_disp_fix('line_fix_z',edges=edges,Uz=0)
##	_m.boundaryConditions[name1].deactivate(press_step)

##	if four_parts == True:
####		edges = edge_select(carbide1_A1,edir='x',y=MIN,z=MIN)
####		BC1 = apply_disp_fix('fix_carbide1',edges=edges,Uy=0)
##		vertice = vertice_select(carbide1_A1,x=MIN,y=MIN,z=MAX)
##		BC1 = apply_disp_fix('fix_carbide1',vertices=vertice,Uy=0)
##		_m.boundaryConditions[BC1].deactivate('step2')
##
####		edges = edge_select(carbide2_A1,edir='y',x=MIN,z=MIN)
####		BC2 = apply_disp_fix('fix_carbide2',edges=edges,Ux=0)
##
##		vertice = vertice_select(carbide2_A1,x=MIN,y=MIN,z=MAX)
##		BC2 = apply_disp_fix('fix_carbide2',vertices=vertice,Ux=0)
##		_m.boundaryConditions[BC2].deactivate('step2')
####
####		point = vertice_select(steel_A1,x=MIN,y=_ymin(steel,x=MIN),z=MIN)
####		coupling_faces_to_point(control_point=point, faces=ymax_faces(carbide1_A1),Uy=ON)
####
####		point = vertice_select(steel_A1,x=_xmin(steel,y=MIN),y=MIN,z=MIN)
####		coupling_faces_to_point(control_point=point, faces=xmax_faces(carbide2_A1),Ux=ON)

##	stop()

	## mesh
	## carbide
	contact_esize = 2
	global_esize = 2*contact_esize

	if four_parts == False:
		if divided == False:
			seed_circular_edges(carbide1,quarter_seed=4)

			edges = edge_select(carbide1,z=MAX,edir='x',y=MAX) + edge_select(carbide1,z=MAX,x=MAX,edir='y') + edge_select(carbide1,z=MAX,radius=WC_R_out)
			seed_edges(carbide1,edges=edges,esize=contact_esize)

			edges = edge_select(carbide1,z=MAX,edir='y',x=MIN)
			seed_edges(carbide1,edges=edges,esize=contact_esize)

			mesh_part(carbide1,esize=global_esize)

		else:
			## carbide1
			seed_circular_edges(carbide1,quarter_seed=4)

			edges = edge_select(carbide1,edir='slope')
			seed_edges(carbide1,edges=edges,esize=contact_esize)

			edges = edge_select(carbide1,z=MAX,edir='x',y=MAX)
			seed_edges(carbide1,edges=edges,esize=contact_esize)

			edges = edge_select(carbide1,z=MAX,edir='y',x=MIN)
			seed_edges(carbide1,edges=edges,esize=contact_esize)

			mesh_part(carbide1,esize=global_esize)

			## carbide2
			seed_circular_edges(carbide2,quarter_seed=4)

			edges = edge_select(carbide2,z=MAX,edir='y',x=MAX)
			seed_edges(carbide2,edges=edges,esize=contact_esize)

			edges = edge_select(carbide2,edir='slope')
			seed_edges(carbide2,edges=edges,esize=contact_esize)

			edges = edge_select(carbide2,z=MAX,edir='x',y=MIN)
			seed_edges(carbide2,edges=edges,esize=contact_esize)

			mesh_part(carbide2,esize=global_esize)


	else:
		edges = edge_select(carbide1,edir='x',y=MAX,z=MIN)
		seed_edges(carbide1,edges=edges,esize=contact_esize)

		edges = edge_select(carbide1,edir='slope')
		seed_edges(carbide1,edges=edges,esize=contact_esize)

		mesh_part(carbide1,esize=global_esize)

		edges = edge_select(carbide2,edir='y',x=MAX,z=MIN)
		seed_edges(carbide2,edges=edges,esize=contact_esize)

		edges = edge_select(carbide2,edir='slope')
		seed_edges(carbide2,edges=edges,esize=contact_esize)

		mesh_part(carbide2,esize=global_esize)

	## steel
	seed_circular_edges(steel)

	edges = edge_select(steel,z=MAX,x=(MIN1,_xmin1(steel,y=MIN)), y=(MIN1,_ymin1(steel,x=MIN)))
	seed_edges(steel,edges=edges,esize=contact_esize)
	mesh_part(steel,esize=global_esize)

##	stop()

	return

def main_A0209_HPHT():
	## VER: 2013-08-20, v1.7   ## A0197 also use this flow
	## collect_and_write_results('pressing',['model','U'],['ANVIL_A1','Mises','PEEQ','S1'], ['BLANK_A1','Mises','PEEQ','S1'])

	## dimensions
	locals0 = locals().keys()
##	total_H = 132.715    ## 132.715 (127 is shown in 187 drawings)
##	blank_R = 62.865   ## 62.865 (57.15 is shown in 187 drawings, blank)
##	blank_H = 80.95   ## 87.31 (80.95 is shown in 187 drawings, blank) (87.31 is total, not only blank)

	customer = 'Duncan'
	purpose = '1. Use new dimension (correct dimensin for big10%) 2. comparison between solid and compound. 3. check hole effect'
	request_date = 'Aug 2013'

	pressure = 8500		;please_check
	size = 'big10%'   ## typical, or big10%
	hole_R = 0
	top_mat = 'H10F'  ## SixUF(6UF), H10F
	bot_mat = 'H10F'

	if size == 'typical':         ##
		blank_R = 2.25*inch       ## 57.15mm
		blank_H = 87.31      	  ## 87.31mm

		land_width = 1.374*inch   ## 34.9mm
		anvil_wall_clearance = 6.36

	elif size == 'big10%':
		blank_R = 2.25*1.1*inch   ## 62.865mm
		blank_H = 3.187*inch      ## 80.95mm (modified) (same as typical)  ## The base height of 80.95 is a compensation of the 10% bigger radius

		land_width = 1.374*inch   ## 34.9mm (same as typical)
		anvil_wall_clearance = 6.36 ## modified  (same as typical)

	cut_depth = blank_R - land_width/2
	## 39.7mm (typical), or 48.67mm (big 10%)

	anvil_H = anvil_wall_clearance + cut_depth
	## 46.05mm (typical), or 59.08mm (big 10%)

	total_H = blank_H + anvil_H
	## 133.37(typical), 132.725(big10%),
##	print2 ('total_H =',total_H)

	anvil_wall_clearance = anvil_H - cut_depth
	## 6.35mm(typical), or 10.414mm (big 10%)

	locals2globals(locals0,locals())

	blank_part('anvil')
	cylinder_grow('anvil','y',OD=2*blank_R,L=total_H)

	bias_cut1(anvil,cut_sides='-x',x=MID)
	bias_cut1(anvil,cut_sides='+z',z=MID)

	bias_cut1(anvil,cut_sides=['+x','+y'], pass_point1 = (land_width/2, total_H,0), angle_with_Y=45)
	bias_cut1(anvil,cut_sides=['-z','+y'], pass_point1 = (0, total_H,-land_width/2), angle_with_Y=45)
##	bias_cut1(anvil,cut_sides=['-x','+y'], pass_point1 = (-land_width/2, total_H,0), angle_with_Y=45)
##	bias_cut1(anvil,cut_sides=['+z','+y'], pass_point1 = (0, total_H,land_width/2), angle_with_Y=45)

	divide(anvil,y=blank_H)
##	divide(anvil,y=blank_H + 1)
##	divide(anvil,y=blank_H - 1)

	new_instance(anvil)

	copy_part(anvil,'blank')
	bias_cut1(blank,y=blank_H,cut_sides='+y')
	bias_cut1(anvil,y=blank_H,cut_sides='-y')
	new_instance(blank)

	if hole_R > 0:
		create_half_ball('ball',radius=hole_R)	;please_check
		boolean_cut(blank,cutters=ball)

	raise Exception

##	if solid == True:
##		set_mat(anvil,mat='H10F')   ## solid model
##	else:
##		set_mat(anvil,mat='SixUF')

	set_mat(anvil,mat=top_mat)
	set_mat(blank,mat=bot_mat)

##	raise Exception

	## mesh
	edges = edge_select(anvil,x=MAX,y=(blank_H,MAX),edir='y')
	seed_edges(anvil,edges=edges,esize=0.5)
	mesh_part(anvil,esize=2)

	edges = edge_select(blank,z=MAX,y=MAX,edir='x')
	seed_edges(blank,edges=edges,esize=2)
	mesh_part(blank,esize=3)

##	raise Exception

	xnodes = nodes_labels_of_faces(faces_of_insts(x=_xmin(anvil_A1)))
	znodes = nodes_labels_of_faces(faces_of_insts(z=_zmax(anvil_A1)))
	assembly_nodes = nodes_labels_of_faces(faces_of_insts(y=_ymin(anvil_A1)))
	bot_nodes = nodes_labels_of_faces(ymin_faces(blank_A1))
	top_elems = elements_labels_of_faces(ymax_faces(anvil_A1))

	tie_nodes_anvil = nodes_labels_of_faces(ymin_faces(anvil_A1))
	tie_nodes_blank = nodes_labels_of_faces(ymax_faces(blank_A1))

	## Interaction

	create_general_static_step(stepname='high_temp',initial_inc=0.002,restart=True)	 ;please_check
##	_m.steps['high_temp'].Restart(frequency=1, numberIntervals=0, overlay=OFF, timeMarks=OFF)
##	global()['restart'] = True
	## will create the jobname.res file for later restart analysis

	set_temperature_predefined_field(initial_step=20,modifys=[('step1',1000)])

	apply_disp_symm('x',faces=faces_of_insts(x=_xmin(anvil_A1)))
	apply_disp_symm('z',faces=faces_of_insts(z=_zmax(anvil_A1)))
	apply_disp_fix('y_fix_bot',faces=faces_of_insts(y=_ymin(anvil_A1)),stepname='step1',Uy=0)

##	raise Exception

	odb_title1 = get_file_name()[:-3] + '_prefield'
	create_inp(odb_title1,restart=True) ;please_check
	mdb.jobs[odb_title1].submit()
	mdb.jobs[odb_title1].waitForCompletion()

##	raise Exception

	## cooling and loading
##	clear_model_settings()

	odb_title2 = get_file_name()[:-3] + '_final'

##	create_new_model(get_file_name())
##	create_new_parts_with_deformed_mesh(odb_title1)

	copy_model(to_name='restart',new_from_name='prefield')
	clear_model_settings()
	import_initial_state(odb_title1)

##	import_initial_stress(odb_title1,name='Imported_stress')

##
##	raise Exception

##	material_database()
##
##	set_mat(BLANK_A1_p,mat='H10F')
##	set_mat(ANVIL_A1_p,mat='SixUF')

	create_general_static_step(stepname='tie',initial_inc=0.002)
	create_general_static_step(stepname='cool_down',initial_inc=0.002)
	create_general_static_step(stepname='pressing',initial_inc=0.002)

##	raise Exception

##	node_region_contact(mnodes=tie_nodes_anvil, snodes=tie_nodes_blank,action='tie',step='step1')
	s2s_tie(mfaces=ymin_faces(anvil_A1),sfaces=ymax_faces(blank_A1))

##	apply_disp_symm('x',nodes=xnodes)
##	apply_disp_symm('z',nodes=znodes)
##	apply_disp_fix('y_fix_bot',nodes=bot_nodes,Uy=0)

	apply_disp_symm('x',faces=faces_of_insts(x=_xmin(anvil_A1)))
	apply_disp_symm('z',faces=faces_of_insts(z=_zmax(anvil_A1)))
	apply_disp_fix('y_fix_bot',faces=ymin_faces(blank_A1),Uy=0)

	set_temperature_predefined_field(initial_step=1000,modifys=[('step2',300)])
##	apply_pressure('load_top',elements=top_elems, MPa=8500,step='step3')
	apply_pressure('load_top',faces=ymax_faces(anvil_A1),MPa=pressure,step='step3')	;please_check

	mdb.saveAs(odb_title2)

	create_inp(odb_title2,clear_jobs=False)
	mdb.jobs[odb_title2].submit()

	return

def main_A0201_sinter_tray():
	## VER: 2013-09-09, v1.0

	check_script_file('AP_A0201_sinter_tray_deep6_lift_concentrteF_X1.py')
	history = 'AJ:has bot support<<<AI:factor=5<<<AH:factor=1<<<AG:rod load on cave radius region, factor of 5<<<AF:manual lift, no bottom spacer<<<AE:No top spacer load<<<AC:sin()<<<AA:spacer radius=3<<<A9:spacer_cave_depth=7mm<<<A8:No side fix for spacer<<<A7:bot spacer is Steel<<<A5:modify functions<<<A3:build spacer<<<A2:add gravity<<<A1:imported model'

	create_general_static_step()

##	step = mdb.openStep('T:/Modelling/_On-going jobs/A0201 - New sintering tray - Chun Wang_Wuxi/incomming/21tray.stp', scaleFromFile=OFF)
##	_m.PartFromGeometryFile(name='tray', geometryFile=step, combine=False, dimensionality=THREE_D, type=DEFORMABLE_BODY)

	keys0 = locals().keys()

	factor = 1
	lift_mode = True	;please_check
	have_top_load = False
	have_top_spacer = False
	if have_top_spacer == True:
		have_top_load = True

	land_width = 25
	rod_weight = 320   ## unit:g
	rod_num = 21
	layer_num = 10
	spacer_weight = 1000 ## g

	tray_width = 300
	tray_height = 20	## 30
	tray_length = 450

	hole_radius = 3.5

	spacer_height = 20
	spacer_width = 13.86
	spacer_radius = 3
	spacer2edge = 13.34

	edge_cave_depth = 6 	## 6, 7, 10.5
	edge_cave_radius = 1.5

	cave_height = 20
	cave_width = 15
	rod_cave_depth = 4.5
	rod_cave_radius = 1.0
	cave2cave = 11.5

	locals2globals(keys0,locals())

##	raise Exception

	blank_part('tray')
	create_block(tray,x=(0,tray_width/2),y=(0,tray_height),z=(0,tray_length/2))
	new_instance(tray)

	blank_part('spacer_cave')
	create_block(spacer_cave,x=(-spacer_width/2,spacer_width/2),y=(0,spacer_height),z=(0,tray_length/2))

	bias_cut(spacer_cave,cut_sides=['-x','-y'],pass_point1=(0,0,0),angle_with_Y=30)
	bias_cut(spacer_cave,cut_sides=['+x','-y'],pass_point1=(0,0,0),angle_with_Y=30)

	copy_part('spacer_cave','spacer')

	round_edges(spacer,edges=edge_select(spacer,y=0),radius=spacer_radius)
	round_edges(spacer_cave,edges=edge_select(spacer_cave,y=0),radius=edge_cave_radius)

##	raise Exception
	move_part(spacer_cave,x1=MID,x2=tray_width/2 - spacer2edge, y1=MIN,y2=tray_height - edge_cave_depth)
	new_instance(spacer_cave)

	move_part(spacer,x1=MID,x2=tray_width/2 - spacer2edge, y1=MAX,y2=_ymax(spacer_cave))
	new_instance(spacer)

	copy_part(spacer_cave,'support_cave',mirror_y=_ymax(tray)/2)
	new_instance(support_cave)

	copy_part(spacer,'support',mirror_y=_ymax(tray)/2)
	new_instance(support)


##	raise Exception

	blank_part('cave')
	create_block(cave,x=(-cave_width/2,cave_width/2),y=(0,cave_height),z=(0,tray_length/2))

	bias_cut(cave,cut_sides=['-x','-y'],pass_point1=(0,0,0),angle_with_Y=45)
	bias_cut(cave,cut_sides=['+x','-y'],pass_point1=(0,0,0),angle_with_Y=45)
	round_edges(cave,edges=edge_select(cave,y=0),radius=rod_cave_radius)

	move_part(cave,x1=MID,x2=0,y1=MIN,y2=tray_height - rod_cave_depth)
	new_instance(cave)

	copy_part(cave,'cave2',mirror_y=_ymax(tray)/2)
	new_instance(cave2)

	pattern_insts([cave_A1,cave2_A1],dir='x', number=10,spacing=cave2cave)

	insts = a.instances.values()
	insts = unselect(insts,tray_A1,support_A1,spacer_A1)

	boolean_cut(tray,cutters=insts,newpart_name='tray',del_cutters=True)

	for i in range(10):
		divide(tray,x=(i+1)*cave2cave)

##	stop()

	set_mat(tray,mat='Graphite')
	set_mat(spacer,mat='Rigid')
	set_mat(support,mat='Rigid')

##	faces = face_select(tray_A1,x=(0,tray_width/2-land_width),y=(MID,MAX),ndir='slope')
	faces = face_select(tray_A1,x=(0,tray_width/2-land_width),y=(MID,MAX),ndir='cylindrical')
	area_rod = get_area(faces[0])
##	F_rod = rod_weight*1e-3*9.81*sin(pi/4)
	F_rod = rod_weight*1e-3*9.81*factor   ## factor of 5  concentrated
	pressure = round(F_rod/area_rod,6)
	apply_pressure('rod_load',faces=faces,MPa = pressure)

	print 'rod_weight = ',rod_weight*1e-3*21
##	raise Exception

	if lift_mode == True:
		del_insts(support_A1)
	else:
		faces1 = face_select(tray_A1,x=(tray_width/2,tray_width/2-land_width),y=(0,MID),ndir='slope')
		faces2 = face_select(support_A1,y=(0,MAX),z=(MIN1,MAX1))
		s2s_interact_std('int_bot_support', mfaces=faces2,sfaces=faces1)

	if have_top_spacer == True:
		faces1 = face_select(tray_A1,x=(tray_width/2,tray_width/2-land_width),y=(MID,MAX),ndir='slope')
		faces2 = face_select(spacer_A1,y=(MIN,_ymax(tray)),z=(MIN1,MAX1))
		s2s_interact_std('int_top_force', mfaces=faces2,sfaces=faces1)
	else:
		del_insts(spacer_A1)


##	raise Exception

	if have_top_load == True:
		if have_top_spacer:
			faces = ymax_faces(spacer_A1)
		else:
			faces = face_select(tray_A1,x=(tray_width/2,tray_width/2-land_width),y=(MID,MAX),ndir='slope')

		area = get_area(faces)
		F_upper = (get_mass(tray) + spacer_weight/2*1e-3 + factor*rod_weight*21*1e-3/4)*layer_num*9.81*sin(pi/6)*2
		pressure = round(F_upper/area,6)
		apply_pressure('upper_load',faces=faces,MPa = pressure)

	apply_gravity(Gy=-9800)

	if lift_mode == True:
		faces = face_select(tray_A1,x=MAX1,y=0)
		apply_disp_fix('bot_fix',faces=faces, Uy=0)
	else:
		apply_disp_fix('bot_fix',faces=ymin_faces(support_A1),Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

	apply_disp_symm('x',faces=faces_of_insts(x=0))
	apply_disp_symm('z',faces=faces_of_insts(z=0))

	raise Exception
	## mesh

	edges = edge_select(tray,z=0,x=(MAX,tray_width/2-land_width),y=(MIN1,MAX1))
	seed_edges(tray,edges=edges,esize=0.5)
	mesh_part(tray,esize=2)

	edges = edge_select(spacer,y=(MIN,_ymax(tray)),z=0)
	seed_edges(spacer,edges=edges,esize=1)
	mesh_part(spacer,esize=2)

	edges = edge_select(support,y=(0,MAX),z=0)
	seed_edges(support,edges=edges,esize=1)
	mesh_part(support,esize=2)

##	raise Exception

	tray_weight = get_mass(tray)

	global _results_disp
##	_results_disp = "collect_and_write_results('step1',['TRAY_A1','U2','S1','Mises'])"
	_results_disp = 'step1',['TRAY_A1','U2','S1','Mises']
##	'tray_weight','hc_bearing',['model',('U2','max'),('U2','min')],['ANVIL_LINE',('U2','max'),('U2','min')], ['BEARER_LINE',('U2','max'),('U2','min')],['SHAFT_A1',('S1','max')])"


	create_inp(inp_file_title) ;please_check
	mdb.jobs[inp_file_title].submit()


	return


def main_A0194_powder_compaction_923():
	## VER: 2013-06-07, v1.2

	global history,brief, _results_disp, script_file_full

	## topic = 'powder_compaction'

	script_file_full = check_script_file('AH_A0248_button_tangent_5108_ALE.py')
	history = 'JE:stable die; IA:converged; I9:收敛; I8: dome=8; HI: friction = 0.1;  HF: reverse punch and ejector; HE:redo, correct L;  HD:change PV, keep PFH=56.5; H0:moving die;  GH: top punch rouded; G6: PV = PV - 0.5; G3:ejector tip radius=0.20; G2:ejector tip radius=0.10;  FX:PV=9.5(benchmark); FT:die_R0 + 0.08;  FT:die_R0 + 0.04; FB: fine mesh; FA: side fine mesh; F7:top dip first; F6:upward first, then downward; F5:fine mesh; EX:EV:ejector tip=0.15;  E: update viewport; EJ:fine mesh; EI:能算到0.97; EG:所有面sweep + adaptive mesh, run to 0.88 sec; EF:ejector=line, 使用单核计算可计算至0.88;  ED: run to 0.49; EC: no sweep, merge edge, run to 0.57; EB:解决adative mesh与sweep mesh的问题(算到0.53); EA:解决adative mesh与sweep mesh的问题(算到0.39); E9:; E8:use adative mesh(can run to 0.38); E7:can run to 0.809sec; E6:top contact with die(can run to 0.72); E5:can run to 0.38sec; E4:divide powder_s for meshing; E3:esize=1'

	save_user_data(jobnum)

	loc = history.find(';')
	if loc == -1:
		brief = history
	else:
		brief = history[:loc]

##	locals0 = locals().keys()

	## ejector
	ejector_R = 9.76				;changing  ## 9.76 is original
	ejector_depth = 9.76  		;changing  ## 9.76(original)
	ejector_land_R = 0.15		;changing1   ## 0.15 is original

	## punch
	punch_land = 0.20			;please_check
	tip_angle = 15
	tilt_angle = 30
	tip_height = 1.59
	punch_depth = 3.66

	die_D0 = 19.96  ## original design
	die_R0 = die_D0/2   ## 9.98(original), ejector_R=9.76(original)
	die_R = die_R0  	;changing   ## 0.04 = 4个丝
	die_D = 2*die_R

	ejector_land = die_R - sqrt(ejector_R**2 - (ejector_R - ejector_depth)**2)   ## 0.22 is original
	ejector_land = round(ejector_land,3)
	if ejector_land < 0:
		raise Exception('*** Negative ejector_land')

	tilt_H = punch_depth - tip_height
	round_radius_p = 1

	save_user_data(ejector_R, ejector_depth, ejector_land_R, ejector_land, die_R, punch_depth)

	## 压制参数
##	 压重:63.94 +/-0.35
##	 压高:29.44 +/-0.03 (PH)
##	 L:47
##	 PV:9.5

##	fill_weight = 55.86
##	ejector_area = 74.81986
##	punch_area = 31.85474
##	ejector_L1 = 46.73
##	punch_L1 = 51.04

	changing1
	fill_volume0 = 16572.60582
	PH = 29.44   ## 压高(press_height, 压制后压配的最终高度)
##	PFH = 56.5   ## 体积不变或几乎不变时(如调整tip的radius)
	PV = 9.5

	save_user_data(fill_volume0,PH,PV)	;changing1

##	raise Exception

	create_dynamic_explicit_step(restart_interval=15,scale_factor=2000)	;changing
	_m.fieldOutputRequests['F-Output-1'].setValues(variables=ALL, timeInterval=0.01)	; please_check

##	_m.historyOutputRequests['H-Output-1'].setValues(variables=ALL, frequency=100)  ## every 100 time increment
##	_m.historyOutputRequests['H-Output-1'].setValues(variables=ALL, timeInterval=0.001)  ## 并不是针对云图结果。

##	raise Exception

	## ejecor
	create_base_sketch(name='s_ejector',ndir='z', return_sketch=True)

	point1,point2,arc1 = create_arc('s_ejector',center=(0,ejector_R - ejector_depth),radius=ejector_R,quarter=4)  ## do not automatically trimed rectangle.
	point3,point4 = connect_points('s_ejector',(0,0),(die_R + 2,0))

	if ejector_R > ejector_depth:
		trim_geometry('s_ejector',point2)

	trim_geometry('s_ejector',point3)
	create_construction('s_ejector',(0,0),angle=90)

	loc = find_loc('s_ejector',y=MAX,groupX=MIN)
	round_sketch_corner('s_ejector',radius=ejector_land_R, loc=loc)

	## punch
	create_base_sketch(name='s_punch',ndir='z', return_sketch=True)

	dx1 = round(tip_height*tan(tip_angle*pi/180),6)
	dx2 = round(tilt_H/tan(tilt_angle*pi/180),6)
	points = connect_points('s_punch',(2,0),(0,0),{'DH':-punch_land},{'DT':(-dx1,tip_height)}, {'DT':(-dx2,tilt_H)},(-die_D/2,punch_depth))

	round_sketch_corner('s_punch',radius=round_radius_p, loc=points[3])
	round_sketch_corner('s_punch',radius=0.18, loc=find_loc('s_punch',y=MIN,groupX=MIN))		;changing

##	raise Exception

	## assembly
	if 'fill_volume0' in globals().keys():
		assembly_and_fill(top_sketch='s_punch',bot_sketch='s_ejector',fill_volume=fill_volume0) ## s_punch和s_ejector会被移动。
	elif 'PFH' in globals().keys():
		assembly_and_fill(top_sketch='s_punch',bot_sketch='s_ejector',PFH=PFH) ## s_punch和s_ejector会被移动。

###	raise Exception

##	keep_PFH = True	;changing
##	PFH = 56.5  ;changing ## 56.5 is original
## 	PV = 9.5		;changing ## 9.5 is original

## 	L = 47 		;changing1  ## 47 is original

 	## design:

	## step0: assembly
##	L = 47   ## 根据PFH = L + PV，可知，L代表PV动作完成后（等效于bot punch上移PV距离)，bot punch与中模上表面的最大距离（即以中模上表面为基准面)。
	changing1
	cal_L = False
	cal_PV = False
	read_vars_from_model_description()
	PFH = _vars['PFH']
	punch_depth = _vars['punch_depth']

##	print PV
##	raise Exception

	if 'PV' in locals().keys():	##已知PV
		L = PFH - PV	;changing
		cal_L = True
	elif 'L' in locals().keys():
		PV = PFH - L
		cal_PV = True


	save_user_data(PV, L, PH, PFH)


	## step1:(top punch only) deep into
##	pre_compaction = 4   ## 3-5mm, 防止粉末溢出(上冲往下走一点点，浸入中模。此时中模不动) (step1)
	## x1 = ?  ## 是自动算出来的(一般3-5mm)，而不是设置的输入参数。

	## step2:(top punch + die)
##	PV = 9.5   ## 9.5(original) 上冲和中模一起向下运动（下冲静止，等效于下冲往上走) (P=punch, V=wall) (step2)
	PV_PH = PV/PH   ## 经常有PV/PH = 0.6 ?

	## step3: (top punch only) 用于最后调整密度，对于压高很大的样品，OB会较大。对于压高很小的样品，OB无需设置，即OB=0即可实现较均匀的密度。
##	OB = 1.5  ## Upper punch move down an OB distance, die and ejector remains the same position
	## OB = ?   ## 设备输入参数

	## step4: eject(top punch moves up, die moves down, so as to eject the green part)
	AB = 1.6*PH   ## bot punch move up AB distance to eject the green part

	Wp = PFH

##	total_pressing = press_downward + press_upward

##	read_vars_from_model_description()
##	ejector_volume = _vars['ejector_volume']
##	punch_volume = _vars['punch_volume']


##	raise Exception

##	## user data
	reverse = False	;changing
##	ejector_volume = get_punch_volume('s_ejector','ejector_area',open='top')
##	punch_volume = get_punch_volume('s_punch','punch_vol',open='bot')
##
##	fill_volume = get_volume(fill_part)
##	fill_weight = get_mass(fill_part)
##	compress = compress_ratio()

##	ejector_L1 = round((fill_volume - ejector_volume)/(pi*die_R*die_R), 5)   ## ejector在下面时，ejector之上的粉的高度。
##	punch_L1 = round((fill_volume - punch_volume)/(pi*die_R*die_R), 5)   		## punch在下面时，punch之上的粉的高度。
##
##	save_user_data(ejector_volume, punch_volume, fill_volume, fill_volume0, ejector_L1, punch_L1, fill_weight, compress, reverse)
##
##	raise Exception

	if reverse == True:
		del_parts()

	if reverse == True:
##		PFH = punch_depth + punch_L1
##
##		L = PFH - PV
##		press_downward = L + ejector_depth - PH
##		save_user_data(PFH,L,press_downward)

	## mirror
		mirror_sketch('s_punch',new_sketch='s_punch2',y=MIN)
		mirror_sketch('s_ejector',new_sketch='s_ejector2',y=MAX)
##		assembly_and_fill(top_sketch='s_ejector2', bot_sketch='s_punch2', L1=punch_L1)
		assembly_and_fill(top_sketch='s_ejector2', bot_sketch='s_punch2',fill_volume=fill_volume0)

		read_vars_from_model_description()
		PFH = _vars['PFH']
		ejector_depth = _vars['ejector_depth']
		punch_depth = _vars['punch_depth']

		if cal_L == True:
			L = PFH - PV
		if cal_PV == True:
			PV = PFH - L

		press_downward = L + ejector_depth - PH
		save_user_data(PFH,L,PV)

##	raise Exception
	## vertical cut
	offset_x_top = 5
	offset_x_bot = 3

	## horizontal cut
	offset_y_top1 = 5
	offset_y_top2 = 5

	offset_y_bot1 = 2 ## left
	offset_y_bot2 = 4 ## right

	point1 = (_xmax(powder) - offset_x_bot, _ymin(powder, x=_xmax(powder) - offset_x_bot), 0)
	point2 = (_xmax(powder) - offset_x_top, _ymax(powder),0)
	divide_faces_by_two_points(powder, powder.faces, point1=point1, point2=point2)

	point1 = (0,_ymax(powder) - offset_y_top1,0)
	point2 = (_xmax(powder),_ymax(powder) - offset_y_top2,0)
	divide_faces_by_two_points(powder, powder.faces, point1=point1, point2=point2)

	point1 = (0,_ymin(powder, x=MAX) + offset_y_bot1, 0)
	point2 = (die_R, _ymin(powder, x=MAX) + offset_y_bot2, 0)
	divide_faces_by_two_points(powder, powder.faces, point1=point1, point2=point2)


	edge_width = ejector_land - 0.01
	divide(powder,x=_xmax(powder) - edge_width)

##	raise Exception

	## edges
	powder_top = edge_select(powder,y=MAX)
	powder_top_left = edge_select(powder,y=MAX,x=(MIN,MAX, -offset_x_top))
	powder_top_right = edge_select(powder,y=MAX,x=(MAX,MAX, -offset_x_top))

	powder_left_top = edge_select(powder,x=MIN,y=MAX1)
	powder_left_bot = edge_select(powder,x=MIN,y=MIN1)

	powder_bot = edge_select(powder,x=(MIN1,MAX),y=(MIN,0))
	powder_bot_right = edge_select(powder, x=(MAX,MAX,-offset_x_bot),y=(0,MIN))
##	powder_bot_left = edge_select(powder,y=MIN1,x=(MIN1,MAX))
	powder_bot_left = edge_select(powder,x=MIN1, y=(0,MIN))

	powder_right = edge_select(powder,x=MAX)
	powder_right_bot = edge_select(powder,y=0.1,x=MAX)
	powder_right_mid = edge_select(powder,y=MID,x=MAX)
	powder_right_top = edge_select(powder,y=MAX1,x=MAX)

##	raise Exception

##	changing
##	set_sweep_path(powder.faces,dir='x',forward=True)
	set_element_shape(powder, objs=powder.faces, technique=SWEEP)

##	seed_edges(powder, edges=powder_top, esize=0.8)

##	edges = edge_select(powder,x=MAX1,y=MAX)
##	seed_edges(powder,edges=edges,enum=5)

##	seed_edges(powder,edges=powder_right_top,esize=1)
##	seed_edges(powder,edges=powder_left_bot,esize=1)

##	seed_edges(powder,edges=powder_right_bot,esize=1)

	## x dir
	edges = edges_at(powder,x=MAX1,y=_ymin(powder,x=MAX1),z=0)
	if reverse == False:
		bias_seed_edges(powder,edges=edges,enum=30,ratio=30,flip=False)   ;please_check
	else:
		bias_seed_edges(powder,edges=edges,enum=10,ratio=10,flip=True)

	edges = edge_select(powder,ref_locx=(MAX,-offset_x_bot + 0.1),y=(0,MIN))
	if reverse == False:
		bias_seed_edges(powder,edges=edges,enum=20,ratio=4,flip=True)	;please_check
	else:
		bias_seed_edges(powder,edges=edges,enum=6,ratio=2,flip=False)	;please_check

	seed_edges(powder,edges=powder_bot_left,esize=0.5)		;changing  ## 可能会影响到底部左下角的变形。0.4 OK for fric=0.2

	## y dir (在压制方向上不要使用bias_seed，否则可能会使网格变形很大。)
##	seed_edges(powder,edges=powder_right_top,esize=0.5)	;changing
	seed_edges(powder,edges=powder_right_bot,esize=0.4)	;changing
##	bias_seed_edges(powder,edges=powder_right_top,enum=10,ratio=5,flip=False)

##	edges = edge_select(powder,y=MAX)
##	seed_edges(powder,edges=edges,esize=0.5)

	mesh_part(powder,esize=1.0)

##	face = face_select(powder,x=MAX1,y=0.1)
##	remesh_region(powder,objs=face,technique=FREE)  ##
##	remesh_region(powder,objs=face,elemShape=TRI)

##	raise Exception

##	mesh_region(powder,faces=unselect(powder.faces,face))

##	apply_adaptive_mesh(faces=powder_A1.faces)	;changing
	apply_adaptive_mesh(elements=powder_A1.elements)	;changing

##	_m.TabularAmplitude(name='PCLOW', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.51, 0.0), (0.99, 21.0), (1.0, 21.0)))
##	_m.TabularAmplitude(name='PCUP', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.51, -30.82), (0.99, -30.82), (1.0, -31.32)))

##	_m.TabularAmplitude(name='press_upward', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.51, 0.0), (0.99, press_upward), (1.0, press_upward)))
##
##	_m.TabularAmplitude(name='press_downward', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.51, -press_downward + 1), (0.99, -press_downward + 1), (1.0, -press_downward)))

##	if punch_depth > 0:
####		dip = punch_depth
##		dip = 4
##	else:
##		dip = 2
	dip = 4  ## 第一步的时间要短，时间要快.

##	global move_die, aspect

	press_upward = PV
	press_downward = L + punch_depth - PH

	move_die = False	;changing1
	dip0 = -dip
	PV0 = -PV
	press_down = -press_downward

	changing
##	apply_gravity(Gy=-9800)

##	aspect = get_aspect_ratio(powder)
	save_user_data(move_die, press_upward, press_downward)

##	raise Exception

	if move_die == False:
		_m.TabularAmplitude(name='press_upward', timeSpan=STEP,
		    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, 0), (0.50, press_upward), (1.0, press_upward)))

		_m.TabularAmplitude(name='press_downward', timeSpan=STEP,
		    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, -dip), (0.50, -dip), (1.0, -press_downward)))

		apply_BC_on_RP_2D(punch_A1,U1=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(punch_A1,U2=1,amplitude='press_downward',stepname='step1')

		apply_BC_on_RP_2D(die_A1,U1=0,U2=0,UR3=0,stepname='step1')

		apply_BC_on_RP_2D(ejector_A1,U1=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(ejector_A1,U2=1,amplitude='press_upward',stepname='step1')

	else: ## PV0 = 0.9*PV0 + 0.1*PV0 ????
		_m.TabularAmplitude(name='top_move', timeSpan=STEP,
		    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, dip0), (0.50, dip0 + PV0),  (1.0, press_down + PV0)))

		_m.TabularAmplitude(name='die_move', timeSpan=STEP,
		    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, 0), (0.50, PV0),  (1.0, PV0)))

		apply_BC_on_RP_2D(punch_A1,U1=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(punch_A1,U2=1,amplitude='top_move',stepname='step1')

		apply_BC_on_RP_2D(ejector_A1,U1=0,U2=0,UR3=0,stepname='step1')

		apply_BC_on_RP_2D(die_A1,U1=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(die_A1,U2=1,amplitude='die_move',stepname='step1')


##	## interact

	## rigid body
	if reverse == False:
		m_punch = part_to_rigid_body(punch_A1, side_num='magenta')
		m_die = part_to_rigid_body(die_A1, side_num='yellow')	;please_check
		m_ejector = part_to_rigid_body(ejector_A1, side_num='magenta')
	else:
		m_punch = part_to_rigid_body(punch_A1, side_num='yellow')
		m_ejector = part_to_rigid_body(ejector_A1, side_num='yellow')
		m_die = part_to_rigid_body(die_A1, side_num='yellow')	;please_check

	## top
	powder_top = edge_select(powder_A1,y=MAX)
	powder_top_left = edge_select(powder_A1,y=MAX,x=MIN1)
	powder_top_right = unselect(powder_top, powder_top_left)

	## bot
	powder_bot = edge_select(powder_A1,x=(MIN1,MAX),y=(MIN,0))  ## OK
	powder_bot_left = edge_select(powder_A1,x=MIN1, y=(0,MIN))
	powder_bot_right = unselect(powder_bot, powder_bot_left)

	## left
	powder_left_top = edge_select(powder_A1,x=MIN,y=MAX1)
	powder_left_bot = edge_select(powder_A1,x=MIN,y=MIN1)

	## right
	powder_right = edge_select(powder_A1,x=MAX)
	powder_right_bot = edge_select(powder_A1,y=0.1,x=MAX)
	powder_right_mid = edge_select(powder_A1,y=MID,x=MAX)
	powder_right_top = edge_select(powder_A1,y=MAX1,x=MAX)

##	raise Exception

	changing
	s2s_interact_explicit('int_punch',master_region=m_punch, slave_edges=powder_top + powder_left_top + powder_right_top)
	s2s_interact_explicit('int_die',master_region=m_die, slave_edges = powder_right + powder_top_right + powder_bot_right)
	s2s_interact_explicit('int_ejector',master_region=m_ejector,slave_edges = powder_left_bot + powder_bot + powder_right_bot)

##	raise Exception
##	stop()

##	_results_disp = "collect_and_write_results('step1',['model',('U2','gap','image'), ('U2','max')],['powder_A1',('S1','max'),('PEQC4','max')])"
	_results_disp = 'fill_volume0', 'fill_volume',  'green_volume', 'compress', 'V2H','L','PV', 'PFH', 'press_downward', 'ejector_land', 'avg_density', ['powder_A1',('Density','gap',1e9), ('Mises','max'), ('S22','min'), ('S12', 'max'), ('S1','min'), ('PEQC4','min'),('DENSITY','range',1e9), ('SENER','max') ]

	save_mdb()
##	raise Exception

	create_inp(inp_file_title) ;please_check
	mdb.jobs[inp_file_title].submit()


	return

def main_A0198_rotary_cutter():
	## VER: 2013-07-23, v1.0

	global history,brief, script_file_full

	script_file_full = check_script_file('IK_A0198_cutter_origina_temp_disp.py')
	history = 'I1:==HW; HW: back to benchmark; HV:step no convection, bearing conv only shaft, bear righ small face no conv; HU: stress analysis; HT:bear right no convection, step no convecton core K=60; HS:bearer right no convection, step have conv, core K=19; HR:highK core and step no convection; HQ: step has convection, bearer core K=60; HP:step no convection, all right faces of bearer have convection; HO:step no convection; HN:bearer righ come back; HM:back to benchmark; HL:add: bearer righ no convection; HJ:bearer core: K=60; HI:改动save选项; HH:anvil非工作面hc降低一半; HG:bearer have right conv(partial); HF:remove copper ring; HE:+copper ring; HD:bearer right without conv, lock has. <<<HC:lock no convection<<<HB:shaft end no convection<<<HA:bearer step without convection<<<H9:modified bearing and bearer_top<<<H7:no gap,benchmark<<<H7:benchmark<<<H5:step no convection<<<H2:no convection on bearer right<<<H1:copper ring<<<GZ:low-K alum<<<GS:Al_6063<<<GJ:has gap and ring<<<GF:hollow<<<GD:correct region<<<G7:has ring gapG4:no hollow<<<G3:hollow<<<G1:hollow design<<<E5: not symmetric in y<<<E4: coupled analysis<<<E2:use deep ring<<<D4:bearing radio=0.05<<<ratio=0.7<<<CL(matched)<<<C7:as title<<<C6:No heat convection on lock and shaft end<<<C0:update bearing temerature based on Jacqus email<<<<         D1:correct the plastic strain<<<C1:correct true stres-strain<<<A5:no hole<<<A3<<<BR:apply only gravity<<<BI: ring from shaft<<<BG:ring on anvil<<<BB(good)<<<B2:No alum<<<B1:add aluminum layer<<<AB:mesh<<<A8:region<<<A6:material<<<A1:imported model<<<DR:esize=1<<<DQ:bigger esize<<DP:<<<DO:not create the rigid body and surface<<<DN:use surface<<<DM<<<DL:no round for punch<<<DK:round corner<<<DI<<<DH:die=1,ejector=1,punch=2(计算到0.36sec)<<<DG:die side=1<<<DF:use another side for rigid<<<DE:side=1 for die<<<DD:gap between punch and powder, adaptive mesh<<<DA:no adaptive mesh, punch=top,die=top+right<<<D9:adaptive mesh, punch=top,die=top+right(存在初始过盈问题)<<<D8:adaptive mesh,计算时间变短，但变形结果变得更合理(0.02秒)<<<D7:die=right,punch=top,ejector=bot+right,计算到0.08秒; 每隔0.001秒输出<<<D6:die=right,punch=top,ejector=bot+right,计算到0.067秒<<<D4:die=right,punch=top,ejector=bot+right,计算到0.012秒<<<B5<<<B2<<<B1<<<A6<<<A3<<<A2<<<A0:HPHT,base heigh=80.95<<<<C2:seperate contact<<<BY:fine mesh<<<BX:correct powder<<<BV:correct density<<<BU:no warn elemem<<<BO:good interact<<<BN:good assembly<<<BM:good mesh<<<BW:<<<BV:6500Pa<<<BU:geometry BC&loading<<<BP:copy model and restart<<<BO:restart<<<BK:import deformed mesh<<<AU:<<<AT:import mesh<<<AS<<<AR:<<<AQ:big 10%<<<AP:curve<<<'

	topic = 'rotary_cutter'
	save_user_data(topic,jobnum)

	loc = history.find('<<<')
	if loc == -1:
		brief = history
	else:
		brief = history[:loc]

	antype = 'thermal_stress'

	locals0 = locals().keys()

	customer = 'Pierre-Luc Dijon/2186/SANDVIK@SANDVIK, Engineering department, France'
	purpose = 'Thermal analysis + induced stress analysis, for the rotary cutter. Abnormal temperature was found  between anvil table and bearing. How to improve.'
	request_date = 'Jul 2013'

	version = 1	;changing1
	have_hollow = False	;changing1

	ring_gap = 0	;changing1
	if ring_gap > 0:
		have_ring = True
	else:
		have_ring = False

	surface_mat = 'Steel_WMoCrV'
	shaft_mat = 'Steel_36NiCrMo'

	changing1
	anvil_mats = [surface_mat, surface_mat]
	shaft_mats = [shaft_mat, shaft_mat]
	bearer_mats = [surface_mat, surface_mat]
	locker_mats = ['Steel_C45']

	save_user_data(anvil_mats,shaft_mats,bearer_mats,locker_mats)

	add_layer = False	;please_check
	add_mat = 'Copper'

	add_layer_thick = 10	;please_check
	add_layer_OD = 166		;please_check  ## 166, 146
	add_layer_ID = add_layer_OD - 2*add_layer_thick

	anvil_OD = 189
	if version == 2:
		anvil_thick = 26.5  ## hollow design
	else:
		anvil_thick = 21.5  ## design version 1.0

	if add_layer == False:
##		anvil_ID = 146  ## original
		anvil_ID = anvil_OD - 2*anvil_thick
	else:
		anvil_ID = add_layer_OD

	if add_layer == False:
##		shaft_D1 = 146   ## original
		shaft_D1 = anvil_ID
	else:
		shaft_D1 = add_layer_ID

	gap_ID = 82.5*2
	gap_OD = shaft_D1

	shaft_D12 = 85
	shaft_D2 = 70
	shaft_D3 = 32.983*2
	shaft_D4 = 20*2

	shaft_D1_length = 210	; x1 = shaft_D1_length	; anvil_length = shaft_D1_length
	shaft_D12_length = 3.5	; x12 = x1 + shaft_D12_length
	shaft_D2_length = 53  ; x2 = x12 + shaft_D2_length		## gap area
	shaft_tilt_length = 80.75	; x3 = x2 + shaft_tilt_length
	shaft_ext = 14.5				; x4 = x3 + shaft_ext
	hollow_length = 221.5/2
	hollow_D = 90
	shaft_length = shaft_D1_length + shaft_D2_length + shaft_tilt_length + shaft_ext  ## half length


	if version == 1:
		ring_thick = anvil_thick
		ring_width = 20
##		ring_width = shaft_D1_length - hollow_length - ring_gap

	else:
		ring_thick = 10.5
		ring_width = shaft_D1_length - hollow_length - ring_gap
	ring_OD = anvil_OD
	ring_ID = ring_OD - 2*ring_thick

	bearer_hole_R1 = shaft_D2/2
	bearer_hole_R2 = 32.645
	bearer_D1 = 189
	bearer_D2 = 165
	bearer_D3 = 100

	bearer_D1_length = 60
	bearer_D2_length = 14
	bearer_D3_length = 4
	bearer_length = bearer_D1_length + bearer_D2_length + bearer_D3_length   ## 78

	lock_length = 14
	lock_R2_length = 4
	lock_R1 = 42.5
	lock_R2 = 34.6
	lock_R3 = 20

	Fmax = 7363
	Fmax = Fmax/3.  ;changing1

	shaft = 'shaft'		;	shaft_A1 = 'shaft_A1'
	layer = 'layer'		;	layer_A1 = 'layer_A1'
	anvil = 'anvil'		;	anvil_A1 = 'anvil_A1'
	bearer = 'bearer'	;	bearer_A1 = 'bearer_A1'
	lock = 'lock'		;	lock_A1 = 'lock_A1'

	locals2globals(locals0,locals())
	save_user_data(Fmax)

##	stp_path = 'T:/Modelling/_On-going jobs/A0198 - rotary cutter_Pierre_ France/incomming/cur__534u0639_simu.stp'
##	import_stp(stp_path)
##
##	cut_instances(z=0,side=1)
##	cut_instances(x=0,side=-1)
##
##	raise Exception

## --
##	stp_path = 'C:/FEM/A0198/incomming/cur__534u0516.stp'
####	stp_path = 'E:/FEM/198/incomming/cur__534u0516.stp'
####	import_stp(stp_path,part_numbers=(1,2,3,9),part_names={1:'shaft',2:'anvil',3:'bearer',9:'lock'})   ## 6: bearing, 10: lock
##	import_stp(stp_path)
##	cut_instances(x=0,side=-1)
##	cut_instances(z=0,side=1)

##	raise Exception

## ---

	blank_part('shaft')
	create_base_sketch(name='s_shaft',ndir='z', return_sketch=True)
	connect_points('s_shaft',(0,0),(0, shaft_D1/2),(x1,shaft_D1/2),(x1,shaft_D12/2),(x12,shaft_D12/2),(x12,shaft_D2/2),
		(x2, shaft_D2/2),(x3, shaft_D3/2), (x3, shaft_D4/2), (x4, shaft_D4/2), (x4, 0), (0,0))

	revolve_sketch_to_part(shaft,'s_shaft',angle=180,axis='H')
	batch_divide(shaft,x=[x1,x2,x3])
	new_instance(shaft)

	if have_hollow == True:
		radial_cut(shaft,ndir='x',OD=hollow_D,x1=0, x2=hollow_length)
		divide(shaft,x=hollow_length)

	faces = face_select(shaft,radius=shaft_D2/2)
	divide_by_face(shaft,face=faces)

	faces = face_select(shaft,radius=shaft_D4/2)
	divide_by_face(shaft,face=faces)

	##	divide(shaft,y=0)
	##	circular_divide(shaft,ndir='x',x=x1,y=0,z=0, D=shaft_D1 - 2*add_layer_thick)

	if add_layer == True:
		blank_part('layer')
		radial_grow(layer,ndir='x',OD=add_layer_OD,ID=add_layer_ID,L=shaft_D1_length)
		bias_cut(layer,cut_sides='+z',z=0)
		new_instance(layer)

##	raise Exception

	blank_part('anvil')
	radial_grow(anvil,ndir='x',ID=anvil_ID,OD=anvil_OD,L=shaft_D1_length)
	bias_cut(anvil,cut_sides='+z',z=0)
	new_instance(anvil)
	divide(anvil,x=50)
##	circular_divide(anvil,ndir='x',x=x1,y=0,z=0,D=shaft_D1 + 2*add_layer_thick)

	blank_part('bearer')
	cylinder_grow(bearer,ndir='x',center0=(0,0,0),OD=bearer_D1,L=bearer_length)
	radial_cut(bearer,ndir='x',L=bearer_D2_length,ID=bearer_D2)
	radial_cut(bearer,ndir='x',x1=bearer_length,x2=bearer_length - bearer_D3_length,ID=bearer_D3)
	bias_cut(bearer,cut_sides='+z',z=0)

	move_part(bearer,x1=MIN,x2=x2)
	new_instance(bearer)
	boolean_cut(bearer,cutters=shaft,newpart_name='bearer',del_cutters=False)
	divide(bearer,x=_xmin(bearer,y=MAX))

##	raise Exception

	blank_part('lock')
	radial_grow(lock,ID=lock_R3*2,OD=lock_R1*2,L=lock_length,ndir='x')
	radial_cut(lock,ndir='x',R1=0,R2=lock_R2,L=lock_R2_length)
	bias_cut(lock,cut_sides='+z',z=0)
	move_part(lock,x1=MIN,x2=_xmax(bearer))
	new_instance(lock)

	if antype == 'thermal':
		cut_instances(y=0,side=-1)
	else:
		batch_divide(_m.parts.keys(),y=0)

	if have_ring == True:
		if version == 1:
			divide(anvil,x=x1-ring_width)
			radial_cut(anvil,ndir='x',x1=anvil_length - ring_width, x2=anvil_length - ring_width - ring_gap, ID=anvil_OD - 2*ring_thick)
			divide(bearer,x=_xmin(bearer,y=MAX))

		else:
			circular_divide(anvil,ndir='x',center=(0,0,0),D=anvil_OD - 2*ring_thick)
			divide(anvil,x=hollow_length)
			radial_cut(anvil,ndir='x',x1=hollow_length,x2=hollow_length + ring_gap, ID=anvil_OD - 2*ring_thick)
			divide(anvil,x=hollow_length + ring_gap)

	## anvil
	cells = radial_select(anvil,axis_dir='x',axis_center=(0,0,0),D_range=(ring_ID,ring_OD))
	cells = cell_select(anvil,cells=cells,x=(MAX,x1-ring_width))
	set_mat(anvil,cells=cells,mat=anvil_mats[1])

	cells = unselect(anvil.cells,cells)
	set_mat(anvil,cells=cells, mat=anvil_mats[0])

	changing
	## bearer
	cells = cell_select(bearer,x=MIN1)
	set_mat(bearer,cells=cells,mat=bearer_mats[0])

	cells = unselect(bearer.cells,cells)
	set_mat(bearer,cells=cells,mat=bearer_mats[1])

##	cells = radial_select(bearer,axis_dir='x', axis_center=(0,0,0), Rmax=bearer_D2/2.)
##	set_mat(bearer,cells=cells,mat='Steel')
##
##	cells = unselect(bearer.cells, cells)
##	set_mat(bearer,cells=cells, mat=surface_mat)


	## shaft
	if have_hollow == True:
		cells = radial_select(shaft,axis_dir='x',axis_center=(0,0,0),D_range = (hollow_D,shaft_D1))
		set_mat(shaft,cells=cells,mat=shaft_mats[0])

		cells = unselect(shaft.cells,cells)
		set_mat(shaft,cells=cells,mat=shaft_mats[1])
	else:
		set_mat(shaft,mat=shaft_mat)

	## lock
	set_mat(lock,mat='Steel_C45')

	if add_layer == True:
		set_mat(layer,mat=add_mat)

	faces = face_select(anvil_A1,radius=anvil_OD/2)
	create_surface(name='anvil_surface',faces=faces)

	faces = face_select(bearer_A1,radius=bearer_D1/2)
	create_surface(name='bearer_surface',faces=faces)

	edges = edge_select(anvil_A1,y=MAX)
	create_set(name='anvil_line',edges=edges)

	edges = edge_select(bearer_A1,y=MAX)
	create_set(name='bearer_line',edges=edges)

	raise Exception

	if antype == 'temp':
		create_heat_transfer_step(response='steady')
	elif antype == 'thermal_stress':
		create_coupled_temp_displacement_step()
	elif antype == 'stress':
		create_general_static_step()

	if  antype == 'stress':
		## for coupled analysis
		divide(shaft,x=(x12+x2)/2)
##		divide(shaft,x=(x12+x2)/2 - 3)
##		divide(shaft,x=(x12+x2)/2 + 3)
##
##		RP, csys = create_RP(shaft_A1,loc=((x12+x2)/2, 0, 0), name='local_csys',csys_type=CYLINDRICAL,axial_dir='z')
##		faces = face_select(shaft_A1,radius=shaft_D2/2,x=((x12+x2)/2 - 3, (x12+x2)/2 + 3),ny=-1)
####		coupling_faces_to_point('shaft_coupling',faces=faces,control_point=RP,U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=DISTRIBUTING)
##		coupling_faces_to_point('shaft_coupling',faces=faces,control_point=RP,U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=KINEMATIC)
##		apply_disp_fix('fix_bearing1',referencePoints=RP,U2=0)
##

##		RP, csys = create_RP(shaft_A1,loc=((x12+x2)/2, 0, 0), name='bear_center',csys_type=CYLINDRICAL,axial_dir='z')
		RP, csys= create_RP(shaft_A1,loc=((x12+x2)/2, 0, 0), name='bear_center',create_CSYS=True, csys_type=CYLINDRICAL)	;please_check
		faces = face_select(shaft_A1,radius=shaft_D2/2,ny=-1)

		coupling_faces_to_point('shaft_coupling',faces=faces,control_point=RP,U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, local_csys=csys, coupling_type=DISTRIBUTING)
##		apply_disp_fix('fix_bearing',referencePoints=RP,local_csys=csys, U1=0, U2=0,U3=0)	;changing1
		apply_disp_fix('fix_bearing',referencePoints=RP,local_csys=csys, U2=0,U3=0)	;changing1

##	stop()

	## have aluminum
	if add_layer == True:
		faces1 = face_select(anvil_A1,radius=anvil_ID/2)
		faces2 = face_select(alum_A1,radius=add_layer_OD/2)
		s2s_tie('tie_anvil_alum',mfaces=faces1,sfaces=faces2)

		faces1 = face_select(alum_A1,radius=add_layer_ID/2)
		faces2 = face_select(shaft_A1,radius=shaft_D1/2)
		s2s_tie('tie_alum_shaft',mfaces=faces1,sfaces=faces2)

	else:
	## without aluminum
		faces1 = face_select(shaft_A1,radius=shaft_D1/2)
		faces2 = face_select(anvil_A1,radius=shaft_D1/2)
		s2s_tie('tie_anvil_shaft',mfaces=faces2,sfaces=faces1)

	faces1 = face_select(shaft_A1,radius=shaft_D4/2)
	faces2 = face_select(lock_A1,radius=shaft_D4/2)
	s2s_tie('tie_shaft_lock',mfaces=faces1,sfaces=faces2)

	faces1 = face_select(shaft_A1,ndir='conical')
	faces2 = face_select(bearer_A1,ndir='conical')
	s2s_tie('tie_shaft_bearer',mfaces=faces1,sfaces=faces2)

	faces1 = face_select(bearer_A1,x=MAX)
	faces2 = face_select(lock_A1,x=MIN)
	s2s_tie('tie_bearer_lock',mfaces=faces1,sfaces=faces2)

##	raise Exception

	## load and BC

	rpm = 350
	Tsource = 35    # 34.5, 25, 30
	Tair = 25    ## 25.5, 20, 25
	if rpm >= 350 or Tsource >= 30:
		T_bearing = 45     ## 45, 40
	else:
		T_bearing = 40

	global hc, hc_bearing

	get_Re(rotate_R=0.1, rpm=rpm)
	get_Nu()
	hc = get_hc(Tsource)

	get_Re(rotate_R=0.05, rpm=rpm)   ## please_check
	get_Nu()
	hc_bearing = get_hc(T_bearing)
	print 'hc=',hc, ', hc_bearing=',hc_bearing

	save_user_data(rpm,Tsource,Tair,T_bearing,hc,hc_bearing)

	if 'thermal' in antype:
		faces = face_select(anvil_A1,x=(0,50),radius=anvil_OD/2)
		set_temperature_BC('anvil_temp',objs=faces,temp=Tsource)  ## 50 or 80 degC
		create_surface(name='heating_anvil',faces=faces)

		faces = face_select(anvil_A1, x=(50, MAX),radius=anvil_OD/2)
		apply_surface_convection('conv_anvil',faces=faces,h=hc, T_air=Tair)

		changing
		faces = face_select(shaft_A1,x=x1+10,radius=shaft_D2/2) + face_select(shaft_A1,x=x1) + face_select(bearer_A1,x=MIN)
		apply_surface_convection('conv_bearing',faces=faces,h=hc_bearing, T_air=T_bearing)  ;please_check

##		faces = face_select(shaft_A1,x=x1+10,radius=shaft_D2/2)
##		apply_surface_convection('conv_bearing',faces=faces,h=hc_bearing, T_air=T_bearing)  ;please_check

		changing
##		faces = face_select(bearer_A1,radius=bearer_D1/2)
##		apply_surface_convection('conv_bearer_top',faces=faces,h=hc, T_air=Tair)

		faces = face_select(bearer_A1,radius=bearer_D1/2) + face_select(bearer_A1,radius=bearer_D2/2)
		apply_surface_convection('conv_bearer_top',faces=faces,h=hc, T_air=Tair)

		changing
##		faces = face_select(bearer_A1,nx=1,x=_xmax(bearer,y=MAX))
		faces = face_select(bearer_A1,nx=1)
		apply_surface_convection('conv_bearer_right',faces=faces,h=hc/2, T_air=Tair)  ;please_check

		faces = face_select(shaft_A1,x=MAX)
		apply_surface_convection('conv_shaft_end',faces=faces,h=hc/4, T_air=Tair)

		faces = face_select(lock_A1,nx=1) + face_select(lock_A1,radius=lock_R1)
		apply_surface_convection('conv_lock',faces=faces,h=hc/4, T_air=Tair)

	if 'stress' in antype:
		apply_disp_symm('x',faces=faces_of_insts(x=0))
		apply_disp_symm('z',faces=faces_of_insts(z=0))
		apply_gravity(Gy=-9800)

##		edges = edge_select(bearer_A1,y=MAX)
##		apply_force(edges=edges,CF2=-Fmax/2)  ## half model

##	raise Exception
##	stop()

	## mesh
	edges = edge_select(anvil,radius=shaft_D1/2.0)
	seed_edges(anvil,edges=edges,enum=25)
	mesh_part(anvil,esize=5)

	if add_layer == True:
		edges = edge_select(layer,radius=add_layer_OD/2.0)
		seed_edges(layer,edges=edges,enum=25)
		mesh_part(layer,esize=5)

##	stop()

	edges = edge_select(shaft,radius=shaft_D1/2.0)
	seed_edges(shaft,edges=edges,enum=25)

	edges = edge_select(shaft,x=x3,edir='y')
	seed_edges(shaft,edges=edges, enum=5)

	mesh_part(shaft,esize=5)

##	raise Exception

	mesh_part(bearer,esize=3)
	mesh_part(lock,esize=2)

	if 'stress' in antype:
		nodes = node_select(bearer_A1,y=MAX)
		node1 = node_select(bearer_A1,y=MAX,x=_xmin(bearer,y=MAX))
		node2 = node_select(bearer_A1,y=MAX,x=_xmax(bearer,y=MAX))
		nodes = unselect(nodes,node1+node2)
		apply_force('CF',nodes=nodes,CF2=-Fmax/2)

	global _results_temp, _results_disp, _results_temp_disp
	_results_temp = "collect_and_write_results('step1','hc','hc_bearing',['model',('NT11','gap','image'), ('NT11','max','save'),('NT11','min')],['ANVIL_A1',('NT11','max'),('NT11','min')], ['BEARER_A1',('NT11','max'),('NT11','min')], '***', ['ANVIL_LINE',('NT11','gap'),('NT11','max'),('NT11','min')], ['BEARER_LINE',('NT11','gap'), ('NT11','max'),('NT11','min')],'***', ['SHAFT_A1',('NT11','max'),('NT11','min')])"
	_results_disp = "collect_and_write_results('step1','hc','hc_bearing',['model',('U2','gap','image'), ('U2','max'),('U2','min')],['ANVIL_LINE',('U2','gap','image'), ('U2','max'),('U2','min')], ['BEARER_LINE',('U2','gap','image'),('U2','max'),('U2','min')],['SHAFT_A1',('S1','max')])"
	_results_temp_disp = "collect_and_write_results('step1','hc','hc_bearing',['model',('U2','gap','image'),('U2','max'),('U2','min')],['ANVIL_LINE',('U2','gap','image'),('U2','max'),('U2','min'),('NT11','max'),('NT11','min')], ['BEARER_LINE',('U2','gap','image'),('U2','max'),('U2','min'),('NT11','max'),('NT11','min')],['SHAFT_A1',('S1','max')])"

##	raise Exception

	create_inp(inp_file_title) ;please_check
	mdb.jobs[inp_file_title].submit()
##	submit_job(inp_file_title)


	return

def main_A0209_HPHT_anvil():
	## VER: 2013-08-20, v1.7
	## collect_and_write_results('pressing',['model','U'],['ANVIL_A1','Mises','PEEQ','S1'], ['BLANK_A1','Mises','PEEQ','S1'])

##	global script_file_full

	script_file_full = check_script_file('BBG_A0209_HPHT_copper_R30_interact.py')

	topic = 'HPHT'

	save_user_data(jobnum, topic)

	## dimensions
	locals0 = locals().keys()
##	total_H = 132.715    ## 132.715 (127 is shown in 187 drawings)
##	blank_R = 62.865   ## 62.865 (57.15 is shown in 187 drawings, blank)
##	blank_H = 80.95   ## 87.31 (80.95 is shown in 187 drawings, blank) (87.31 is total, not only blank)

	customer = 'Selassie'
	purpose = '1. Use new dimension (correct dimensin for big10%) 2. comparison between solid and compound. 3. check hole effect'
	request_date = 'Nov 2013'

	pressure = 8500		;please_check
	size = 'big10%'   ## typical, or big10%
	top_mat = 'SixUF'  ## SixUF(6UF), H10F
	bot_mat = 'H10F'

	cool_down = False			;changing1
	copper_contact = 'interact'	;changing1  ## merge, tie, interact, hole, None
	if cool_down == True:
		copper_contact = 'merge'

	hole_R = 30				;changing1
	if copper_contact in empty:
		hole_R = 0

	save_user_data(pressure, size, hole_R, top_mat, bot_mat, copper_contact, cool_down)

##	_results_disp = 'pressure','size','hole_R', 'top_mat','bot_mat','copper_contact', [top_mat,('S1','max'),('PEEQ','max')], [bot_mat,('S1','max'),('PEEQ','max')],['Copper',('S1','max'),('PEEQ','max')]
	if size == 'typical':         ##
		blank_R = 2.25*inch       ## 57.15mm
		blank_H = 87.31      	  ## 87.31mm

		land_width = 1.374*inch   ## 34.9mm
		anvil_wall_clearance = 6.36

	elif size == 'big10%':
		blank_R = 2.25*1.1*inch   ## 62.865mm
		blank_H = 3.187*inch      ## 80.95mm (modified) (same as typical)  ## The base height of 80.95 is a compensation of the 10% bigger radius

		land_width = 1.374*inch   ## 34.9mm (same as typical)
		anvil_wall_clearance = 6.36 ## modified  (same as typical)

	cut_depth = blank_R - land_width/2
	## 39.7mm (typical), or 48.67mm (big 10%)

	anvil_H = anvil_wall_clearance + cut_depth
	## 46.05mm (typical), or 59.08mm (big 10%)

	total_H = blank_H + anvil_H
	## 133.37(typical), 132.725(big10%),
##	print2 ('total_H =',total_H)

	anvil_wall_clearance = anvil_H - cut_depth
	## 6.35mm(typical), or 10.414mm (big 10%)

	locals2globals(locals0,locals())

##	blank_part('block')
##	create_block(block,x=(0,2),y=(0,4),z=(0,5))
##	point1 = (0,4,5)
##	point2 = (2,0,5)
##	point3 = (2,0,0)

##	bias_cut(block,point1=point1,point2=point2,point3=point3)
##	raise Exception

##	faces = xmax_faces(block)
##	edges = edge_select(block,edir='z',x=MAX,y=MIN)
##	datum_plane = rotate_plane_to_datum_plane(faces[0],edges[0],angle=10)
##	bias_cut(datum_plane,cut_dir3='+')
##
##	raise Exception
##
##	datum_plane = create_datum_plane_by_3points(block,point1,point2,point3)
##	bias_cut(datum_plane,cut_dir3='+')
##
##	raise Exception

	blank_part('anvil')
	cylinder_grow('anvil','y',OD=2*blank_R,L=total_H)

	bias_cut(anvil,x=MID,cut_sides='-x')
	bias_cut(anvil,z=MID,cut_sides='+x')

##	bias_cut(anvil,point1 = (0, total_H,-land_width/2), cut_sides=['+z','+y'], angle_with_Y=15)  ## good

##	bias_cut(anvil,point1 = (land_width/2, total_H,0),cut_sides=['+x','+z'], angle_with_Z=15) ## good

##	bias_cut(anvil,point1 = (land_width/2, total_H,0), cut_sides=['+y','+x'], angle_with_Y=15) ## good
##	raise Exception

##	bias_cut(anvil,point1 = (land_width/2, total_H,0), angle_with_X=-15, thumb_axis='y',cut_dir3='+')  ## angle_with_X > 0: cut +x side; angle_with_X < 0: cut -x side
##	bias_cut(anvil,point1 = (land_width/2, total_H,0), angle_with_Y=15, thumb_axis='z',cut_dir3='+')  ## angle_with_Y > 0: cut +y side; angle_with_Y < 0: cut -y side
##	bias_cut(anvil,point1 = (0, total_H,-land_width/2), angle_with_Y=15, thumb_axis='x',cut_dir3='-')  ## angle_with_Y < 0: cut -y side; angle_with_Y > 0: cut +y side
##	bias_cut(anvil,point1 = (0, total_H,-land_width/2), angle_with_Z=-15, thumb_axis='x',cut_dir3='+')  ### angle_with_Z < 0: cut -z side; angle_with_Z > 0: cut +z side

##	raise Exception

##	bias_cut(anvil,cut_sides='-x',x=MID)
##	bias_cut(anvil,cut_sides='+z',z=MID)

##	raise Exception

	bias_cut(anvil,cut_sides=['+x','+y'], pass_point1 = (land_width/2, total_H,0), angle_with_Y=45)
	bias_cut(anvil,cut_sides=['-z','+y'], pass_point1 = (0, total_H,-land_width/2), angle_with_Z=45)

##	raise Exception

##	bias_cut(anvil,cut_sides=['+x','+y'], pass_point1 = (land_width/2, total_H,0), angle_with_Y=45)
##	bias_cut(anvil,cut_sides=['-z','+y'], pass_point1 = (0, total_H,-land_width/2), angle_with_Y=45)

	divide(anvil,y=blank_H)
##	divide(anvil,y=blank_H + 1)
##	divide(anvil,y=blank_H - 1)

	new_instance(anvil)
	copy_part(anvil,'blank')

##	raise Exception

	bias_cut(blank,y=blank_H,cut_sides='+y')
	bias_cut(anvil,y=blank_H,cut_sides='-y')

	new_instance(blank)
	new_instance(anvil)

##	create_ball('ball0',50)
##	raise Exception

	if hole_R > 0:
		create_half_ball('ball',radius=hole_R)	;please_check
##		raise Exception
		bias_cut(ball,cut_sides='-x',x=MID)
		bias_cut(ball,cut_sides='+z',z=MID)
		new_instance(ball)

		if copper_contact not in empty:
			boolean_cut(blank,cutters=ball)

			if copper_contact in ['tie','interact']:
				new_instance(ball)
			elif copper_contact == 'merge':
				merge_instances(partname='blank',parts=(blank,ball))
				new_instance(blank)

##	raise Exception
	set_mat(anvil,mat=top_mat)
	if copper_contact in empty:
		set_mat(blank,mat=bot_mat)
	else:
		if copper_contact == 'merge':
			cells = cell_select(blank,y=MAX1)
			set_mat(blank,cells=cells, mat=bot_mat)

			cells = unselect(blank.cells, cells)
			set_mat(blank,cells=cells, mat='Copper')
		else:
			set_mat(ball,mat='Copper')
			set_mat(blank,mat=bot_mat)

##	raise Exception

	## mesh
	edges = edge_select(anvil,x=MAX,y=(blank_H,MAX),edir='y')
	seed_edges(anvil,edges=edges,esize=0.5)
	mesh_part(anvil,esize=2)

	edges = edge_select(blank,z=MAX,y=MAX,edir='x')
	seed_edges(blank,edges=edges,esize=2)

	if copper_contact == 'merge':
		edges = edge_select(blank,edir='y',y=MIN1,x=MIN,z=MAX)
		seed_edges(blank,edges=edges,esize=2)
	mesh_part(blank,esize=3)

	## copper
	if copper_contact in ['tie','interact']:
		mesh_part(ball,esize=2)

##	raise Exception

##	xnodes = nodes_labels_of_faces(faces_of_insts(x=_xmin(anvil_A1)))
##	znodes = nodes_labels_of_faces(faces_of_insts(z=_zmax(anvil_A1)))
##	assembly_nodes = nodes_labels_of_faces(faces_of_insts(y=_ymin(anvil_A1)))
##	bot_nodes = nodes_labels_of_faces(ymin_faces(blank_A1))
##	top_elems = elements_labels_of_faces(ymax_faces(anvil_A1))
##
##	tie_nodes_anvil = nodes_labels_of_faces(ymin_faces(anvil_A1))
##	tie_nodes_blank = nodes_labels_of_faces(ymax_faces(blank_A1))

	## Interaction

##	create_general_static_step(stepname='cool',initial_inc=0.002,restart=True)	 ;please_check
##	_m.steps['high_temp'].Restart(frequency=1, numberIntervals=0, overlay=OFF, timeMarks=OFF)
##	global()['restart'] = True
	## will create the jobname.res file for later restart analysis

##	set_temperature_predefined_field(initial_step=20,modifys=[('step1',1000)])
##	set_temperature_predefined_field(initial_step=1000,modifys=[('step1',300)]))

##	apply_disp_symm('x',faces=faces_of_insts(x=_xmin(anvil_A1)))
##	apply_disp_symm('z',faces=faces_of_insts(z=_zmax(anvil_A1)))
##	apply_disp_fix('y_fix_bot',faces=faces_of_insts(y=_ymin(anvil_A1)),stepname='step1',Uy=0)

##	raise Exception

##	odb_title1 = script_file_full[:-3] + '_prefield'
##	create_inp(odb_title1,restart=True) ;please_check
##	mdb.jobs[odb_title1].submit()
##	mdb.jobs[odb_title1].waitForCompletion()

##	raise Exception

	## cooling and loading
##	clear_model_settings()

##	odb_title2 = script_file_full[:-3] + '_final'
####	create_new_model(script_file_full)
####	create_new_parts_with_deformed_mesh(odb_title1)
##
##	copy_model(to_name='restart',new_from_name='prefield')
##	clear_model_settings()
##	import_initial_state(odb_title1)

##	import_initial_stress(odb_title1,name='Imported_stress')


##	create_general_static_step(stepname='tie',initial_inc=0.002)
	if  cool_down == True:
		create_general_static_step(stepname='cool_down',initial_inc=0.002)
		set_temperature_predefined_field(initial_step=850,modifys=[('step1',300)])

	create_general_static_step(stepname='pressing',initial_inc=0.002)


##	raise Exception

##	node_region_contact(mnodes=tie_nodes_anvil, snodes=tie_nodes_blank,action='tie',step='step1')
	s2s_tie(mfaces=ymin_faces(anvil_A1),sfaces=ymax_faces(blank_A1))

##	apply_disp_symm('x',nodes=xnodes)
##	apply_disp_symm('z',nodes=znodes)
##	apply_disp_fix('y_fix_bot',nodes=bot_nodes,Uy=0)

	apply_disp_symm('x',faces=faces_of_insts(x=_xmin(anvil_A1)))
	apply_disp_symm('z',faces=faces_of_insts(z=_zmax(anvil_A1)))

	if cool_down == True:
		apply_disp_fix('top_fix',faces=ymax_faces(anvil_A1),Uy=0,step='cool_down', modifys=[('pressing','inactive')])

	if cool_down == True:
		cells = cell_select(blank_A1, mat=bot_mat)
		faces = faces_of_cells(cells=cells, y=MIN)
		apply_disp_fix('bot_fix',faces=faces,Uy=0,step=-1)
	else:
		faces = faces_of_insts(y=0)
		apply_disp_fix('bot_fix',faces=faces,Uy=0,step='pressing')


##	set_temperature_predefined_field(initial_step=1000,modifys=[('step2',300)])
##	apply_pressure('load_top',elements=top_elems, MPa=8500,step='step3')
	apply_pressure('load_top',faces=ymax_faces(anvil_A1),MPa=pressure,step='pressing')	;please_check

	if copper_contact in ['interact','tie']:
		faces1 = face_select(blank_A1,radius=hole_R)
		faces2 = face_select(ball_A1, radius=hole_R)
		if copper_contact == 'interact':
			s2s_interact_std('int_hole',mfaces=faces2,sfaces=faces1,friction=0.2,step=-1,force_create=True)
		else:
			s2s_tie('int_hole',mfaces=faces2,sfaces=faces1,step=-1,force_create=True)

	global _results_disp
##	_results_disp = 'pressure','size','hole_R', 'top_mat','bot_mat','copper_contact', [top_mat,('S1','max'),('PEEQ','max')], [bot_mat,('S1','max'),('PEEQ','max')],['Copper',('S1','max'),('PEEQ','max')]
##	save_user_data(_results_disp)

##	raise Exception

	_results_disp = 'pressure','size','hole_R', 'top_mat','bot_mat','cool_down', 'copper_contact', ['SixUF','S1','PEEQ'], ['H10F','S1','PEEQ'],['Copper','S1','PEEQ']
	disp = repr(_results_disp)[1:-1]
	save_user_data(disp)

	create_inp(inp_file_title) ;please_check
	mdb.jobs[inp_file_title].submit()


	return


def main_A0204_stamp_tool():
	## VER: 2013-06-07, v1.2

	global history,brief, _results_disp, script_file_full, _results_temp, _results_temp_disp

	topic = 'stamping_tool'
	script_file_full = check_script_file('CS_A0204_stamping_Tshape_steel_L60.py')
	history = 'BZ: no pin; BP:pin2end=9mm; BA:radius=1; AS: frictionless; AR:圆柱面固定，摩擦系数0.1，无过盈。此时应力仍然非常大。AK:overclosure=0.05; AI: fix y in bottom; AH:overclosure=-0.1, master=pin; AG:overclosure=0.01; AA: pin no interference, A0:model'

	save_user_data(jobnum)

	loc = history.find(';')
	if loc == -1:
		brief = history
	else:
		brief = history[:loc]

	locals0 = locals().keys()

	topic = 'stamping_tool'
	stamp_D = 10	;changing	## original: 10
	land2land = 10.68  ## grow out
	cut2cut = 9.48
	stamp_L = 60		;changing1	## original: 82.5

	case_width = cut2cut + 2*2
	case_L = 50
	case_short = 10
	case_R = 2

	block_L = 4.04
	block_H = 0.76
	button_R = 1.5

	land_width = 2.58
##	ext = 1

	pin_width = 3.58
	pin_length = land2land + 2
	pin_R = 0	;changing

	cylind_D = 4			;changing
	groove_depth = 3
	pin_H = groove_depth + 1
	pin2end = 9.5		;changing	## original: 9.5

	half_model = False	;changing
	CF = 100	;changing  ## 100kgf
	CF = CF*10
	if half_model == True:
		CF = CF/2.0

	save_user_data(CF,pin2end,cylind_D)


	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	slope_length = 5
	holder_length = 25

	steel_thick = 5	;changing1
	steel_width = 20

	blank_part('stamp')
	create_block(stamp,x=(-stamp_D/2, stamp_D/2),z=(-stamp_D/2, stamp_D/2),y=(0,-stamp_L))
	create_block(stamp,x=(-steel_width/2, steel_width/2), z=(-steel_width/2, steel_width/2),y=(0,-steel_thick))
	divide(stamp,y=_ymax(stamp) - holder_length)
	divide(stamp,y=-pin2end)

	cells = cell_select(stamp,y=(0,-holder_length))
	set_mat(stamp,cells=cells, mat='Steel')

	cells = unselect(stamp.cells, cells)
	set_mat(stamp,cells=cells, mat='H10F')

	new_instance(stamp)

	create_general_static_step()


##	create_block(stamp,x=(0,stamp_D),z=(0,stamp_D),y=(0,-holder_length))
##	faces_extrude(faces=ymin_faces(stamp),length=slope_length,expansion=0)

##	changing1
##	create_block(stamp,x=(0,stamp_D + 4),z=(0,stamp_D + 4),y=(0,-holder_length))	;changing1
##	faces_extrude(faces=ymin_faces(stamp),length=slope_length,expansion=-2)
##	faces_extrude(faces=ymin_faces(stamp),length=stamp_L - holder_length - slope_length)

	## pin
	## rect pin
##	hex_cut(stamp,poiRefX=(MIN,groove_depth),y=(-pin2end - pin_width/2, -pin2end + pin_width/2))
##	divide(stamp,y=-pin2end + pin_width/2)

	## hole pin
##	drill_hole(stamp,ndir='z',D=cylind_D,x=MID,y=-pin2end)
##	divide(stamp, y=-pin2end + cylind_D/2 + 2)

##	new_instance(stamp)
##	set_mat(stamp,mat='H10F')

##	edges = edge_select(stamp,edir='slope') + edge_select(stamp,edir='y')
##	edges = edge_select(stamp,edir='slope')
##	round_edges(stamp, edges=edges,radius=1)

##	raise Exception

##	blank_part('stamp')
##	cylinder_grow(stamp,ndir='z',OD=stamp_D,L=stamp_L)
##	bias_cut(stamp,cut_sides='+x',x=cut2cut/2)
##	bias_cut(stamp,cut_sides='-x',x=-cut2cut/2)
##	new_instance(stamp)
##
##	raise Exception
##
##	blank_part('land')
##	create_base_sketch(name='s_land',ndir='z', return_sketch=True)
##	connect_points('s_land',(0,0),(land_width,0))
##	create_arc('s_land',center=(land_width,button_R),radius=button_R,quarter=41)
##	connect_points('s_land',(land_width,2*button_R),(0,2*button_R))
##	create_arc('s_land',center=(0,button_R),radius=button_R,quarter=23)
##
##	extrude_sketch_to_part(land,sketch='s_land',length=stamp_L)
##	move_part(land,y1=MAX,y2=land2land/2,x1=MID,x2=0)
##	new_instance(land)
##	new_instance(land,y1=MIN,y2=-land2land/2)
##
##	merge_instances(partname='stamp',parts=(stamp,land),boundary='merge')
##	new_instance('stamp')
##
##	blank_part('pin')		;changing1
##	cylinder_grow(pin, ndir='x',OD=cylind_D, L = pin_length)
##	move_part(pin, y1=MID,y2=_ymid(stamp),z1=MID, z2=pin2end, x1=MID,x2=0)
##
####	create_block(pin, x=(0,pin_length),y=(0,pin_H), z=(0,pin_width))
####	move_part(pin,y1=MIN,y2=_ymax(stamp) - groove_depth,z1=MID, z2=pin2end, x1=MID,x2=0)
####
####	if pin_R > 0:
####		edges = edge_select(pin,y=MIN,edir='x')
####		round_edges(pin,edges=edges,radius=pin_R)
##
##	new_instance(pin)
##
####	raise Exception
##
##	boolean_cut(stamp,cutters=pin,newpart_name='stamp',del_cutters=False)
##
##	changing
##	divide(stamp,z=_zmax(pin) + 2)
##	divide(stamp,z=_zmin(pin) - 2)
##
##	## case
##	blank_part('case')
##	create_block('case',x=(0,case_width),y=(0,case_width),z=(0,case_L))
##	move_part(case,x1=MID,x2=_xmid(stamp),y1=MID,y2=_ymid(stamp),z1=MAX,z2=_zmax(stamp) - case_short)
##	new_instance(case)
##
##	edges = edge_select(case,edir='z')
##	round_edges(case,edges=edges,radius=case_R)
##
##	boolean_cut(case,cutters=stamp,del_cutters=False)
####	raise Exception
##
##	changing1
##	if half_model == True:
##		cut_instances(x=0,side=-1)
##
##	set_mat(stamp,mat='H10F')
##	set_mat(case,mat='Steel')
##	set_mat(pin,mat='Steel')
##
##	rotate_part(stamp,rotate_center=(0,0,0),angle_x=90)
##	new_instance(stamp)
##
##	rotate_part(pin,rotate_center=(0,0,0),angle_x=90)
##	new_instance(pin)
##
##	del_insts(case_A1)	;changing
##	del_insts(pin_A1)		;changing1
####	raise Exception

	## interact
##	friction = 0.2		;changing
##	save_user_data(friction)

	## 1, pin_R = 0
##	s2s_interact_std('int_pin_side1',mfaces=face_select(stamp_A1, z=_zmin(pin)), sfaces=zmin_faces(pin_A1), overclosure=0, friction=friction)
##	s2s_interact_std('int_pin_side2',mfaces=face_select(stamp_A1, z=_zmax(pin)), sfaces=zmax_faces(pin_A1), overclosure=0, friction=friction)

##	faces1 = face_select(pin_A1, y=MIN)
##	faces2 = face_select(stamp_A1, z=_zmid(pin), ny=1, ndir='y')
##	s2s_interact_std('int_pin_bot', mfaces=faces2, sfaces=faces1, friction=friction)

##	raise Exception

	## 2. pin_R > 0
##	sfaces = face_select(pin_A1,x=MID,y=(MAX1,MIN))
##	mfaces = faces = get_inner_faces(stamp_A1)
##	s2s_interact_std('int_pin',mfaces=mfaces, sfaces=sfaces)


##	create_general_contact_std(prop=0.2)
##	raise Exception

	apply_gravity(Gy=-9800)

##	raise Exception

	changing
##	faces = face_select(stamp_A1, z=(_zmin(pin_A1),MIN))
##	faces = unselect(faces, xmax_faces(stamp_A1))

	changing1
	faces = face_select(stamp_A1,y=-steel_thick - 1)
	apply_disp_fix('stamp_fix',faces=faces, Ux=0,Uz=0)

	apply_disp_fix('end_fix',faces=ymax_faces(stamp_A1), Uy=0)

##	faces = face_select(stamp_A1,z=MIN1)
##	apply_disp_fix('stamp_fix', faces=zend_faces(stamp_A1),Ux=0,Uy=0)
##	apply_disp_fix('stamp_fix_z', faces=zmin_faces(stamp_A1),Uz=0)

##	if 'pin_A1' in a.instances.keys():
##		apply_disp_fix('pin_fix',faces=xmax_faces(pin_A1), Ux=0, Uy=0, Uz=0)
##		apply_disp_fix('pin_fix',faces=xmin_faces(pin_A1), Ux=0, Uy=0, Uz=0)		;changing1
##
##	if 'case_A1' in a.instances.keys():
##		apply_disp_fix('case_move', faces=zmax_faces(case_A1),Uz=10)

##	changing1
	## half model
##	faces = faces_of_insts(x=0)
##	apply_disp_symm('x',faces=faces)

##	raise Exception


	## case
##	edges = edge_select(case,y=MIN)
##	seed_edges(case,edges=edges, esize=0.3)
##	mesh_part(case)

##	raise Exception

	## stamp
	edges = edge_select(stamp,y=MIN, exterior=True)
	seed_edges(stamp,edges=edges, esize=1)
##
	edges = edge_select(stamp,y=MAX, exterior=True)
	seed_edges(stamp,edges=edges, esize=1)
##
	changing
##	edges = edge_select(stamp,z=_zmid(pin))
##	seed_edges(stamp,edges=edges, enum=4)
##
##	edges = edge_select(stamp,y=3,z=MAX,edir='circular')
##	seed_edges(stamp,edges=edges,esize=0.2)

##	set_element_shape(stamp,elemShape=TET)

	mesh_part(stamp, esize=2)

##	## pin
##	mesh_part(pin, esize=0.5)
##
	## load: CF-bending


##	edges = edge_select(stamp_A1,y=MAX,edir='x',z=MAX)
##	apply_CF(name='CF', edges=edges, CF2=CF)

##	nodes = node_select(stamp_A1, y=MIN,z=MAX)
##	apply_force(name='CF', nodes=nodes, CF3=-CF/2)

	nodes = node_select(stamp_A1,y=MIN,x=_xmin(stamp_A1,y=MIN))
	apply_force(name='CF', nodes=nodes, CF1=CF)

##	nodes = node_select(stamp_A1,y=MIN,x=_zmax(stamp_A1,y=MIN))
##	apply_force(name='CF', nodes=nodes, CF3=-CF)


##	raise Exception

##	_results_disp = 'pin2end', 'stamp_D', 'CF', ['stamp_A1',('Mises','max'), ('S1','max') , ('S22','max'),  ('U2', 'max'), ('CPRESS','max')]

	_results_disp = {'var':('pin2end','stamp_D','CF'),'stamp_A1':('Mises','S1','S22','U2','U1')}

	create_inp(inp_file_title, request_num=2) ;please_check
##	raise Exception

	mdb.jobs[inp_file_title].submit()


	return

def main_A0205_press_tool():
	## VER: 2014-01-08, v1.0

	global history,brief, _results_disp, script_file_full

	topic = 'press_tool'
	script_file_full = check_script_file('C2_A0205_press_tool_922_H15F_L20.py')	;changing
	history = 'esize=1; B0:carbide length=30; AY:H15F+Steel; AX:H10F+steel; AE:rigid body; A1:model'

	pressure = 200		;changing1
	save_user_data(jobnum,pressure)

	loc = history.find(';')
	if loc == -1:
		brief = history
	else:
		brief = history[:loc]

	locals0 = locals().keys()

	punch_thick = 4.71
	punch_width = 31.48
	punch_length = 85	;changing1	## original: 116
	carbide_length = 20		;changing  ## 15(original)

	side_angle = 15
	mid_angle = 46.79		;changing1	## 46.79(original),60
	cut_angle = 22

	tip_radius = 0			;changing1	## original: 0
	carbide_mat = 'H15F'	;changing1	## H10F, Steel_K390

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	## punch
	blank_part('punch')
	create_block(punch,x=(0,punch_width + 10),y=(0,150), z=(0,punch_thick))

	bias_cut(punch,cut_sides=['-x','+z'], point1=(0,0,0), angle_with_Z=side_angle)
	bias_cut(punch,cut_sides=['+x','-z'], point1=(punch_width,0,0), angle_with_Z=side_angle)

	copy_part('punch', newpart_name='cutter')

	point1 = _xmid(cutter),_ymin(cutter), _zmid(cutter)
	axis1 = create_datum_axis(cutter,point1=point1,edir='x',angle=-mid_angle,about_axis='y')

	face1 = face_select(cutter,z=MAX)[0]
	point2 = intersect_point_of_line_and_plane(line=axis1, plane=face1)

	face1 = face_select(cutter,z=MIN)[0]
	point3 = intersect_point_of_line_and_plane(line=axis1, plane=face1)

	axis2 = create_datum_axis(cutter,point1=point2,edir='x',angle=-cut_angle, about_axis='z')
	plane1 = create_datum_plane_by_2axis(cutter,axis1,axis2)
	bias_cut(cutter,cut_sides='-y',datum_plane=plane1)

	axis3 = create_datum_axis(cutter,point1=point3,edir='x',angle=cut_angle, about_axis='z')
	plane2 = create_datum_plane_by_2axis(cutter,axis1,axis3)
	bias_cut(cutter,cut_sides='-y',datum_plane=plane2)

	if tip_radius > 0:
		edges = edge_select(cutter,y=MIN)
		round_edges(cutter,edges=edges,radius=tip_radius)

	move_part(cutter, y1=MIN, y2=_ymax(punch) - 15, x1=MID, x2=_xmid(punch))

	new_instance(punch)
	new_instance(cutter)

##	raise Exception

	boolean_cut(punch, cutters=cutter)	## punch_A1 recreated
	divide(punch,y=_ymax(punch) - carbide_length)

##	raise Exception

	## case
	blank_part('case')
	create_block(case,x=(0,4*punch_width),y=(0,punch_length + 10),z=(0,60))
	move_part(case,x1=MID,x2=_xmid(punch),y1=MAX,y2=_ymax(punch) - 10,z1=MID,z2=_zmid(punch))  ## punch冒出来
	new_instance(case)

	boolean_cut(case, cutters=punch,del_cutters=False)
	bias_cut(punch,cut_sides='-y',y=_ymax(punch) - punch_length)

	cells = cell_select(punch,y=MIN1)
	set_mat(punch,cells=cells,mat='Steel_K460')	;changing1	## Steel

	cells = unselect(punch.cells,cells)
	set_mat(punch,cells=cells,mat=carbide_mat)	;changing1	## H10F, Steel_K390

	move_part(case,y1=MID,y2=_ymid(punch))

##	move_part(case,y1=MAX,y2=_ymax(punch) + 10)
##	bias_cut(punch,y=_ymin(case),cut_sides='-y')

	clearance = 0.04  ;changing1		## 40um

	faces = get_inner_faces(case,nx=1)
	angle_x = face_angle(faces[0],'x')
	angle_z = face_angle(faces[0],'z')

	faces_to_shellpart(faces,name='shell1',rigid=True)
	move_part(shell1,dx=-clearance*sinD(angle_x),dz=clearance*sinD(angle_z))	;changing1
	new_instance(shell1)

	faces = get_inner_faces(case,nx=-1)
	faces_to_shellpart(faces,name='shell2',rigid=True)
	move_part(shell2,dx=clearance*sinD(angle_x),dz=-clearance*sinD(angle_z))
	new_instance(shell2)

	faces = get_inner_faces(case,ndir='z',nz=1)
	faces_to_shellpart(faces,name='shell3',rigid=True)
	move_part(shell3,dz=-clearance)
	new_instance(shell3)

	faces = get_inner_faces(case,ndir='z',nz=-1)
	faces_to_shellpart(faces,name='shell4',rigid=True)
	move_part(shell4,dz=clearance)
	new_instance(shell4)

	create_general_static_step()

##	raise Exception

##	shell.setValues(space=THREE_D, type=DISCRETE_RIGID_SURFACE)
##	new_instance(shell)

	have_shell = True		;changing1
	if have_shell == False:
		del_insts([shell1_A1, shell2_A1, shell3_A1, shell4_A1])
	else:
		part_to_rigid_body(shell1_A1,region_type='body')
		part_to_rigid_body(shell2_A1,region_type='body')
		part_to_rigid_body(shell3_A1,region_type='body')
		part_to_rigid_body(shell4_A1,region_type='body')

	##	raise Exception

		## create surface
		sfaces = face_select(punch_A1,nx=1,x=MAX1)
		mfaces = create_surface(shell2_A1.faces, side='-x')
		s2s_interact_std('right_face',mfaces=mfaces,sfaces=sfaces)

	##	mfaces,sfaces = mate_faces_in_inst(shell_A1,faces=faces)
	##	s2s_interact_std('right_face',mfaces=mfaces,sfaces=sfaces,initial_clearance=0.04)

		sfaces = face_select(punch_A1,nx=-1,x=MIN1)
		mfaces = create_surface(shell1_A1.faces, side='+x')
		s2s_interact_std('left_face',mfaces=mfaces,sfaces=sfaces)

	##	mfaces,sfaces = mate_faces_in_inst(shell_A1,faces=faces)
	##	s2s_interact_std('left_face',mfaces=mfaces,sfaces=sfaces,initial_clearance=0.04)

		sfaces = face_select(punch_A1,z=MIN)
		mfaces = create_surface(shell3_A1.faces, side='+z')
		s2s_interact_std('back_face',mfaces=mfaces,sfaces=sfaces)

	##	mfaces,sfaces = mate_faces_in_inst(shell_A1,faces=faces)
	##	s2s_interact_std('back_face',mfaces=mfaces,sfaces=sfaces,initial_clearance=0.04)

		sfaces = face_select(punch_A1,z=MAX)
		mfaces = create_surface(shell4_A1.faces, side='-z')
		s2s_interact_std('front_face',mfaces=mfaces,sfaces=sfaces)

	##	mfaces,sfaces = mate_faces_in_inst(shell_A1,faces=faces)
	##	s2s_interact_std('right_face',mfaces=mfaces,sfaces=sfaces,initial_clearance=0.04)


		## loand and BC
	##	faces = shell_A1.faces
	##	apply_disp_fix('shell_fix',faces=faces, Ux=0, Uy=0, Uz=0)

		apply_disp_fix('shell_fix_left',referencePoints=shell1_A1,Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)
		apply_disp_fix('shell_fix_right',referencePoints=shell2_A1,Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)
		apply_disp_fix('shell_fix_back',referencePoints=shell3_A1,Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)
		apply_disp_fix('shell_fix_front',referencePoints=shell4_A1,Ux=0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

		history_output_request(rigid_body=shell1_A1,variables='RF')
		history_output_request(rigid_body=shell2_A1,variables='RF')
		history_output_request(rigid_body=shell3_A1,variables='RF')
		history_output_request(rigid_body=shell4_A1,variables='RF')

	##	raise Exception

	faces = ymin_faces(punch_A1)
	apply_disp_fix('punch_fix',faces=faces,Uy=0, Ux=0, Uz=0)

	faces = face_select(punch_A1,ny=1)
	apply_pressure('load_top',faces=faces,MPa=pressure,step='step1')		;changing1

##	raise Exception

	## mesh
	edges = edge_select(punch,z=MIN1)
	seed_edges(punch,edges=edges,enum=6)
	mesh_part(punch,esize=1)

	## shell
	edges = edge_select(shell1,z=MIN1)
	seed_edges(shell1,edges=edges,enum=6)

	mesh_part(shell1,esize=1)

	edges = edge_select(shell2,z=MIN1)
	seed_edges(shell2,edges=edges,enum=6)

	mesh_part(shell2,esize=1)

	mesh_part(shell3,esize=1)
	mesh_part(shell4,esize=1)

##	raise Exception

##	_results_disp = ['punch_A1',('S1','max'),('Mises','max'), ('U3','max')]

	global _results_disp
	_results_disp = {'var':'pressure', 'punch_A1':('S1','Mises','U3')}
##	_results_disp = {'punch_A1':('S1','Mises',('U3','min'))}

	create_inp(inp_file_title, request_num=2) ;please_check
##	raise Exception

	mdb.jobs[inp_file_title].submit()

	return


def main_A0999_dengzi():
	## VER: 2014-03-24, v1.0


	global _results_disp, script_file_full

	topic = 'press_tool'
	script_file_full = check_script_file('A2_A0999_deng_model_enhanced.py')	;changing
	history = 'AP:tip_gap increase 0.5mm; AH:offset, x=-1mm;  A0:model'
	save_user_data(jobnum, topic)

	create_step('step1')

	locals0 = locals().keys()

	deng_length = 1000
	deng_H = 1100
	top_width = 160

	## 14号槽钢
	cao_thick = 6
	cao_width = 58
	cao_height = 140

	## 角钢
	jiao_width = 50
	jiao_thick = 5

	bot_width = top_width + 100

	leg_H = deng_H - jiao_width - cao_width

	force = 5000*10
	work_width = 500

	locals2globals(locals0,locals(),save_var=True)

	blank_part('beam')
	create_block(beam, (0,cao_height), (0,cao_width), (0,deng_length))
	hex_cut(beam, (cao_thick, cao_height - cao_thick), (cao_thick, cao_width), (0, deng_length))

	copy_part(beam,'leg1')
	rotate_part(leg1,angle_x=90)
	move_part(leg1,y1=MIN,y2=cao_width,x1=MIN,x2=0,z1=MIN,z2=0)
	bias_cut(leg1,y=_ymin(leg1) + leg_H, cut_sides='+y')

	copy_part(beam,'leg2')
	rotate_part(leg2,angle_x=-90)
	move_part(leg2,y1=MIN,y2=cao_width, x1=MIN,x2=0, z1=MAX, z2=top_width)
	bias_cut(leg2,y=_ymin(leg2) + leg_H, cut_sides='+y')

	new_instance(leg1)
	new_instance(leg1,x1=0, x2=deng_length - cao_height)

	new_instance(leg2)
	new_instance(leg2,x1=0, x2=deng_length - cao_height)

	blank_part('base')
	create_block(base,(0,deng_length + 40),(0,cao_width),(0,bot_width))
	move_part(base,z1=MID,z2=top_width/2, x1=MID, x2=deng_length/2)
	new_instance(base)

	blank_part('anvil')
	create_block(anvil, (0,deng_length), (0,jiao_width), (0,top_width))
	hex_cut(anvil, (jiao_thick, deng_length - jiao_thick), (jiao_thick, jiao_width), (jiao_thick, top_width - jiao_thick))
	move_part(anvil, y1=MIN, y2=_ymax(leg1))
	new_instance(anvil)
	divide(anvil, y=_ymin(anvil) + jiao_thick)
	divide(anvil, z=_zmin(anvil) + jiao_thick)
	divide(anvil, z=_zmax(anvil) - jiao_thick)
	divide(anvil, x=_xmin(anvil) + jiao_thick)
	divide(anvil, x=_xmax(anvil) - jiao_thick)

	blank_part('wood')
	create_block(wood, (jiao_thick, deng_length - jiao_thick), (0, jiao_width), (jiao_thick, top_width - jiao_thick))
	move_part(wood, y1=MIN, y2=_ymin(anvil) + jiao_thick, x1=MID, x2=deng_length/2)
	new_instance(wood)

	divide(wood,x=_xmid(wood) - work_width/2)
	divide(wood,x=_xmid(wood) + work_width/2)

	## jin
	blank_part('jin1')
	create_block(jin1, z=(0, deng_length - 2*cao_height), x=(0,jiao_width), y=(0, jiao_width))
	hex_cut(jin1, x=(0, jiao_width - jiao_thick), y=(0, jiao_width - jiao_thick))
	rotate_part(jin1, angle_y=90)

	move_part(jin1, x1=MIN, x2=cao_height, y1=MAX, y2=_ymax(leg1), z1=MAX, z2=cao_width)
	new_instance(jin1)

	copy_part(jin1, 'jin2')
	rotate_part(jin2, angle_y=180)
	move_part(jin2, x1=MIN, x2=cao_height, y1=MAX, y2=_ymax(leg1), z1=MIN, z2=_zmax(anvil) - cao_width)
	new_instance(jin2)


##	raise Exception

	set_mat(wood, mat='wood')
	for part in [leg1, leg2, anvil, base, jin1, jin2]:
		set_mat(part, mat='Steel')

	## contact
	s2s_tie('tie_leg1_base', insts=(base_A1, leg1_A1), y=_ymax(base_A1))
	s2s_tie('tie_leg1_base', insts=(base_A1, leg1_A2), y=_ymax(base_A1))
	s2s_tie('tie_leg2_base', insts=(base_A1, leg2_A1), y=_ymax(base_A1))
	s2s_tie('tie_leg2_base', insts=(base_A1, leg2_A2), y=_ymax(base_A1))

	s2s_tie('tie_leg1_anvil', insts=(anvil_A1, leg1_A1), y=_ymin(anvil_A1))
	s2s_tie('tie_leg1_anvil', insts=(anvil_A1, leg1_A2), y=_ymin(anvil_A1))
	s2s_tie('tie_leg1_anvil', insts=(anvil_A1, leg2_A1), y=_ymin(anvil_A1))
	s2s_tie('tie_leg1_anvil', insts=(anvil_A1, leg2_A2), y=_ymin(anvil_A1))

	s2s_interact_std('int_wood_anvil_bot', parts=(anvil, wood), y=_ymin(wood))
	s2s_interact_std('int_wood_anvil_sidex', parts=(anvil, wood), x=_xmin(wood))
	s2s_interact_std('int_wood_anvil_sidex', parts=(anvil, wood), x=_xmax(wood))
	s2s_interact_std('int_wood_anvil_sidez', parts=(anvil, wood), z=_zmin(wood))
	s2s_interact_std('int_wood_anvil_sidez', parts=(anvil, wood), z=_zmax(wood))

	s2s_tie('tie_jin1_anvil', parts=(anvil, jin1), y=_ymax(jin1))
	s2s_tie('tie_jin1_anvil', parts=(anvil, jin2), y=_ymax(jin1))

	s2s_interact_std('int_jin1_leg1', insts=(jin1_A1, leg1_A1), x=_xmin(jin1))
	s2s_interact_std('int_jin1_leg1', insts=(jin1_A1, leg1_A2), x=_xmax(jin1))

	s2s_interact_std('int_jin2_leg1', insts=(jin2_A1, leg2_A1), x=_xmin(jin1))
	s2s_interact_std('int_jin2_leg1', insts=(jin2_A1, leg2_A2), x=_xmax(jin1))

##	raise Exception


	## contact
##	mfaces = ymax_faces(base_A1)
##	sfaces = ymin_faces(leg1_A1)
##	s2s_tie('tie_leg1_base', mfaces=mfaces, sfaces=sfaces)
##
##	sfaces = ymin_faces(leg1_A2)
##	s2s_tie('tie_leg1_base', mfaces=mfaces, sfaces=sfaces)
##
##	sfaces = ymin_faces(leg2_A1)
##	s2s_tie('tie_leg2_base', mfaces=mfaces, sfaces=sfaces)
##
##	sfaces = ymin_faces(leg2_A2)
##	s2s_tie('tie_leg2_base', mfaces=mfaces, sfaces=sfaces)
##
##	mfaces = ymin_faces(anvil_A1)
##	sfaces = ymax_faces(leg1_A1)
##	s2s_tie('tie_leg1_anvil', mfaces=mfaces, sfaces=sfaces)
##
##	sfaces = ymax_faces(leg1_A2)
##	s2s_tie('tie_leg1_anvil', mfaces=mfaces, sfaces=sfaces)
##
##	sfaces = ymax_faces(leg2_A1)
##	s2s_tie('tie_leg2_anvil', mfaces=mfaces, sfaces=sfaces)
##
##	sfaces = ymax_faces(leg2_A2)
##	s2s_tie('tie_leg2_anvil', mfaces=mfaces, sfaces=sfaces)
##
##	mfaces = face_select(anvil_A1, y=_ymin(anvil_A1) + jiao_thick)
##	sfaces = ymin_faces(wood_A1)
##	s2s_interact_std('int_anvil_wood_bot',mfaces=mfaces,sfaces=sfaces)
##
##	mfaces = face_select(anvil_A1,z=_zmax(anvil) - jiao_thick)
##	sfaces = zmax_faces(wood_A1)
##	s2s_interact_std('int_anvil_wood_zmax', mfaces=mfaces, sfaces=sfaces)
##
##	mfaces = face_select(anvil_A1,z=_zmin(anvil) + jiao_thick)
##	sfaces = zmin_faces(wood_A1)
##	s2s_interact_std('int_anvil_wood_zmin', mfaces=mfaces, sfaces=sfaces)
##
##
##	mfaces = face_select(anvil_A1,x=_xmax(anvil) - jiao_thick)
##	sfaces = xmax_faces(wood_A1)
##	s2s_interact_std('int_anvil_wood_xmax', mfaces=mfaces, sfaces=sfaces)
##
##	mfaces = face_select(anvil_A1,x=_xmin(anvil) + jiao_thick)
##	sfaces = xmin_faces(wood_A1)
##	s2s_interact_std('int_anvil_wood_xmin', mfaces=mfaces, sfaces=sfaces)

	## BC:
	apply_disp_fix('bot_fix', faces=ymin_faces(base_A1), fix_all=True)

	## load
	faces = face_select(wood_A1, y=MAX,x=MID)
	apply_pressure('pressure', faces=faces, MPa=force/get_area(faces))

	## mesh
	for part in [anvil, leg1, leg2, base, wood, jin1, jin2]:
		mesh_part(part, esize=15)

##	mesh_part(anvil, esize=15)
##	mesh_part(leg1, esize=15)
##	mesh_part(leg2, esize=15)
##	mesh_part(base, esize=15)
##	mesh_part(wood, esize=15)

	create_inp(inp_file_title, request_num=2) ;please_check
	mdb.jobs[inp_file_title].submit()

	return




def main_A0400_XFEM():
	## VER: 2014-04-19, v1.0

	global _results_dict    ## XFEM

	check_script_file('A3_A0216_XFEM_example.py')	;changing
	history = ' A0:model'

	## plate
	blank_part('plate')
	create_block(plate,x=(0,3),y=(3,-3),z=(0,1))

	s1 = create_base_sketch('sk_crack')
	s1.Line(point1=(0.0, 0.08), point2=(1.5, 0.08))
	sketch_to_shellpart(s1,partname='crack', pshape='3D', depth=1.0)

	set_mat(plate,mat='Steel')

	## Fracture evolution
	_m.materials['Steel'].MaxpsDamageInitiation(table=((84.4, ), ))    ## S1 = 84.4 MPa
	_m.materials['Steel'].maxpsDamageInitiation.DamageEvolution(
	    type=ENERGY, mixedModeBehavior=POWER_LAW, power=1.0, table=((42200e3,
	    42200e3, 42200e3), ))

	raise Exception

	return





def main_A0214_powder_compaction():
	## VER: 2014-03-18, v1.0

	global _results_dict

	check_script_file('BK_A0214_compaction_double_top_dome_PH20_R5.py')	;changing
	history = ' A0:model'
##	save_user_data(jobnum, topic)

	locals0 = locals().keys()
	topic = 'lateral_pressure'
	green_H = 2			;changing
	green_R = 20		;changing
	top_dome = False	;changing
	bot_dome = False	;changing
	double = False		;changing  ## double action
	locals2globals(locals0,locals(),save_var=True)

	s1 = create_base_sketch('s_tpunch')
	if top_dome == False:
		connect_points(s1, (green_R + 1, 0), (0,0))   ## top punch要从右向左画，这样surface为SPOS
	else:
		create_arc(s1, center=(0,0), point1=(green_R, 0), point2=(0,green_R))
		connect_points(s1,(green_R + 1, 0), (green_R, 0))
	create_construction(s1,x=0)

	s1 = create_base_sketch('s_bpunch')  ## bot punch要从左向右画，这样surface为SPOS
	if bot_dome == False:
		connect_points(s1, (0,0), (green_R + 1, 0))
	else:
		create_arc(s1, center=(0,0), point2=(green_R, 0), point1=(0,-green_R))
		connect_points(s1,(green_R, 0),(green_R + 1, 0))
	create_construction(s1,x=0)

##	pars = get_PH_PFH(green_R=green_R, green_H=green_H, top_punch_sketch='s_tpunch')
	pars = get_PH_PFH(green_R=green_R, green_H=green_H, bot_punch_sketch='s_bpunch')
	raise Exception

	locals0 = locals().keys()
	fill_H = pars['fill_H']
	green_H = pars['green_H']
	green_R = pars['green_R']

	move_die = False
	green_section = pars['green_section']
	compressed_H = pars['compressed_H']
	tpunch_depth = _ylength('s_tpunch')
	bpunch_depth = _ylength('s_bpunch')
	green_weight = pars['green_weight']
	press_ratio = pars['press_ratio']
	fill_mid_H = pars['fill_mid_H']

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	assembly_and_fill(top_sketch='s_tpunch', bot_sketch='s_bpunch', PFH=fill_H, PH=green_H, die_R=green_R)
##	raise Exception

	create_dynamic_explicit_step()

	## mesh
	edges = edge_select(powder,x=MAX1,exterior=False)
	bias_seed_single(powder, edges=edges, enum=10,ratio=10,dir='+x')

##	edges = edge_select(powder,y=MAX1,exterior=False)
##	bias_seed_single(powder, edges=edges, enum=10,ratio=10,dir='+y')

	set_element_shape(powder, objs=powder.faces, technique=SWEEP)  ## 可能仍然有些区域无法用sweep方法。
	mesh_part(powder,esize=0.5)  ## origin: 0.2			## 同时使用SWEEP和ALE时，esize不能小于0.5.
	apply_adaptive_mesh(elements=powder_A1.elements)	;changing

	## ALE control
##	mdb.models['Model-1'].AdaptiveMeshControl(name='Ada-1')
##	mdb.models['Model-1'].steps['step1'].adaptiveMeshDomains['step1'].setValues(
##	    controls='Ada-1')

	mesh_part(tpunch,esize=0.2)
	mesh_part(bpunch,esize=0.2)
	mesh_part(die,esize=0.2)

##	raise Exception

	## surface and interact
	tpunch_surface = create_surface(name='sf_tpunch', edges=tpunch_A1.edges,side='-y')
	bpunch_surface = create_surface(name='sf_bpunch', edges=bpunch_A1.edges,side='+y')
	die_surface = create_surface(name='sf_die', edges=die_A1.edges,side='-x')

	edges = edge_select(powder_A1,y=(MAX,MAX1))
##	edges = edge_select(powder_A1,y=(MAX,MAX1),x=(MIN1,MAX))
	top_surface = create_surface(name='powder_top', edges=edges)

	edges = edge_select(powder_A1, y=(0.1,MIN))
	bot_surface = create_surface(name='powder_bot', edges=edges)

	edges = edge_select(powder_A1,x=(MAX, MAX1))
	side_surface = create_surface(name='powder_side', edges=edges)

	s2s_interact_explicit('int_tpunch',msurface=tpunch_surface, ssurface=top_surface)
	s2s_interact_explicit('int_die',msurface=die_surface, ssurface = side_surface)
	s2s_interact_explicit('int_bpunch',msurface=bpunch_surface,ssurface = bot_surface)

	## powder self contact (can't use with ALE)
##	a = mdb.models['Model-1'].rootAssembly
##	s1 = a.instances['powder_A1'].edges
##	side1Edges1 = s1.findAt(((5.0, 44.3025, 0.0), ), ((4.25, 47.95, 0.0), ), ((1.0,
##	    47.95, 0.0), ), ((0.0, 37.0075, 0.0), ))
##	region=a.Surface(side1Edges=side1Edges1, name='Surf-7')
##	mdb.models['Model-1'].SelfContactExp(name='Int-4', createStepName='Initial',
##	    surface=region, mechanicalConstraint=KINEMATIC,
##	    interactionProperty='Friction')

##	raise Exception

##	s2s_interact_explicit('int_tpunch',master_region=tpunch_surface, slave_edges=top_surface)
##	s2s_interact_explicit('int_die',master_region=die_surface, slave_edges = side_surface)
##	s2s_interact_explicit('int_bpunch',master_region=bpunch_surface,slave_edges = bot_surface)

##	raise Exception

	## loading
	if double == False:
		_m.TabularAmplitude(name='top_move', timeSpan=STEP,
		    smooth=SOLVER_DEFAULT, data=((0.0, 0), (1.0, -(fill_H - green_H))))

		apply_BC_on_RP_2D(tpunch_A1,U1=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1')

		apply_BC_on_RP_2D(bpunch_A1,U1=0,U2=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(die_A1,U1=0,U2=0, UR3=0,stepname='step1')
	else:
		if top_dome == False and bot_dome == False:
			_m.TabularAmplitude(name='top_move', timeSpan=STEP,
			    smooth=SOLVER_DEFAULT, data=((0.0, 0), (1.0, -compressed_H/2)))

			_m.TabularAmplitude(name='bot_move', timeSpan=STEP,
			    smooth=SOLVER_DEFAULT, data=((0.0, 0), (1.0, compressed_H/2)))
		else:
			effect_L = compressed_H - tpunch_depth - bpunch_depth
			if top_dome == True and bot_dome == False:   ## top have gap to fill, so top punch move first.
				_m.TabularAmplitude(name='top_move', timeSpan=STEP,
				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.5, -tpunch_depth), (1.0, -tpunch_depth - effect_L/2)))

				_m.TabularAmplitude(name='bot_move', timeSpan=STEP,
				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.5,0), (1.0, effect_L/2)))

			elif top_dome == False and bot_dome == True:
				_m.TabularAmplitude(name='top_move', timeSpan=STEP,
				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.5, 0), (1.0, -effect_L/2)))

				_m.TabularAmplitude(name='bot_move', timeSpan=STEP,
				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.5,bpunch_depth), (1.0, bpunch_depth + effect_L/2)))

			else:  ## top have gap to fill, so top punch move first.
				_m.TabularAmplitude(name='top_move', timeSpan=STEP,
				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.4, -tpunch_depth), (0.8, -tpunch_depth), (1.0, -tpunch_depth - effect_L/2)))

				_m.TabularAmplitude(name='bot_move', timeSpan=STEP,
				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.4, 0), (0.8, bpunch_depth), (1.0, bpunch_depth + effect_L/2)))

##				_m.TabularAmplitude(name='top_move', timeSpan=STEP,
##				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.4, 0), (0.8, 0), (1.0, -effect_L/2)))
##
##				_m.TabularAmplitude(name='bot_move', timeSpan=STEP,
##				    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.4, bpunch_depth), (0.8, bpunch_depth + tpunch_depth), (1.0, bpunch_depth + tpunch_depth + effect_L/2)))


		apply_BC_on_RP_2D(tpunch_A1,U1=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1')

		apply_BC_on_RP_2D(bpunch_A1,U1=0,UR3=0,stepname='step1')
		apply_BC_on_RP_2D(bpunch_A1,U2=1,amplitude='bot_move',stepname='step1')

		apply_BC_on_RP_2D(die_A1,U1=0,U2=0, UR3=0,stepname='step1')


	apply_gravity(Gy=-9800)
##	raise Exception

	history_output_request(rigid_body=tpunch_A1,variables=['RF','S'])
	history_output_request(rigid_body=bpunch_A1,variables=['RF','S'])
	history_output_request(rigid_body=die_A1,variables=['RF','S'])

	save_mdb()
##	raise Exception

	create_inp(inp_file_title,request_num=1) ;please_check
	mdb.jobs[inp_file_title].submit()


	_results_dict = {'func':'cal_axial_pressure', 'vars':('fill_H','green_weight', 'press_ratio', 'green_section'), 'powder_A1':('PEQC4','DENSITY','SENER','S1','Mises','U2'), 'TPUNCH_A1':('RF','CPRESS   SPOS'), 'BPUNCH_A1':('RF','CPRESS   SPOS'), 'Die_A1':('RF','CPRESS   SPOS')}


	return



def main_A0210_multi_cavity_press_tool():
	## VER: 2014-01-08, v1.0

	global _results_dict, script_file_full

	topic = 'press_tool'
	script_file_full = check_script_file('AZ_A0215_PDC_1300_loft_CTE_remesh.py')	;changing
	history = 'BP: cavity num effect; AP:tip_gap increase 0.5mm; AH:offset, x=-1mm;  A0:model'
	save_user_data(jobnum, topic)

	create_step('shrink_fit')
	create_step('pressing')

	locals0 = locals().keys()

	pressure = 200		;	changing   ## wall pressure
##	pressure = globals()['pressure']

##	steel_OD = 70
	steel_thick = 30	;	changing	## original: 5
	steel_height = 10
##	steel_ID = steel_OD - 2*steel_thick
	steel_ID = 60
	steel_OD = steel_ID + 2*steel_thick

	interference = 0.04  ## 40um
	carbide_OD = steel_ID + interference
	tip_num = 4
	tip_width = 3.74
	tip_gap = 4.26 - 1.5			;changing	## original: 4.26
	tip_length = 27.12
	tip_radius = 6.13
	tip_H = sqrt(tip_radius*tip_radius - (tip_radius - tip_width)**2)
	tip_H = round(tip_H,6)
	corner_radius = 0.5		;changing1  ## 不显示的倒角半径一般为0.15左右。

	offset_x = 0	;changing1
	offset_y = 0	;changing1
	mirror = True	;changing
	cavity_num = 4	;changing

	PH = 4   ## PH
	force = 100*1000  ## 150KN
	zeta1 = 0.6
	zeta2 = 0.5

	carbide_mat = 'H10F'		;changing1	## H10F, Steel_K390
	steel_mat = 'Steel_4340'

	esize = 1.0		;changing1

	locals2globals(locals0,locals(),save_var=True)

	## sketch
	s1 = create_base_sketch('s_die')
	point1,point2,arc1 = create_arc(s1,center=(0,0),quarter=2,radius=tip_radius)
	point3 = trim_sketch(s1,right_cut=tip_radius - tip_width)
	connect_points(s1,point3[0],{'DV':-tip_length},{'DH':-tip_width},point2)

	if corner_radius > 0:
		round_sketch_corner(s1,radius=corner_radius, loc=point3[0])

##	raise Exception

	extrude_sketch_to_part('green',sketch=s1,length=PH)
	area = get_area(zmin_faces('green'))
##	print area   ## 95mm2
##	axial_pressure = force/4/area
##	print axial_pressure

	global axial_pressure1, axial_force1, axial_pressure2, axial_force2
	axial_pressure1 = pressure/zeta1
	axial_force1 = smart_round(axial_pressure1*area*cavity_num/1000)	## KN

	axial_pressure2 = pressure/zeta2
	axial_force2 = smart_round(axial_pressure2*area*cavity_num/1000)	## KN

	save_user_data(axial_pressure1, axial_force1, axial_pressure2, axial_force2)

##	print ' '
##	print 'axial_pressure=',axial_pressure
##	print 'axial_force=',axial_force
##	print 'zeta=',zeta1

##	raise Exception

	if mirror == False:
		pattern_geometry(s1,number1=cavity_num,spacing1=tip_width + tip_gap)
##		check1()
		move_geometry(s1,geometry=s1.geometry.values(),x1=MID,x2=0,y1=MID,y2=0)
##		raise Exception

	else:
		pattern_geometry(s1,number1=2,spacing1=tip_width + tip_gap)
		move_geometry(s1,geometry=s1.geometry.values(),x1=_xmax_sketch(s1) + tip_gap/2,x2=0,y1=MID,y2=0)	;please_check
##		create_construction(s1)
		mirror_geometry(s1,x=0)

##	raise Exception

	create_circle(s1,center=(0,0),radius = carbide_OD/2)
	sketch_to_shellpart(s1,partname='carbide')

##	raise Exception

	## case
	s2 = create_base_sketch('s_case')
	create_circle(s2,center=(0,0),radius = steel_ID/2)
	create_circle(s2,center=(0,0),radius = steel_OD/2)
	sketch_to_shellpart(s2,partname='case')

	new_instance('carbide')
	new_instance('case')

##	stop()

	set_mat(carbide,mat=carbide_mat)
	set_mat(case,mat=steel_mat)

	## interaction: shrink fit
	edges1 = edge_select(carbide_A1,radius=carbide_OD/2.)
	edges2 = edge_select(case_A1,radius=steel_ID/2.)
	s2s_interact_std(mfaces=edges1,sfaces=edges2,interference='shrink_fit')

	## loading and BC
	edges = edge_select(carbide_A1,radius=carbide_OD/2.)
	edges = unselect(carbide_A1.edges,edges)
##	region = create_surface('surf1',edges=edges)
##	raise Exception

##	region = list2region(edges,region_type='surface',name='surf-1')
##	raise Exception
	apply_pressure('pressing',MPa=pressure, faces=edges, step='step2')

##	_m.Pressure(name='Load-1', createStepName='pressing', region=region, distributionType=UNIFORM, field='', magnitude=pressure, amplitude=UNSET)

##	stop()
##	raise Exception

	edges = edge_select(carbide_A1,radius=carbide_OD/2.)
	vertices = edges_to_vertices(edges)
	apply_disp_fix('point_fix',objs=vertices[0],fix_all=True)

##	stop()

	## mesh
	## carbide
	if corner_radius > 0:
		edges = edge_select(carbide,radius=corner_radius)
		seed_edges(carbide,edges=edges,enum=1,fixed=True)

	mesh_part(carbide,esize=esize)
##	raise Exception

	mesh_part(case,esize=esize)

	_results_dict = {'var':('gap', 'pressure', 'zeta1','axial_pressure1','axial_force1','zeta2','axial_pressure2','axial_force2'), 'carbide_A1':('S1','Mises','U1','U2'), 'case_A1':('S1','Mises','U1','U2')}

	create_inp(inp_file_title, request_num=2) ;please_check
	mdb.jobs[inp_file_title].submit()


	return


def main_A0217_HPHT():
	## VER: 2014-06-17, v1.8   ## A0197 also use this flow
	## collect_and_write_results('pressing',['model','U'],['ANVIL_A1','Mises','PEEQ','S1'], ['BLANK_A1','Mises','PEEQ','S1'])

	check_script_file('A2_A0217_HPHT_6UF.py')	;changing
	history = 'AS:with steel DAM outside the steel case; A1:model'

	blank_cae(inp_file_title)

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	## dimensions
	locals0 = locals().keys()
##	total_H = 132.715    ## 132.715 (127 is shown in 187 drawings)
##	blank_R = 62.865   ## 62.865 (57.15 is shown in 187 drawings, blank)
##	blank_H = 80.95   ## 87.31 (80.95 is shown in 187 drawings, blank) (87.31 is total, not only blank)

	customer = 'Stefan'
	purpose = 'DM80 instead of 6UF, as solid material'
	request_date = 'Aug 2013'

	pressure = 7000		;please_check
	size = 'typical'   ## typical, or big10%
	hole_R = 0
	top_mat = 'SixUF'  ## SixUF(6UF), H10F, DM80(8UF)
	bot_mat = 'SixUF'

	if size == 'typical':         ##
		blank_R = 2.25*inch       ## 57.15mm
		blank_H = 87.31      	  ## 87.31mm

		land_width = 1.374*inch   ## 34.9mm
		anvil_wall_clearance = 6.36

	elif size == 'big10%':
		blank_R = 2.25*1.1*inch   ## 62.865mm
		blank_H = 3.187*inch      ## 80.95mm (modified) (same as typical)  ## The base height of 80.95 is a compensation of the 10% bigger radius

		land_width = 1.374*inch   ## 34.9mm (same as typical)
		anvil_wall_clearance = 6.36 ## modified  (same as typical)

	cut_depth = blank_R - land_width/2
	## 39.7mm (typical), or 48.67mm (big 10%)

	anvil_H = anvil_wall_clearance + cut_depth
	## 46.05mm (typical), or 59.08mm (big 10%)

	total_H = blank_H + anvil_H
	## 133.37(typical), 132.725(big10%),
##	print2 ('total_H =',total_H)

	anvil_wall_clearance = anvil_H - cut_depth
	## 6.35mm(typical), or 10.414mm (big 10%)

	locals2globals(locals0,locals())

	blank_part('anvil')
	cylinder_grow('anvil','y',OD=2*blank_R,L=total_H)

	bias_cut(anvil,cut_sides='-x',x=MID)
	bias_cut(anvil,cut_sides='+z',z=MID)

	bias_cut(anvil,cut_sides=['+x','+y'], pass_point1 = (land_width/2, total_H,0), angle_with_Y=45)
	bias_cut(anvil,cut_sides=['-z','+y'], pass_point1 = (0, total_H,-land_width/2), angle_with_Y=45)
##	bias_cut(anvil,cut_sides=['-x','+y'], pass_point1 = (-land_width/2, total_H,0), angle_with_Y=45)
##	bias_cut(anvil,cut_sides=['+z','+y'], pass_point1 = (0, total_H,land_width/2), angle_with_Y=45)

	divide(anvil,y=blank_H)
##	divide(anvil,y=blank_H + 1)
##	divide(anvil,y=blank_H - 1)

	new_instance(anvil)

	copy_part(anvil,'blank')
	bias_cut(blank,y=blank_H,cut_sides='+y')
	bias_cut(anvil,y=blank_H,cut_sides='-y')
	new_instance(blank)

	if hole_R > 0:
		create_half_ball('ball',radius=hole_R)	;please_check
		boolean_cut(blank,cutters=ball)

##	raise Exception

##	if solid == True:
##		set_mat(anvil,mat='H10F')   ## solid model
##	else:
##		set_mat(anvil,mat='SixUF')

	set_mat(anvil,mat=top_mat)
	set_mat(blank,mat=bot_mat)

##	raise Exception

	## mesh
	edges = edge_select(anvil,x=MAX,y=(blank_H,MAX),edir='y')
	seed_edges(anvil,edges=edges,esize=0.5)
	mesh_part(anvil,esize=2)

	edges = edge_select(blank,z=MAX,y=MAX,edir='x')
	seed_edges(blank,edges=edges,esize=2)
	mesh_part(blank,esize=3)

##	raise Exception

	xnodes = nodes_labels_of_faces(faces_of_insts(x=_xmin(anvil_A1)))
	znodes = nodes_labels_of_faces(faces_of_insts(z=_zmax(anvil_A1)))
	assembly_nodes = nodes_labels_of_faces(faces_of_insts(y=_ymin(anvil_A1)))
	bot_nodes = nodes_labels_of_faces(ymin_faces(blank_A1))
	top_elems = elements_labels_of_faces(ymax_faces(anvil_A1))

	tie_nodes_anvil = nodes_labels_of_faces(ymin_faces(anvil_A1))
	tie_nodes_blank = nodes_labels_of_faces(ymax_faces(blank_A1))

	## Interaction

	create_general_static_step(stepname='high_temp',initial_inc=0.002,restart=True)	 ;please_check
##	_m.steps['high_temp'].Restart(frequency=1, numberIntervals=0, overlay=OFF, timeMarks=OFF)
##	global()['restart'] = True
	## will create the jobname.res file for later restart analysis

	set_temperature_predefined_field(initial_step=20,modifys=[('step1',1000)])

	apply_disp_symm('x',faces=faces_of_insts(x=_xmin(anvil_A1)))
	apply_disp_symm('z',faces=faces_of_insts(z=_zmax(anvil_A1)))
	apply_disp_fix('y_fix_bot',faces=faces_of_insts(y=_ymin(anvil_A1)),stepname='step1',Uy=0)

##	raise Exception

	odb_title1 = script_file_full[:-3] + '_prefield'
	create_inp(odb_title1,restart=True) ;please_check
	mdb.jobs[odb_title1].submit()
	mdb.jobs[odb_title1].waitForCompletion()

##	raise Exception

	## cooling and loading
##	clear_model_settings()

	odb_title2 = script_file_full[:-3] + '_final'
##	create_new_model(script_file_full)
##	create_new_parts_with_deformed_mesh(odb_title1)

	copy_model(to_name='restart',new_from_name='prefield')
	clear_model_settings()
	import_initial_state(odb_title1)

##	import_initial_stress(odb_title1,name='Imported_stress')

##
##	raise Exception

##	material_database()
##
##	set_mat(BLANK_A1_p,mat='H10F')
##	set_mat(ANVIL_A1_p,mat='SixUF')

	create_general_static_step(stepname='tie',initial_inc=0.002)
	create_general_static_step(stepname='cool_down',initial_inc=0.002)
	create_general_static_step(stepname='pressing',initial_inc=0.002)

##	raise Exception

##	node_region_contact(mnodes=tie_nodes_anvil, snodes=tie_nodes_blank,action='tie',step='step1')
	s2s_tie(mfaces=ymin_faces(anvil_A1),sfaces=ymax_faces(blank_A1))

##	apply_disp_symm('x',nodes=xnodes)
##	apply_disp_symm('z',nodes=znodes)
##	apply_disp_fix('y_fix_bot',nodes=bot_nodes,Uy=0)

	apply_disp_symm('x',faces=faces_of_insts(x=_xmin(anvil_A1)))
	apply_disp_symm('z',faces=faces_of_insts(z=_zmax(anvil_A1)))
	apply_disp_fix('y_fix_bot',faces=ymin_faces(blank_A1),Uy=0)

	set_temperature_predefined_field(initial_step=1000,modifys=[('step2',300)])
##	apply_pressure('load_top',elements=top_elems, MPa=8500,step='step3')
	apply_pressure('load_top',faces=ymax_faces(anvil_A1),MPa=pressure,create_step='step3')	;please_check

	mdb.saveAs(odb_title2)

	create_inp(odb_title2,clear_jobs=False)
	mdb.jobs[odb_title2].submit()

	return


def main_A0206_wiredraw_919():
	## started: 2014-05-12
	## Request from Miguel, Spain, for wire draw evaluation.

	check_script_file('EF_A0206_esize002_nib01_fric001_15deg.py')	;changing
	history = 'D9(good); D5:modify wire; D2(success in wire deform):modify nib contact; CU: wire no num seed; CS: to compare with BJ; CA: wire yield = 400; BJ: add riveting for nib to remove nib top fix; BF:use implicit dynamic step as second step; BA:restart; AI:drawing process; AC: interference in general contact; A1:model'

##	open_cae('_A0206_imported_model.cae',new_name=inp_file_title)
	blank_cae(inp_file_title)
##	raise Exception

	locals0 = locals().keys()

	nib_H = 7
	nib_OD = 6   ## nib type = D6H7
	nib_R = nib_OD/2
	bell_R = 5
	bell_round = 1.5  ## round radius
	bell_angle = 35
	center_to_bot = nib_H - 3.479

	bearing_D = 0.3
	bearing_R = bearing_D/2
	bearing_length = bearing_D*0.35
	bearing_to_bot = 2 - bearing_length/2

	approach_angle = 11
	approach_H = 2 - bearing_length/2
	reduction = 0.2

	relief_dy = bearing_length
	relief_angle = 27

	exit_dy = bearing_to_bot - relief_dy
	exit_angle = 60

	approach_dy = nib_H - approach_H - bearing_length - relief_dy - exit_dy
	nib_thick = nib_R - bearing_D/2

	## case file: assembly_WDBDRHS2000213.pdf
	interference = 0.04		;changing1
	case_H = 14
	case_OD = 28   ## case type: 28x14
	nib_to_top = 3.0
	nib_bot_to_bot = case_H - nib_to_top - nib_H
##	case_land_D = 3
	case_land_H = 0.3
	case_ID = nib_OD - interference*2	;changing
##	case_ID = nib_OD
	case_exit_H = nib_bot_to_bot - case_land_H
	case_exit_angle = 60
	case_land_ID = 3.0   ## different for another drawing(3.5)
	case_entrance_cut = 1.0       ## refer to case_WDBDRHS20002M
	case_entrance_cut_angle = 30  ## refer to case_WDBDRHS20002M
	land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.
	corner_chamfer = 0.5

	esize = 0.02				;changing
	friction = 0.01 			;changing
	cut_angle = 15	  			;changing
	draw_time = 1.5e-4  		;changing

	if cut_angle == 15:
		cut_height = 1.09  ## nib
		cut_R = 5.65
	else:
		cut_height = 0.5
		cut_R = 0

	wire_D = sqrt(bearing_D*bearing_D/(1-reduction))
	wire_D = round(wire_D,3)
	wire_R = wire_D/2.0
	wire_length = 10		;changing1
	offset = 1
	speed = -16*1000		;changing1
	wire_cut_x=0.1
	wire_cut_y = 0.2

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'
	wire = 'wire'
	wire_A1 = 'wire_A1'

	locals2globals(locals0,locals(),save_var=True)

	material_database()
	create_contact_props(friction=friction)					;please_check('default=0.15')

	## wire elastic
##	wire_plastic = (275,0), (690, 0.2), (960, 0.4), (1206, 0.6), (1654, 1), (2240, 1.6)  ## hardening steel
	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
	set_plastic('Steel', wire_plastic)	;changing
##	set_plastic('Steel', (500, 0))	;changing

	set_plastic('H3F',(5000,0))		;changing1

	s1 = create_base_sketch('sk_nib')

	loc0 = (bearing_R,bearing_to_bot)
	loc1 = (bearing_R,bearing_length + bearing_to_bot)

	line1 = slope_construction(s1,loc=loc1,angle=90 - approach_angle/2)

	arcs,center,point1 = create_tangent_circle(s1,line1,radius=bell_R,center=(10,center_to_bot),fix_y=True)
	point2 = find_loc(s1,y=nib_H,groupX=MIN)

	del_sketch_objs(s1, arcs)
	connect_points(s1,loc0,loc1,point1)

	create_arc(s1,center,point1=point1, point2=point2,direction=CLOCKWISE)
	points = connect_points(s1,point2,{'H':nib_R},{'V':cut_height}, ytilt(-cut_height,-cut_angle))

##	raise Exception

	if cut_R > 0:
		round_sketch_corner(s1,loc=points[-2],radius=cut_R)
	round_sketch_corner(s1,loc=point2,radius=bell_round)

	connect_points(s1,loc0,ytilt(-relief_dy,relief_angle/2),ytilt(-exit_dy,exit_angle/2),points[-1])
	sketch_to_shell(s1,partname='nib',symmetric=True)

##	raise Exception

	## case
	s1 = create_base_sketch('sk_case')
	points = connect_points(s1,(case_land_ID/2,case_exit_H),{'dy':case_land_H},{'x':case_ID/2.0},
		{'y':case_H - case_entrance_cut}, ytilt(case_entrance_cut, case_entrance_cut_angle), {'x':case_OD/2 - corner_chamfer},(case_OD/2, case_H - corner_chamfer),
		{'y':corner_chamfer},(case_OD/2 - corner_chamfer,0))
	round_sketch_corner(s1,loc=points[2],radius=land_corner_R)

	connect_points(s1,(case_land_ID/2,case_exit_H), ytilt(-case_exit_H,case_exit_angle/2),(case_OD/2 - corner_chamfer,0))
	sketch_to_shell(s1, partname='case',symmetric=True)

##	raise Exception

	move_part(nib,y1=MIN,y2=nib_bot_to_bot)
	new_instance(nib)
	new_instance(case)
	plot(a)
	session.viewports['Viewport: 1'].view.fitView()

	## add riveting
	divide(case,y=_ymax(nib_A1))
	loc1 = (case_ID/2.0, _ymax(nib_A1))
	loc2 = (case_ID/2.0 - 0.5, _ymax(nib_A1) + 0.4)
	create_rectangle_shell(case, corner1=loc1,corner2=loc2)

	faces = face_select(case,y=(_ymax(nib_A1), MAX))
	divide(case,faces=faces,x=case_ID/2.0)

##	vertice = vertice_select(nib_A1,x=MIN,groupY=MIN)
##	mouth_y = vertice[0].pointOn[0][1]	;please_check
	loc = find_loc(nib_A1,x=MIN,groupY=MIN)
	mouth_y = loc[1]

##	raise Exception

	## wire
	create_rectangle_shell('wire',corner1=(0,0),corner2=(wire_R, wire_length),axis_symmetric = True)
	move_part(wire,y1=MIN,y2=_ymin(nib) + 2)

##	bias_cut(wire, cut_sides='bot_right', point1=(wire_R, _ymin(wire) + 0.2, 0), point2=(wire_R*0.7, _ymin(wire), 0))
	bias_cut(wire,cut_sides=('+x','-y'), point1=(wire_R, _ymin(wire) + offset,0), point2=(wire_R/2,_ymin(wire),0))
##	round_corner(wire,radius=5,x=MAX,groupY=MIN)
	new_instance(wire)

	divide(wire,y=_ymin(wire) + 2)	;changing
##	bias_cut(wire,cut_sides='bot',y=_ymin(wire) + 0.75)

##	loc = find_loc(nib_A1,x=MAX,groupY=MIN)
##	divide(case,y=loc[1])		;changing1

	set_mat(case,mat='Steel_EN10718')
	set_mat(nib,mat='H3F')
	set_mat(wire,mat='Steel')	;changing1

	edges = edge_select(case_A1,ny=1,groupY=MIN)
	create_surface('case_land',edges=edges)

	edges = edge_select(case_A1,y=MID,nx=-1)
	create_surface('case_ID',edges=edges)

	edges1 = edge_select(nib_A1,nx=1)
##	edges1 = edge_select(nib_A1,x=MAX,y=MID)
	create_surface('nib_OD',edges=edges1)

##	edges = edge_select(nib_A1,nx=1)
##	edges = unselect(edges, edges1)
##	create_surface('nib_corner', edges=edges)

	edges = edge_select(nib_A1,y=MIN)
	create_surface('nib_bot', edges=edges)

	edges3s = edge_select(wire_A1,nx=1)
	create_surface('wire_surf',edges=edges3s)

	vertices = vertice_select(nib_A1,x=MIN)
	edges3m = vertices_to_edges(vertices)
	create_surface('nib_surf',edges=edges3m)

	edges1 = edge_select(nib_A1,y=MAX)
	create_surface('nib_top',edges=edges1)

	edges2 = edge_select(case_A1,y=_ymax(nib_A1))
	create_surface('rivet',edges=edges2)

	get_current_model()

##	raise Exception

	## mesh case
	edges = edge_select(case,x=(MIN,case_ID/2.0 + 0.1),y=(MIN1,MAX1))
	seed_edges(case,edges=edges,esize=0.10)	;changing

	mesh_2D(case,esize=0.2)		;changing

##	raise Exception

	## mesh nib
##	esize = 0.02	;changing
	edges = edge_select(nib,nx=-1,y=(MIN,MID))
	seed_edges(nib,edges=edges, esize=0.02)			;changing

	edges = edge_select(nib,x=MIN)
	seed_edges(nib,edges=edges, enum=4)		;changing1

	mesh_2D(nib,esize=0.10)	;changing

	## mesh wire
	edges = edge_select(wire,y=MAX)
	seed_edges(wire,edges=edges,enum=15)	;changing ## enum

	mesh_2D(wire,esize=esize)

##	raise Exception

	times1 = myrange(0,1,0.05)
	timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1

	times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,50, 0.5)
	timepoints2 = create_timepoints(times2,factor=1e-5)

	## steps implicit way
	solver = 'implicit'	;changing
	if solver == 'implicit':
		create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
		create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
		field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

##		create_general_contact_std(pairs=[('nib_OD','case_ID'),('nib_bot','case_land'),('nib_top','rivet'),('nib_surf','wire_surf')],
##			interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))

		## contact
##		create_general_contact_std(interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))
##		create_general_contact_std(property_pairs=('nib_surf','wire_surf',friction))


		s2s_interact_std('int_nib_support', mfaces='nib_bot', sfaces='case_land')
		s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',overclosure='shrink_fit')
##		s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',initial_clearance=-0.04)

		s2s_interact_std('int_nib_rivet', mfaces='nib_top', sfaces='rivet')
##
		s2s_interact_std('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',friction=friction,step='step2')

		## Fix
		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		edges = edge_select(wire_A1,y=MAX)
		apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0,deactive_step='step2')

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
		apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing

	elif solver == 'explicit':
		create_dynamic_explicit_step(step='step1', timePeriod=draw_time)
		field_output_request(timepoints=timepoints2,variables=ALL)	;changing

		s2s_interact_explicit('int_nib_support', mfaces='nib_bot', sfaces='case_land',sliding=SMALL)
		s2s_interact_explicit('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',interference=interference)
##		s2s_interact_explicit('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',prop=friction,step='step1')

		vertices = vertice_select(nib_A1,x=MIN)
		edges = vertices_to_edges(vertices)
		s2s_interact_explicit('int_nib_wire', mfaces=edges, sfaces='wire_surf',prop=friction,step='step1')

		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		apply_velocity('initial_speed',faces=_inst(wire_A1).faces, Vy=speed, step='Initial')

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
		apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step1')	;changing

	odb_title1 = create_inp(inp_file_title,request_num=6,submit=False) ;please_check


##	## restart model, explicit
##	create_restart_model(model_name='restart',odb_title1=odb_title1)
####	new_instance(wire)
####	import_initial_stress(odb_title1)
##
####	raise Exception
##
##	create_dynamic_explicit_step(stepname='step2',timePeriod=draw_time)
##
##	times = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,30, 0.5)
##	timepoints = create_timepoints(times,factor=1e-5)
##
##	del _m.fieldOutputRequests['F-Output-1']
##	_m.FieldOutputRequest(name='Field output', createStepName='step2', variables=PRESELECT, timePoint=timepoints)  ## default to save results of every increment
##
##	edges1s = edge_select(case_A1,ny=1,y=(MIN,MID))
##	edges1m = edge_select(nib_A1,y=MIN)
##	s2s_interact_explicit('int_nib_support', mfaces=edges1m, sfaces=edges1s,prop='Frictionless')
##
##	edges2s = edge_select(case_A1,nx=-1,y=MID)
##	edges2m = edge_select(nib_A1,nx=1)
##	s2s_interact_explicit('int_nib_case', mfaces=edges2m, sfaces=edges2s,prop='Frictionless')
##
##	edges3s = edge_select(wire_A1,nx=1)
##	edges3m = edge_select(nib_A1,nx=-1)
##	s2s_interact_explicit('int_wire_nib', mfaces=edges3m, sfaces=edges3s,prop=friction)
##
##	## load, BC
##	edges = edge_select(case_A1,y=MIN)
##	apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)
##
##	edges = edge_select(nib_A1,y=MAX)
##	apply_disp_fix('nib_fix',edges=edges,Uy=0)
##
##	apply_velocity('initial_speed',faces=_inst(wire_A1).faces, Vy=speed, step='Initial')
##
##	faces = face_select(wire_A1,y=MIN1,mark_select=True)
##	apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing
##
##	odb_title2 = create_inp(inp_file_title,request_num=6,submit=True) ;please_check

	return

def main_A0223():
	## VER: 2014-08-07, v1.0, ejecto crack after powder compaction. 5 pcs cracked.

	check_script_file('A7_A0223_922_ejector_thick_land300.py')	;changing
	history = 'A4:thick add 0.2mm; A3: round corner, A2:half symmetric; A1:imported'

	open_cae('_A0223_ejector_imported2.cae', new_name=inp_file_title)

	locals0 = locals().keys()

	ejector = 'ejector'
	ejector_A1 = 'ejector_A1'
	shell = 'shell'
	shell_A1 = 'shell_A1'

	gap = 0.01   ## 10um
	add = 0 	;changing	## punch_D = 17.871, 17.871-17.271 = 0.6mm, thick=0.3mm
	punch_D0 = 17.581
	land_ID = 17.271		## 17.391 (model 1, current)
	punch_D = punch_D0 + add*2
	shell_D = punch_D + 2*gap
	punch_L = 40

	locals2globals(locals0,locals(),save_var=True)

	rotate_part('ejector',angle_z=180)
	move_part('ejector',y1=MIN,y2=0)

	edges = edge_select(ejector,edir='y')
	remove_redundant_edges(ejector, edges=edges)
	new_instance(ejector)

	if add > 0:
		create_circular_shell('p1',ndir='y',L=punch_L, ID=punch_D0, OD=punch_D)
		new_instance('p1')

		merge_instances(partname=ejector, insts=[ejector_A1,'p1_A1'],boundary='remove')

##		create_circular_shell('p2',ndir='y',center=(0,punch_L,0),ID=land_ID,OD=punch_D)
##		new_instance('p2')
##
##		merge_instances(partname=ejector, parts=(ejector,'p2'),boundary='keep')
##		bias_cut(ejector,cut_sides='+y',y=punch_L)

##		edges = edge_select(ejector,y=MAX,D=punch_D0)
##		remove_redundant_edges(ejector,edges=edges)
		bias_cut(ejector,cut_sides='+y',y=MAX1)
		divide(ejector,x=MID)

		new_instance(ejector)

##	raise Exception

	bias_cut(ejector,cut_sides='+z',z=0)
	divide(ejector,y=MID)

##	edges = edge_select(ejector,y=MAX,edir='circular',xD=punch_D)
##	light(edges)
	edges = edge_select(ejector,D=land_ID)
	round_edges(ejector, edges=edges[0], radius=0.05)

##	raise Exception

	set_mat(ejector,mat='H10F')
##	raise Exception

	## shell
	create_circular_shell('shell',ndir='y',L=punch_L, D=shell_D,ptype='discrete')

	move_part('shell',x1=MID,x2=0, y1=MIN,y2=0, z1=MID,z2=0)
	new_instance('shell')

	bias_cut(shell,cut_sides='+z',z=0)

##	raise Exception

	create_general_static_step('step1', period=1)
	history_output_request(rigid_body=shell_A1,variables=['RF','S'])

	## contact
	sfaces = face_select(ejector_A1,D=punch_D)
	mfaces = create_surface(objs=_inst(shell_A1).faces,side_num=2)
	s2s_interact_std('int-1',mfaces=mfaces,sfaces=sfaces)

	faces = face_select(ejector_A1,ny=1,y=(MIN,MAX1))
	apply_pressure('pressure',faces=faces,MPa=100, create_step='step1')

	## BC:
	faces = face_select(ejector_A1,y=MIN)
	apply_disp_fix('ejector_fix',faces=faces,Ux=0,Uy=0,UR1=0,UR2=0,UR3=0)

	apply_disp_fix(name='RP_fix',referencePoints=shell_A1,fix_all=True)
	apply_disp_symm('z',faces=faces_of_insts(z=0))


	## mesh
##	mesh_3D_TET_disp_std(ejector,esize=0.5)

	edges = edge_select(ejector,edir='y',y=(MID,MAX))
	bias_seed_single(ejector,edges=edges, minSize=0.2,maxSize=0.8,fine_dir='+y')	;changing
##
####	edges =edge_select(ejector,y=MAX,D=punch_D)
####	seed_edges(ejector,edges=edges,esize=0.5)
##
	cells = cell_select(ejector,y=(MID,MAX))
	mesh_3D_TET_disp_std(cells,esize=0.8)
####	raise Exception
##
	edges = edge_select(ejector,y=(MID,MIN),edir='y')
	seed_edges(ejector,edges=edges,esize=2)
##
	cells = cell_select(ejector,y=(MID,MIN))
	mesh_3D_TET_disp_std(cells)

	## shell
	edges = edge_select(shell,edir='y')
	bias_seed_single(shell,edges=edges, minSize=0.2,maxSize=0.8,fine_dir='+y')	;changing

##	edges =edge_select(shell,y=MAX,D=shell_D)
##	seed_edges(shell,edges=edges,esize=0.5)

	mesh_part('shell',esize=0.8)

##	raise Exception

	create_inp(inp_file_title,request_num=6) ;please_check
	mdb.jobs[inp_file_title].submit()

	return



def main_A187_shelf():
	## 2014-09-04, v1.0

	check_script_file('BU_A187_shelf_door_13row_30ton_3400.py')
	history = 'BQ:coupling; BP:add strengthen plate; AS:examine the H steel as stand; AO:density load, fix edge; AH:correct bridge_start and bridge_stand; A1:model'
	## 15 meters skip

	build_model = True		;changing
	if build_model == True:
		blank_cae(inp_file_title)
	else:
		open_cae('_' + jobnum + '_imported_model.cae')

	locals0 = locals().keys()

	rail_sec = [160,80,6]   ;changing  ## 规格：160*80* (4-10.0)  (original = 6mm)
	rail_gap = 1200
	rail_thick = rail_sec[2]

	bridge_sec = [120,80,3]
	bridge_length = rail_gap
	bridge_start = 290  	;changing1 ## 290(original)	## 第一根bridge的中心到rail的边缘的距离。
	bridge_end = 490     	;changing1 ## 最后一根bridge的中心到rail的边缘的距离。original (490)
	bridge_interval = 1200
	bridge_num = 13	;changing
	rail_length = (bridge_num - 1)*bridge_interval + bridge_start + bridge_end
	rail_mid = rail_length/2.0	;changing1

	stand_sec = [120,60,4]   ## Rect pipe
##	stand_sec = [125,60,6,8]	;changing (H steel)
	H_steel = False				;changing1
	check_H = False				;changing1
	stand_length = 680		## 680 - 10
	stand_thick = stand_sec[2]

	palm_hang = 75
	palm_broad = palm_hang + stand_sec[0]  ## 120 + 75
	palm_length = stand_length
	palm_thick = 10  ## correct
	check_palm = False		;changing1
	hole_D = 10

	finger_width = 70
	finger_thick = palm_thick
	finger_height = 48
	finger_R = 10
	finger_to_bot = 18
	finger_to_top = 100
	finger_to_finger = 66
	finger_tip = 4
	finger_num = 9

	steel_grade = 'Steel_Q235'	;changing
	load_method = 'density'	;changing1
	load = 30		;changing
	load = load*1000/4.0
##	load = 6000		;changing	## 4ton
	stack = 4		;changing1
	support_to_end = 3400	;changing
	if bridge_num == 7:
		support_to_end = 2190
##	support_to_end = rail_mid - 600	;changing  ## forklift

	have_strip = False		;changing
	strip_length = 7330
	strip_thick = 10		;changing
	strip_width = 80

	have_leg = True		;changing
	check_leg = True		;changing
	leg_sec = [60,4]
	leg_width = leg_sec[0]
	leg_thick = leg_sec[1]
	leg_length = stand_length
	leg_gap = 300
	connect_width = 120
	connect_thick = 10
##	leg_hole = 30		;changing
	connect_length = leg_sec[0]*2 + leg_gap
	bar_D = 30		;changing
	bar_length = leg_width*2 + connect_thick*2
	cap_thick = 10
	cap_width = leg_width

	rail = 'rail'		;		rail_A1 = 'rail_A1'	;		rail_A2 = 'rail_A2'
	bridge = 'bridge'	;		bridge_A1 = 'bridge_A1'
	stand = 'stand'		;		stand2 = 'stand2'		;	stand_A1 = 'stand_A1'	;	stand2_A1 = 'stand2_A1'

	palm = 'palm'			;		palm2 = 'palm2'		;		palm_A1 = 'palm_A1'	;		palm2_A1 = 'palm2_A1'

	finger = 'finger'
	plate = 'plate'		;	plate_A1 = 'plate_A1'		;	plate_A2 = 'plate_A2'
	pad = 'pad'			;	pad_A1 = 'pad_A1'			;	pad_A2 = 'pad_A2'

	strip = 'strip'		;	strip_A1 = 'strip_A1'		;	strip_A2 = 'strip_A2'

	leg = 'leg'		;	leg_A1 = 'leg_A1'			;	leg_A2 = 'leg_A2'
	connect = 'connect'	;	connect_A1 = 'connect_A1'	;	connect_A2 = 'connect_A2'
	bar = 'bar'			;	bar_A1 = 'bar_A1'
	hang = 'hang'		;	hang_A1 = 'hang_A1'
	ban = 'ban'			;	ban_A1 = 'ban_A1'	## 加强板

	locals2globals(locals0,locals(),save_var=True)

	material_database()
	create_contact_props(friction=0.1)

	if check_leg == True:
		create_pipe_steel(rail,rec_sec = rail_sec, length=rail_length,bone_dir='y')
		bias_cut(rail,z=MID,cut_sides='+z')
		new_instance(rail)

		create_pipe_steel(leg,rec_sec = leg_sec, length=leg_length)
		rotate_part(leg,angle_x=90)
		move_part(leg,y1=MIN,y2=_ymax(rail),x1=MAX,x2=_xmax(rail),z1=MAX,z2=support_to_end - leg_gap/2.0)
		create_block(leg,x=_xspace(leg),z=_zspace(leg),y=(_ymax(leg), _ymax(leg) - 10))

		new_instance(leg)
		new_instance(leg,dz=leg_gap + leg_width)

##		batch_divide(rail,z=_zspace(leg_A1))
##		batch_divide(rail,z=_zspace(leg_A2))

##		raise Exception

		batch_divide(rail,z=zlocs(leg_A1,pointOn=False))
		batch_divide(rail,z=zlocs(leg_A2,pointOn=False))
		batch_divide(rail,x=xlocs(leg_A1,pointOn=False))

		divide(rail,z=_zmax(leg_A2) + 4)
		divide(rail,z=_zmin(leg_A1) - 4)
		divide(leg,x=_xmax(rail) - rail_thick)

##		raise Exception

		## connect
		create_block(connect,x=(0,connect_thick),y=(0,connect_width), z=(0,connect_length))
		move_part(connect,x1=MAX,x2=_xmin(leg),y1=MAX,y2=_ymax(leg),z1=MIN,z2=_zmin(leg))
		new_instance(connect)
		new_instance(connect,x1=MIN,x2=_xmax(leg))  ## 会超出rail的边界。

		divide(connect,z=_zmin(leg_A2))
		divide(connect,z=_zmax(leg_A1))
		divide(leg,y=_ymin(connect))

		## bar
		cylinder_grow('bar',ndir='x',OD=bar_D, L=_xmax('connect_A2') - _xmin('connect_A1'))
		move_part(bar,y1=MID,y2=_ymid(connect), z1=MID,z2=_zmid(connect),x1=MIN,x2=_xmin(connect))
		new_instance(bar)

		boolean_cut('connect_A1',cutters=bar)
		new_instance(connect)
		new_instance(connect,x1=MIN,x2=_xmax(leg))

		divide(bar,x=_xmax(connect_A1))
		divide(bar,x=_xmin(connect_A2))
		divide(bar,x=_xmid(bar) + 10)
		divide(bar,x=_xmid(bar) - 10)
		divide(bar,y=MID)
		divide(bar,z=MID)

		## strengthen bar
		create_block(ban,x=connect_thick,y=connect_width,z=connect_length)
		move_part(ban,x1=MIN,x2=_xmax(rail),y1=MID,y2=_ymax(rail),z1=MID,z2=_zmid(connect))
		new_instance(ban)

		divide(leg,y=_ymax(ban))
		divide(rail,y=_ymin(ban))
		divide(ban,z=_zmin(leg_A2))
		divide(ban,z=_zmax(leg_A1))
		divide(ban,y=_ymax(rail))

##		raise Exception

		for part in ['leg','connect','bar','ban']:
			set_mat(part,mat='Steel_Q345')
		set_mat(rail,mat='Steel_Q235')

		vol = get_volume(rail)
		dens = load/(vol*1e-9)
		dens = dens*KD
		_m.materials['Steel_Q235'].density.setValues(table=((dens, ), ))	;changing1

##		create_rigid_plane('hang',x=20,y=80)
##		rotate_part(hang,angle_x=90)
##		move_part(hang,x1=MID,x2=_xmid(bar),y1=MIN,y2=_ymin(bar),z1=MID,z2=_zmid(bar))
##		divide(hang,z=MID)   ## for contact with bar
##		new_instance(hang)

##		raise Exception

##		create_rigid_pipe('hang',radius=(bar_D + 5)/2.0,length=50)
##		bias_cut('hang',y=MID,cut_sides='+y')
##		rotate_part('hang',angle_y=90)
##		move_part('hang',x1=MID,x2=_xmid(bar),y1=MIN,y2=_ymin(bar), z1=MID,z2=_zmid(bar))
##		divide(hang,z=MID)
##		new_instance(hang)

		## hang
		s1 = create_base_sketch('sk_hang')
		create_arc(s1,center=(0,0),quarter=34,radius=(bar_D + 5)/2.0)
		connect_points(s1,'xmin',('dy',30))
		connect_points(s1,'xmax',('dy',30))
		create_rigid_pipe('hang',sketch=s1,length=20)
		rotate_part('hang',angle_y=90)
		move_part('hang',x1=MID,x2=_xmid(bar),y1=MIN,y2=_ymin(bar), z1=MID,z2=_zmid(bar))
		divide(hang,z=MID)
##		new_instance(hang)

##		raise Exception

##		create_pipe_steel(bridge,rec_sec=bridge_sec,length=bridge_length,ndir='x',bone_dir='y')
##		move_part(bridge,x1=MIN,x2=_xmax(rail),y1=MID,y2=_ymid(rail),z1=MID,z2=bridge_start)
##
##		patternz(bridge, num=7, step=bridge_interval)
##
##		create_pipe_steel(stand,rec_sec=stand_sec,length=stand_length,ndir='y',bone_dir='z')
##		move_part(stand,x1=MIN,x2=_xmin(rail_A1),y1=MIN,y2=_ymax(rail_A1),z1=MID,z2=_zmid(bridge_A1))

##		for inst in insts_of_part(bridge):
##			new_instance(stand,z1=MID,z2=_zmid(inst))

		create_general_static_step()

		## contacts
		s2s_contact_std('tie',loc_pair=(leg_A1,'ymin',rail_A1,'s'))
		s2s_contact_std('tie',loc_pair=(leg_A2,'ymin',rail_A1,'s'))

		space1 = _yspace(connect)
		mfaces = face_select(leg_A1,y=space1,x=MIN)
		sfaces = mate_faces_in_inst(connect_A1,mfaces)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

		mfaces = face_select(leg_A1,y=space1,x=MAX)
		sfaces = mate_faces_in_inst(connect_A2,mfaces)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

		mfaces = face_select(leg_A2,y=space1,x=MIN)
		sfaces = mate_faces_in_inst(connect_A1,mfaces)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

		mfaces = face_select(leg_A2,y=space1,x=MAX)
		sfaces = mate_faces_in_inst(connect_A2,mfaces)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

		mfaces = face_select(bar_A1,ndir='circular',x=_xspace(connect))
		sfaces = face_select(connect_A1,ndir='circular')
		s2s_contact_std('tie',mfaces=mfaces, sfaces=sfaces)

		mfaces = face_select(bar_A1,ndir='circular',x=_xspace(connect_A2))
		sfaces = face_select(connect_A2,ndir='circular')
		s2s_contact_std('tie',mfaces=mfaces, sfaces=sfaces)

		## hang interact
##		create_surface('surf_hang',faces=hang_A1,side=2)
##		sfaces = face_select(bar_A1,ny=-1,x=MID,mark_select=True)
##		s2s_contact_std('interact',mfaces='surf_hang',sfaces=sfaces)

		## ban connect
		mfaces = face_select(leg_A1,y=(MIN,_ymax(ban)),x=MAX)
		sfaces = mate_faces_in_inst(ban_A1,mfaces)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

		mfaces = face_select(leg_A2,y=(MIN,_ymax(ban)),x=MAX)
		sfaces = mate_faces_in_inst(ban_A1,mfaces)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

		mfaces = face_select(rail_A1,z=_zspace(ban),x=MAX,y=(_ymin(ban),MAX))
		sfaces = mate_faces_in_inst(ban_A1,mfaces)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)


##		raise Exception

		## mesh:
		seed_edges_of_faces(rail, z=MAX, enum_short=2, esize_long=8)

		edges1 = edge_select(rail,z=_zmid(leg_A1))
		edges2 = edge_select(rail,z=_zmid(leg_A2))
		seed_edges(rail,edges=edges1 + edges2, esize=8)

		mesh_region(rail,esize=25)

		## leg
		seed_edges_of_faces(leg, y=MIN, enum_short=2, esize_long=8)

		edges = edge_select(leg,y=_ymid(connect))
		seed_edges(leg,esize=8)

		mesh_region(leg,esize=15)

		## connect
		seed_edges_of_faces(connect,z=MAX,enum_short=2, esize_long=8)

		seed_circular_edges(connect,quarter_seed=6)

		mesh_region(connect,esize=15)

		## bar
		seed_circular_edges(bar,quarter_seed=8)

		edges = edge_select(bar,x=MIN1) + edge_select(bar,x=MAX1)
		seed_edges(bar,enum=2)

		mesh_region(bar,esize=8)

		##hang
		seed_circular_edges(hang,quarter_seed=8)

##		edges = edge_select(hang,x=MIN)
##		seed_edges(hang,edges=edges,esize=2)
		mesh_region(hang,esize=8)

		## ban
		seed_edges_of_faces(ban,z=MAX,enum_short=2, esize_long=8)

		edges = edge_select(ban,z=MIN1) + edge_select(ban,z=MAX1)
		seed_edges(ban,edges=edges,esize=8)

		mesh_region(ban,esize=15)

##		raise Exception


		## load,BC
##		apply_disp_symm('z',faces=zmax_faces(rail_A1))
		apply_disp_fix('sym',faces=zmax_faces(rail_A1), Ux=0, Uz=0,UR2=0,UR1=0)	# Ux=0 is required
##		apply_disp_fix(name='hang_fix',referencePoints=hang_A1,fix_all=True)

		RP = create_RP(bar_A1,loc=(_xmid(bar),_ymid(bar_A1),_zmid(bar_A1)),name='bar_center')
		RP_set = create_set(objs=RP,setname='bar_center')

		faces = face_select(bar_A1,x=MID,mark_select=True)
		coupling_faces_to_point('bar_coupling',faces=faces,control_point='bar_center',U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=DISTRIBUTING)
		apply_disp_fix('fix_bar',referencePoints=RP, Ux=0,Uy=0)  ;changing	## jianzhi

##		RP = create_RP(ashaft_A1,loc=(bearing_x, _ymid(ashaft), _zmid(ashaft)), name='ashaft_bearing')
##		RP_set2 = create_set(objs=RP,setname='ashaft_RP_set')
##
##		faces = face_select(ashaft_A1,diameter=anvil_OD3)
##		coupling_faces_to_point('ashaft_coupling',faces=faces,control_point='ashaft_RP_set',U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=DISTRIBUTING)
##		apply_disp_fix('fix_ashaft',referencePoints=RP, Ux=0,Uz=0)  ;changing	## jianzhi


##		sfaces = face_select(bar_A1,ny=-1,x=MID,mark_select=True)
##		apply_disp_fix('bar_fix',faces=sfaces, Uy=0)

		apply_gravity(Gy=-9800)

		create_inp(inp_file_title,request_num=4) ;please_check
		mdb.jobs[inp_file_title].submit()


		raise Exception

	if check_palm == True:
		material_database()
		create_contact_props(friction=0.1)

		## palm
		create_block(palm,(0,palm_broad),(0,palm_length),(0,palm_thick))
		create_block(finger,(0,finger_width),(0,finger_height),(0,finger_thick))

		edges = edge_select(finger,x=MAX,edir='z')
		round_edges(finger, edges=edges, radius=finger_R)
		move_part(finger,dy=finger_to_bot)

		new_instance(palm)
		patterny(finger,num=finger_num,step=finger_to_finger)

		boolean_cut(palm,cutters=finger, del_cutters=True)
		hex_cut(palm,x=(MIN, _xmax(finger)),y=(MAX,_ymax(palm) - finger_to_top))

		divide(palm,x=_xmin(palm) + 60)
		divide(palm,z=MID)

		## drill hole
		drill_hole(palm,ndir='z',x=_xmid(palm,y=MAX), y=0.3*stand_length,D=hole_D)
		drill_hole(palm,ndir='z',x=_xmid(palm,y=MAX), y=0.6*stand_length,D=hole_D)

		set_mat(palm,mat='Steel_Q235')
		new_instance(palm)

		## plate
		create_rigid_plane('plate',length = _lenx(palm) + 10, width = 15)
		rotate_part('plate',angle_x=90)
		move_part('plate',x1=MID,x2=_xmid(palm), y1=MAX, y2=_ymin(palm), z1=MID,z2=_zmid(palm))
		new_instance(plate)

##		raise Exception

		create_general_static_step()

		s2s_contact_std('interact',name='plate_support',loc_pair=(palm_A1,'ymin',plate_A1,'s'))

		edges = edge_select(palm,x=MIN)
		seed_edges(palm,edges=edges, enum=3)

		edges = edge_select(palm,x=MIN1)
		seed_edges(palm,edges=edges,enum=8)

		mesh_region(palm,esize=8)

		edges = edge_select(plate,x=MIN)
		seed_edges(plate,enum=3)

		mesh_region(plate,esize=8)

		## load and BC
		faces = face_select(palm_A1,x=MIN1, ny=1,mark_select=True)
		pressure = load*10/(2*bridge_num)/get_area(faces)
		apply_pressure('finger_load',faces=faces,MPa=pressure)

		apply_gravity(Gy=-9800)

		faces = face_select(palm_A1,D=hole_D)
		apply_disp_fix('hole_fix',faces=faces, Ux=0,Uy=0, Uz=0)

##		apply_disp_fix(name='RP_fix1',referencePoints=plate_A1,fix_all=True)

		apply_disp_fix('bot_fix',faces=ymin_faces(palm_A1),fix_all=True)

		create_inp(inp_file_title,request_num=4) ;please_check
		mdb.jobs[inp_file_title].submit()


		raise Exception

	if check_H == True:
		material_database()
		create_contact_props(friction=0.1)

	  	create_H_steel('stand',H_sec=stand_sec,length=stand_length,ndir='y',bone_dir='z')
	  	create_block('pad',x=_xspace(stand),y=(0,10),z=_zspace(stand))
	  	move_part('pad',x1=MID,x2=_xmid(stand),y1=MAX,y2=_ymin(stand),z1=MID,z2=_zmid(stand))
		batch_divide(pad,x=xlocs(stand))
		batch_divide(pad,z=zlocs(stand))
		divide(pad,z=_zmax(pad) - 3)
		divide(pad,z=_zmin(pad) + 3)

	  	new_instance(stand)
	  	new_instance('pad')
	  	new_instance('pad',y1=MIN,y2=_ymax(stand))
	  	set_mat(stand,mat='Steel_Q235')
	  	set_mat(pad,mat='Steel_Q235')

##	  	raise Exception

	  	create_general_static_step()

	  	## mesh stand
	  	seed_edges_of_faces(stand,y=MAX,enum_short=2, esize_long=6)
	  	mesh_region(stand,esize=12)

	  	## mesh pad
	  	seed_edges_of_faces(pad,z=MAX,enum_short=2, esize_long=8)
	  	mesh_region(pad,esize=8)

	  	s2s_contact_std('tie',loc_pair=(pad_A1,'ymax',stand_A1,'s'))
	  	s2s_contact_std('tie',loc_pair=(pad_A2,'ymin',stand_A1,'s'))

	  	## load and BC
	  	faces = face_select(pad_A1,y=MIN)
	  	apply_disp_fix('bot_fix',faces=faces,fix_all=True)

	  	sfaces = face_select(bar_A1,ny=-1,x=MID,mark_select=True)
	  	apply_disp_fix('hang_fix',faces=sfaces,Uy=0)

	  	faces = face_select(pad_A2,y=MAX)
	  	area = get_area(faces)
	  	pressure = load*10/(2*bridge_num)/area
	  	apply_pressure('stack_load',faces=faces,MPa=pressure)

		create_inp(inp_file_title,request_num=4) ;please_check
		mdb.jobs[inp_file_title].submit()


	  	raise Exception


	if build_model == True:
		material_database()
		create_contact_props(friction=0.1)

		create_pipe_steel(rail,rec_sec = rail_sec, length=rail_length,bone_dir='y')
		new_instance(rail)
		new_instance(rail,dx=rail_sec[1] + rail_gap)
		divide(rail,z=rail_mid)	;changing1

		create_pipe_steel(bridge,rec_sec=bridge_sec,length=bridge_length,ndir='x',bone_dir='y')
		move_part(bridge,x1=MIN,x2=_xmax(rail),y1=MID,y2=_ymid(rail),z1=MID,z2=bridge_start)

		patternz(bridge, num=bridge_num, step=bridge_interval)
		divide(rail,y=_ymax(bridge))
		divide(rail,y=_ymin(bridge))

		create_pipe_steel(stand,rec_sec=stand_sec,length=stand_length,ndir='y',bone_dir='z')
		move_part(stand,x1=MIN,x2=_xmin(rail_A1),y1=MIN,y2=_ymax(rail_A1),z1=MID,z2=_zmid(bridge_A1))

		for inst in insts_of_part(bridge):
			new_instance(stand,z1=MID,z2=_zmid(inst))

		copy_part(stand,'stand2',x1=MAX,x2=_xmax(rail_A2))
		for inst in insts_of_part(bridge):
			new_instance(stand2,z1=MID,z2=_zmid(inst))

	##	  create_H_steel('H1',H_sec=(100,50,7,5),length=200,ndir='y',bone_dir='x')
	##	  create_C_steel('C1',C_sec=(120, 50, 20, 2.5),length=200, ndir='y', bone_dir='z')

		## palm
		create_block(palm,(0,palm_broad),(0,palm_length),(0,palm_thick))
		create_block(finger,(0,finger_width),(0,finger_height),(0,finger_thick))

		edges = edge_select(finger,x=MAX,edir='z')
		round_edges(finger, edges=edges, radius=finger_R)
		move_part(finger,dy=finger_to_bot)

		new_instance(palm)
		patterny(finger,num=finger_num,step=finger_to_finger)
	##	raise Exception

		boolean_cut(palm,cutters=finger, del_cutters=True)
		hex_cut(palm,x=(MIN, _xmax(finger)),y=(MAX,_ymax(palm) - finger_to_top))

##		divide(palm,x=_xmin(palm) + finger_tip)
		divide(palm,x=_xmin(palm) + 60)
		divide(palm,z=MID)

		if load_method == 'density':
			cells = cell_select(palm,x=_xmin(palm) + 20)
			vol0 = get_volume(cells)
			dens = (7.85e3*vol0*1e-9 + load/(2*bridge_num))/(vol0*1e-9)		;please_check
			dens = dens*KD
			set_mat(palm,cells=cells,mat='Steel1')
			_m.materials['Steel1'].density.setValues(table=((dens, ), ))

			cells = unselect(_part(palm).cells,cells)
			set_mat(palm,cells=cells,mat=steel_grade)	;changing
		else:
			set_mat(palm,mat=steel_grade)	;changing

##		raise Exception

		rotate_part(palm,angle_y = 90)
		move_part(palm,x1=MIN,x2=_xmax(stand), y1=MIN,y2=_ymax(rail), z1=MIN,z2=_zmin(stand))
		divide(palm,z=_zmax(stand) - stand_thick)
	##	new_instance(palm)

		copy_part(palm,'palm2',x1=MAX,x2=_xmin(stand2))
	##	new_instance(palm2)

		for inst in insts_of_part(stand):
			new_instance(palm,z1=MIN,z2=_zmin(inst))
			new_instance(palm2,z1=MIN,z2=_zmin(inst))

		for inst in insts_of_part(palm):
			divide(rail,z=_zmax(inst))

		divide(rail,x=_xmin(palm))


		for inst in insts_of_part(stand):
			batch_divide(rail,z=_zspace(inst))
##			divide(rail,z=_zmin(inst))
##			divide(rail,z=_zmax(inst))

	##	cut_instances(cut_sides='+z',z=_zmid(rail))
		cut_instances(cut_sides='+x',x=_xmid(bridge))
##		raise Exception

		if have_strip == True:
			create_block(strip, x=(0,strip_width), y=(0,strip_thick), z=(0, strip_length))
			move_part(strip, y1=MIN, y2=_ymax(stand), x1=MID, x2=_xmid(stand), z1=MIN, z2=_zmin('stand_A4'))
			divide(strip,x=_xmax(stand))
			new_instance(strip)

			for inst in insts_of_part(stand):
				batch_divide(strip,z=_zspace(inst))

		for part in _m.parts.keys():
			if part not in ['palm','palm2']:
				set_mat(part, mat=steel_grade)		;changing

		create_rigid_pipe('plate',x=100,y=100,length=300)
		rotate_part('plate',angle_y=90, rotate_center=(0,0,0))

		move_part('plate',x1=MID,x2=_xmid(rail), y1=MAX,y2=_ymin(rail), z1=MID,z2=_zmin(rail) + support_to_end)	;changing
		new_instance('plate')
		new_instance('plate', z1=MID,z2=_zmax(rail) - support_to_end)
		batch_divide(rail,z=[_zmin(plate_A1),_zmax(plate_A1),_zmin(plate_A2),_zmax(plate_A2)])

	if build_model == True:
		save_mdb('_' + jobnum + '_imported_model.cae')
		raise Exception

	create_general_static_step()

	## mesh bridge
	seed_edges_of_faces(bridge, x=MAX, enum_short=2, esize_long=12)
	mesh_region(bridge,esize=20)

	## rail
	seed_edges_of_faces(rail, z=MAX, enum_short=2, esize_long=12)

	edges1 = edge_select(rail,z=_zmid(plate_A1))
	edges2 = edge_select(rail,z=_zmid(plate_A2))
	seed_edges(rail,edges=edges1 + edges2, esize=12)

	edges = []
	edges1 = edge_select(rail,x=MAX)
	for inst in insts_of_part(palm):
		edges = edges + edge_select(rail,edges=edges1, z=_zspace(inst))
	seed_edges(rail,edges=edges, esize=12)

	mesh_region(rail,esize=25)	;changing

	## stand
	seed_edges_of_faces(stand,y=MAX,  esize_long=12)	;changing
	mesh_region(stand, esize=20)

	## palm
	edges = edge_select(palm, x=MAX)
	seed_edges(palm, edges=edges, esize=12)

	mesh_region(palm,esize=12)

	## strip
	if have_strip == True:
		seed_edges_of_faces(strip, z=MAX, enum_short=2, esize_long=12)

		for i in [4,5,6,7,8,9,10]:
			inst = 'stand_A' + str(i)
			edges = edge_select(strip,z=_zmid(inst))
			seed_edges(strip,edges=edges, esize=12)
		mesh_region(strip,esize=20)

	## plate
	mesh_region(plate,esize=12)


##	raise Exception
	## bridge-rail
	for inst in insts_of_part(bridge):
		s2s_contact_std('tie', loc_pair=(inst,'xmin',rail_A1,'s'))

	## stand-rail
	for inst in insts_of_part(stand):
		s2s_contact_std('tie',loc_pair=(inst,'ymin',rail_A1,'s'))

	for i in range(len(insts_of_part(palm))):
		inst1 = 'palm_A' + str(i+1)
		inst2 = 'stand_A' + str(i+1)
		s2s_contact_std('tie',loc_pair=(inst1,'xmin',inst2,'s'))   ## palm - stand
		s2s_contact_std('tie',loc_pair=(inst1,'ymin',rail_A1,'s'))	## palm - rail

##		s2s_contact_std('tie',loc_pair=('s',inst1,'x',_xmax(stand),inst2))   ## palm - stand
##		s2s_contact_std('tie',loc_pair=('s',inst1,'y',_ymax(rail),rail_A1))	## palm - rail

	for i in [4,5,6,7,8,9,10]:
		inst1 = 'stand_A' + str(i)
		inst2 = 'palm_A' + str(i)
		space = _zspace(inst1)

		sfaces = face_select(strip_A1,z=space)
		mfaces = ymax_faces(inst1)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

		mfaces = ymax_faces(inst2)
		s2s_contact_std('tie',mfaces=mfaces,sfaces=sfaces)

	sfaces = face_select(rail_A1,z=_zspace(plate_A1))
##	mfaces = create_surface(faces=_inst(plate_A1).faces, side='+y')	;changing
	faces = face_select(plate_A1,y=MAX)
	mfaces = create_surface('plate_top1',faces=faces,side='+y')
	s2s_contact_std('interact', name='plate_support1',mfaces=mfaces, sfaces=sfaces)

	sfaces = face_select(rail_A1,z=_zspace(plate_A2))
##	mfaces = create_surface(faces=_inst(plate_A1).faces, side='+y')	;changing
	faces = face_select(plate_A2,y=MAX)
	mfaces = create_surface('plate_top2',faces=faces,side='+y')
	s2s_contact_std('interact',name= 'plate_support2',mfaces=mfaces, sfaces=sfaces)

##	faces = face_select(rail_A1,z=rail_mid,exterior=False)
##	apply_disp_fix(name='mid_fix',faces=faces,Uz=0)  ## 过约束?

	## load, BC
	edges = edge_select(rail_A1,z=rail_mid,edir='x',y=MIN)
	apply_disp_fix(name='mid_fix',edges=edges,Uz=0)

	apply_disp_fix(name='RP_fix1',referencePoints=plate_A1,fix_all=True)
	apply_disp_fix(name='RP_fix1',referencePoints=plate_A2,fix_all=True)

	apply_gravity(Gy=-9800)

	faces = faces_of_insts(parts=bridge,x=_xmax(bridge))
	apply_disp_symm('x',faces=faces)

	if load_method == 'pressure':
		faces = []
		for inst in insts_of_part(palm):
			faces1 = face_select(inst,z=_zmax(inst) - 30, ny=1,mark_select=True)
			faces = faces + faces1

		area = get_area(faces)*2   ## half model
		pressure = round(load*10/area,2)   ## 全部重量/所有finger面积
		apply_pressure('palm_load',faces=faces,MPa=pressure)

##	raise Exception

	global _results_dict
	_results_dict = {'var':('bridge_num', 'rail_length','load','support_to_end','load_method'), 'rail_A1':('Mises','U2','U'), 'palm7_A1':('Mises','PEEQ')}

	create_inp(inp_file_title,request_num=4) ;please_check
	mdb.jobs[inp_file_title].submit()

	return

def main_A0224_wiredraw_919():
	## VER:2014-09-02, v1.0   wire draw nib recycle bu pushing the nib out (demold)

	check_script_file('BG_A0224_wiredraw_Nib_F8100_25_int20.py')	;changing
	history = 'B4:divide(★),B3:divide case; AJ:surface for inspection; AH:case no chamfer; A1:model'

	blank_cae(inp_file_title)

	locals0 = locals().keys()
	## bell->approach -> reduction -> bearing -> relief->exit
	## drawing#: 75-E-466-07-P..

	nib_type = '9*6'
	nib_H = 6
	nib_OD = 9
	nib_R = nib_OD/2

	alpha = 6   ## 2*alpha = 12
	d1 = 0.30
	I2 = 1.0
	I3 = 0
	I4 = 1.0
	beta = None
	R = 3.9
	gama = 45

	## approach
	approach_radius = R
	bell_R = R

	## reduction
	reduction_angle = alpha
	reduction_dy = I2

	## bearing
	bearing_D = d1
	bearing_R = bearing_D/2
	bearing_length = I3

	## exit
	exit_dy = I4
	exit_angle = gama

	## chamfer
	nib_chamfer_angle = 15
	nib_chamfer = 1.09
	case_chamfer_angle = 45
	case_corner_chamfer = 0.8

	interference = 0.020	;changing

	## case
	case_OD = 28
	case_R = case_OD/2
	case_ID = nib_OD - 2*interference
	case_H = 15
	case_exit_angle = 40
	case_land_ID = 4.2
	case_land_H = 0.3
	rivet_H = 0.5
	rivet_L = 0.55
	rivet_ID = 9.5
	rivet_R = rivet_ID/2
	rivet_offset = 0.004 ## offset in height

	## assemble:
	nib_to_top = 2.5
	nib_bot_to_bot = case_H - nib_to_top - nib_H

	## force
	force = 8100			;changing
	temperature=25		;changing
	friction = 0.1		;changing1
	initial_step = 25		;changing  ## 室温下铆接没有过盈，但侧壁有过盈。

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'

	locals2globals(locals0,locals(),save_var=True)

	material_database()
	create_contact_props(friction=0.1)					;please_check('default=0.15')

	C45_expansion = (25,11e-6),(100,11.59e-6),(200, 12.32e-6), (300,13.09e-6), (400, 13.71e-6)
	set_CTE('Steel_C45',C45_expansion)	;changing

	## Nib
	s1 = create_base_sketch('sk_nib')
	loc0 = (bearing_R,exit_dy)

	connect_points(s1,loc0,ytilt(-exit_dy,exit_angle),{'x':case_land_ID/2.0},{'x':nib_R},{'y':nib_H})
	connect_points(s1,loc0,ytilt(reduction_dy,reduction_angle),ytilt(nib_H - reduction_dy - exit_dy - bearing_length,reduction_angle),{'x':nib_R})

	loc1 = find_loc(s1,y=MAX,groupX=MIN)
	round_sketch_corner(s1,loc=loc1,radius=bell_R)

	sketch_to_shell(s1,partname='nib',symmetric=True)

	bias_cut(nib,cut_sides='bot_right',point1=(nib_R,nib_chamfer),angle_with_Y=nib_chamfer_angle)
	move_part(nib,y1=MIN,y2=nib_bot_to_bot)
	new_instance(nib)

	## case
	s1 = create_base_sketch('sk_case')
	loc0 = (case_land_ID/2,nib_bot_to_bot)

	connect_points(s1,loc0,{'dy':-case_land_H},ytilt(-nib_bot_to_bot + case_land_H, case_exit_angle), {'x':case_R},{'y':case_H})
	connect_points(s1,loc0,{'x':case_ID/2},{'dy':nib_H + rivet_offset},{'dx':-rivet_L},{'dy':rivet_H})	;changing
	connect_points(s1,last_point,{'x':rivet_ID/2.0},{'y':case_H},{'x':case_R})

	sketch_to_shell(s1,partname='case',symmetric=True)

	bias_cut(case,cut_sides='bot_right',point1=(case_R,case_corner_chamfer),angle_with_Y=45)
	bias_cut(case,cut_sides='top_right',point1=(case_R,case_H - case_corner_chamfer),angle_with_Y=45)

	loc = find_loc(case,y=MAX,groupX=MIN)
	bias_cut(case,cut_sides='top_left',point1=(loc[0] + case_corner_chamfer,loc[1],0),angle_with_Y=45)

	divide(case,y=_ymid(nib))
##	raise Exception

	new_instance(case)

	set_mat(nib,mat='H3F')
	set_mat(case,mat='Steel_C45')

##	edges = edge_select(case_A1,y=MID,nx=-1)
	edges = edge_select(case_A1,x=case_ID/2.0)
	create_surface('case_ID',edges=edges)

	edges1 = edge_select(nib_A1,x=nib_R)
	create_surface('nib_OD',edges=edges1)

	edges = edge_select(case_A1,y=_ymin(nib_A1))
	create_surface('case_land',edges=edges)

	edges = edge_select(nib_A1,y=MIN)
	create_surface('nib_bot', edges=edges)

##	edges1 = edge_select(nib_A1,y=MAX)
	edges = edge_select(nib_A1,ny=1,y=(MID,MAX))
	create_surface('nib_top',edges=edges)

##	edges = edge_select(case_A1,y=_ymax(nib_A1))
	edges = edge_select(case_A1,ny=-1,groupY=MAX)
	create_surface('rivet',edges=edges)

	faces = face_select(case_A1,y=MAX1,mark_select=True)
	create_set('top_part',faces=faces)

	get_current_model()

##	raise Exception

	## mesh case

	## steps
	times1 = myrange(0,1,0.05)
	timepoints1 = create_timepoints(times1)	;changing1

	create_coupled_temp_displacement_step(stepname='shrink_fit')
	create_coupled_temp_displacement_step(stepname='push')
	field_output_request(timepoints=(timepoints1, timepoints1),variables=ALL)	;changing1

	edges = edge_select(case,x=MIN)
	seed_edges(case,edges=edges, enum=3)

	edges= edge_select(case,x=case_ID/2.0)
	seed_edges(case,edges=edges,esize=0.15)

	edges = edge_select(case,x=(0,nib_R),y=(_ymax(nib),MAX))
	seed_edges(case,edges=edges,esize=0.15)

	choose_element_type(case)
	choose_element_type(nib,hour_glass='enhance')

	mesh_2D(case,esize=0.2)

	mesh_2D(nib,esize=0.15)

##	raise Exception

	## contacts
	create_general_contact_std(interference_pairs=('nib_OD','case_ID','interference_fit'),
		property_pairs=('nib_OD','case_ID',friction))  ;changing

##	s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',overclosure='shrink_fit',friction=friction)
##	s2s_interact_std('int_nib_support', mfaces='nib_bot', sfaces='case_land')
##	s2s_interact_std('int_nib_rivet', mfaces='nib_top', sfaces='rivet')
##
##	edges = edge_select(nib_A1,nx=1,ny=-1)
##	s2s_interact_std('int_nib_corner', mfaces=edges, sfaces='case_ID')
##	raise Exception

	## load
	edges = edge_select(case_A1,y=MAX)
	apply_disp_fix('case_fix',objs=edges,U2=0,UR3=0)

	edges = edge_select(nib_A1,x=case_land_ID/2.0 - 0.1,ny=-1)
	loc1 = find_loc(nib_A1,y=MIN,groupX=MIN)
	area = pi*(case_land_ID*case_land_ID/4 - loc1[0]*loc1[0])
	pressure = round(force/area,2)
	apply_pressure('nib_push',faces=edges, MPa=pressure,step='step2')

	objs = _inst(nib_A1).faces + _inst(case_A1).faces
	region = create_set('cell_region',objs=objs)

	_m.Temperature(name='Predefined Field-1',
	    createStepName='Initial', region=region, distributionType=UNIFORM,
	    crossSectionDistribution=CONSTANT_THROUGH_THICKNESS, magnitudes=(initial_step, ))  	;changing

	set_temperature_BC('temp_change',objs=region, temp=initial_step,step='step1')   ## shrink fit
	set_temperature_BC('temp_change',objs=region, temp=temperature,step='step2')
	apply_gravity(Gy=9800)

##	_m.predefinedFields['Predefined Field-1'].setValuesInStep(stepName='shrink_fit',magnitude=temperature)

	global _results_dict
	_results_dict = {'var':('temperature', 'force','friction','interference'), 'TOP_PART':('PEEQ','Mises'), 'CASE_A1':('S1','Mises','PEEQ')}

	create_inp(inp_file_title,request_num=6) ;please_check
	mdb.jobs[inp_file_title].submit()


	return

def main_A0206_wiredraw_919():
	## started: 2014-05-12
	## Request from Miguel, Spain, for wire draw evaluation.

	check_script_file('EF_A0206_esize002_nib01_fric001_15deg.py')	;changing
	history = 'D9(good); D5:modify wire; D2(success in wire deform):modify nib contact; CU: wire no num seed; CS: to compare with BJ; CA: wire yield = 400; BJ: add riveting for nib to remove nib top fix; BF:use implicit dynamic step as second step; BA:restart; AI:drawing process; AC: interference in general contact; A1:model'

##	open_cae('_A0206_imported_model.cae',new_name=inp_file_title)
	blank_cae(inp_file_title)
##	raise Exception

	locals0 = locals().keys()

	nib_H = 7
	nib_OD = 6   ## nib type = D6H7
	nib_R = nib_OD/2
	bell_R = 5
	bell_round = 1.5  ## round radius
	bell_angle = 35
	center_to_bot = nib_H - 3.479

	bearing_D = 0.3
	bearing_R = bearing_D/2
	bearing_length = bearing_D*0.35
	bearing_to_bot = 2 - bearing_length/2

	reduction_angle = 11
	approach_H = 2 - bearing_length/2
	reduction = 0.2

	relief_dy = bearing_length
	relief_angle = 27

	exit_dy = bearing_to_bot - relief_dy
	exit_angle = 60

	approach_dy = nib_H - approach_H - bearing_length - relief_dy - exit_dy
	nib_thick = nib_R - bearing_D/2

	## case file: assembly_WDBDRHS2000213.pdf
	interference = 0.04		;changing1
	case_H = 14
	case_OD = 28   ## case type: 28x14
	nib_to_top = 3.0
	nib_bot_to_bot = case_H - nib_to_top - nib_H
##	case_land_D = 3
	case_land_H = 0.3
	case_ID = nib_OD - interference*2	;changing
##	case_ID = nib_OD
	case_exit_H = nib_bot_to_bot - case_land_H
	case_exit_angle = 60
	case_land_ID = 3.0   ## different for another drawing(3.5)
	case_entrance_cut = 1.0       ## refer to case_WDBDRHS20002M
	case_entrance_cut_angle = 30  ## refer to case_WDBDRHS20002M
	land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.
	corner_chamfer = 0.5

	esize = 0.02				;changing
	friction = 0.01 			;changing
	cut_angle_y = 15	  			;changing
	draw_time = 1.5e-4  		;changing

	if cut_angle_y == 15:
		cut_height = 1.09  ## nib
		cut_R = 5.65
	else:
		cut_height = 0.5
		cut_R = 0

	wire_D = sqrt(bearing_D*bearing_D/(1-reduction))
	wire_D = round(wire_D,3)
	wire_R = wire_D/2.0
	wire_length = 10		;changing1
	offset = 1
	speed = -16*1000		;changing1
	wire_cut_x=0.1
	wire_cut_y = 0.2

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'
	wire = 'wire'
	wire_A1 = 'wire_A1'

	locals2globals(locals0,locals(),save_var=True)

	material_database()
	create_contact_props(friction=friction)					;please_check('default=0.15')

	## wire elastic
##	wire_plastic = (275,0), (690, 0.2), (960, 0.4), (1206, 0.6), (1654, 1), (2240, 1.6)  ## hardening steel
	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
	set_plastic('Steel', wire_plastic)	;changing
##	set_plastic('Steel', (500, 0))	;changing

	set_plastic('H3F',(5000,0))		;changing1

	s1 = create_base_sketch('sk_nib')

	loc0 = (bearing_R,bearing_to_bot)
	loc1 = (bearing_R,bearing_length + bearing_to_bot)

	line1 = slope_construction(s1,loc=loc1,angle=90 - reduction_angle/2)

	arcs,center,point1 = create_tangent_circle(s1,line1,radius=bell_R,center=(10,center_to_bot),fix_y=True)
	point2 = find_loc(s1,y=nib_H,groupX=MIN)

	del_sketch_objs(s1, arcs)
	connect_points(s1,loc0,loc1,point1)

	create_arc(s1,center,point1=point1, point2=point2,direction=CLOCKWISE)
	points = connect_points(s1,point2,{'H':nib_R},{'V':cut_height}, ytilt(-cut_height,-cut_angle_y))

##	raise Exception

	if cut_R > 0:
		round_sketch_corner(s1,loc=points[-2],radius=cut_R)
	round_sketch_corner(s1,loc=point2,radius=bell_round)

	connect_points(s1,loc0,ytilt(-relief_dy,relief_angle/2),ytilt(-exit_dy,exit_angle/2),points[-1])
	sketch_to_shell(s1,partname='nib',symmetric=True)

##	raise Exception

	## case
	s1 = create_base_sketch('sk_case')
	points = connect_points(s1,(case_land_ID/2,case_exit_H),{'dy':case_land_H},{'x':case_ID/2.0},
		{'y':case_H - case_entrance_cut}, ytilt(case_entrance_cut, case_entrance_cut_angle), {'x':case_OD/2 - corner_chamfer},(case_OD/2, case_H - corner_chamfer),
		{'y':corner_chamfer},(case_OD/2 - corner_chamfer,0))
	round_sketch_corner(s1,loc=points[2],radius=land_corner_R)

	connect_points(s1,(case_land_ID/2,case_exit_H), ytilt(-case_exit_H,case_exit_angle/2),(case_OD/2 - corner_chamfer,0))
	sketch_to_shell(s1, partname='case',symmetric=True)

##	raise Exception

	move_part(nib,y1=MIN,y2=nib_bot_to_bot)
	new_instance(nib)
	new_instance(case)
	plot(a)
	session.viewports['Viewport: 1'].view.fitView()

	## add riveting
	divide(case,y=_ymax(nib_A1))
	loc1 = (case_ID/2.0, _ymax(nib_A1))
	loc2 = (case_ID/2.0 - 0.5, _ymax(nib_A1) + 0.4)
	create_rectangle_shell(case, corner1=loc1,corner2=loc2)

	faces = face_select(case,y=(_ymax(nib_A1), MAX))
	divide(case,faces=faces,x=case_ID/2.0)

##	vertice = vertice_select(nib_A1,x=MIN,groupY=MIN)
##	mouth_y = vertice[0].pointOn[0][1]	;please_check
	loc = find_loc(nib_A1,x=MIN,groupY=MIN)
	mouth_y = loc[1]

##	raise Exception

	## wire
	create_rectangle_shell('wire',corner1=(0,0),corner2=(wire_R, wire_length),axis_symmetric = True)
	move_part(wire,y1=MIN,y2=_ymin(nib) + 2)

##	bias_cut(wire, cut_sides='bot_right', point1=(wire_R, _ymin(wire) + 0.2, 0), point2=(wire_R*0.7, _ymin(wire), 0))
	bias_cut(wire,cut_sides=('+x','-y'), point1=(wire_R, _ymin(wire) + offset,0), point2=(wire_R/2,_ymin(wire),0))
##	round_corner(wire,radius=5,x=MAX,groupY=MIN)
	new_instance(wire)

	divide(wire,y=_ymin(wire) + 2)	;changing
##	bias_cut(wire,cut_sides='bot',y=_ymin(wire) + 0.75)

##	loc = find_loc(nib_A1,x=MAX,groupY=MIN)
##	divide(case,y=loc[1])		;changing1

	set_mat(case,mat='Steel_EN10718')
	set_mat(nib,mat='H3F')
	set_mat(wire,mat='Steel')	;changing1

	edges = edge_select(case_A1,ny=1,groupY=MIN)
	create_surface('case_land',edges=edges)

	edges = edge_select(case_A1,y=MID,nx=-1)
	create_surface('case_ID',edges=edges)

	edges1 = edge_select(nib_A1,nx=1)
##	edges1 = edge_select(nib_A1,x=MAX,y=MID)
	create_surface('nib_OD',edges=edges1)

##	edges = edge_select(nib_A1,nx=1)
##	edges = unselect(edges, edges1)
##	create_surface('nib_corner', edges=edges)

	edges = edge_select(nib_A1,y=MIN)
	create_surface('nib_bot', edges=edges)

	edges3s = edge_select(wire_A1,nx=1)
	create_surface('wire_surf',edges=edges3s)

	vertices = vertice_select(nib_A1,x=MIN)
	edges3m = vertices_to_edges(vertices)
	create_surface('nib_surf',edges=edges3m)

##	edges1 = edge_select(nib_A1,y=MAX)
	edges = edge_select(nib_A1,ny=1,y=(MID,MAX))
	create_surface('nib_top',edges=edges)

	edges = edge_select(case_A1,y=_ymax(nib_A1))
	create_surface('rivet',edges=edges)

	get_current_model()

##	raise Exception

	## mesh case
	edges = edge_select(case,x=(MIN,case_ID/2.0 + 0.1),y=(MIN1,MAX1))
	seed_edges(case,edges=edges,esize=0.10)	;changing

	mesh_2D(case,esize=0.2)		;changing

##	raise Exception

	## mesh nib
##	esize = 0.02	;changing
	edges = edge_select(nib,nx=-1,y=(MIN,MID))
	seed_edges(nib,edges=edges, esize=0.02)			;changing

	edges = edge_select(nib,x=MIN)
	seed_edges(nib,edges=edges, enum=4)		;changing1

	mesh_2D(nib,esize=0.10)	;changing

	## mesh wire
	edges = edge_select(wire,y=MAX)
	seed_edges(wire,edges=edges,enum=15)	;changing ## enum

	mesh_2D(wire,esize=esize)

##	raise Exception

	times1 = myrange(0,1,0.05)
	timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1

	times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,50, 0.5)
	timepoints2 = create_timepoints(times2,factor=1e-5)

	## steps implicit way
	solver = 'implicit'	;changing
	if solver == 'implicit':
		create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
		create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
		field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

##		create_general_contact_std(pairs=[('nib_OD','case_ID'),('nib_bot','case_land'),('nib_top','rivet'),('nib_surf','wire_surf')],
##			interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))

		## contact
##		create_general_contact_std(interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))
##		create_general_contact_std(property_pairs=('nib_surf','wire_surf',friction))


		s2s_interact_std('int_nib_support', mfaces='nib_bot', sfaces='case_land')
		s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',overclosure='shrink_fit')
##		s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',initial_clearance=-0.04)

		s2s_interact_std('int_nib_rivet', mfaces='nib_top', sfaces='rivet')
##
		s2s_interact_std('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',friction=friction,step='step2')

		## Fix
		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		edges = edge_select(wire_A1,y=MAX)
		apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0,deactive_step='step2')

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
		apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing

	elif solver == 'explicit':
		create_dynamic_explicit_step(step='step1', timePeriod=draw_time)
		field_output_request(timepoints=timepoints2,variables=ALL)	;changing

		s2s_interact_explicit('int_nib_support', mfaces='nib_bot', sfaces='case_land',sliding=SMALL)
		s2s_interact_explicit('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',interference=interference)
##		s2s_interact_explicit('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',prop=friction,step='step1')

		vertices = vertice_select(nib_A1,x=MIN)
		edges = vertices_to_edges(vertices)
		s2s_interact_explicit('int_nib_wire', mfaces=edges, sfaces='wire_surf',prop=friction,step='step1')

		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		apply_velocity('initial_speed',faces=_inst(wire_A1).faces, Vy=speed, step='Initial')

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
		apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step1')	;changing

	odb_title1 = create_inp(inp_file_title,request_num=6,submit=False) ;please_check


##	## restart model, explicit
##	create_restart_model(model_name='restart',odb_title1=odb_title1)
####	new_instance(wire)
####	import_initial_stress(odb_title1)
##
####	raise Exception
##
##	create_dynamic_explicit_step(stepname='step2',timePeriod=draw_time)
##
##	times = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,30, 0.5)
##	timepoints = create_timepoints(times,factor=1e-5)
##
##	del _m.fieldOutputRequests['F-Output-1']
##	_m.FieldOutputRequest(name='Field output', createStepName='step2', variables=PRESELECT, timePoint=timepoints)  ## default to save results of every increment
##
##	edges1s = edge_select(case_A1,ny=1,y=(MIN,MID))
##	edges1m = edge_select(nib_A1,y=MIN)
##	s2s_interact_explicit('int_nib_support', mfaces=edges1m, sfaces=edges1s,prop='Frictionless')
##
##	edges2s = edge_select(case_A1,nx=-1,y=MID)
##	edges2m = edge_select(nib_A1,nx=1)
##	s2s_interact_explicit('int_nib_case', mfaces=edges2m, sfaces=edges2s,prop='Frictionless')
##
##	edges3s = edge_select(wire_A1,nx=1)
##	edges3m = edge_select(nib_A1,nx=-1)
##	s2s_interact_explicit('int_wire_nib', mfaces=edges3m, sfaces=edges3s,prop=friction)
##
##	## load, BC
##	edges = edge_select(case_A1,y=MIN)
##	apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)
##
##	edges = edge_select(nib_A1,y=MAX)
##	apply_disp_fix('nib_fix',edges=edges,Uy=0)
##
##	apply_velocity('initial_speed',faces=_inst(wire_A1).faces, Vy=speed, step='Initial')
##
##	faces = face_select(wire_A1,y=MIN1,mark_select=True)
##	apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing
##
##	odb_title2 = create_inp(inp_file_title,request_num=6,submit=True) ;please_check

	return

def main_A0226_wiredraw_919():
	## VER: 2014-09-24, v1.0

	check_script_file('AH_A0226_12x10nib_45deg_coupled.py')
	history='A9:elastic nib; A6:general contact; A1:based on BG_A0224'

	imported1 = True

	dx = 'dx'
	dy = 'dy'

	cut_angle_y = 45	;changing
	if cut_angle_y == 45:
		cut_height = 0.5

	if imported1:
		open_cae('_A0226_imported_12X10nib',new_name=inp_file_title)

		edges = edge_select('nib0',x=(MID,MAX),z=MAX)
		sketch = edges_to_sketch(edges,sketchname='sk_nib')
		s1 = sketch['sketch']

		if cut_angle_y == 45:
			loc1 = find_loc(s1,x=MAX,groupY=MIN)
			loc2 = find_loc(s1,y=MIN,groupX=MAX)

			edges = geometry_select(s1,x=(loc1[0],loc2[0]),y=(loc1[1],loc2[1]))
			del_geometry(s1,edges)
			connect_points(s1,loc2,('x',_xmax(s1)),loc1)

			sketch_to_shell(s1,partname='nib',symmetric=True)
			bias_cut('nib',cut_sides='bot_right',point1=(_xmax('nib'),_ymin('nib') + cut_height),angle_with_Y=cut_angle_y)

		else:
			sketch_to_shell(s1,partname='nib',symmetric=True)

		edges = edge_select('case0',x=(MID,MAX),z=MAX)
		sketch = edges_to_sketch(edges,sketchname='sk_case')
		s1 = sketch['sketch']
		sketch_to_shell(s1,partname='case',symmetric=True)

		new_instance('nib')
		new_instance('case')

##	raise Exception

	nib_type = 'D12H10'		;changing
	locals0 = locals().keys()   ## need both stp file and assembly file with bearing dimensions.
	## for D12H10 nib, the bearing diameter=0.8mm, then wire diameter= 0,889
	## for D9H6 nib, the bearing diameter=0.1mm, then wire diameter=0,111
	## bell->approach -> reduction -> bearing -> relief->exit

	if nib_type == 'D9H6':
		nib_OD = 9
		nib_H = 6
		nib_R = nib_OD/2

		## partial reduction
		reduction_angle = 11
		reduction = 0.2
		joint_to_reduction_top = 0.388  ## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。

		## 1. bearing (首先要确定的参数)
		bearing_D = 0.1
		joint_D = 0.09   ## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
		bearing_mid_to_bot = 1.947   ## 一般取2   bering mid to bot
		bearing_R = bearing_D/2
		bearing_length = bearing_D*0.35   ## 这是规律
		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)
		nib_thick = nib_R - bearing_D/2		;please_check

		## 2. relief
		relief_dy = bearing_length	## 这是规律
		relief_angle = 27

		## 3. exit
		exit_dy = bearing_mid_to_bot - 1.5*bearing_length
		exit_angle = 90

		## 4. reduction
	##	reduction_angle = 11
	##	reduction = 0.2
		reduction_dy = joint_to_reduction_top - joint_to_bearing_top
		wire_D = joint_D/(1-reduction)	## 这是规律, 是直径的缩减率，不是面积的缩减率。  (根据joint_D可以知道wire_D，所以提供stp文件给客户即可)
		wire_R = wire_D/2.0

		## 5. approach
		approach_angle = 35
		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy
		## 不需要知道approach_H，因为会倒圆角bell_R

		## 6. bell (round)
		bell_R = 2

		## nib corner cut
		cut_angle_y = 45	  			;changing
		if cut_angle_y == 15:
			cut_height = 1.0  ## nib
			cut_R = 5.65
		else:
			cut_height = 0.5
			cut_R = 0

		## case file: 75-E-464-31-P010
		case_H = 14
		case_OD = 28   ## case type: 28x14
		case_R = case_OD/2.0

		interference = 0.03		;changing1   ## 9*6 nib: 20-40um, 12*10 nib: 40-60um
		case_ID = nib_OD - interference*2	;changing  ## use shrink fit, not initial_closure

		case_entrance_cut = 1.5
		case_entrance_cut_angle = 30

		rivet_H = 0.5
		rivet_ID = 8
		rivet_L = (nib_OD - rivet_ID)/2.0
		rivet_R = rivet_ID/2
		rivet_offset = 0.004 	;changing1	## offset in height, rivet与nib之间的间隙，考虑shrink fit后会消除。

		nib_to_top = 3.0
		nib_bot_to_bot = case_H - nib_to_top - nib_H

		case_land_H = 0.5   ## 0.3-0.5
		case_land_ID = 4.5   ## different for another drawing(3.5)
		land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.

		case_exit_H = nib_bot_to_bot - case_land_H
		case_exit_angle = 60

		case_corner_chamfer = 1.0

	elif nib_type == 'D12H10': ## 75-E-464-32-P080
		nib_OD = 12
		nib_H = 10
		nib_R = nib_OD/2

		## partial reduction
		reduction_angle = 11   ## so, wire_D = bearing_D*1.11
		reduction = 0.2
##		joint_to_reduction_top = 0.388  ## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。

		## 1. bearing (首先要确定的参数)
		bearing_D = 0.8
		bearing_R = bearing_D/2
		bearing_length = 0.28
##		joint_D = 0.09   ## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
##		bearing_mid_to_bot = 1.947   ## 一般取2   bering mid to bot
##		bearing_length = bearing_D*0.35   ## 这是规律
##		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)
##		nib_thick = nib_R - bearing_D/2		;please_check

		## 2. relief
		relief_dy = bearing_length	## 这是规律
		relief_angle = 27

		## 3. exit
##		exit_dy = bearing_mid_to_bot - 1.5*bearing_length
		exit_angle = 90

		## 4. reduction
	##	reduction_angle = 11
	##	reduction = 0.2
##		reduction_dy = joint_to_reduction_top - joint_to_bearing_top
##		wire_D = joint_D/(1-reduction)	## 这是规律, 是直径的缩减率，不是面积的缩减率。  (根据joint_D可以知道wire_D，所以提供stp文件给客户即可)
		wire_D = 0.889
		wire_R = wire_D/2.0

		## 5. approach
		approach_angle = 40
##		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy
		## 不需要知道approach_H，因为会倒圆角bell_R
		approach_reduction_round = 1.0

		## 6. bell (round)
		bell_R = 2.3

		## nib corner cut
		cut_angle_y = 45	  			;changing
		if cut_angle_y == 15:
			cut_height = 1.0  ## nib
			cut_R = 5.65
		else:
			cut_height = 0.5
			cut_R = 0

		## case file: 75-E-464-31-P010
		case_OD = 28   ## case type: 28x14
		case_H = 14
		case_R = case_OD/2.0

		interference = 0.03		;changing1   ## 9*6 nib: 20-40um, 12*10 nib: 40-60um
		case_ID = nib_OD - interference*2	;changing  ## use shrink fit, not initial_closure

		case_entrance_cut = 1.5
		case_entrance_cut_angle = 30

		rivet_H = 0.5
		rivet_ID = 8
		rivet_L = (nib_OD - rivet_ID)/2.0
		rivet_R = rivet_ID/2
		rivet_offset = 0.004 	;changing1	## offset in height, rivet与nib之间的间隙，考虑shrink fit后会消除。

		nib_to_top = 0.7
		nib_bot_to_bot = case_H - nib_to_top - nib_H

		case_land_H = 0.5   ## 0.3-0.5
		case_land_ID = 6.5   ## different for another drawing(3.5)
		land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.

		case_exit_H = nib_bot_to_bot - case_land_H
		case_exit_angle = 60

		case_corner_chamfer = 1.0

##	esize = 0.02				;changing
	friction = 0.01 			;changing
	draw_time = 2.0e-4  		;changing

	## wire
	wire_length = 10		;changing1
	wire_cut_H = 1
	speed = -16*1000		;changing1
	wire_cut_x=0.1
	wire_cut_y = 0.2

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'
	wire = 'wire'
	wire_A1 = 'wire_A1'

	locals2globals(locals0,locals(),save_var=True)

	material_database()
	create_contact_props(friction=friction)					;please_check('default=0.15')

	## wire elastic
##	wire_plastic = (275,0), (690, 0.2), (960, 0.4), (1206, 0.6), (1654, 1), (2240, 1.6)  ## hardening steel
	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
	set_plastic('Steel', wire_plastic)	;changing
##	set_plastic('Steel', (500, 0))	;changing

	set_plastic('H3F',(5000,0))		;changing1

	if imported1 == False:
		## Nib
		s1 = create_base_sketch('sk_nib')
		loc0 = (bearing_R,0)
		loc1 = loc0

		if relief_dy > 0:
			connect_points(s1,loc0,ytilt(-relief_dy,relief_angle/2))
			loc1 = last_point
		connect_points(s1,loc1,ytilt(-exit_dy,exit_angle/2),('x',nib_R),(dy,nib_H))

		if bearing_length > 0:
			connect_points(s1,loc0,(dy,bearing_length))
			loc1 = last_point
		locs = connect_points(s1,loc1,ytilt(reduction_dy,reduction_angle/2),ytilt(approach_dy,approach_angle/2),('x',nib_R))
		round_sketch_corner(s1,loc=locs[-2],radius=bell_R)

		sketch_to_shell(s1,partname='nib',symmetric=True)

		move_part(nib,y1=MIN,y2=nib_bot_to_bot)
		bias_cut(nib,cut_sides='bot_right',point1=(nib_R,_ymin(nib) + cut_height),angle_with_Y=cut_angle_y)
		new_instance(nib)

		## case
		s1 = create_base_sketch('sk_case')
		loc0 = (case_land_ID/2,nib_bot_to_bot)	## nib的底面

		connect_points(s1,loc0,(dy,-case_land_H),ytilt(-nib_bot_to_bot + case_land_H, case_exit_angle/2), ('x',case_R),('y',case_H))
		connect_points(s1,loc0,('x',case_ID/2),('dy',nib_H + rivet_offset),('x',rivet_ID/2),('dy',rivet_H))	;changing
		connect_points(s1,last_point,('x',case_ID/2.0),('y',case_H),('x',case_R))

		sketch_to_shell(s1,partname='case',symmetric=True)

		bias_cut(case,cut_sides='bot_right',point1=(case_R,case_corner_chamfer),angle_with_Y=45)
		bias_cut(case,cut_sides='top_right',point1=(case_R,case_H - case_corner_chamfer),angle_with_Y=45)

		loc = find_loc(case,y=MAX,groupX=MIN)
		bias_cut(case,cut_sides='top_left',point1=(loc[0],loc[1] - case_entrance_cut,0),angle_with_Y=case_entrance_cut_angle)

		new_instance(case)

##	divide(case,y=_ymin(nib,x=MAX))

	## wire
	create_rectangle_shell('wire',corner1=(0,0),corner2=(wire_R, wire_length),axis_symmetric = True)
	move_part(wire,y1=MIN,y2=_ymin(nib) + 2)

##	bias_cut(wire, cut_sides='bot_right', point1=(wire_R, _ymin(wire) + 0.2, 0), point2=(wire_R*0.7, _ymin(wire), 0))
	bias_cut(wire,cut_sides=('+x','-y'), point1=(wire_R, _ymin(wire) + wire_cut_H,0), point2=(wire_R/2,_ymin(wire),0))
##	round_corner(wire,radius=5,x=MAX,groupY=MIN)
	new_instance(wire)

##	divide(wire,y=_ymin(wire) + wire_cut_H)
	divide(wire,y=_ymin(wire) + wire_cut_H + 0.5)	;changing

	set_mat(nib,mat='H3F')
	set_mat(case,mat='Steel_C45')
	set_mat(wire,mat='Steel')	;changing1

	## step
	times1 = myrange(0,1,0.05)
	timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1

	times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,50, 0.5)
	timepoints2 = create_timepoints(times2,factor=1e-5)

	create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
##	create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
	create_coupled_temp_displacement_step(stepname='draw',timePeriod=draw_time)
	field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

	raise Exception

	## create surfaces
	edges = edge_select(case_A1,ny=1,groupY=MIN)
	create_surface('case_land',edges=edges)

##	edges = edge_select(case_A1,y=MID,nx=-1)
##	create_surface('case_ID',edges=edges)

	edges = edge_select('case_A1',nx=-1,x=(MIN1,MAX),y=_yspace('nib'))
	create_surface('case_ID',edges=edges)

	edges1 = edge_select(nib_A1,nx=1)  ## use for general contact
##	edges1 = edge_select(nib_A1,x=MAX,y=MID)
	create_surface('nib_OD',edges=edges1)

	edges = edge_select(nib_A1,nx=1,ny=-1)
##	edges = unselect(edges, edges1)
	create_surface('nib_corner', edges=edges)

	edges = edge_select(case_A1,x=case_ID/2,y=_ymin(nib,x=MAX) - 0.1)
	create_surface('case_corner',edges=edges)

	edges = edge_select(nib_A1,y=MIN)
	create_surface('nib_bot', edges=edges)

	edges3s = edge_select(wire_A1,nx=1)
	create_surface('wire_surf',edges=edges3s)

	vertices = vertice_select(nib_A1,x=MIN)
	edges3m = vertices_to_edges(vertices)
	create_surface('nib_surf',edges=edges3m)

	edges1 = edge_select(nib_A1,y=MAX)
	create_surface('nib_top',edges=edges1)

##	edges2 = edge_select(case_A1,y=_ymax(nib_A1) + rivet_offset)
##	create_surface('rivet_bot',edges=edges2)

	get_current_model()

##	raise Exception

	## mesh case
	edges = edge_select(case,x=(MIN,case_ID/2.0 + 0.1),y=(MIN1,MAX1))
	seed_edges(case,edges=edges,esize=0.15)	;changing

	mesh_2D(case,esize=0.2)		;changing

	## mesh nib
##	esize = 0.02	;changing
##	edges = edge_select(nib,nx=-1,y=(MIN,MID))

	esize = min(bearing_length/6,0.05)
	edges = edge_select(nib,x=(MIN,MIN1))
	seed_edges(nib,edges=edges, esize=esize)			;changing

##	edges = edge_select(nib,x=MIN)
##	seed_edges(nib,edges=edges, enum=4)		;changing1

##	edges = edge_select(nib,nx=1)
##	seed_edges(nib,edges=edges,esize=0.1)

	mesh_2D(nib,esize=0.15)	;changing

	## mesh wire
	edges = edge_select(wire,y=MAX)
	seed_edges(wire,edges=edges,enum=15)	;changing ## enum

	mesh_2D(wire,esize=esize)

##	raise Exception

##	times1 = myrange(0,1,0.05)
##	timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1
##
##	times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,50, 0.5)
##	timepoints2 = create_timepoints(times2,factor=1e-5)

	## steps implicit way
	solver = 'implicit'		;changing
	if solver == 'implicit':
##		create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
##
##		create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
##		field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

##		create_general_contact_std(pairs=[('nib_OD','case_ID'),('nib_bot','case_land'),('nib_top','rivet'),('nib_surf','wire_surf')],
##		interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))

		## contact
##		create_general_contact_std(interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))
##		create_general_contact_std(property_pairs=('nib_surf','wire_surf',friction))

##		raise Exception

		if imported1 == False:
			s2s_interact_std('int_nib_support', mfaces='nib_bot', sfaces='case_land')
			s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',overclosure='shrink_fit')
	##		s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',initial_clearance=-0.04)

			s2s_interact_std('int_nib_rivet', mfaces='nib_top', sfaces='rivet_bot')
	##
			s2s_interact_std('int_nib_corner',mfaces='nib_corner',sfaces='case_corner',overclosure='shrink_fit')  ## 在有初始过盈的情况下，必须设置shrink fit,否则一开始由于侵入，不收敛。
			s2s_interact_std('int_nib_corner2',mfaces='nib_corner',sfaces='case_land')

			s2s_interact_std('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',friction=friction,step='step2')

		else:
			create_general_contact_std(friction=0.01,interference_pairs=(('nib_OD','case_ID','interfernce_fit')))

##		raise Exception

		## Fix
		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		edges = edge_select(wire_A1,y=MAX)
		apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0,deactive_step='step2')

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
##		faces = _inst(wire_A1).faces
		apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing

	create_inp(inp_file_title,request_num=6,submit=True)

	return

def main_A0222_nozle_compaction():
	## VER: 2014-09-10, v1.0

	check_script_file('CH_A0222_nozle_compaction_LeftRight_cut_combine2.py')
	history = 'CG:one part; CD:powder is not orphan mesh; C9: adative mesh control; A1:model'
	## 倒角压型，半径从0.25到0.2（烧结）
	## 草图尺寸，烧结后的尺寸是压坯尺寸的0.8 (80%)

	blank_cae(inp_file_title)
	locals0 = locals().keys()

	## corepin: ejector
	corepin_OD = 6.06
	ejector_R = 2.5
	ejector_land = 0.1
	ejector_tangent_angle = 50
	ejector_land_R = 0.05

	bpunch_ID = corepin_OD
	bpunch_OD = 8.75
	bpunch_R = bpunch_OD/2.0
	bpunch_land = 0.1
	bpunch_land_R = 0.13
	bpunch_land_angle = 45
	bpunch_depth = 0.19
	bpunch_step_R = 0.25
	bpunch_to_bot = 10.4

	die_ID = bpunch_OD
	die_R = die_ID/2.0

	tpunch_tip_R = 0.25  ## D=0.5, sinter=0.4
	tpunch_tip_H = 1.5  ## include R, kevin = 1.75
	tpunch_depth = 7.5  ## kevin = 7.75

	tpunch_step1_R1 = 0.13   ## 0.1/0.8 = 0.125, sinter=0.1
	tpunch_step1_R2 = 0.25
	tpunch_step1_H = 0.38   ## sinter to 0.3
	tpunch_step1_W = 1.0

	tpunch_step2_R1 = 0.1   ## sinter=0.1*0.8 = 0.08
	tpunch_step2_R2 = 0.25
	tpunch_step2_IR = tpunch_tip_R + tpunch_step1_W

	tpunch_slope_angle = 29

	tpunch_wall_R1 = 0.63
	tpunch_wall_R2 = 0.38
	tpunch_wall_H = 3.63
	tpunch_wall_ID = 4.31
	tpunch_slope_H = tpunch_depth - tpunch_wall_H - tpunch_step1_H - tpunch_tip_H
	tpunch_OD = bpunch_OD
	tpunch_land = (tpunch_OD - tpunch_wall_ID)/2.0
	tpunch_ext = 4.0  ## extend into powder

	tpunch = 'tpunch'
	bpunch = 'bpunch'
	powder = 'powder'
	corepin = 'corepin'
	die = 'die'
	powder2 = 'powder2'
	powder3 = 'powder3'

	tpunch_A1 = 'tpunch_A1'
	bpunch_A1 = 'bpunch_A1'
	powder_A1 = 'powder_A1'
	corepin_A1 = 'corepin_A1'   ## ejector
	die_A1 = 'die_A1'
	powder2_A1 = 'powder2_A1'
	powder3_A1 = 'powder3_A1'

	PFH = 20.73
	orphan = False			;changing
	multi_part = False	;changing

	locals2globals(locals0,locals(),save_var=True)

	dx = 'dx'
	dy = 'dy'
	x = 'x'
	y = 'y'

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	## ejector
	s1 = create_base_sketch('sk_ejector')

	locs = connect_points(s1,(corepin_OD/2.0, 0), (dx, - ejector_land), xtilt(-corepin_OD/2.0,  ejector_tangent_angle - 90))

	fix_constraint(s1.geometry[last_line])

	create_arc(s1,center=(0,2*ejector_R),radius=ejector_R,quarter=4)
	arc_constraint(s1.geometry[last_arc],fix_x=True)

	tangent_constraint(s1,last_line,last_arc)

	del_geometry(s1,y=MAX1)
	del_geometry(s1,y=MIN1)

	loc = find_loc(s1,y=MAX,groupX=MIN)
	round_sketch_corner(s1,loc=loc,radius=ejector_land_R)


	## bpunch
	s1 = create_base_sketch('sk_bpunch')

	locs = connect_points(s1,(bpunch_R,0), (dx,-bpunch_land),ytilt(-bpunch_depth,-bpunch_land_angle),
		(x,bpunch_ID/2.0),(dy,-10))

	round_sketch_corner(s1,loc=locs[1],radius=bpunch_land_R)
	round_sketch_corner(s1,loc=locs[2],radius=bpunch_land_R)
	round_sketch_corner(s1,loc=locs[3],radius=bpunch_step_R)


	## tpunch
	s1 = create_base_sketch('sk_tpunch')
	create_arc(s1,center=(0,-tpunch_tip_R),radius=tpunch_tip_R, quarter=1)
	locs1 = connect_points(s1,(tpunch_tip_R,-tpunch_tip_R),(dy,-tpunch_tip_H + tpunch_tip_R),(dx,tpunch_step1_W),(dy,-tpunch_step1_H))

	locs2 = connect_points(s1,(tpunch_OD/2.0, -tpunch_depth), (dx,-tpunch_land),
		(dy,tpunch_wall_H), ytilt(tpunch_slope_H, -tpunch_slope_angle/2.0), (x,tpunch_step2_IR))

	round_sketch_corner(s1,loc=locs1[1],radius=tpunch_step1_R1)
	round_sketch_corner(s1,loc=locs1[2],radius=tpunch_step1_R2)
	round_sketch_corner(s1,loc=locs1[3],radius=tpunch_step2_R1)

	round_sketch_corner(s1,loc=locs2[-2],radius=tpunch_step2_R2) ## 0.25
	round_sketch_corner(s1,loc=locs2[-3],radius=tpunch_wall_R1)  ## 0.63
	round_sketch_corner(s1,loc=locs2[-4],radius=tpunch_wall_R2)  ## 0.38

	mirror_geometry(s1,y=0)

##	## extend
##	loc = find_loc(s1,y=MIN)
##	connect_points(s1,loc,(dy,-2))

##	raise Exception

	move_geometry('sk_tpunch', y1=_ymin('sk_tpunch'), y2=_ymin('sk_ejector') + PFH)
	move_geometry('sk_bpunch', y1=MAX, y2=_ymin('sk_ejector') + bpunch_to_bot)



	## die
	s1 = create_base_sketch('sk_die')
	connect_points(s1,(die_R,0),(die_R,27))

	s1 = create_base_sketch('sk_powder')
	add_sketches(s1, ['sk_bpunch','sk_ejector'])
	bias_cut_sketch(s1, x=die_R, side='+')

	trim_geometry(s1,x=corepin_OD/2.0,groupY=MIN1)

	loc1 = find_loc(s1,x=MIN)	;x1,y1 = loc1
	loc2 = find_loc(s1,x=MAX)

	connect_points(s1,loc1,(dy,PFH),(dx,die_R),loc2)
	powder_sketch = merge_and_clear_sketch_objs(s1)

	## extend sketch:
	connect_points('sk_tpunch','ymin',(dy,-tpunch_ext))
	connect_points('sk_ejector','xmax',(dx,0.5))
	connect_points('sk_bpunch','xmax',(dx,0.5))

	sketch_to_shell('sk_powder',partname='powder', symmetric=True)
	sketch_to_wire('sk_tpunch',partname='tpunch',symmetric=True, ptype='discrete')

	sketch_to_wire('sk_bpunch',partname='bpunch',symmetric=True, ptype='discrete')
	sketch_to_wire('sk_ejector',partname='corepin',symmetric=True, ptype='discrete')
	sketch_to_wire('sk_die',partname='die',symmetric=True, ptype='discrete')

##	sketch_to_wire('sk_tpunch',partname='tpunch',symmetric=True, ptype='analy')
##
##	sketch_to_wire('sk_bpunch',partname='bpunch',symmetric=True, ptype='analy')
##	sketch_to_wire('sk_ejector',partname='corepin',symmetric=True, ptype='analy')
##	sketch_to_wire('sk_die',partname='die',symmetric=True, ptype='analy')


##	raise Exception

	new_instance(powder)
	new_instance(tpunch)
	new_instance(bpunch)
	new_instance(die)
	new_instance(corepin)

	set_mat(powder,mat='H10pow')


##	raise Exception

	## step
	create_dynamic_explicit_step(restart_interval=15,scale_factor=2000)	;changing
	_m.fieldOutputRequests['F-Output-1'].setValues(variables=ALL, timeInterval=0.01)	; please_check

	divide_loc = 'left-right'	;changing

##	if multi_part == True:
##		copy_part(powder,'powder2')
##		copy_part(powder,'powder3')
##
##		split1 = 11
##		split2 = 8.265
##		bias_cut(powder,y=split1,cut_sides='-y')
##		bias_cut(powder2,y=split1,cut_sides='+y')
##		bias_cut(powder2,y=split2,cut_sides='-y')
##		bias_cut(powder3,y=split2,cut_sides='+y')
##
##		new_instance('powder2')
##		new_instance(powder3)
##
##
##		## mesh powder (top part)
##		## partition top edge of powder
##		if divide_loc == 'top':
##			edges = edge_select(powder,y=MAX)
##			divide_edge(edges[0],xpar=0.7)		;changing
##
##			vertices = vertice_select(powder,x=MAX,y=MIN)  ## 冲头在左上角，所以最佳合并为右下角。
##			ignore_vertices(powder,vertices=vertices)
##
##			edges = edges_at(powder,x=MIN1,y=MAX) + edges_at(powder,y=MIN1,x=MAX)  ## 冲头一侧
##			seed_edges(powder,edges=edges,enum=20)	;changing
##
##			edges = unselect(powder,edges)
##			seed_edges(powder,edges=edges,enum=10)	;changing
##
##		elif divide_loc == 'right':
##			edges = edge_select(powder,x=MAX)
##			divide_edge(edges[0], ypar=0.5)  ;changing
##
##			ignore_vertices(powder,x=MIN,y=MAX)
##
##			edges = edges_at(powder,x=MAX,y=MAX1) + edges_at(powder,x=MAX1,y=MIN)
##			seed_edges(powder,edges=edges,enum=20)   ## fine mesh
##
##			edges = unselect(powder,edges)
##			seed_edges(powder,edges=edges, enum=30)
##
##	##		raise Exception
##	##
##	##		edges = edge_select(powder,y=MIN1)
##	##		seed_edges(powder,edges=edges, enum=10)
##	##
##	##		edges = unselect(powder,edges)
##	##		seed_edges(powder,edges=edges,enum=40)
##
##		set_element_shape(powder, eshape=QUAD, technique=STRUCTURED)
##
##		mesh_region(powder)
##
##	##	raise Exception
##		if orphan == True:
##			create_mesh_part(powder)	;changing
##			new_instance(powder)
##
##
##		## mesh powder2 (mid part)  ## 横竖结构网格
##		vertices = vertice_select(powder2,x=(MIN1,MAX1),y=(MIN,MAX1))
##		ignore_vertices(powder2,vertices=vertices)
##
##		set_element_shape(powder2, eshape=QUAD, technique=STRUCTURED)
##
##		edges = edge_select(powder2,x=MID)
##		seed_edges(powder2,edges=edges,enum=20)
##
##		edges = unselect(powder2, edges)
##		seed_edges(powder2,edges=edges, enum=10)
##
##		mesh_region(powder2)
##
##	##	create_mesh_part(powder2)
##	##	new_instance(powder)
##
##		## mesh powder3  (bot part) ## 横竖结构网格
##		vertices = vertice_select(powder3,x=(MIN1,MAX1),y=(MIN,MAX1))
##		ignore_vertices(powder3,vertices=vertices)
##
##		set_element_shape(powder3, eshape=QUAD, technique=STRUCTURED)
##
##		edges = edge_select(powder3,x=MID)
##		seed_edges(powder3,edges=edges,enum=30)
##
##		edges = unselect(powder3, edges)
##		seed_edges(powder3,edges=edges, enum=30)
##
##		mesh_region(powder3)
##
##	##	create_mesh_part(powder3)
##	##	new_instance(powder)

	if multi_part == False:
		y1 = _ymax(powder) - 6
		y2 = _ymax(bpunch,x=MIN)

		divide(powder,y=y1)
		divide(powder,y=y2)

		if divide_loc == 'left-right':
			edges = edges_at(powder,x=MIN,y=MAX1)
			divide_edge(edges, ypar=0.7)
			ignore_vertices(powder,x=MIN,y=MAX)

			edges = edges_at(powder,x=MAX,y=MAX1)
			divide_edge(edges, ypar=0.7)
			ignore_vertices(powder,x=MAX,y=MAX)

			edges = edge_select(powder,y=(y1,MAX),x=MID)
			seed_edges(powder, edges=edges, enum=50)

			edges = edge_select(powder, y=y1 + 0.1)
			seed_edges(powder, edges=edges, enum=10)

			## bottom combine
			vertices = vertice_select(powder,x=(MIN1,_xmin(bpunch) - 0.001),y=(MIN,y2 - 0.1))
			ignore_vertices(powder,vertices=vertices)

			edges = edges_at(powder,x=MIN1,groupY=MIN)
			seed_edges(powder,edges=edges, enum=20)

			set_element_shape(powder, eshape=QUAD, technique=STRUCTURED)
			mesh_region(powder)

##		raise Exception

	changing
	control = adaptive_mesh_control(predictor='previous', curvature=0.05, weight=(1,0,0), order='first')
	apply_adaptive_mesh(insts=inst_names_with('powder'),frequence=1,sweep=2, controls=control)

##	apply_adaptive_mesh(elements=powder_A1.elements)
##	apply_adaptive_mesh(elements=powder2_A1.elements)
##	apply_adaptive_mesh(elements=powder3_A1.elements)

##	raise Exception

	## merge vertices for tpunch
##	vertices = vertice_select(tpunch,x=(MIN1,MAX1))
	vertices = vertice_select(tpunch,x=(MIN,MAX1),y=(MIN1,MAX))
	ignore_vertices(tpunch,vertices=vertices)

	vertices = vertice_select(bpunch,y=MIN) + vertice_select(bpunch,x=MAX)
	vertices = unselect(bpunch,vertices)
	ignore_vertices(bpunch,vertices=vertices)

	vertices = vertice_select(corepin,x=(MIN1,MAX1))
	ignore_vertices(corepin,vertices=vertices)

##	raise Exception

	surf_tpunch = create_surface('surf_tpunch',edges=_inst(tpunch_A1).edges, side_num=1)
	surf_bpunch = create_surface('surf_bpunch',edges=_inst(bpunch_A1).edges, side_num=1)
	surf_die = create_surface('surf_die',edges=_inst(die_A1).edges, side_num=1)
	surf_corepin = create_surface('surf_corepin',edges=_inst(corepin_A1).edges, side_num=1)

	## mesh rigids
	for part in [tpunch,die,bpunch,corepin]:
		mesh_region(part,esize=0.1)

	## load and BC
	apply_gravity(Gy=-9800)

	for part in [die,bpunch,tpunch,corepin]:
		create_RP(part,loc=_part(part).vertices[1].pointOn[0])

	apply_disp_fix(name='RP_fix1',referencePoints=die_A1,fix_all=True)
	apply_disp_fix(name='RP_fix2',referencePoints=bpunch_A1,fix_all=True)
	apply_disp_fix(name='RP_fix3',referencePoints=corepin_A1,fix_all=True)
	apply_disp_fix(name='RP_fix4',referencePoints=tpunch_A1,Ux=0,UR3=0)


	_m.TabularAmplitude(name='top_move', timeSpan=STEP,
	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, -1), (0.50, -5),  (1.0, -10)))

	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1')

	## nodal surfaces
	nodes = node_select(powder_A1,y=MAX) + node_select(powder_A1,x=MIN,poiRefY=(MAX,-2.0))	;changing
	powder_tpunch = create_nodal_surface(powder_A1,nodes=nodes,name='powder_tpunch')

	nodes = node_select(powder_A1,poiRefX=(MAX,-1.0)) + node_select(powder_A1,y=MAX,poiRefX=(MAX,-3.0))	;changing
	powder_die = create_nodal_surface(powder_A1,nodes=nodes,name='powder_die')

	loc3 = find_loc(corepin, x=_xmin(bpunch) - 1.5)
	nodes = node_select(powder_A1, x=(loc3[0], MAX), y=(loc3[1], _ymax(bpunch) + 2.0))
	powder_bpunch = create_nodal_surface(powder_A1,nodes=nodes,name='powder_bpunch')

	nodes = node_select(powder_A1, y=(MIN, _ymax(corepin) + 2))
	powder_corepin = create_nodal_surface(powder_A1, nodes=nodes, name='powder_corepin')

##	raise Exception

##	if multi_part == True:
##		nodes = node_select(powder_A1,y=MIN)
##		powder_bot = create_nodal_surface(powder_A1,nodes=nodes,name='powder_bot')
##
##		nodes = node_select(powder2_A1,y=MAX)
##		powder2_top = create_nodal_surface(powder2_A1,nodes=nodes,name='powder2_top')
##
##		nodes = node_select(powder2_A1,x=MAX) + node_select(powder2_A1, poiRefX=(MAX,-0.5),y=(MIN,MAX1))
##		powder2_right = create_nodal_surface(powder2_A1,nodes=nodes,name='powder2_right')
##
##		nodes = node_select(powder2_A1,x=MAX,groupY=MIN)   ## corner
##		y1 = nodes[0].coordinates[1]
##
##		nodes = node_select(powder2_A1, y=MIN, groupX=MAX)
##		x1 = nodes[0].coordinates[0]
##
##		nodes = node_select(powder2_A1, x=(x1, MAX), y=(MIN,y1 + 0.5))
##		powder2_bpunch = create_nodal_surface(powder2_A1, nodes=nodes, name='powder2_bpunch')
##
##		nodes = node_select(powder2_A1, y=MIN)
##		powder2_bot = create_nodal_surface(powder2_A1, nodes=nodes, name='powder2_bot')
##
##		nodes = node_select(powder3_A1, y=MAX)
##		powder3_top = create_nodal_surface(powder3_A1, nodes=nodes, name='powder3_top')
##
##		nodes = node_select(powder3_A1,x=MAX) + node_select(powder3_A1,poiRefX=(MAX,-2.5),y=(MIN,MAX1))
##		powder3_right = create_nodal_surface(powder3_A1, nodes=nodes, name='powder3_right')
##
##		edges = edge_select(powder3_A1,x=MID,y=(MIN,MID))
##		nodes = edges_to_nodes(edges)
##		powder3_bot = create_nodal_surface(powder3_A1, nodes=nodes,name='powder3_bot')

	## interact
	s2s_interact_explicit('powder_tpunch',mfaces=surf_tpunch, sfaces=powder_tpunch)
	s2s_interact_explicit('powder_die',mfaces=surf_die, sfaces=powder_die)

##	s2s_contact_std('tie', name='powder1_powder2',mfaces=powder2_top, sfaces=powder_bot)

##	s2s_interact_explicit('die_powder2',mfaces=surf_die, sfaces=powder2_right)
	s2s_interact_explicit('powder_bpunch',mfaces=surf_bpunch, sfaces=powder_bpunch)
##	s2s_interact_explicit('powder2_powder3',mfaces=powder3_top, sfaces=powder2_bot)
##	s2s_contact_std('tie', name='powder2_powder3',mfaces=powder3_top, sfaces=powder2_bot)

##	s2s_interact_explicit('bpunch_powder3',mfaces=surf_bpunch, sfaces=powder3_right)
	s2s_interact_explicit('powder_corepin',mfaces=surf_corepin, sfaces=powder_corepin)


##	raise Exception

	create_inp(inp_file_title,request_num=4) ;please_check
	mdb.jobs[inp_file_title].submit()

	return

def main_A0227_wiredraw_919():
	## VER: 2014-09-24, v1.0

	check_script_file('B5_A0227_wiredraw_width05_60_R3.py')
	history='AF:change mesh and wire material property; A9:elastic nib; A6:general contact; A1:based on BG_A0224'

	nib_type = 'D6H7'		;changing
	imported1 = False

	dx = 'dx'
	dy = 'dy'

		## 5. nib cut
##		## option1, new design
##	cut_height = 1.09
##	cut_angle_y = 15
##	cut_width = cut_height*tanD(cut_angle_y)
##	cut_round = 5.65

		## option2, old design
##	cut_height = 0.5
##	cut_width = 0.5
##	cut_angle_y = 45
##	cut_round = 0

	##	optionA
##	cut_width = 0.3
##	cut_angle_y = 45
##	cut_height = cut_width*tanD(cut_angle_y)
##	cut_round = 0.5

		## optionB
	cut_width = 0.5
	cut_angle_y = 60
	cut_round = 3
	cut_height = cut_width*tanD(cut_angle_y)

	if imported1:
		open_cae('_A0226_imported_12X10nib',new_name=inp_file_title)

		edges = edge_select('nib0',x=(MID,MAX),z=MAX)
		sketch = edges_to_sketch(edges,sketchname='sk_nib')
		s1 = sketch['sketch']

		if cut_angle_y == 45:
			loc1 = find_loc(s1,x=MAX,groupY=MIN)
			loc2 = find_loc(s1,y=MIN,groupX=MAX)

			edges = geometry_select(s1,x=(loc1[0],loc2[0]),y=(loc1[1],loc2[1]))
			del_geometry(s1,edges)
			connect_points(s1,loc2,('x',_xmax(s1)),loc1)

			sketch_to_shell(s1,partname='nib',symmetric=True)
			bias_cut('nib',cut_sides='bot_right',point1=(_xmax('nib'),_ymin('nib') + cut_height),angle_with_Y=cut_angle_y)

		else:
			sketch_to_shell(s1,partname='nib',symmetric=True)

		edges = edge_select('case0',x=(MID,MAX),z=MAX)
		sketch = edges_to_sketch(edges,sketchname='sk_case')
		s1 = sketch['sketch']
		sketch_to_shell(s1,partname='case',symmetric=True)

		new_instance('nib')
		new_instance('case')

##	raise Exception

	locals0 = locals().keys()   ## need both stp file and assembly file with bearing dimensions.
	## for D12H10 nib, the bearing diameter=0.8mm, then wire diameter= 0,889
	## for D9H6 nib, the bearing diameter=0.1mm, then wire diameter=0,111
	## bell->approach -> reduction -> bearing -> relief->exit

	if nib_type == 'D9H6':
		nib_OD = 9
		nib_H = 6
		nib_R = nib_OD/2

		case_H = 14
		case_OD = 28   ## case type: 28x14
		case_R = case_OD/2.0
		interference = 0.03		;changing1   ## 9*6 nib: 20-40um, 12*10 nib: 40-60um

		## partial reduction
		reduction_angle = 11
		reduction = 0.2
		joint_to_reduction_top = 0.388  ## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。

		## 1. bearing (首先要确定的参数)
		bearing_D = 0.1
		joint_D = 0.09   ## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
		bearing_mid_to_bot = 1.947   ## 一般取2   bearing mid to bot
		bearing_R = bearing_D/2
		bearing_length = bearing_D*0.35   ## 这是规律
		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)
		nib_thick = nib_R - bearing_D/2		;please_check

		## 2. relief
		relief_dy = bearing_length	## 这是规律
		relief_angle = 27

		## 3. exit
		exit_dy = bearing_mid_to_bot - 1.5*bearing_length
		exit_angle = 90

		## 4. reduction
	##	reduction_angle = 11
	##	reduction = 0.2
		reduction_dy = joint_to_reduction_top - joint_to_bearing_top
		wire_D = joint_D/(1-reduction)	## 这是规律, 是直径的缩减率，不是面积的缩减率。  (根据joint_D可以知道wire_D，所以提供stp文件给客户即可)
		wire_R = wire_D/2.0

		## 5. approach
		approach_angle = 35
		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy
		## 不需要知道approach_H，因为会倒圆角bell_R

		## 6. bell (round)
		bell_R = 2

		## nib corner cut
		cut_angle_y = 45	  			;changing
		if cut_angle_y == 15:
			cut_height = 1.0  ## nib
			cut_round = 5.65
		else:
			cut_height = 0.5
			cut_round = 0

		## case file: 75-E-464-31-P010
		case_ID = nib_OD - interference*2	;changing  ## use shrink fit, not initial_closure

		case_entrance_cut = 1.5
		case_entrance_cut_angle = 30

		rivet_H = 0.5
		rivet_ID = 8
		rivet_L = (nib_OD - rivet_ID)/2.0
		rivet_R = rivet_ID/2
		rivet_offset = 0.004 	;changing1	## offset in height, rivet与nib之间的间隙，考虑shrink fit后会消除。

		nib_to_top = 3.0
		nib_bot_to_bot = case_H - nib_to_top - nib_H

		case_land_H = 0.5   ## 0.3-0.5
		case_land_ID = 4.5   ## different for another drawing(3.5)
		land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.

		case_exit_H = nib_bot_to_bot - case_land_H
		case_exit_angle = 60

		case_corner_chamfer = 1.0

	elif nib_type == 'D12H10': ## 75-E-464-32-P080
		nib_OD = 12
		nib_H = 10
		nib_R = nib_OD/2

		## partial reduction
		reduction_angle = 11   ## so, wire_D = bearing_D*1.11
		reduction = 0.2
##		joint_to_reduction_top = 0.388  ## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。

		## 1. bearing (首先要确定的参数)
		bearing_D = 0.8
		bearing_R = bearing_D/2
		bearing_length = 0.28
##		joint_D = 0.09   ## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
##		bearing_mid_to_bot = 1.947   ## 一般取2   bering mid to bot
##		bearing_length = bearing_D*0.35   ## 这是规律
##		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)
##		nib_thick = nib_R - bearing_D/2		;please_check

		## 2. relief
		relief_dy = bearing_length	## 这是规律
		relief_angle = 27

		## 3. exit
##		exit_dy = bearing_mid_to_bot - 1.5*bearing_length
		exit_angle = 90

		## 4. reduction
	##	reduction_angle = 11
	##	reduction = 0.2
##		reduction_dy = joint_to_reduction_top - joint_to_bearing_top
##		wire_D = joint_D/(1-reduction)	## 这是规律, 是直径的缩减率，不是面积的缩减率。  (根据joint_D可以知道wire_D，所以提供stp文件给客户即可)
		wire_D = 0.889
		wire_R = wire_D/2.0

		## 5. approach
		approach_angle = 40
##		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy
		## 不需要知道approach_H，因为会倒圆角bell_R
		approach_reduction_round = 1.0

		## 6. bell (round)
		bell_R = 2.3

		## nib corner cut
		cut_angle_y = 45	  			;changing
		if cut_angle_y == 15:
			cut_height = 1.0  ## nib
			cut_round = 5.65
		else:
			cut_height = 0.5
			cut_round = 0

		## case file: 75-E-464-31-P010
		case_OD = 28   ## case type: 28x14
		case_H = 14
		case_R = case_OD/2.0

		interference = 0.03		;changing1   ## 9*6 nib: 20-40um, 12*10 nib: 40-60um
		case_ID = nib_OD - interference*2	;changing  ## use shrink fit, not initial_closure

		case_entrance_cut = 1.5
		case_entrance_cut_angle = 30

		rivet_H = 0.5
		rivet_ID = 8
		rivet_L = (nib_OD - rivet_ID)/2.0
		rivet_R = rivet_ID/2
		rivet_offset = 0.004 	;changing1	## offset in height, rivet与nib之间的间隙，考虑shrink fit后会消除。

		nib_to_top = 0.7
		nib_bot_to_bot = case_H - nib_to_top - nib_H

		case_land_H = 0.5   ## 0.3-0.5
		case_land_ID = 6.5   ## different for another drawing(3.5)
		land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.

		case_exit_H = nib_bot_to_bot - case_land_H
		case_exit_angle = 60

		case_corner_chamfer = 1.0

	elif nib_type == 'D6H7': ## job#: A0227
		nib_OD = 6   ## nib type = D6H7
		nib_H = 7
		nib_R = nib_OD/2

		case_H = 14
		case_OD = 28   ## case type: 28x14
		case_R = case_OD/2
		interference = 0.04		;changing1

		## profile angles
		approach_angle = None	;please_check
		reduction_angle = 11
		relief_angle = 27		;please_check
		exit_angle = 60
		joint_D = 0.3 		## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
		bearing_D = None
		reduction = 0.2

		## 1. bearing and relief (首先要确定的参数)
		nib_info = get_nib_bearing(joint_D=joint_D, bearing_D=bearing_D, angles=(reduction_angle, exit_angle))
		bearing_D = nib_info['BD']
		bearing_length = nib_info['BH']
		relief_dy = nib_info['RH']
		joint_D = nib_info['JD']

		bearing_R = bearing_D/2
##		nib_thick = nib_R - bearing_R		;please_check

		## VA: reduction top, connecting with approach
		## VB: reduction bot, connecting bearing
		bot_to_joint = 2
		joint_to_VA = 2
		bot_to_VA = bot_to_joint + joint_to_VA
		top_to_VA = nib_H - bot_to_VA

		reduction_dy = joint_to_VA - bearing_length - nib_info['y1']
		top_to_VB = reduction_dy + top_to_VA

		exit_dy = bot_to_joint - nib_info['y2']
##		approach_dy = nib_H - bot_to_joint - joint_to_VA   ## approach与reduction之间的连接点不能倒角。

##		bearing_mid_to_bot = 2	## 一般取2   bearing mid to bot

##		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)

		## 2. exit
##		exit_dy = bearing_mid_to_bot - 1.5*bearing_length

		## 3. reduction
##		joint_to_reduction_top = 2		## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。
##		reduction_dy = joint_to_reduction_top - joint_to_bearing_top
##		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy

		wire_D = joint_D/(1-reduction)	## 这是规律, 是直径的缩减率，不是面积的缩减率。  (根据joint_D可以知道wire_D，所以提供stp文件给客户即可)
		wire_R = wire_D/2.0

		## 不需要知道approach_H，因为会倒圆角bell_R

		## 4. bell (round)
		bell_R = 5	## origin: 5
		bell_round = 1.5  ## round radius
		bell_center_to_top = 3.479
		bell_center_to_bot = nib_H - bell_center_to_top

##		## 5. nib cut
####		## option1
##		cut_height = 1.09
##		cut_angle_y = 15
##		cut_width = cut_height*tanD(cut_angle_y)
##		cut_round = 5.65
##
##		## option2
####		cut_height = 0.5
####		cut_width = 0.5
####		cut_angle_y = 45
####		cut_round = 0
##
####		cut_option = 'B'	;changing
######		## option3
####		if cut_option == 'A':
####			cut_width = 0.3
####			cut_angle_y = 45
####			cut_height = cut_width*tanD(cut_angle_y)
####			cut_round = 0.5
####
####		## option4
####		if cut_option == 'B':
####			cut_width = 0.3
####			cut_angle_y = 60
####			cut_height = cut_width*tanD(cut_angle_y)
####			cut_round = 2

		## case file: assembly_WDBDRHS2000213.pdf
		nib_to_top = 3.0
		nib_bot_to_bot = case_H - nib_to_top - nib_H
		case_land_H = 0.3
		case_ID = nib_OD - interference*2	;changing   ## interference fit
		case_exit_H = nib_bot_to_bot - case_land_H
		case_exit_angle = 60
		case_land_ID = 3.0   ## different for another drawing(3.5)
		case_entrance_cut = 1.0       ## refer to case_WDBDRHS20002M
		case_entrance_cut_angle = 30  ## refer to case_WDBDRHS20002M
		land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.
		case_corner_chamfer = 0.5

		rivet_H = 0.5
		rivet_L = 0.55
		rivet_offset = 0.005 ## offset in height (5um)

		esize = 0.02				;changing
		friction = 0.01 			;changing
		cut_angle_y = 15	  			;changing
		draw_time = 1.5e-4  		;changing

	friction = 0.01 			;changing
	draw_time = 2.0e-4  		;changing

	## wire
	wire_length = 10		;changing1
	wire_cut_H = 1
	speed = -16*1000		;changing1
	wire_cut_x=0.1
	wire_cut_y = 0.2

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'
	wire = 'wire'
	wire_A1 = 'wire_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception
	material_database()
	create_contact_props(friction=friction)					;please_check('default=0.15')

	## wire elastic
	wire_plastic = (275,0), (690, 0.2), (960, 0.4), (1206, 0.6), (1654, 1), (2240, 1.6)  ## hardening steel
##	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
	set_plastic('Steel', wire_plastic)	;changing
##	set_plastic('Steel', (500, 0))	;changing

	set_plastic('H3F',(5000,0))		;changing1

	if imported1 == False:
		## Nib
		s1 = create_base_sketch('sk_nib')
		loc0 = (bearing_R,0)
		loc1 = loc0

		if relief_dy > 0:
			connect_points(s1,loc0,ytilt(-relief_dy,relief_angle/2))
			loc1 = last_point
		connect_points(s1,loc1,ytilt(-exit_dy,exit_angle/2),('x',nib_R),(dy,nib_H))

		if bearing_length > 0:
			connect_points(s1,loc0,(dy,bearing_length))
			loc1 = last_point

		if approach_angle not in empty:  ## there is approach slope line
			locs = connect_points(s1,loc1,ytilt(reduction_dy,reduction_angle/2),ytilt(approach_dy,approach_angle/2),('x',nib_R))
			round_sketch_corner(s1,loc=locs[-2],radius=bell_R)
		else:
			line1 = slope_construction(s1,loc=loc1,angle=90 - reduction_angle/2)
			dict1 = create_tangent_circle(s1,radius=bell_R,center_x=10, center_y=(MAX,-bell_center_to_top),tangent_line=line1, toY=_ymax(s1))
			connect_points(s1,loc1,dict1['start'])
			connect_points(s1,dict1['end'],('x',nib_R))
			round_sketch_corner(s1,loc=dict1['end'],radius=bell_round)

		sketch_to_shell(s1,partname='nib',symmetric=True)

		move_part(nib,y1=MIN,y2=nib_bot_to_bot)
		bias_cut(nib,cut_sides='bot_right',point1=(nib_R,_ymin(nib) + cut_height), point2=(nib_R - cut_width,_ymin(nib)))
		round_corner(nib,x=MAX,groupY=MIN,radius=cut_round)

		edges = edge_select(nib,nx=-1,ny=-1,y=MIN1)
		divide_edge(edges=edges[0],xpar=0.4)

		new_instance(nib)

##		raise Exception

		## case
		s1 = create_base_sketch('sk_case')
		loc0 = (case_land_ID/2,nib_bot_to_bot)	## nib的底面

		connect_points(s1,loc0,(dy,-case_land_H),ytilt(-nib_bot_to_bot + case_land_H, case_exit_angle/2), ('x',case_R),('y',case_H))
		locs = loc0,('x',case_ID/2),('dy',nib_H + rivet_offset),('dx',-rivet_L),('dy',rivet_H),('dx',rivet_L)
		connect_points(s1,points=locs)

		connect_points(s1,last_point,('y',case_H),('x',case_R))

		sketch_to_shell(s1,partname='case',symmetric=True)

		bias_cut(case,cut_sides='bot_right',point1=(case_R,case_corner_chamfer),angle_with_Y=45)
		bias_cut(case,cut_sides='top_right',point1=(case_R,case_H - case_corner_chamfer),angle_with_Y=45)

		loc = find_loc(case,y=MAX,groupX=MIN)
		bias_cut(case,cut_sides='top_left',point1=(loc[0],loc[1] - case_entrance_cut,0),angle_with_Y=case_entrance_cut_angle)

		new_instance(case)

##	divide(case,y=_ymin(nib,x=MAX))

	## wire
	create_rectangle_shell('wire',corner1=(0,0),corner2=(wire_R, wire_length),axis_symmetric = True)
	move_part(wire,y1=MIN,y2=_ymin(nib) + 2)

##	bias_cut(wire, cut_sides='bot_right', point1=(wire_R, _ymin(wire) + 0.2, 0), point2=(wire_R*0.7, _ymin(wire), 0))
	bias_cut(wire,cut_sides=('+x','-y'), point1=(wire_R, _ymin(wire) + wire_cut_H), point2=(wire_R/2,_ymin(wire)))
##	round_corner(wire,radius=5,x=MAX,groupY=MIN)

	vertices = vertice_select(wire,x=MAX,groupY=MIN)
	ignore_vertices(wire,vertices=vertices)

	new_instance(wire)

##	divide(wire,y=_ymin(wire) + wire_cut_H)
	divide(wire,y=_ymin(wire) + wire_cut_H + 0.5)	;changing

	set_mat(nib,mat='H3F')
	set_mat(case,mat='Steel_C45')
	set_mat(wire,mat='Steel')	;changing1

	## step
	times1 = myrange(0,1,0.05)
	timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1

	times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,50, 0.5)
	timepoints2 = create_timepoints(times2,factor=1e-5)

	create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
	create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
##	create_coupled_temp_displacement_step(stepname='draw',timePeriod=draw_time)
	field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

##	raise Exception

	## create surfaces
	edges = edge_select(case_A1,ny=1,groupY=MIN)
	create_surface('case_land',edges=edges)

	please_check
	edges = edge_select('case_A1',nx=-1,x=(MIN1,MAX),y=_yspace('nib'))
	create_surface('case_ID',edges=edges)

	please_check
	edges1 = edge_select(nib_A1,nx=1)  ## use for general contact
##	edges1 = edge_select(nib_A1,x=MAX,y=MID)
	create_surface('nib_OD',edges=edges1)

	edges = edge_select(nib_A1,nx=1,ny=-1)
##	edges = unselect(edges, edges1)
	create_surface('nib_corner', edges=edges)

	edges = edge_select(case_A1,x=case_ID/2,y=_ymin(nib,x=MAX) - 0.1)
	create_surface('case_corner',edges=edges)

	edges = edge_select(nib_A1,y=MIN)
	create_surface('nib_bot', edges=edges)

	edges3s = edge_select(wire_A1,nx=1)
	create_surface('wire_surf',edges=edges3s)

	vertices = vertice_select(nib_A1,x=MIN)
	edges3m = vertices_to_edges(vertices)
	create_surface('nib_surf',edges=edges3m)

	edges1 = edge_select(nib_A1,y=MAX)
	create_surface('nib_top',edges=edges1)

##	edges2 = edge_select(case_A1,y=_ymax(nib_A1) + rivet_offset)
##	create_surface('rivet_bot',edges=edges2)

	get_current_model()

##	raise Exception

	## mesh case
	edges = edge_select(case,x=(MIN,case_ID/2.0 + 0.1),y=(MIN1,MAX1))
	seed_edges(case,edges=edges,esize=0.15)	;changing

	mesh_2D(case,esize=0.5)		;changing

	## mesh nib
##	esize = 0.02	;changing
##	edges = edge_select(nib,nx=-1,y=(MIN,MID))

	esize = round(min(bearing_length/3,0.05),3)
##	edges = edge_select(nib,x=(MIN,MIN1))
	edges = edge_select(nib,poiRefX=(MIN,wire_R))
	seed_edges(nib,edges=edges, esize=esize)			;changing

##	edges = edge_select(nib,x=MIN)
##	seed_edges(nib,edges=edges, enum=4)		;changing1

##	edges = edge_select(nib,nx=1)
##	seed_edges(nib,edges=edges,esize=0.1)

	mesh_2D(nib,esize=0.15)	;changing

	## mesh wire
	check1()
	edges = edge_select(wire,y=MAX) + edge_select(wire,y=MIN)
	seed_edges(wire,edges=edges,enum=12)	;changing ## enum

	mesh_2D(wire,esize=esize)

	raise Exception

##	times1 = myrange(0,1,0.05)
##	timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1
##
##	times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,50, 0.5)
##	timepoints2 = create_timepoints(times2,factor=1e-5)

	## steps implicit way
	solver = 'implicit'		;changing
	if solver == 'implicit':
		## 以下适用于已经存在过盈
		create_general_contact_std(friction=0.01,interference_pairs=(('nib_OD','case_ID','interfernce_fit')))

##		create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
##
##		create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
##		field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

##		create_general_contact_std(pairs=[('nib_OD','case_ID'),('nib_bot','case_land'),('nib_top','rivet'),('nib_surf','wire_surf')],
##		interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))

		## contact
##		create_general_contact_std(interference_pairs=('nib_OD','case_ID','interference_fit',interference), property_pairs=('nib_surf','wire_surf',friction))
##		create_general_contact_std(property_pairs=('nib_surf','wire_surf',friction))

##		raise Exception

##		if imported == False:
##			s2s_interact_std('int_nib_support', mfaces='nib_bot', sfaces='case_land')
##			s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',overclosure='shrink_fit')
##	##		s2s_interact_std('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',initial_clearance=-0.04)
##
##			s2s_interact_std('int_nib_rivet', mfaces='nib_top', sfaces='rivet_bot')
##	##
##			s2s_interact_std('int_nib_corner',mfaces='nib_corner',sfaces='case_corner',overclosure='shrink_fit')  ## 在有初始过盈的情况下，必须设置shrink fit,否则一开始由于侵入，不收敛。
##			s2s_interact_std('int_nib_corner2',mfaces='nib_corner',sfaces='case_land')
##
##			s2s_interact_std('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',friction=friction,step='step2')
##
##		else:
##			create_general_contact_std(friction=0.01,interference_pairs=(('nib_OD','case_ID','interfernce_fit')))

##		raise Exception

		## Fix
		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		edges = edge_select(wire_A1,y=MAX)
		apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0,deactive_step='step2')

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
##		faces = _inst(wire_A1).faces
		apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing

	_results_dict = { 'Nib':('S1','PEEQ'), 'CASE':('U','Mises','PEEQ')}
##	raise Exception
	create_inp(inp_file_title,request_num=6,submit=False)

	return

def main_A0229_HPHT_crack():
	## VER: 2014-11-11, v1.0

	check_script_file('AK_A0229_HPHT_anvil_crack_A_50mm.py')
	history = 'A6:merge and divide; A1: model'
	blank_cae(inp_file_title)

	locals0 = locals().keys()

	requestor = 'Stefan'
	purpose = 'check the existed crack effect in the compound anvil, is it still safe?'
	top_mat = 'DM80'
	bot_mat = 'H10F'  ;changing1

	blank_D = 160
	blank_R = blank_D/2.0
	total_H = 115
	blank_H = 2.125*inch
	blank_hold = 15		;changing1
	anvil_joint = 2		;changing1

	land_taper_angle = 41.3
	land_taper_length = 15
	land_taper_depth = land_taper_length*sinD(land_taper_angle)
	taper_angle2 = 46
	land_width = 49

	crack_length = 50		;changing
	crack_depth = 10		;changing
	crack_thick = 10e-3		;changing1

	position = 'A'			;changing
	full_model = True
	bonding_temperature = 900
	work_temperature = 350
	pressure = 8500	;changing1

	anvil = 'anvil'
	blank = 'blank'
	crack = 'crack'
	anvil_A1 = 'anvil_A1'
	blank_A1 = 'blank_A1'

	locals2globals(locals0,locals())

	material_database()
	create_contact_props(friction=0.1)					;please_check('default=0.15')

	blank_part('anvil')
	cylinder_grow('anvil','y',OD=blank_D,L=total_H)

	bias_cut(anvil,cut_sides='-x',x=MID)
	bias_cut(anvil,cut_sides='+z',z=MID)

	bias_cut(anvil,cut_sides=['+x','+y'], pass_point1 = (land_width/2, total_H,0), angle_with_Y=90 - land_taper_angle)
	bias_cut(anvil,cut_sides=['-z','+y'], pass_point1 = (0, total_H,-land_width/2), angle_with_Y=90 - land_taper_angle)

	divide(anvil,y=total_H - land_taper_depth)
	divide(anvil,y=blank_H)

	vertices = vertice_select(anvil,x=(MIN1,MAX1),z=0,y=(MIN1,MAX1))
	bias_cut(anvil,cut_sides=['+x','+y'], pass_point1 =vertices[0] , angle_with_Y=90 - taper_angle2)

	vertices = vertice_select(anvil,y=(MIN1,MAX1),x=0,z=(MIN1,MAX1))
	bias_cut(anvil,cut_sides=['-z','+y'], pass_point1 = vertices[0], angle_with_Y=90 - taper_angle2)

	if full_model == True:
		copy_part('anvil','anvil2',mirror_x=0)
		copy_part('anvil','anvil3',mirror_z=0)
		copy_part('anvil2','anvil4',mirror_z=0)

		new_instance('anvil')
		new_instance('anvil2')
		new_instance('anvil3')
		new_instance('anvil4')

		merge_instances(partname='anvil',insts=('anvil_A1','anvil2_A1','anvil3_A1','anvil4_A1'),boundary='merge')
		new_instance('anvil')

		divide(anvil,x=0)
		divide(anvil,z=0)

		del_parts('anvil2','anvil3','anvil4')

##	raise Exception

	copy_part(anvil,'blank')
	bias_cut(blank,y=blank_H,cut_sides='+y')
	bias_cut(anvil,y=blank_H,cut_sides='-y')
	new_instance(blank)
	divide(blank,y=blank_hold)

	set_mat(anvil,mat=top_mat)
	set_mat(blank,mat=bot_mat)

	## fan crack
	s1 = create_base_sketch('sk_crack')
	angle = crack_length/(pi*blank_D)*360
	mid_angle = 0
	alpha1 = mid_angle - angle/2.0
	alpha2 = mid_angle + angle/2.0

	point1 = (blank_R*cosD(alpha1),blank_R*sinD(alpha1))
	point2 = (blank_R*cosD(alpha2),blank_R*sinD(alpha2))

	create_arc(s1, (0,0),point1=point1,point2=point2,direction=COUNTERCLOCKWISE)
	connect_points(s1,point1,(0,0))
	connect_points(s1,point2,(0,0))

	extrude_sketch_to_part('crack',sketch=s1,length=crack_thick)
	radial_cut('crack',ndir='z',R1=0,R2=blank_R - crack_depth)

	rotate_part(crack,angle_x = 90)
	new_instance(crack)

	faces = face_select(crack,radius=blank_R - crack_depth)
	edges = edge_select(crack,faces=faces,edir='y')
	chamfer_edges(crack,edges=edges,length=crack_depth)		;changing1

	if position == 'A':
		rotate_instances(insts='crack_A1',angle_y=-45)
	elif position == 'B':
		rotate_instances(insts='crack_A1',angle_y=-90)

	move_instances('crack_A1',y1=MIN,y2=_ymin('anvil_A1'))
	boolean_cut('anvil_A1',cutters='crack_A1',del_cutters=True)
	new_instance(anvil)
	divide(anvil,y=_ymin(anvil) + anvil_joint)
	divide(anvil,y=_ymin(anvil) + 2*anvil_joint)
	divide(blank,y=_ymax(blank) - anvil_joint)

	del_parts('crack')

	cells = cell_select(anvil,z=(MID,MIN))
	create_set(anvil,name='anvil_back',cells=cells)

	cells = cell_select(anvil,x=(MID,MIN))
	create_set(anvil,name='anvil_left',cells=cells)

	cells = cell_select(blank,z=(MID,MIN))
	create_set(blank,name='blank_back',cells=cells)

	cells = cell_select(blank,x=(MID,MIN))
	create_set(blank,name='blank_left',cells=cells)

	faces = face_select(anvil_A1,ny=-1)
	create_surface(name='anvil_bot',faces=faces)

	faces = face_select(anvil_A1,y=_ymin(anvil_A1) + crack_thick, ny=-1)
	create_surface(name='crack_surf',faces=faces)

	raise Exception

	## step
	create_general_static_step(stepname='heating',initial_inc=0.002,restart=True)	 ;please_check
	create_general_static_step(stepname='bond',initial_inc=0.002)
	create_general_static_step(stepname='cool_down',initial_inc=0.002)
	create_general_static_step(stepname='pressing',initial_inc=0.002)

##	field_output_request(variables=ALL)
	field_output_request()
##	raise Exception

	## mesh
	faces = face_select(anvil,radius=blank_R)
	edges = edge_select(anvil,faces=faces,y=_ymin(anvil) + anvil_joint + 0.1)
	seed_edges(anvil,edges=edges,esize=2)

	edges = edge_select(anvil,y=_ymin(anvil) + crack_thick)
	seed_edges(anvil,edges=edges,esize=2)	;changing1

	mesh_region(anvil,esize=4)

##	raise Exception

	cells = get_unmeshed_region(anvil)
	if cells not in empty:
		set_element_shape(anvil,cells=cells,eshape='TET')
		choose_element_type(anvil,cells=cells,order=1)		;changing1
		mesh_region(anvil,cells=cells)

	edges = edge_select(blank,y=MAX,shape='line')
	seed_edges(blank,edges=edges,esize=2)
	mesh_region(blank,esize=5)

##	raise Exception


##	raise Exception
##	odb_title1 = script_file_full[:-3] + '_prefield'
##	create_inp(odb_title1,restart=True) ;please_check
##	mdb.jobs[odb_title1].submit()
##
####	raise Exception
##
##	mdb.jobs[odb_title1].waitForCompletion()
##
##	odb_title2 = script_file_full[:-3] + '_restart'
##	copy_model(to_name='restart',new_from_name='prefield')
##	clear_model_settings()
##	import_initial_state(odb_title1)


	## interaction
##	create_general_contact_std()   ## always created in initial step
	s2s_contact_std('interact',mfaces='crack_surf',sfaces=ymax_faces(blank_A1),step='step3')
	s2s_contact_std('interact',mfaces=ymin_faces(anvil_A1),sfaces=ymax_faces(blank_A1),prop='tie',step='step2')
##	s2s_tie(mfaces=ymin_faces(anvil_A1),sfaces=ymax_faces(blank_A1))

	## load and BC
	set_temperature_predefined_field(initial_step=20,modifys=[('step1',bonding_temperature),('step3',work_temperature)])
	apply_disp_fix('fix_bond',faces=faces_of_insts(y=_ymin(anvil_A1)),stepname='step1',deactive_step='step2',Uy=0,UR1=0,UR2=0,UR3=0)

##	if full_model == True:
##		vertices = vertice_select(anvil_A1,y=MIN,x=0,z=0)
##		apply_disp_fix('point_fix_top',vertices=vertices, Ux=0,Uz=0,deactive_step='step2')
##
##		vertices = vertice_select(blank_A1,y=MAX,x=0,z=0)
##		apply_disp_fix('point_fix_bot',vertices=vertices, Ux=0,Uz=0,deactive_step='step2')

##	edges = edge_select(anvil_A1,x=0,z=0,edir='y') + edge_select(blank_A1,x=0,z=0,edir='y')
##	apply_disp_fix('fix_center',edges=edges, Ux=0,Uz=0,step='step1',deactive_step='step4')

	nodes = node_select(anvil_A1,x=0,z=0,exterior=False) + node_select(blank_A1,x=0,z=0,y=(MIN1,MAX),exterior=False)
	apply_disp_fix('fix_center',nodes=nodes, Ux=0,Uz=0,step='step1',deactive_step='step4')

	## loading and BC
	csys1 = create_cylind_csys('cylind_CSYS_1',origin=(0,0,0),ndir='y')

	faces = face_select(blank_A1,y=MIN1,radius=blank_R)
	apply_disp_fix('fix_bot',faces=ymin_faces(blank_A1),U3=0,step='step2',local_csys=csys1)

	apply_disp_fix('fix_radius',faces=faces,U1=0,local_csys=csys1,step='step4')

##	raise Exception

##	faces = face_select(blank_A1,y=MIN1)
##	apply_disp_fix('blank_hold',faces=faces,Ux=0,Uz=0)

##	vertices = vertice_select(blank_A1,y=MIN,x=0,z=0)
##	apply_disp_fix('point_fix_bot',vertices=vertices, Ux=0,Uz=0)

##	set_temperature_predefined_field(initial_step=bonding_temperature,modifys=[('step2',work_temperature)])

	y1 = ylocs(anvil,pointOn=False)[-2]
	y2 = total_H
##	p = (y-y1)/(y2-y1)*pressure
	expression = '(y - ' + str(y1) + ')' + '/' + str(y2-y1) + '*' + str(pressure)
	express = create_expression(expression)

##	faces = face_select(anvil_A1,y=(MAX,MAX1),include_ends=True)
##	apply_pressure('load_top',faces=faces,MPa=pressure,create_step='step3')	;please_check
	faces = face_select(anvil_A1,y=MAX1)
	apply_pressure('load_taper',faces=faces,expression=express,create_step='step4')	;please_check

	faces = face_select(anvil_A1,y=MAX)
	apply_pressure('load_land',faces=faces,MPa=pressure,create_step='step4')	;please_check

##	mdb.saveAs(odb_title2)

##	create_inp(odb_title2,clear_jobs=False)
##	mdb.jobs[odb_title2].submit()

	create_inp(inp_file_title,request_num=6,submit=False)

	return

def main_A0215_HPHT_PDC():
	## VER: 2014-04-22, v1.0, PDC cutter residual analysis
	## started on: 2014-04-22

	check_script_file('HC_A0215_PDC_1200degC_PCD37.py')	;changing
	history = 'GJ:no cooling, only pressure; GE:updated tor; G7: add P and BF; FI: benchmark model dimensions; FF:pressure increase and reach max at room temperature; EQ:delete modulus at high temperature 1300; EM:no plastic at 1200degC; EH:vertice constraint after model change; ED:repeated D7; D5:transient static analysis; C0:neck_Dg=19mm; BZ:neck_Dg=18mm; BY:no change in thickness, change neck_Dg; BX:carbide_Hg=8.0mm; BV:diamond_Hg=2.92(not change), carbide_Hg=7.112mm; BU:diamond_Hg=4.0mm; BT:diamond_Hg=3.5mm; BS:keep dimensions2, change PCD thickness of phase1, but not change the carbide thick; BR:PCD=2.1mm; BQ:PCD=2.5mm; BP:PCD=2.3mm, keep total_Hc=8mm; BL:back support; BK:top plate, tor=80um; BH:modulus of PDC; BB: no control on mesh of compound; B9:esize=0.4, merge model; B5: new imported loft mdoel; B6:diamond thick=1.5mm; B5:use CTE curve; B3:no pressure; B0: interact then tie; AU: half model, output at timepoints; AT:modify pressure; AP:small pressure; AO:merge to be one part; AJ:different CTE; AI:only CTE ends; AG: yield strength + CTE; AB:half model, cool from 800degC; A5:temperature dependent material properties; A3: 1400degC; A1:model'

##	import_stp('458400001_new.stp', part_names={1:'carbide',2:'diamond'},scale=25.4)
	open_cae('_A0215_model_imported.cae', new_name=inp_file_title)

##	open_cae('_A0215_model1_assembly.cae', new_name=inp_file_title)

	## Source: tooling report,
	H11N_plastic = ((2070.0, 0.0, 25.0),
			(1940,0.0, 250.0),
			(1200,0.0, 750),  (1800, 0.005,  750),
			(800, 0.0, 800),  (1450, 0.0075, 800),
			(580, 0.0, 900),  (950,  0.0075, 900),
			(250, 0.0, 1000), (500,  0.02,   1000),
			(250, 0.02, 1100))                        ;changing
##			(50,  0.0, 1200), (50,   0.025,  1200)   ## 变形不属于塑性变形，也对室温的应力实际贡献不大。

	set_plastic('H11N', H11N_plastic)

##	H11N_elastic = (569419.0, 0.22, 25.0), (566120.0, 0.22, 100.0), (560551.0, 0.23, 200.0),  \
##				   (554344.0, 0.23, 300.0), (547997.0, 0.23, 400.0), (541515.0, 0.23, 500.0),  \
##				   (534469.0, 0.23, 600.0), (525941.0, 0.23, 700.0), (514549.0, 0.23, 800.0)

	E0 = 570000  ## 570GPa
	H11N_elastic = (1.0*E0, 0.22, 25), (0.98*E0, 0.22, 200), (0.96*E0, 0.23, 400), (0.94*E0, 0.23, 600), (0.9*E0, 0.23, 800), (0.86*E0, 0.23, 900),  \
					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200)	;changing
##					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200), (0.205*E0, 0.24, 1300)

	set_modulus('H11N', H11N_elastic)

##	H11N_expansion = (5.21e-06, 25.0), (6.78e-06, 800.0) ## Source: ludwig report

##	H11N_expansion = (5.21e-06, 25.0), (5.6e-06, 200.0), (5.99e-06, 400.0), (6.39e-06, 600.0), (6.78e-06, 800.0) ## Source: ludwig report
###	H11N_expansion = (5.21e-06, 25.0), (5.6e-06, 200.0), (5.99e-06, 400.0), (6.39e-06, 600.0), (6.78e-06, 800.0), (7.18e-6, 1000), (7.56e-6, 1200)   ## 线性拟合外推 (Source: ludwig report)
##	H11N_expansion = (5.8e-6, 20), (6.8e-6, 200), (6.7e-6, 300), (6.0e-6, 400), (5.9e-6, 500), (5.7e-6, 600), (5.5e-6, 700), (5.4e-6, 800),  \
##					(5.5e-6, 900), (5.4e-6, 1000), (5.4e-6, 1200)  ## Source: tooling report, TM R&D 44600, room temp to high temp
##	H11N_expansion = (5.8e-6, 25), (5.4e-6, 1200)  ## Only two ends

##	H11N_expansion = (5.8e-6, 20), (6.45e-6, 200), (6.55e-6, 300), (6.4e-6, 400), (6.3e-6, 500), (6.2e-6, 600), (6.1e-6, 700), (6.0e-6, 800),  \
##					(5.9e-6, 900), (5.8e-6, 1000)  ## Source: tooling report, TM R&D 44600, H10F, transient CTE

	H11N_expansion = (5.2e-6, 20), (5.4e-6, 400), (5.7e-6, 800)   ## H11N by Stefan

##	H11N_expansion = (5.4e-6, 400), (5.7e-6, 800)  ## Source: tooling report (stress level is high)
	set_CTE('H11N', H11N_expansion)	;changing1

	## H11
	copy_material('H11N','H11')
	H11_elastic = (0.001*E0, 0.22, 22),(0.1*E0, 0.22, 23),(0.5*E0, 0.22, 24),(1.0*E0, 0.22, 25), (0.98*E0, 0.22, 200), (0.96*E0, 0.23, 400), (0.94*E0, 0.23, 600), (0.9*E0, 0.23, 800), (0.86*E0, 0.23, 900),  \
					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200)	;changing
##					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200), (0.205*E0, 0.24, 1300)

	set_modulus('H11',H11_elastic)

	## PCD
	PCD_expansion = (1.72e-6, 20), (2.39e-6, 200), (3.06e-6, 400),(3.72e-6, 600), (4.39e-6, 800)
	set_CTE('PCD',PCD_expansion)

	changing1
##	PCD_elastic = (875000, 0.14, 25), (850000, 0.14, 600), (820000, 0.14, 700), (200000, 0.14, 1300)
	PCD_elastic = (1045000, 0.14, 25), (990000, 0.14, 700), (415000, 0.14, 1300)	 ## decrease by 5% at 700degC.
##	PCD_elastic = (1045000, 0.14, 25), (990000, 0.14, 700)		;changing	 ## decrease by 5% at 700degC.
	set_modulus('PCD', PCD_elastic)

	## PCD1
	copy_material('PCD','PCD1')
	PCD1_elastic = (1045000*0.001, 0.14, 22),(1045000*0.1, 0.14, 23), (1045000*0.5, 0.14, 24), (1045000, 0.14, 25), (990000, 0.14, 700), (415000, 0.14, 1300)	 ## decrease by 5% at 700degC.
	set_modulus('PCD1',PCD1_elastic)

	locals0 = locals().keys()

	## original
	diamond_H0 = 2.92
	carbide_H0 = 7.112
	neck_D0 = 17.145
	diamond_D0 = 17.5768
	carbide_D0 = 17.8816
	total_H0 = diamond_H0 + carbide_H0  ## 10.032

	## diameter scale and pressing dimensions
##	diamond_Hg = diamond_H0		;changing	## original: 2.92
##	carbide_Hg = carbide_H0						## original: 9.112
##	total_Hg = carbide_Hg + diamond_Hg			## original: 10.032

	diamond_Hg = 3.7			;changing
	carbide_Hg = total_H0 - diamond_Hg		;changing
	total_Hg = diamond_Hg + carbide_Hg
##	carbide_Hg = total_Hg - diamond_Hg
	neck_Dg = neck_D0			;changing1
	radius = neck_Dg/2
	thick_ratio = round(diamond_Hg/total_Hg, 2)
	D_ratio = 1.0		;changing


	## after material remove
##	diamond_Hc = 2.1
##	total_Hc = 8.0
##	carbide_Hc = 5.9
##	cylind_D = 15.875

	diamond_Hc = 2.1		;changing
	total_Hc = 8.0
	carbide_Hc = total_Hc - diamond_Hc
	cylind_D = 15.875
	final_R = cylind_D/2.0    ## 7.9375

	axial_tor = 0.04	;changing1
	radial_tor = 0.045	;changing1
	carbide_cut = carbide_Hg - carbide_Hc - axial_tor
	diamond_cut = diamond_Hg - diamond_Hc - axial_tor

	create_geometry = True		;changing1
	remove = False				;changing1
	cal_time = 270				;changing1
	if remove == False:
		cal_time = 250

	high_temp = 1200   ;changing1
	room_temp = 25
	half_symm = False	;changing1
	merge = True
	transient = False	;changing1
	esize = 0.5			;changing1
	temperature_only = False	;changing1
	pressure_only = False		;changing1
	increase_press = False		;changing1

	if increase_press == True:
		high_temp = 1300
	elif temperature_only == True:
		high_temp = 1300
	elif pressure_only == True:
		high_temp = 25

	carbide = 'carbide'
	diamond = 'diamond'
	compound = 'compound'
	plate = 'plate'

	carbide_A1 = 'carbide_A1'
	diamond_A1 = 'diamond_A1'
	compound_A1 = 'compound_A1'
	plate_A1 = 'plate_A1'

	locals2globals(locals0,locals(),save_var=True)

	if neck_Dg - cylind_D < 0.3:
		print neck_Dg - cylind_D
		raise Exception('*** too small neck_Dg or too large cylind_D')

	if carbide_cut < 0.2:
		raise Exception('*** carbide_cut is too small: ' + str(carbide_cut))

	if diamond_cut < 0.2:
		raise Exception('*** diamond_cut is too small: ' + str(diamond_cut))

	if high_temp == 1300:  ## 25sec时才将到1300度
		temp_table = ((0, 1300), (25, 1300), (28, 1292), (31, 1275), (34, 1256), (37, 1240), (40, 1222),
			(43,1200), (50, 1167), (53,1147), (56,1126), (59, 1100), (62,1084), (65,1063),(75, 1000), (90, 882),
				(99, 812), (108, 741), (121, 647), (130, 577), (139, 507), (151, 415), (166, 324), (179, 242),
				(188, 198), (198, 166), (213, 132), (229, 112), (241, 90), (250, 25),(255,25),(260,24),(265,23),(270,22))	;changing1

		## 25sec时，压强开始施加
		press_table = ((0,0), (25, 0), (30,7400), (37, 7400), (43,7400), (50, 7300),
				(59, 7120), (75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

		if increase_press == True:
			table1 = press_table[2:-2]
			table1 = shift_table(table1,dy=-7400)
			table1 = shift_table(table1,absolute=True)
			table1 = tolist(press_table[:2]) + tolist(table1) + tolist(press_table[-2:])
			table1 = totable(table1)
			press_table = table1
			save_user_data(press_table)
			print fnln(),table1
##  ((0, 0), (25, 0), (30, 0), (37, 0), (43, 0), (50, 100), (59, 280), (75, 580), (90, 920), (99, 1100), (108, 1300), (121, 1600), (130, 1800),
##  (139, 2000), (151, 2300), (166, 2800), (179, 3400), (188, 3800), (198, 4300), (213, 5100), (229, 6000), (241, 6700), (250, 7400), (255, 0), (270, 0))

	elif high_temp == 1200: ## 43sec时，才降到1200degC
		temp_table = ((0, 1200),  (43,1200), (50, 1167), (53,1147), (56,1126), (59, 1100), (62,1084), (65,1063),(75, 1000), (90, 882),
				(99, 812), (108, 741), (121, 647), (130, 577), (139, 507), (151, 415), (166, 324), (179, 242),
				(188, 198), (198, 166), (213, 132), (229, 112), (241, 90), (250, 25),(255,25),(260,24),(265,23),(270,22))	;changing1

		## 43sec时，压强开始施加
		press_table = ((0,0),(43,0), (50, 7300), (59, 7120), (75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

		if increase_press == True:
			table1 = press_table[2:-2]
			table1 = shift_table(table1,dy=-7400)
			table1 = shift_table(table1,absolute=True)
			table1 = tolist(press_table[:2]) + tolist(table1) + tolist(press_table[-2:])
			table1 = totable(table1)
			press_table = table1
			save_user_data(press_table)
			print fnln(),table1

##		((0, 0), (43, 0), (50, 100), (59, 280), (75, 580), (90, 920), (99, 1100), (108, 1300), (121, 1600), (130, 1800), (139, 2000),
##		(151, 2300), (166, 2800), (179, 3400), (188, 3800), (198, 4300), (213, 5100), (229, 6000), (241, 6700), (250, 7400), (255, 0), (270, 0))

	elif high_temp == 1100:
		temp_table = ((0, 1100),  (59, 1100), (62,1084), (65,1063),(75, 1000), (90, 882),
				(99, 812), (108, 741), (121, 647), (130, 577), (139, 507), (151, 415), (166, 324), (179, 242),
				(188, 198), (198, 166), (213, 132), (229, 112), (241, 90), (250, 25),(255,25),(260,24),(265,23),(270,22))

		## 59sec时，压强开始施加
		press_table = ((0,0),(59, 0), (65,6950),(75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

	if pressure_only:
		temp_table = (0,25),(250, 25),(255,25),(260,24),(265,23),(270,25)

		press_table = (0,0),(5, 7400), (250, 740),(255,0),(270,0)
##		press_table = ((0,0), (25, 0), (30,7400), (37, 7400), (43,7400), (50, 7300),
##				(59, 7120), (75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
##				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
##				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

	_m.TabularAmplitude(name='Amp_temp', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(temp_table))
	_m.TabularAmplitude(name='Amp_press', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(press_table))

	times1 = [0.001, 0.005, 0.01, 0.05, 0.1, 0.2, 0.4, 0.6, 0.8, 0.9, 0.95, 1.0]
	timepoints1 = create_timepoints(times1, name='TimePoints-1', factor=5)	;changing1

	times2 = [0.001, 0.01, 0.02, 0.04, 0.06, 0.08, 0.1, 0.12, 0.14, 0.16, 0.18, 0.2, 0.25, 0.3,0.35, 0.4, 0.45, 0.5,0.55, 0.6,0.65, 0.7,0.75, 0.8,0.85, 0.9, 0.95, 1.0]
	times2 = scale_list(times2,270) + [1, 2, 12, 25, 37, 50, 59, 74, 90, 99, 108, 121, 130, 139, 151, 166, 179, 188, 198, 213, 229, 241, 250, 255, 260, 265, 270]
	timepoints2 = create_timepoints(times2, name='TimePoints-2')

##	temp_table2 = (0,1200),    (10,200),(15,25),  (20,25),(25,24),(30,23),(35,22)	;changing
##	press_table2 = (0,0),(9,0),(10,7400),(15,7400),(20,0),(35,0)
##
##	times3 = (0,9,10,15,20,25,30,35)
##	timepoints3 = create_timepoints(times3, name='TimePoints-3')
##
##	_m.TabularAmplitude(name='Amp_temp2', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(temp_table2))
##	_m.TabularAmplitude(name='Amp_press2', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(press_table2))

	create_general_static_step('cooling', period=cal_time)
	if remove == True:
		create_general_static_step('remove', period=5)	;changing1

	field_output_request(timepoints={'cooling':timepoints2, 'remove':timepoints1},later_remove=('remove','P'))  ;changing1
##	raise Exception

	if create_geometry == True:
		ydisp = 0 - _ymin(carbide)
		move_part(carbide,x1=MID,x2=0, z1=MID,z2=0,dy=ydisp)  ## not use
		move_part(diamond,x1=MID,x2=0, z1=MID,z2=0,dy=ydisp)

		cylinder_grow('p1',ndir='+y',OD=carbide_D0, half_angle=(carbide_D0,neck_D0,carbide_H0), L = carbide_H0 + diamond_H0 - 0.1)
		move_part('p1',y1=MIN,y2 = _ymax('diamond') - diamond_H0 - carbide_H0)

		new_instance(diamond)
		new_instance('p1')

		boolean_cut('p1_A1', cutters='diamond_A1',newpart_name='carbide2')
		new_instance('carbide2')

		merge_instances(partname='compound', insts=('diamond_A1', 'carbide2_A1'))
		new_instance('compound')

		cylinder_grow('p2',ndir='y',x=0,z=0, y=_ymax(compound),OD=diamond_D0, L=5,half_angle=(neck_D0,diamond_D0,diamond_H0))
		cylinder_grow('p3',ndir='-y',y=_ymin(compound),OD=carbide_D0, L=5,half_angle=(neck_D0,carbide_D0,carbide_H0))
		merge_instances(partname='compound', parts=('compound','p2','p3'),boundary='remove')
		new_instance(compound)

##		raise Exception

		if PK(neck_Dg, neck_D0) != 0:
			del_insts('compound_A1')
			scale_part(compound,'compound2', scale=neck_Dg/neck_D0)

			rename('compound','compound0')
			rename('compound2','compound')
			new_instance(compound)

		faces = face_select(compound)
		edges = edge_select(compound,edir='circular',y=(MIN1,MAX1),faces=faces,groupY=MIN)
		yloc = edges[0].pointOn[0][1]
		yloc = round(yloc,5)

		if _ymax(compound) - yloc > diamond_Hg:
			bias_cut(compound,cut_sides='+y',y=yloc + diamond_Hg)

		if yloc - _ymin(compound) > carbide_Hg:
			bias_cut(compound,cut_sides='-y',y=yloc - carbide_Hg)

		cells = cell_select(compound,y=MIN1)
		set_mat(compound,cells=cells,mat='H11N')

		cells = unselect(compound,cells)
		set_mat(compound,cells=cells,mat='PCD')

##		raise Exception
		bias_cut(compound, cut_sides='-x', x=MID)
		bias_cut(compound, cut_sides='+z', z=MID)

		if remove == True:
			divide(compound,y=_ymin(compound) + carbide_cut)
			divide(compound,y=_ymax(compound) - diamond_cut)

			circular_divide('compound', ndir='y',D=cylind_D + 2*radial_tor, center=(0,0,0))

			cells = cell_select(compound,mat='H11N',groupY=MAX)
			cells1 = unselect(_mat(compound,mat='H11N'),cells)
			cross_set_mat(compound,cells=cells1,mat='H11')

			cells = cells_in_y('compound')[2]
			cells1 = cell_select(compound,mat='PCD')
			cells1 = unselect(cells1,cells)
			cross_set_mat(compound,cells=cells1,mat='PCD1')

		if D_ratio != 1:
			copy_part(compound,'compound2', scale=D_ratio)
			del_parts(compound)
			rename('compound2',compound)
			new_instance(compound)

		s1 = create_base_sketch('s_plate',ndir='y')
		s1.rectangle(point1=(0.0, 0.0), point2=(15, -15))
		_m.Part(name='plate', dimensionality=THREE_D, type=DISCRETE_RIGID_SURFACE)
		p = _m.parts['plate']
		p.BaseShell(sketch=s1)
		get_current_model()
		rotate_part('plate',angle_x=90, rotate_center=(0,0,0))

		move_part('plate',x1=MIN,x2=0, y1=MIN,y2=_ymin(compound_A1), z1=MAX,z2=0)	;changing1
		new_instance('plate')

	## mesh (mesh region可以用于interact and load, BC)
	choose_element_type(compound)
	set_element_shape(compound,eshape='TET')
	mesh_region(compound,esize=esize)	;changing1

	hex_mesh('plate',esize=esize)	;changing1

##	raise Exception

	## interact
	sfaces = face_select(compound_A1,y=MIN)
	mfaces = create_surface(faces=_inst(plate_A1).faces, side='+y')	;changing1
	s2s_contact_std('interact', name='plate_support',mfaces=mfaces, sfaces=sfaces,step='cooling')

  	history_output_request(rigid_body=plate_A1,variables=['RF','S'])   ## 此时，现有assembly，才能有history output request.

	## Load, BC (may based on deformed nodes.)
	apply_disp_fix(name='RP_fix',referencePoints=plate_A1,fix_all=True,step='step1')  ## plate整个过程都被fix

	if transient == True:
		set_temperature_predefined_field(initial_step=high_temp)
		set_temperature_BC('HPHT', amplitude='Amp_temp',step='cooling')
	else:
		set_temperature_predefined_field(initial_step=high_temp,modifys=[('cooling','Amp_temp')])
##		set_temperature_predefined_field(initial_step=high_temp,modifys=[('cooling','Amp_temp2')])	;changing

	apply_disp_symm('x',faces=faces_of_insts(x=0))
	apply_disp_symm('z',faces=faces_of_insts(z=0))

	if temperature_only == False:
		faces = face_select('compound_A1', ndir='conical')	;changing1
		apply_pressure('side_pressure', faces=faces, amplitude='Amp_press',step='cooling')	;changing1

		faces = face_select(compound_A1, y=MAX)		;changing1
		apply_pressure('end_pressure', faces=faces, amplitude='Amp_press',step='cooling')	;changing1

	apply_gravity(Gy=-9800)

	## model change
	if remove == True:
		ycells = cells_in_y(compound_A1)
		final_cells = ycells[1:3]
		set1 = create_set(name='final_cells', cells=final_cells)

		remove_cells = unselect(_inst(compound_A1).cells,final_cells)
		model_change(cells=remove_cells,step='remove',active=False)		;changing1

		faces1 = face_select(compound_A1,cells=final_cells, x=0)
		apply_disp_symm('x',faces=faces1,step='remove')

		faces2 = face_select(compound_A1,cells=final_cells, z=0)
		apply_disp_symm('z',faces=faces2,step='remove')

		y1 = ylocs(compound,x=0,z=0,axis=True)[1]
		nodes = node_select(compound_A1,y=y1,exterior=False)
		apply_disp_fix('node_fix',nodes=nodes,step='remove',Uy=0)

##		vertices = vertice_select(compound_A1,x=0,z=0,y=_ymin(compound_A1) + carbide_cut)
##		apply_disp_fix('final_y',vertices=vertices,step='remove',Uy=0)

##		faces3 = face_select(compound_A1,cells=final_cells, y=_ymin(compound_A1) + carbide_cut)	;please_check  ## _ymin(compound_A1) + carbide_cut
##		apply_disp_fix('final_y',faces=faces3,step='remove',Uy=0)	## 面约束比点约束更能保证model change的收敛

		apply_disp_fix(name='RP_fix',referencePoints=plate_A1,fix_all=True,step='remove')   ## 可有可无，为什么?


		get_current_model()


##	raise Exception

	global _results_dict
	_results_dict = {'var':('PCD_H', 'carbide_Hg', 'thick_ratio','cylind_D','high_temp'), 'H11N':('S1','Mises','S11','S22','U'), 'PCD':('S1','Mises','S11','S22')}

	create_inp(inp_file_title,request_num=6) ;please_check
##	back_run()
##	mdb.jobs[inp_file_title].submit()

	return

def main_A0212_rotary_cutter_918():
	## VER: 2014-04-23, v1.0

	check_script_file('EC_A0212_rotary_initialV150_test.py')

	history = 'E8:no damage; E1:ductile damage; CU: fine mesh in cutting edge contact region; CJ: fine mesh; C8:move cutter to middle; C6:cshaft bearing center Ux=0; C3:land=70um; BH:constant velocity; BF: applied force; BA: gravity and coupling on carbide(good); AT:velocity=200mm/s; AQ: No general contact; AN: plastic; AM: partition; AL: carbide and cshaft no int; AJ:fine mesh for cutter and anvil; A1:model'

##	import_stp('cuc__542u1070_asm.stp', part_numbers=(341, 342, 343, 348))
##	open_cae('A0212_imported_model.cae')

##	E:\FEM\A0212 - Impact velocity of rotary cutter_Pierre\py
##	open_cae('E:/FEM/A0212 - Impact velocity of rotary cutter_Pierre/py/A0212_imported_model.cae')
##	open_cae('py/A0212_imported_model.cae')

##	create_dynamic_explicit_step(stepname='step1',timePeriod=2e-4, output_num=50)
##	_m.FieldOutputRequest(name='field_output', variables=ALL, timeInterval=0.0001,createStepName='step1')

	blank_cae(inp_file_title)
##	open_cae('A0212_imported22.cae', new_name=inp_file_title)
	import_part_from_cae('imported/_model_parts_test2.cae','cutEdge')	;changing

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

##	initiate_table = \
##	  (2.31,   -3.33,   0.001),
##	  (2.31,  -0.333,   0.001)
##	  2.18,  -0.267,   0.001
##	  2.06,    -0.2,   0.001
##	  1.95,  -0.133,   0.001
##	  1.85, -0.0667,   0.001
##	  1.76,      0.,   0.001
##	  1.67,  0.0667,   0.001
##	  1.59,   0.133,   0.001
##	  1.52,     0.2,   0.001
##	  1.46,   0.267,   0.001
##	   1.4,   0.333,   0.001
##	  1.35,     0.4,   0.001
##	   1.3,   0.467,   0.001
##	  1.26,   0.533,   0.001
##	  1.23,     0.6,   0.001
##	   1.2,   0.667,   0.001
##	  1.15,    0.73,   0.001
##	  1.06,   0.851,   0.001
##	 0.945,    1.02,   0.001
##	 0.816,    1.24,   0.001
##	 0.685,    1.51,   0.001
##	 0.202,    3.33,   0.001

	## ductile damage, 可多核并行运算。
##	_m.materials['Steel_WMoCrV'].DuctileDamageInitiation(table=(
##		(0.05, -0.33, 0.001),(0.05, -0.33, 0.1),(0.05, -0.33, 10),(0.05,-0.33, 100),(0.05, -0.33, 1000),(0.05,- 0.33, 1000),(0.05, -0.33, 10000) ))		;changing
##	_m.materials['Steel_WMoCrV'].ductileDamageInitiation.DamageEvolution(type=ENERGY, softening=EXPONENTIAL, table=((50.0*K_energy, ), ))
##	raise Exception

##	_m.materials['Steel_WMoCrV'].DuctileDamageInitiation(table=((0.05, -0.33, 0.001),))
####		(0.05, -0.33, 0.001),(0.03, 0, 0.001),(0.01, 5, 0.001),(0.05, -0.33, 100000),(0.03, 0, 100000),(0.01, 5, 100000)))		;changing
##	_m.materials['Steel_WMoCrV'].ductileDamageInitiation.DamageEvolution(type=ENERGY, softening=EXPONENTIAL, table=((1.0, ), ))


	unit = 'test'
	locals0 = locals().keys()
	if unit == 'design':
		carbide_ID = 96
		anvil_OD = 149
		anvil_L = 140   ## half length
		anvil_L2 = 48.5
		anvil_OD2 = 70
		anvil_L3 = 64
		anvil_OD3 = 60   ## corresponding to cshaft_OD4
		anvil_groove_x1 = 118
		anvil_groove_gap = 4
		anvil_groove_OD = 143
		anvil_ring_L = 18
		divide_D = 130

		carbide_ID = 96
		carbide_OD1 = 121
		carbide_L1 = 74
		carbide_ring_OD = 136.39
		carbide_ring_L = 16

		cshaft_L1 = 50
		cshaft_OD1 = 121

		cshaft_L2 = 90
		cshaft_OD2 = carbide_ID

		cshaft_L3 = 48.5
		cshaft_OD3 = 70

		cshaft_L4 = 64
		cshaft_OD4 = 60
		bearing_x = cshaft_L1 + cshaft_L2 + cshaft_L3 + cshaft_L4/2

		cshaft_L5 = 76
		cshaft_OD5 = 50

		bearing_mass = 12.37   ## 12.37 kg
		ring_H = 7.695
		h = 0.002   				## extension of land
		edge_H = ring_H + h
		edge_land = 0.04  	;changing1 ## between 0.02 and 0.07
		edge_angle = 80
		edge_width = 5.536
		edge_loc = 52.5   	;changing1	## range: 9 - 52.5mm, from left

		edge_OD = carbide_ring_OD + 2*h
		simplified = False		;changing1
		angle = 0				;changing1

		cylinder_H = 15		;changing1
		piston_area = 7854   ## mm
		Fac = 1570
		Fs = 357   ## 单个，Ks*X = 22.3*16

	elif unit == 'test':
		## cshaft
		cshaft_x1 = 90
		cshaft_D1 = 143

		cshaft_x2 = 240
		cshaft_D2 = 120

		cshaft_x3 = 260
		cshaft_D3 = 75

		cshaft_x4 = 311.5
		cshaft_D4 = 65
		bearing_cshaft = (cshaft_x3 + cshaft_x4)/2.0
		bearing_cshaft_ID = cshaft_D4

		cshaft_x5 = 347.5
		cshaft_D5 = 40

		## carbide
		carbide_x0 = cshaft_x1
		carbide_x1 = 220
		carbide_OD1 = 147
		carbide_ID = cshaft_D2

		h = 0.002
		carbide_x2 = 240
		carbide_OD2 = 167.12 - 2*h

		cutter_OD = 167.12

		## anvil
		anvil_ID = 127.4
		anvil_OD = 179.0
		anvil_x1 = 75
		anvil_x2 = 90
		anvil_x3 = 207.5
		anvil_x4 = 242.5

		anvil_x5 = 295
		anvil_D2 = 55
		bearing_ashaft = (anvil_x4 + anvil_x5)/2.0
		bearing_ashaft_ID = anvil_D2

		## grove
		grove_depth = 2		## 2mm
		grove_OD = anvil_OD - 2*grove_depth
		grove_x1 = 206
		grove_x2 = 210
		divide_D = grove_OD

		## edge
		edge_land = 0.1		## 100 um宽

		bearing_mass = 14.98   ;changing1
##		cylinder_H = 15		;changing1
##		piston_area = 7854   ## mm
		Fac = 1570
		Fs = 43.2   ## 单个, Ks*X = 2.7*16

	## travel
	velocity = 150					;changing
	travel_time = 0.5e-5 			## 5 increments
	impact_time = 1e-3			;changing
	gap = velocity*travel_time		## gap between cutting edge and anvil surface
	if gap < 1e-3:
		gap = 1e-3  		;changing1 ## gap is at least 1um

	## names
	anvil = 'anvil'		;		anvil_A1 = 'anvil_A1'
	ashaft = 'ashaft'	;		ashaft_A1 = 'ashaft_A1'
	cshaft = 'cshaft'	;		cshaft_A1 = 'cshaft_A1'
	cutEdge = 'cutEdge'
	carbide = 'carbide'	;		carbide_A1 = 'carbide_A1'
	cutter = 'cutter'	;		cutter_A1 = 'cutter_A1'

	locals2globals(locals0,locals(),save_var=True)

	if unit == 'test':
		create_cylinder_series('cshaft','x',dlocs=[(cshaft_D1,cshaft_x1),(cshaft_D2,cshaft_x2),(cshaft_D3,cshaft_x3),
			(cshaft_D4,cshaft_x4),(cshaft_D5,cshaft_x5)])

		create_cylinder_series('carbide','x',x0=carbide_x0, keep_D1 = cshaft_D2, dlocs=[(carbide_OD1,carbide_x1),(carbide_OD2,carbide_x2)])

		create_cylinder_series('anvil','x',dlocs=[(anvil_ID,anvil_OD,anvil_x1), (anvil_OD,anvil_x2),
			(anvil_ID,anvil_OD,anvil_x3), (anvil_OD,anvil_x4), (anvil_D2, anvil_x5)])

		_m.parts.changeKey(fromName='cutEdge', toName='cutter')	;changing
		loc,axis = center_axis_of_poi(cutter)
		move_part(cutter, y1=loc[1], y2=_ymid(carbide), z1=MID, z2 = _zmid(carbide))

		move_part(anvil,y1=MAX, y2=_ymin(cutter) - gap)
		new_instance(anvil)
		## 现在可以测量anvil与cutter之间的距离

		new_instance('cutter')
		new_instance('carbide')
		new_instance('cshaft')

		divide('carbide',y=MID)
		divide('carbide',z=MID)

		divide('cshaft',y=MID)
		divide('cshaft',z=MID)

		divide('anvil',y=MID)
		divide('anvil',z=MID)

		rotate_part(anvil, angle_x=45)
		radial_cut('anvil',ndir='x', ID=grove_OD,x1=grove_x1,x2=grove_x2)
		circular_divide(anvil,ndir='x',D=anvil_OD - grove_depth)

		copy_part('anvil','ashaft')

		radial_cut(anvil,ndir='x',  OD=anvil_OD - 2*grove_depth)
		radial_cut(ashaft,ndir='x', ID=anvil_OD - 2*grove_depth)

		new_instance(anvil)
		new_instance(ashaft)

		## sets
		faces = face_select(anvil,diameter=anvil_OD)
		cells = faces_to_cells(faces)
		create_set(anvil,cells=cells, name='table')

		get_current_model()

	elif unit == 'design':
		create_cylinder_series('anvil', 'x', [(anvil_OD, anvil_groove_x1), (anvil_groove_OD, anvil_groove_gap),
			(anvil_OD, anvil_ring_L),(anvil_OD2, anvil_L2), (anvil_OD3, anvil_L3)])

		## general
		divide('anvil',y=MID)
		divide('anvil',z=MID)

		circular_divide(anvil,ndir='x',D=anvil_OD - 10)

		rotate_part(anvil, angle_x=45)

		copy_part(anvil, 'ashaft')
		radial_cut(ashaft, ndir='x', ID=divide_D)
		radial_cut(anvil,ndir='x', OD=divide_D)
	##	divide(ashaft,x=bearing_x)

		cells = cell_select(anvil,x=(0,anvil_groove_x1))
		create_set(anvil,cells=cells, name='table')

	##	raise Exception

		create_cylinder_series('carbide', 'x', [(carbide_OD1, carbide_L1), (carbide_ring_OD, carbide_ring_L)],partition=True)
		divide('carbide',y=MID)
		divide('carbide',z=MID)
		radial_cut('carbide', ndir='x', OD=carbide_ID)

		create_cylinder_series('cshaft','x', [(cshaft_OD1,cshaft_L1),(cshaft_OD2,cshaft_L2),(cshaft_OD3,cshaft_L3),(cshaft_OD4,cshaft_L4),(cshaft_OD5,cshaft_L5)],partition=True)
		circular_divide(cshaft, ndir='x', D=cshaft_OD5)
		divide('cshaft',y=MID)
		divide('cshaft',z=MID)
	##	divide('cshaft',x=bearing_x)

		## edge
		dx1 = 0.765
		dx2 = (edge_width - edge_land)/2
		dy1 = 4.34
		create_base_sketch('sk_edge')
		connect_points('sk_edge', (0,0),(dx1,dy1), (dx2, edge_H), (dx2 + edge_land, edge_H),
			(edge_width - dx1, dy1), (edge_width, 0), (0,0))

		move_geometry('sk_edge', y1=0, y2=carbide_OD1/2)
		revolve_sketch_to_part('cutter',sketch='sk_edge', angle=360, axis='H')

	##	raise Exception

		move_part('carbide', x1=MIN, x2=cshaft_L1 + 1e-3)	;please_check
		new_instance(cshaft)
		new_instance(carbide)

	##	raise Exception

		move_part(cutter, y1=MID, y2=_ymid(carbide), x1=0, x2=edge_loc + _xmin(carbide))
		divide(cutter, z=MID)
		divide(cutter, y=MID)

		if simplified == False:
			_m.parts.changeKey(fromName='cutter', toName='cutter1')	;changing

			move_part(cutEdge, y1=MID, y2=_ymid(carbide), z1=MID, z2 = _zmid(carbide))
			_m.parts.changeKey(fromName='cutEdge', toName='cutter')	;changing

			get_current_model()

		changing
		radial_cut(carbide,ndir='x',ID=_leny(cutter) - 2*h)
		new_instance(cutter)

		if angle > 0 and simplified == False:
			rotate_instances(insts=cutter_A1,ref_part=carbide,angle_x=angle)

	##	divide(carbide, x=_xmin(cutter))
	##	divide(carbide, x=_xmax(cutter))
	##	raise Exception

		move_part(anvil,y1=MAX, y2=_ymin(cutter_A1) - gap)
		new_instance(anvil)

		move_part(ashaft, y1=MID, y2=_ymid(anvil))
		new_instance(ashaft)

	## divide for mesh
	locs = locs_of_poi(cutter_A1, y=MIN,axis='x',pointOn=False)  ## test unit: locs = [103.908438, 104.008401]
	x1,x2 = locs[0],locs[-1]   ## for test unit: x2 - x1 = 0.1mm
	batch_divide(anvil, x=(x1, (x1+x2)/2, x2))   ## edge的land也被分成两个单元。

	x1 = x1 - (x2-x1)/2.0
	x2 = x2 + (x2-x1)/2.0
	batch_divide(anvil, x=[x1 - 1.5, x1-1, x1-0.7, x1-0.5, x1 - 0.3, x1-0.2,
		x1-0.1, x1, x2, x2 + 0.1, x2+0.2, x2 + 0.3, x2 + 0.5, x2+0.7, x2 + 1, x2 + 1.5])

	batch_divide(cutter,z=[-5,5])

	refresh()
	set_mat(cutter, mat='H10F')
	set_mat(carbide,mat='H10F')
	set_mat(anvil,mat='Steel_WMoCrV')

	set_mat(ashaft,mat='Steel_WMoCrV')
	set_mat(cshaft,mat='Steel_36NiCrMo')

	## step and output
	create_dynamic_explicit_step(stepname='step1',timePeriod=impact_time, output_num=20)

	times = [0.1, 0.3, 0.5] + myrange(1,30,1) + myrange(32,300,2)		;changing
	timepoints = create_timepoints(times,factor=1e-5)

	field_output_request(timepoints=timepoints)

	## mesh
	edges = edge_select(anvil,poiRefY=(MAX,-grove_depth),diameter=anvil_OD)
	seed_edges(anvil, edges=edges, enum=100)

	edges = edge_select(anvil,x=MAX1,edir='x')
	seed_edges(anvil,edges=edges,esize=2)

	mesh_region(anvil,esize=5)

	## ashaft
	edges = edge_select(ashaft,poiRefY=(MAX,-6))
	seed_edges(ashaft, edges=edges, esize=2.5)	;changing
	mesh_region(ashaft,esize=5)

	## cutter
##	set_element_shape(cutter,eshape='TET')
	mesh_region(cutter,esize=1.5)

	mesh_region(cshaft)


	## carbide
	edges = edge_select(carbide, x=MAX, poiRefY=(MIN, grove_depth), diameter=_leny(carbide))
 	seed_edges(carbide, edges=edges, esize=2)

	edges = edge_select(carbide,x=MAX1,edir='x')
	seed_edges(carbide,edges=edges,esize=2)

	mesh_region(carbide, esize=5)

##	raise Exception

	sfaces = face_select(cshaft_A1,diameter=carbide_ID)
	mfaces = face_select(carbide_A1, diameter=carbide_ID)
	s2s_tie('tie_cshaft', mfaces=mfaces, sfaces=sfaces)

	sfaces = face_select(anvil_A1, diameter=divide_D)
	mfaces = face_select(ashaft_A1,diameter=divide_D)
	s2s_tie('tie_anvil',mfaces=mfaces,sfaces=sfaces)

##	raise Exception
	sfaces = face_select(cutter_A1,diameter=carbide_OD1)
	mfaces = face_select(carbide_A1,diameter=carbide_OD1)
	s2s_tie('tie_cutter', mfaces=mfaces, sfaces=sfaces)

	sfaces = face_select(cshaft_A1,x=_xmin(carbide_A1))
	mfaces = face_select(carbide_A1,x=MIN)
	s2s_interact_explicit(name='int_cshaft_carbide',mfaces=mfaces,sfaces=sfaces)

##	raise Exception

	x1 = _xmin(carbide)
	x2 = _xmax(cutter)
	sfaces = face_select(anvil_A1,diameter=anvil_OD,x=(x1,x2))
	mfaces = face_select(cutter_A1,diameter=MAX)
	s2s_interact_explicit('int_anvil_edge', mfaces=mfaces, sfaces=sfaces)

	sfaces = face_select(anvil_A1,diameter=anvil_OD,x=(x1,x2))
	mfaces = face_select(cutter_A1,z=(-20,20),ny=-1,nx=-1)
	s2s_interact_explicit('int_anvil_edge', mfaces=mfaces, sfaces=sfaces)

	sfaces = face_select(anvil_A1,diameter=anvil_OD,x=(x1,x2))
	mfaces = face_select(cutter_A1,z=(-20,20),ny=-1,nx=1)
	s2s_interact_explicit('int_anvil_edge', mfaces=mfaces, sfaces=sfaces)

##	raise Exception


##	raise Exception

	sfaces = face_select(anvil_A1,diameter=anvil_OD,x=(grove_x2,MAX))
	mfaces = face_select(carbide_A1,diameter=carbide_OD2)
	s2s_interact_explicit('int_anvil_carbide', mfaces=mfaces, sfaces=sfaces)

##	raise Exception

	changing   ## coupling
	RP = create_RP(cshaft_A1,loc=(bearing_cshaft, _ymid(cshaft), _zmid(cshaft)), name='cshaft_bearing')
	RP_set1 = create_set(objs=RP,setname='cshaft_RP_set')

	faces = face_select(cshaft_A1,diameter=bearing_cshaft_ID)
	coupling_faces_to_point('cshaft_coupling',faces=faces,control_point='cshaft_RP_set',U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=DISTRIBUTING)
	apply_disp_fix('fix_cshaft',referencePoints=RP,  Ux=0, Uy=0,Uz=0)  ;changing	## jianzhi

	## ashaft: 参考点参与：1）耦合 2）作为质量点 3）约束  4）施加速度
	RP = create_RP(ashaft_A1,loc=(bearing_ashaft, _ymid(ashaft_A1), 0), name='ashaft_bearing')
	RP_set2 = create_set(objs=RP,setname='ashaft_RP_set')

##	raise Exception

	faces = face_select(ashaft_A1,diameter=bearing_ashaft_ID)
	coupling_faces_to_point('ashaft_coupling',faces=faces,control_point='ashaft_RP_set',U1=ON, U2=ON, U3=ON, UR1=ON, UR2=ON, UR3=ON, coupling_type=DISTRIBUTING)
	apply_disp_fix('fix_ashaft',referencePoints=RP, Ux=0,Uz=0)  ;changing	## jianzhi

	create_point_mass_damping(RP=RP_set2, mass=bearing_mass/1000)
	apply_velocity(name='mass_point_velocity',region='ashaft_RP_set', Vy=velocity, step='Initial')	;changing

	regionDef=_m.rootAssembly.sets['ashaft_RP_set']
	_m.HistoryOutputRequest(name='H-Output-2',
	    createStepName='step1', variables=('U2', 'V2', 'A2', 'RF2','COORD'), frequency=1, region=regionDef, sectionPoints=DEFAULT, rebar=EXCLUDE)

	regionDef=_m.rootAssembly.sets['cshaft_RP_set']
	_m.HistoryOutputRequest(name='H-Output-3',
	    createStepName='step1', variables=('U2', 'V2', 'A2', 'RF2','COORD'), frequency=1, region=regionDef, sectionPoints=DEFAULT, rebar=EXCLUDE)

	locs = locs_of_poi(anvil,axis='x',pointOn=False)
	if unit == 'design':
		vertices = vertice_select(anvil_A1,x=locs[1], groupY=MAX)
	elif unit == 'test':
		vertices = vertice_select(anvil_A1,x=locs[3], groupY=MAX)
	create_set(objs=vertices, name='anvil_cut')

	vertices = vertice_select(anvil_A1,x=MAX, groupY=MAX)
	create_set(objs=vertices, name='anvil_bearer')

	if unit == 'design':
		vertices = vertice_select(ashaft_A1,x=188.5, groupY=MAX)
	elif unit == 'test':
		vertices = vertice_select(ashaft_A1,x=MAX,groupY=MAX)
	create_set(objs=vertices, name='bearing_pt')

##	raise Exception

	regionDef=a.sets['anvil_cut']
	_m.HistoryOutputRequest(name='H-Output-4',
	    createStepName='step1', variables=('U2', 'V2', 'A2','CF2', 'RF2','COORD'),
	    timeInterval=2e-06, region=regionDef, sectionPoints=DEFAULT, rebar=EXCLUDE)

	regionDef=a.sets['anvil_bearer']
	_m.HistoryOutputRequest(name='H-Output-5',
	    createStepName='step1', variables=('U2', 'A2','CF2', 'RF2', 'V2','COORD'),
	    timeInterval=2e-06, region=regionDef, sectionPoints=DEFAULT, rebar=EXCLUDE)

	regionDef=a.sets['bearing_pt']
	_m.HistoryOutputRequest(name='H-Output-6',
	    createStepName='step1', variables=('U2', 'A2', 'CF2','RF2', 'V2','COORD'),
	    timeInterval=2e-06, region=regionDef, sectionPoints=DEFAULT, rebar=EXCLUDE)

##	raise Exception

	## load
	apply_velocity(insts=[anvil_A1,ashaft_A1], Vy=velocity, step='Initial')  ;please_check		## initial

	changing1 ## velocity
	if 'step2' in _m.steps.keys():
		apply_velocity(insts=[anvil_A1,ashaft_A1], Vy=velocity, step='step1',deactive_step='step2')    ## constant

##	raise Exception

	changing  ## gravity
	apply_gravity(insts=[cshaft_A1,cutter_A1, carbide_A1], Gy=-9800)
	apply_gravity_body_force(insts=[ashaft_A1, anvil_A1])

	changing
	apply_force(RP='ashaft_bearing',CF2=Fac - 2*Fs - bearing_mass*9.8)

	faces = faces_of_insts(x=0)
	apply_disp_fix('symm_fix', faces=faces, Ux=0, UR1=0, UR2=0, UR3=0)

##	apply_disp_fix('fix_rotate_carbide', cells=carbide_A1.cells, UR1=0, UR2=0, UR3=0)
##	apply_disp_fix('fix_rotate_cutter', cells=cutter_A1.cells, UR1=0, UR2=0, UR3=0)

##	raise Exception


	create_inp(inp_file_title,request_num=6) 		;please_check
##	mdb.jobs[inp_file_title].submit()
	back_run()

	return


def main_A0216_pressdie():
	## started: 2014-06-13, started, 2015-03-26 continued

	check_script_file('C8_A0216_pressdie_old_max_R10.py')	;changing
	history = 'C0: to check inner radius effect; B7:no hole; AX:hole fix; AU:hole not fixed; AS:with steel DAM outside the steel case; A1:model'

	blank_cae(inp_file_title)

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	locals0 = locals().keys()

	## 长方形的case的外围尺寸不能修改
	case_length = 580
	case_width = 149.5

##	dam_width = 250
##	dam_length = case_length

	hole_fix = False			;changing1
	have_frame = True			;changing1
	model = '3D'	;changing
	if model == '3D':
		hole_fix = False

	case_OD_x = case_width
	case_OD_y = case_length

	frame_ID_x = case_OD_x
	frame_ID_y = case_OD_y

	frame_thick = 150
	die_thick = 95

	bot_open_x = 100
	frame_width = 600
	if model == '2D':
##		frame_width = frame_width + (case_width - bot_open_x)*2   ## compensate
		frame_width = frame_width + case_width*1.5

	frame_OD_x = frame_width
	frame_thick_x = (frame_width - case_width)/2

	bot_open_y = 500
	frame_thick_y = 170
	if model == '2D':
##		frame_thick_y = frame_thick_y + (case_length - bot_open_y)  ## compensate
		frame_thick_y = frame_thick_y + case_length/4

	frame_OD_y = frame_ID_y + 2*frame_thick_y
	frame_length = frame_OD_y

	axial_pressure_max = 164   ## 164MPa
##	work_ratio = 0.841				;changing1
##	work_pressure = axial_pressure_max*work_ratio
	work_pressure = 138
	work_ratio = work_pressure/axial_pressure_max

	lateral_coefficient = 0.5	;changing1
	cavity_num = 1

	carbide_mat = 'H10F'		;changing1

	situation = 'max'	;changing  ## work or max
	design = 'old'		;changing
	if design == 'old':
		carbide_cavity_x = 26.38   ## ID cannot change, sintered D=20.3mm  (carbide_cavity_x is the carbide_cavity_x)
		carbide_cavity_y = 403.75
		work_ton = 150
		max_ton = 178

	else:
		carbide_cavity_x = 38.95   ## ID cannot change, sintered D=30.3mm
		carbide_cavity_y = 235  ;changing # original: 235 (156)(77)
		piece_length = 79  ## 77 + 79=156, 156+79=235

	## origin
##	carbide_wall_x = 28.025
##	carbide_wall_y = 20

##	wall = globals()['wall']
##	carbide_wall_x = 28	;changing
##	carbide_wall_y = 23

##	carbide_OD_x = carbide_cavity_x + 2*carbide_wall_x
##	carbide_OD_y = carbide_cavity_y + 2*carbide_wall_y

##	wall = carbide_wall_x

##	carbide_wall_x = (carbide_OD_x - carbide_cavity_x)/2
####	carbide_wall_y = (carbide_OD_y - carbide_cavity_y)/2
##	carbide_OD_y = carbide_cavity_y + 2*carbide_wall_y

	if design == 'old':
		carbide_OD_x = 65
		carbide_OD_y = 450
	else:
		carbide_OD_x = 95
		carbide_OD_y = 275  	;changing		## original: 275 (200)

	carbide_wall_x = (carbide_OD_x - carbide_cavity_x)/2
	carbide_wall_y = (carbide_OD_y - carbide_cavity_y)/2

	cavity_area = carbide_cavity_x*carbide_cavity_y

##	axial_ton_max = axial_pressure_max*cavity_area/(1000*9.8)*cavity_num
##	work_ton = axial_ton_max*work_ratio

	land = 30		;changing	### origin: 10
	force_max = pressure_on_area(axial_pressure_max,carbide_cavity_x, carbide_cavity_y,lateral_coefficient)  ## (178.24, 10650.93, 164.0, 82.0)
	force_work = pressure_on_area(work_pressure,carbide_cavity_x, carbide_cavity_y,lateral_coefficient)	## 150 10650.93 138.02 69.01
	if situation == 'max':
		side_pressure = force_max[3]	;changing1
	else:
		side_pressure = force_work[3]

##	area1 = 26.38*403.75		## 10650.925
##	ton1 = 178  ## 178 ton force
##	axial_ref1 = round(ton1*9800/area1,1)   ## 163.8 MPa
##	side1 = axial_ref1*lateral_coefficient   ## 98.28MPa
##
##	area2 = 26.38*403.75		## 10650.925
##	ton2 = 150  ## 178 ton force
##	axial_ref2 = round(ton2*9800/area1,1)   	## 138.0 MPa
##	side2 = axial_ref2*lateral_coefficient		## 82.8 MPa

	## max: (178, 10650.93, 163.78, 98.27)
	force_old_max = ton_on_area(178, 403.75, 26.38, lateral_coefficient)   ## sintered D=20.3mm, 20.3/26.38 = 0.77

	## work: (150, 10650.93, 138.02, 82.81)
	force_old_work = ton_on_area(150, 403.75, 26.38, lateral_coefficient)

	## max: (153, 9153.25, 163.81)
	force1_new_max = ton_on_area(153, 235, 38.95, lateral_coefficient)

	## max: (153.18, 9153.25, 164.0, 98.4)
	force2_new_max = pressure_on_area(164, 235, 38.95, lateral_coefficient)	## sintered D=30.3mm, 30.3/38.95 = 0.778

	## max: (50.19, 2999.15, 164.0, 98.4)
	force3_new_max = pressure_on_area(164, 77, 38.95, lateral_coefficient)

	## max: (101.68, 6076.2, 164.0, 98.4)
	force4_new_max = pressure_on_area(164, 156, 38.95, lateral_coefficient)

	interference = 0.06   ## coventry: 80um, taiwan: 60um

	case_ID_x = carbide_OD_x - interference*2
	case_ID_y = carbide_OD_y - interference*2

	case_wall_x = (case_OD_x - case_ID_x)/2
	case_wall_y = (case_OD_y - case_ID_y)/2
	ratio_x = round(carbide_wall_x/case_wall_x,2)
	ratio_y = round(carbide_wall_y/case_wall_y,2)

	corner_R = 8		## carbide outer R
	inner_R = 1.0		;changing  ## carbide inner R, origin = 8
	hole_D = 9
	hole2hole = 180
	hole2edge_y = (case_length - 3*hole2hole)/2
	hole2edge_x = (case_width - 125)/2

	hole_x = case_OD_x/2 - hole2edge_x
	hole_y1 = case_OD_y/2 - hole2edge_y - hole2hole
	hole_y2 = case_OD_y/2 - hole2edge_y

	carbide = 'carbide'		;		carbide_A1 = 'carbide_A1'
	frame = 'frame'			;		frame_A1 = 'frame_A1'
	case = 'case'			;		case_A1 = 'case_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception
	## carbide
	create_rectangle_shell('carbide0',corner2=(carbide_OD_x/2, carbide_OD_y/2),axis_symmetric = False)
	plane_cut('carbide0',x=(0,carbide_cavity_x/2), y=(0,carbide_cavity_y/2))

	shellpart_to_sketch('carbide0',sketchname='sk_carbide')

	round_sketch_corner('sk_carbide',loc=(carbide_cavity_x/2, carbide_cavity_y/2),radius=inner_R)	;changing
	round_sketch_corner('sk_carbide',loc=(carbide_OD_x/2, carbide_OD_y/2),radius=corner_R)

	if model == '3D':
		extrude_sketch_to_part('carbide', sketch='sk_carbide', length=die_thick)

		divide(carbide,z=_zmid(carbide) - land/2)
		divide(carbide,z=_zmid(carbide) + land/2)

	else:
		sketch_to_shellpart('sk_carbide',partname='carbide')

	## case
	create_rectangle_shell('case0',corner2=(case_OD_x/2, case_OD_y/2),axis_symmetric = False)
	plane_cut('case0',x=(0,case_ID_x/2), y=(0,case_ID_y/2))

##	s1 = create_base_sketch('sk_hole')
##	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y), radius=hole_D/2)
##	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y - hole2hole), radius=hole_D/2)
##	plane_cut('case0',sketch=s1)

	shellpart_to_sketch('case0',sketchname='sk_case')
	round_sketch_corner('sk_case',loc=(case_ID_x/2, case_ID_y/2),radius=corner_R)

	if model == '3D':
		extrude_sketch_to_part('case',sketch='sk_case',length=die_thick)

	else:
		sketch_to_shellpart('sk_case',partname='case')

	## frame

##	raise Exception

	if model == '3D':
		create_block('frame',x=(0,frame_width/2),y=(0,frame_length/2), z=(0,frame_thick))
		hex_cut('frame', x=(0,frame_ID_x/2),y=(0,frame_ID_y/2), z=(frame_thick - die_thick, frame_thick))
		hex_cut('frame', x=(0,bot_open_x/2),y=(0,bot_open_y/2),z=(MIN,MAX))

##		drill_hole('frame',x=hole_x, y=hole_y1, D=hole_D)
##		drill_hole('frame',x=hole_x, y=hole_y2, D=hole_D)

		divide('frame',z=frame_thick - die_thick)
		move_part('case',z1=MIN,z2=frame_thick - die_thick)
		move_part('carbide',z1=MIN,z2=frame_thick - die_thick)

##		cylinder_grow('pin',ndir='z', center0=(hole_x,hole_y1,0),OD=hole_D,L=frame_thick)
##		divide('pin',z=frame_thick - die_thick)
##		new_instance('pin')
##		new_instance('pin', dy=hole2hole)

	else:
		create_rectangle_shell('frame',corner2 = (frame_width/2,frame_length/2))
		plane_cut('frame',x=(0,frame_ID_x/2),y=(0,frame_ID_y/2))

	divide(frame,x=frame_ID_x/2)
	divide(frame,y=frame_ID_y/2)

	new_instance('carbide')
	new_instance('case')
	if have_frame == True:
		new_instance('frame')

	set_mat(carbide,mat=carbide_mat)
	set_mat(case,mat='Steel_D2')
	set_mat(frame,mat='Steel_D2')
##	set_mat(pin,mat='Steel')

##	raise Exception

	create_general_static_step(period=1)
##	create_general_static_step(period=1)

	period = 1
	_m.TimePoint(name='TimePoints-1', points=((0.001*period, ),(0.002*period, ), (0.01*period, ), (0.02*period, ),(0.1*period, ), (0.2*period, ), (0.4*period, ), (0.6*period, ),
		(0.8*period, ), (0.9*period, ), (0.95*period, ), (1.0*period, )))

	field_output_request(timepoints = 'TimePoints-1')

##	raise Exception

	if model == '2D':
		## interaction
		medges = edge_select(carbide_A1,poiRefX=(MAX,-corner_R - 1),y=(MAX,MIN1))
		sedges = edge_select(case_A1,x=(MIN1,case_ID_x/2),y=(MIN1,case_ID_y/2))
		s2s_interact_std('fit',mfaces=medges,sfaces=sedges,prop='Friction')

		if 'frame_A1' in a.instances.keys():
			sedges = edge_select(frame_A1,x=frame_ID_x/2)
			medges = edge_select(case_A1,x=MAX)
			s2s_interact_std('damming',mfaces=medges,sfaces=sedges,step='step1')

			sedges = edge_select(frame_A1,y=frame_ID_y/2)
			medges = edge_select(case_A1,y=MAX)
			s2s_interact_std('damming',mfaces=medges,sfaces=sedges,step='step1')


		## load, BC
		edges = edges_of_insts(x=0)
		apply_disp_fix('xsym',edges=edges,Ux=0,UR3=0)

		edges = edges_of_insts(y=0)
		apply_disp_fix('ysym',edges=edges,Uy=0,UR3=0)

		changing1
		if hole_fix == True:
			edges = edge_select(case_A1,radius=hole_D/2)
			apply_disp_fix('hole_fix',edges=edges,Ux=0,Uy=0,UR3=0)

		## side_pressure
		edges = edge_select(carbide_A1,x=(MIN1,carbide_cavity_x/2),y=(MIN1,carbide_cavity_y/2))
		apply_pressure('pressing',edges=edges,MPa=side_pressure,create_step='step1')

	elif model == '3D':
		## interaction
		mfaces = face_select(carbide_A1,nx=1) + face_select(carbide_A1,ny=1)
		sfaces = face_select(case_A1,x=case_ID_x/2) + face_select(case_A1,y=case_ID_y/2) + face_select(case_A1,radius=corner_R)
		s2s_interact_std('fit',mfaces=mfaces,sfaces=sfaces,prop='Friction')

		if have_frame == True:
			mfaces = face_select(case_A1,x=MAX)
			sfaces = face_select(frame_A1,x=_xmax(case))
			s2s_interact_std('dam_x', mfaces=mfaces, sfaces=sfaces)

			mfaces = face_select(case_A1,y=MAX)
			sfaces = face_select(frame_A1,y=_ymax(case))
			s2s_interact_std('dam_y', mfaces=mfaces, sfaces=sfaces)

			sfaces = face_select(case_A1,z=MIN)
			mfaces = face_select(frame_A1,z=_zmin(case))
			s2s_interact_std('dam_z', mfaces=mfaces, sfaces=sfaces)

##		sfaces = face_select(pin_A1,z=0.1,mark_select=True)
##		mfaces = face_select(frame_A1,radius=hole_D/2., y=(hole_y1 - hole_D, hole_y1 + hole_D))
##		s2s_tie('tie-1',mfaces=mfaces,sfaces=sfaces)
##
##		sfaces = face_select(pin_A2,z=0.1,mark_select=True)
##		mfaces = face_select(frame_A1,radius=hole_D/2., y=(hole_y2 - hole_D, hole_y2 + hole_D))
##		s2s_tie('tie-2',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A1,z=MAX1,mark_select=True)
##		sfaces = face_select(case_A1,radius=hole_D/2., y=(hole_y1 - hole_D, hole_y1 + hole_D))
##		s2s_interact_std('pin-1',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A2,z=MAX1,mark_select=True)
##		sfaces = face_select(case_A1,radius=hole_D/2., y=(hole_y2 - hole_D, hole_y2 + hole_D))
##		s2s_interact_std('pin-2',mfaces=mfaces,sfaces=sfaces)

		## load, BC
		faces = faces_of_insts(x=0)
		apply_disp_symm('x',faces=faces)

		faces = faces_of_insts(y=0)
		apply_disp_symm('y',faces=faces)

##		if have_frame == True:
##			faces = faces_of_insts(z=0)
##			apply_disp_fix('zfix',faces=faces,Uz=0)

		edges = edges_of_insts(y=0,z=_zmax(carbide))
		apply_disp_fix('zfix',edges=edges, Uz=0)

		faces = get_inner_faces(carbide_A1)
		faces = face_select(carbide_A1,z=MID,faces=faces,mark_select=True)
		apply_pressure('pressing',faces=faces,MPa=side_pressure,create_step='step1')

##	raise Exception

	## meshing
	if model == '2D':
		## mesh
		edges = edge_select(carbide,edir='circular')
		seed_edges(carbide,edges=edges,enum=4)
		mesh_part(carbide,esize=4)

		edges = edge_select(case,radius=corner_R)
		seed_edges(case,edges=edges,enum=4)

		edges = edge_select(case,radius=hole_D/2)
		seed_edges(case,edges=edges,enum=12)

		mesh_part(case,esize=4)

		## mesh frame
		edges = edge_select(frame,x=frame_ID_x/2) + edge_select(frame,y=frame_ID_y/2)
		seed_edges(frame,edges=edges, esize=3)

		edges = edge_select(frame,y=MAX1,exterior=False)
		bias_seed_single(frame,edges=edges, ratio=10,enum=20,fine_dir='-y')

		edges = edge_select(frame,x=MAX1,exterior=False)
		bias_seed_single(frame,edges=edges, ratio=10,enum=20,fine_dir='-x')

		mesh_part(frame,esize=5)

	elif model == '3D':
		## carbide
##		edges = edge_select(carbide,edir='circular')
		edges = edge_select(carbide,radius=inner_R)
		seed_edges(carbide,edges=edges,enum=4)

		edges = edge_select(carbide,edir='z')
		seed_edges(carbide,edges=edges, esize=8)

		edges = edge_select('carbide',x=MIN1,thenYseq=-2)
		seed_edges(carbide,edges=edges,enum=3)

		mesh_part(carbide,esize=4)

		## mesh case
		edges = edge_select(case,radius=corner_R)
		seed_edges(case,edges=edges,enum=4)

		edges = edge_select(case,radius=hole_D/2)
		seed_edges(case,edges=edges,enum=12)

		edges = edge_select(case,edir='z')
		seed_edges(case,edges=edges, esize=8)

		mesh_part(case,esize=4)
		mesh_part(frame,esize=8)
##		mesh_part(pin)

##	raise Exception

	global _results_dict
	_results_dict = {'var':('interference',  'force_max', 'corner_R', 'ratio_x','ratio_y','carbide_mat','side_pressure'), 'carbide_A1':('S1','Mises','U1','U2'), 'case_A1':('S1','Mises','U1','U2')}

	create_inp(inp_file_title,request_num=6) ;please_check
##	mdb.jobs[inp_file_title].submit()

	return

def main_A0236_press_tool_design():
	## started: 2014-06-13, started, 2015-03-26 continued

	check_script_file('CE_A0236_pressdie_old_max_R015_2D.py')	;changing
	history = 'C0: to check inner radius effect; B7:no hole; AX:hole fix; AU:hole not fixed; AS:with steel DAM outside the steel case; A1:model'

	blank_cae(inp_file_title)

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	locals0 = locals().keys()

	## 长方形的case的外围尺寸不能修改
	case_length = 580
	case_width = 149.5

##	dam_width = 250
##	dam_length = case_length

	hole_fix = False			;changing1
	have_frame = True			;changing
	model = '2D'	;changing
	if model == '3D':
		hole_fix = False

	case_OD_x = case_width
	case_OD_y = case_length

	frame_ID_x = case_OD_x
	frame_ID_y = case_OD_y

	frame_thick = 150
	die_thick = 95

	bot_open_x = 100
	frame_width = 600
	if model == '2D':
##		frame_width = frame_width + (case_width - bot_open_x)*2   ## compensate
		frame_width = frame_width + case_width*1.5

	frame_OD_x = frame_width
	frame_thick_x = (frame_width - case_width)/2

	bot_open_y = 500
	frame_thick_y = 170
	if model == '2D':
##		frame_thick_y = frame_thick_y + (case_length - bot_open_y)  ## compensate
		frame_thick_y = frame_thick_y + case_length/4

	frame_OD_y = frame_ID_y + 2*frame_thick_y
	frame_length = frame_OD_y

	axial_pressure_max = 164   ## 164MPa
##	work_ratio = 0.841				;changing1
##	work_pressure = axial_pressure_max*work_ratio
	work_pressure = 138
	work_ratio = work_pressure/axial_pressure_max

	lateral_coefficient = 0.5	;changing1
	cavity_num = 1

	carbide_mat = 'H10F'		;changing1

	situation = 'max'	;changing  ## work or max
	design = 'old'		;changing
	if design == 'old':
		carbide_cavity_x = 26.38   ## ID cannot change, sintered D=20.3mm  (carbide_cavity_x is the carbide_cavity_x)
		carbide_cavity_y = 403.75
		work_ton = 150
		max_ton = 178

	else:
		carbide_cavity_x = 38.95   ## ID cannot change, sintered D=30.3mm
		carbide_cavity_y = 235  ;changing # original: 235 (156)(77)
		piece_length = 79  ## 77 + 79=156, 156+79=235

	## origin
##	carbide_wall_x = 28.025
##	carbide_wall_y = 20

##	wall = globals()['wall']
##	carbide_wall_x = 28	;changing
##	carbide_wall_y = 23

##	carbide_OD_x = carbide_cavity_x + 2*carbide_wall_x
##	carbide_OD_y = carbide_cavity_y + 2*carbide_wall_y

##	wall = carbide_wall_x

##	carbide_wall_x = (carbide_OD_x - carbide_cavity_x)/2
####	carbide_wall_y = (carbide_OD_y - carbide_cavity_y)/2
##	carbide_OD_y = carbide_cavity_y + 2*carbide_wall_y

	if design == 'old':
		carbide_OD_x = 65
		carbide_OD_y = 450
	else:
		carbide_OD_x = 95
		carbide_OD_y = 275  	;changing		## original: 275 (200)

	carbide_wall_x = (carbide_OD_x - carbide_cavity_x)/2
	carbide_wall_y = (carbide_OD_y - carbide_cavity_y)/2

	cavity_area = carbide_cavity_x*carbide_cavity_y

##	axial_ton_max = axial_pressure_max*cavity_area/(1000*9.8)*cavity_num
##	work_ton = axial_ton_max*work_ratio

	land = 30		;changing	### origin: 10
	force_max = pressure_on_area(axial_pressure_max,carbide_cavity_x, carbide_cavity_y,lateral_coefficient)  ## (178.24, 10650.93, 164.0, 82.0)
	force_work = pressure_on_area(work_pressure,carbide_cavity_x, carbide_cavity_y,lateral_coefficient)	## 150 10650.93 138.02 69.01
	if situation == 'max':
		side_pressure = force_max[3]	;changing1
	else:
		side_pressure = force_work[3]

##	area1 = 26.38*403.75		## 10650.925
##	ton1 = 178  ## 178 ton force
##	axial_ref1 = round(ton1*9800/area1,1)   ## 163.8 MPa
##	side1 = axial_ref1*lateral_coefficient   ## 98.28MPa
##
##	area2 = 26.38*403.75		## 10650.925
##	ton2 = 150  ## 178 ton force
##	axial_ref2 = round(ton2*9800/area1,1)   	## 138.0 MPa
##	side2 = axial_ref2*lateral_coefficient		## 82.8 MPa

	## max: (178, 10650.93, 163.78, 98.27)
	force_old_max = ton_on_area(178, 403.75, 26.38, lateral_coefficient)   ## sintered D=20.3mm, 20.3/26.38 = 0.77

	## work: (150, 10650.93, 138.02, 82.81)
	force_old_work = ton_on_area(150, 403.75, 26.38, lateral_coefficient)

	## max: (153, 9153.25, 163.81)
	force1_new_max = ton_on_area(153, 235, 38.95, lateral_coefficient)

	## max: (153.18, 9153.25, 164.0, 98.4)
	force2_new_max = pressure_on_area(164, 235, 38.95, lateral_coefficient)	## sintered D=30.3mm, 30.3/38.95 = 0.778

	## max: (50.19, 2999.15, 164.0, 98.4)
	force3_new_max = pressure_on_area(164, 77, 38.95, lateral_coefficient)

	## max: (101.68, 6076.2, 164.0, 98.4)
	force4_new_max = pressure_on_area(164, 156, 38.95, lateral_coefficient)

	interference = 0.06   ## coventry: 80um, taiwan: 60um

	case_ID_x = carbide_OD_x - interference*2
	case_ID_y = carbide_OD_y - interference*2

	case_wall_x = (case_OD_x - case_ID_x)/2
	case_wall_y = (case_OD_y - case_ID_y)/2
	ratio_x = round(carbide_wall_x/case_wall_x,2)
	ratio_y = round(carbide_wall_y/case_wall_y,2)

	corner_R = 8		## carbide outer R
	inner_R = 0.15		;changing  ## carbide inner R, origin = 8
	hole_D = 9
	hole2hole = 180
	hole2edge_y = (case_length - 3*hole2hole)/2
	hole2edge_x = (case_width - 125)/2

	hole_x = case_OD_x/2 - hole2edge_x
	hole_y1 = case_OD_y/2 - hole2edge_y - hole2hole
	hole_y2 = case_OD_y/2 - hole2edge_y

	carbide = 'carbide'		;		carbide_A1 = 'carbide_A1'
	frame = 'frame'			;		frame_A1 = 'frame_A1'
	case = 'case'			;		case_A1 = 'case_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception
	## carbide
	create_rectangle_shell('carbide0',corner2=(carbide_OD_x/2, carbide_OD_y/2),axis_symmetric = False)
	plane_cut('carbide0',x=(0,carbide_cavity_x/2), y=(0,carbide_cavity_y/2))

	shellpart_to_sketch('carbide0',sketchname='sk_carbide')

	round_sketch_corner('sk_carbide',loc=(carbide_cavity_x/2, carbide_cavity_y/2),radius=inner_R)	;changing
	round_sketch_corner('sk_carbide',loc=(carbide_OD_x/2, carbide_OD_y/2),radius=corner_R)

	if model == '3D':
		extrude_sketch_to_part('carbide', sketch='sk_carbide', length=die_thick)

		divide(carbide,z=_zmid(carbide) - land/2)
		divide(carbide,z=_zmid(carbide) + land/2)

	else:
		sketch_to_shellpart('sk_carbide',partname='carbide')

	## case
	create_rectangle_shell('case0',corner2=(case_OD_x/2, case_OD_y/2),axis_symmetric = False)
	plane_cut('case0',x=(0,case_ID_x/2), y=(0,case_ID_y/2))

##	s1 = create_base_sketch('sk_hole')
##	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y), radius=hole_D/2)
##	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y - hole2hole), radius=hole_D/2)
##	plane_cut('case0',sketch=s1)

	shellpart_to_sketch('case0',sketchname='sk_case')
	round_sketch_corner('sk_case',loc=(case_ID_x/2, case_ID_y/2),radius=corner_R)

	if model == '3D':
		extrude_sketch_to_part('case',sketch='sk_case',length=die_thick)

	else:
		sketch_to_shellpart('sk_case',partname='case')

	## frame

##	raise Exception

	if model == '3D':
		create_block('frame',x=(0,frame_width/2),y=(0,frame_length/2), z=(0,frame_thick))
		hex_cut('frame', x=(0,frame_ID_x/2),y=(0,frame_ID_y/2), z=(frame_thick - die_thick, frame_thick))
		hex_cut('frame', x=(0,bot_open_x/2),y=(0,bot_open_y/2),z=(MIN,MAX))

##		drill_hole('frame',x=hole_x, y=hole_y1, D=hole_D)
##		drill_hole('frame',x=hole_x, y=hole_y2, D=hole_D)

		divide('frame',z=frame_thick - die_thick)
		move_part('case',z1=MIN,z2=frame_thick - die_thick)
		move_part('carbide',z1=MIN,z2=frame_thick - die_thick)

##		cylinder_grow('pin',ndir='z', center0=(hole_x,hole_y1,0),OD=hole_D,L=frame_thick)
##		divide('pin',z=frame_thick - die_thick)
##		new_instance('pin')
##		new_instance('pin', dy=hole2hole)

	else:
		create_rectangle_shell('frame',corner2 = (frame_width/2,frame_length/2))
		plane_cut('frame',x=(0,frame_ID_x/2),y=(0,frame_ID_y/2))

	divide(frame,x=frame_ID_x/2)
	divide(frame,y=frame_ID_y/2)

	new_instance('carbide')
	new_instance('case')
	if have_frame == True:
		new_instance('frame')

	set_mat(carbide,mat=carbide_mat)
	set_mat(case,mat='Steel_D2')
	set_mat(frame,mat='Steel_D2')
##	set_mat(pin,mat='Steel')

##	raise Exception

	create_general_static_step(period=1)
##	if model == '2D':
##		create_general_static_step(period=1)

	period = 1
	_m.TimePoint(name='TimePoints-1', points=((0.001*period, ),(0.002*period, ), (0.01*period, ), (0.02*period, ),(0.1*period, ), (0.2*period, ), (0.4*period, ), (0.6*period, ),
		(0.8*period, ), (0.9*period, ), (0.95*period, ), (1.0*period, )))

	field_output_request(timepoints = 'TimePoints-1')

##	raise Exception

	if model == '2D':
		## interaction
		medges = edge_select(carbide_A1,poiRefX=(MAX,-corner_R - 1),y=(MAX,MIN1))
		sedges = edge_select(case_A1,x=(MIN1,case_ID_x/2),y=(MIN1,case_ID_y/2))
		s2s_interact_std('fit',mfaces=medges,sfaces=sedges,prop='Friction',overclosure='shrink_fit')	;changing

		if 'frame_A1' in a.instances.keys():
			sedges = edge_select(frame_A1,x=frame_ID_x/2)
			medges = edge_select(case_A1,x=MAX)
			s2s_interact_std('damming',mfaces=medges,sfaces=sedges,step='step1')

			sedges = edge_select(frame_A1,y=frame_ID_y/2)
			medges = edge_select(case_A1,y=MAX)
			s2s_interact_std('damming',mfaces=medges,sfaces=sedges,step='step1')


		## load, BC
		edges = edges_of_insts(x=0)
		apply_disp_fix('xsym',edges=edges,Ux=0,UR3=0)

		edges = edges_of_insts(y=0)
		apply_disp_fix('ysym',edges=edges,Uy=0,UR3=0)

		changing1
		if hole_fix == True:
			edges = edge_select(case_A1,radius=hole_D/2)
			apply_disp_fix('hole_fix',edges=edges,Ux=0,Uy=0,UR3=0)

##		## side_pressure
		edges = edge_select(carbide_A1,x=(MIN1,carbide_cavity_x/2),y=(MIN1,carbide_cavity_y/2))
		apply_pressure('pressing',edges=edges,MPa=side_pressure,create_step='step1')

	elif model == '3D':
		## interaction
		mfaces = face_select(carbide_A1,nx=1) + face_select(carbide_A1,ny=1)
		sfaces = face_select(case_A1,x=case_ID_x/2) + face_select(case_A1,y=case_ID_y/2) + face_select(case_A1,radius=corner_R)
		s2s_interact_std('fit',mfaces=mfaces,sfaces=sfaces,prop='Friction',overclosure='shrink_fit')	;changing

		if have_frame == True:
			mfaces = face_select(case_A1,x=MAX)
			sfaces = face_select(frame_A1,x=_xmax(case))
			s2s_interact_std('dam_x', mfaces=mfaces, sfaces=sfaces)

			mfaces = face_select(case_A1,y=MAX)
			sfaces = face_select(frame_A1,y=_ymax(case))
			s2s_interact_std('dam_y', mfaces=mfaces, sfaces=sfaces)

			sfaces = face_select(case_A1,z=MIN)
			mfaces = face_select(frame_A1,z=_zmin(case))
			s2s_interact_std('dam_z', mfaces=mfaces, sfaces=sfaces)

##		sfaces = face_select(pin_A1,z=0.1,mark_select=True)
##		mfaces = face_select(frame_A1,radius=hole_D/2., y=(hole_y1 - hole_D, hole_y1 + hole_D))
##		s2s_tie('tie-1',mfaces=mfaces,sfaces=sfaces)
##
##		sfaces = face_select(pin_A2,z=0.1,mark_select=True)
##		mfaces = face_select(frame_A1,radius=hole_D/2., y=(hole_y2 - hole_D, hole_y2 + hole_D))
##		s2s_tie('tie-2',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A1,z=MAX1,mark_select=True)
##		sfaces = face_select(case_A1,radius=hole_D/2., y=(hole_y1 - hole_D, hole_y1 + hole_D))
##		s2s_interact_std('pin-1',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A2,z=MAX1,mark_select=True)
##		sfaces = face_select(case_A1,radius=hole_D/2., y=(hole_y2 - hole_D, hole_y2 + hole_D))
##		s2s_interact_std('pin-2',mfaces=mfaces,sfaces=sfaces)

		## load, BC
		faces = faces_of_insts(x=0)
		apply_disp_symm('x',faces=faces)

		faces = faces_of_insts(y=0)
		apply_disp_symm('y',faces=faces)

##		if have_frame == True:
##			faces = faces_of_insts(z=0)
##			apply_disp_fix('zfix',faces=faces,Uz=0)

		edges = edges_of_insts(y=0,z=_zmax(carbide))
		apply_disp_fix('zfix',edges=edges, Uz=0)

		faces = get_inner_faces(carbide_A1)
		faces = face_select(carbide_A1,z=MID,faces=faces,mark_select=True)

		apply_pressure('pressing',faces=faces,MPa=side_pressure,create_step='step1')

##	raise Exception

	## meshing
	if model == '2D':
		## mesh
##		edges = edge_select(carbide,edir='circular')
		enum = 4
		if inner_R <= 0.5:
			enum = 2

		if inner_R > 0:
			edges = edge_select(carbide,radius=inner_R)
			seed_edges(carbide,edges=edges,enum=enum)

		edges = edge_select(carbide,x=MIN1,ny=-1)
		seed_edges(carbide,edges=edges,enum=3)	;changing

		mesh_part(carbide,esize=4)

		edges = edge_select(case,radius=corner_R)
		seed_edges(case,edges=edges,enum=4)

		edges = edge_select(case,radius=hole_D/2)
		seed_edges(case,edges=edges,enum=12)

		mesh_part(case,esize=4)

		## mesh frame
		edges = edge_select(frame,x=frame_ID_x/2) + edge_select(frame,y=frame_ID_y/2)
		seed_edges(frame,edges=edges, esize=3)

		edges = edge_select(frame,y=MAX1,exterior=False)
		bias_seed_single(frame,edges=edges, ratio=10,enum=20,fine_dir='-y')

		edges = edge_select(frame,x=MAX1,exterior=False)
		bias_seed_single(frame,edges=edges, ratio=10,enum=20,fine_dir='-x')

		mesh_part(frame,esize=5)

	elif model == '3D':
		## carbide
##		edges = edge_select(carbide,edir='circular')
		if inner_R > 0:
			edges = edge_select(carbide,radius=inner_R)
			seed_edges(carbide,edges=edges,enum=4)

		edges = edge_select(carbide,edir='z')
		seed_edges(carbide,edges=edges, esize=8)

		edges = edge_select('carbide',x=MIN1,thenYseq=-2)
		seed_edges(carbide,edges=edges,enum=3)

		mesh_part(carbide,esize=4)

		## mesh case
		edges = edge_select(case,radius=corner_R)
		seed_edges(case,edges=edges,enum=4)

		edges = edge_select(case,radius=hole_D/2)
		seed_edges(case,edges=edges,enum=12)

		edges = edge_select(case,edir='z')
		seed_edges(case,edges=edges, esize=8)

		mesh_part(case,esize=4)
		mesh_part(frame,esize=8)
##		mesh_part(pin)

##	raise Exception

	global _results_dict
	_results_dict = {'var':('interference',  'force_max', 'corner_R', 'ratio_x','ratio_y','carbide_mat','side_pressure'), 'carbide_A1':('S1','Mises','U1','U2'), 'case_A1':('S1','Mises','U1','U2')}

	create_inp(inp_file_title,request_num=6) ;please_check
	mdb.jobs[inp_file_title].submit()

	return

def get_nib_dimensions(nib_type):
	## VER: 2015-09-07, v1.2

	locals0 = locals().keys()   ## need both stp file and assembly file with bearing dimensions.
	## for D12H10 nib, the bearing diameter=0.8mm, then wire diameter= 0,889
	## for D9H6 nib, the bearing diameter=0.1mm, then wire diameter=0,111
	## bell->approach -> reduction -> bearing -> relief->exit

	## Required info by email: (Contact Miguel)
	## drawing PDF of nib and case and the assembly and the influence between nib and case,
	## dimension drawing of wire and the bearing region
	## wire drawing speed

	if nib_type == 'D9H6':  ## A0284
		## data provided by Miguel
		nib_OD = 9.005	;	interference = 0.045
##		nib_OD = 9.005	;	interference = 0.040
##		nib_OD = 9.005	;	interference = 0.035
##		nib_OD = 9.005	;	interference = 0.030
##		nib_OD = 9.005	;	interference = 0.025
		case_ID = nib_OD - interference

##		nib_OD = 9
		nib_H = 6
		nib_R = nib_OD/2

		## Nib需要参数: 共九个
		## 0) approach_angle, bell_R
		## 1) (wire_D,bearing_D,reduction)三个中的两个。
		## 2) reduction_angle, joint_to_reduction_top, joint_D
		## 3) relief_angle
		## 4) exit_angle, bearing_mid_to_bot

		## 下面三个角度一般不变
		bell_R = 2		;	approach_angle = 35
		reduction_angle = 11
		relief_angle = 27
		exit_angle = 60

		## 余下可能会发生改变的参数为:（共6个)
		## 1) (wire_D,bearing_D,reduction)三个中的两个。
		## 2) joint_to_reduction_top, joint_D, bearing_length
		## 4) bearing_mid_to_bot

		## job#A0284
		wire_D = 0.24		;	bearing_D = 0.2		;	joint_D = 0.12
		bearing_length = 0.1
		joint_to_reduction_top = 0.475
		bearing_mid_to_bot = 1.948  ## 一般约等于2

		## 3. reduction and bearing (实际上无reduction的detail)
		## reduction: 与wire接触并使wire直径越来越小。颈缩
##		reduction = 0.2  ## 有时直接给出wire_D and bearing_D，不需要reduction

		changing ## 需要有wire in bearing region 的尺寸图

		## A0247
##		wire_D = 0.24		;wire_R = wird_D/2
##		bearing_D = 0.32  	;changing ## wire_D = 0.34mm  ## 0.1 for A0226
##		joint_D = 0.3   ## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
##		LD_ratio = 0.7		;changing   ## bearing length/diameter ratio (2017: Miguel 说LD_ratio一般0.5左右)
##		bearing_length = bearing_D*LD_ratio   ## 这是规律

		## A0284
		wire_R = wire_D/2
		bearing_R = bearing_D/2
		joint_R = joint_D/2
##		bearing_length = 0.1
		diff_R = bearing_R - joint_R
		LD_ratio = bearing_length/bearing_D  ## 0.1/0.2 = 0.5
		reduction = round((wire_D - bearing_D)/wire_D,2)  	##其实就是直径的shrinkage。reduction的值可能在0.2左右。
															## 反过来，如果知道reduction和bearing_D，也可算出合适的wire_D
		wire_shrinkage = reduction
		nib_thick = nib_R - bearing_R		;please_check

		## joint_D是普通草图提供的尺寸，即该草图不提供bearing的详细信息(bearing_D and bearing_length)

		## joint: reduction angle与exit angle交汇于relief region的某个高度。交点与轴线的距离为joint_R
		## joint不是reduction angle与relief angle的交点。
		## 与bearing length线构成三角形，上下角度分布为reduction angle 和exit angle的一半
		## 水平方向上，该三角形的高度为bear_R - joint_R
		## PDF上一般标出joint_to_reduction_top来。细节图一般标出joint_D来。
		changing  ## 相同的nibD和nibH，joint_to_reduction_top也可能不同

##		reduction_angle = 11	;changing  ## 全角 (origin:11)
##		joint_to_reduction_top = 0.998  ## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。
		joint_to_bearing_top = diff_R/tanD(reduction_angle/2.0) ## 与有无relief无关
		reduction_dy = joint_to_reduction_top - joint_to_bearing_top

		## 4. relief
##		relief_angle = 27  ## half=13.5
		relief_dy = bearing_length	## 这是规律

		## 5. exit。PDF草图上通常会标出bearing_mid_to_bot，而不会标出joint_to_bot
##		exit_angle = 60		## 60 for new Bekaert  90
##		bearing_mid_to_bot = 1.948   ;changing ## 1.948(A0284)  1.87(A0247) 1.947   ## 一般取2   bearing mid to bot
		exit_dy = bearing_mid_to_bot - 1.5*bearing_length  ##　exit_dy = bearing_mid_to_bot - 0.5*bearing_length - relief_dy

		## 2. bell and approach
##		bell_R = 2
##		approach_angle = 35  ## 全角
		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy  ## reference
		## 不需要知道approach_dy，因为会倒圆角bell_R

		## case file: 75-E-464-31-M		## case type: 28x14, 没有铆接rivet
		case_H = 14
		case_OD = 28
		case_R = case_OD/2.0
##		interference = 0.035		;changing ## 0.3 for D6H7 and 0.35 for D9H6  ## 9*6 nib: 20-40um, 12*10 nib: 40-60um
##		case_ID = nib_OD - interference*2	;changing1  ## use shrink fit, not initial_closure

		## 没有铆接的情况下，会有ID1和ID2.其中ID1与Nib接触
##		case_ID = 8.965
		case_ID2 = 9.06
		entrance_cut_dy = 1.8
		entrance_cut_Ay = 30
		mouth_D = case_ID2 + 2*entrance_cut_dy*tanD(entrance_cut_Ay)
		mouth_D = round(mouth_D,3)

		case_ID2_bot_to_top = 4
		case_ID2_dy = case_ID2_bot_to_top - entrance_cut_dy

		case_ID1_bot_to_top = 9
		case_ID_dy = case_ID1_bot_to_top - case_ID2_bot_to_top

		case_land_H = 0.5   ## 0.3-0.5
		case_land_ID = 5   	## different for another drawing(3.5)
		land_corner_R = 0.2   ## this corner is corresponding to the chamfer in the nib.

		case_exit_angle = 60
		nib_bot_to_bot = 5
		case_exit_H = nib_bot_to_bot - case_land_H

		case_corner_chamfer = 0.5  ## 45度角切边

		carve_mid_to_bot = 7
		carve_open_dy = 1.2
		carve_bot = carve_mid_to_bot - carve_open_dy/2
		carve_top = carve_mid_to_bot + carve_open_dy/2
		carve_angle = 60
		carve_round = 0.2


##		## case file: 75-E-464-31-P010
##		case_H = 14
##		case_OD = 28   ## case type: 28x14
##		case_R = case_OD/2.0
##		interference = 0.035		;changing ## 0.3 for D6H7 and 0.35 for D9H6  ## 9*6 nib: 20-40um, 12*10 nib: 40-60um
##		case_ID = nib_OD - interference*2	;changing1  ## use shrink fit, not initial_closure
##
##		case_entrance_cut = 1.5
##		case_entrance_cut_angle = 30
##
##		rivet_H = 0.5
##		rivet_ID = 8
##		rivet_L = (nib_OD - rivet_ID)/2.0
##		rivet_R = rivet_ID/2
##		rivet_offset = 0.004 	;changing1	## offset in height, rivet与nib之间的间隙，考虑shrink fit后会消除。
##
##		nib_to_top = 2.5	;changing1
##		nib_bot_to_bot = case_H - nib_to_top - nib_H
##
##		case_land_H = 0.5   ## 0.3-0.5
##		case_land_ID = 4.5   ## different for another drawing(3.5)
##		land_corner_R = 0.2   ## this corner is corresponding to the chamfer in the nib.
##
##		case_exit_H = nib_bot_to_bot - case_land_H
##		case_exit_angle = 60
##
##		case_corner_chamfer = 1.0  ## 45度角切边

	elif nib_type == 'D6H7': ## job#: A0227
		nib_OD = 6   ## nib type = D6H7
		nib_H = 7
		nib_R = nib_OD/2

		## BARRE
		## 3. reduction and bearing (实际上无reduction的detail)
		## reduction: 与wire接触并使wire直径越来越小。
		reduction_angle = 11	;changing  ## 全角(origin:11)
##		reduction = 0.2  ## 有时直接给出wire_D and bearing_D，不需要reduction

		## 名义高度，因为bearing的细节不提供在图纸中(refrence)
		joint_to_reduction_top = 2		## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。

		bearing_D = 0.32	;changing
		bearing_R = bearing_D/2
		LD_ratio = 0.35		;changing  ## origin:0.35 	## bearing length/diameter ratio
		bearing_length = bearing_D*LD_ratio	## 这是规律
		nib_thick = nib_R - bearing_R		;please_check

		## joint_D是普通草图提供的尺寸，即该草图不提供bearing的详细信息(bearing_D and bearing_length)
		joint_D = 0.3 		## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
		bearing_mid_to_bot = 2   ## 1.947   ## 一般取2   bearing mid to bot
		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)
		reduction_dy = joint_to_reduction_top - joint_to_bearing_top	  ## reference value,

		## 4. relief
		relief_dy = bearing_length	## 这是规律
		relief_angle = 27

		## 5. exit
		exit_angle = 60		;changing1  ## 9*6为90度（宽型），6*7为60度（瘦型）
		exit_dy = bearing_mid_to_bot - 1.5*bearing_length

		## 2. bell and approach
		approach_angle = None	;please_check
		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy  ## reference
		## 不需要知道approach_H，因为会倒圆角bell_R

		bell_R = 5	## origin: 5
		bell_round = 1.5  ## round radius
		bell_center_to_top = 3.479
		bell_center_to_bot = nib_H - bell_center_to_top

##		## 1. bearing and relief (首先要确定的参数)
##		nib_info = get_nib_bearing(joint_D=joint_D, bearing_D=bearing_D, angles=(reduction_angle, exit_angle))
##		bearing_D = nib_info['BD']
##		bearing_length = nib_info['BH']
##		relief_dy = nib_info['RH']
##		joint_D = nib_info['JD']


		## VA: reduction top, connecting with approach
		## VB: reduction bot, connecting bearing
##		bot_to_joint = 2
##		joint_to_VA = 2
##		bot_to_VA = bot_to_joint + joint_to_VA
##		top_to_VA = nib_H - bot_to_VA

##		reduction_dy = joint_to_VA - bearing_length - nib_info['y1']
##		top_to_VB = reduction_dy + top_to_VA
##
##		exit_dy = bot_to_joint - nib_info['y2']
##		approach_dy = nib_H - bot_to_joint - joint_to_VA   ## approach与reduction之间的连接点不能倒角。

##		bearing_mid_to_bot = 2	## 一般取2   bearing mid to bot

##		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)

		## 2. exit
##		exit_dy = bearing_mid_to_bot - 1.5*bearing_length

		## 3. reduction
##		reduction_dy = joint_to_reduction_top - joint_to_bearing_top
##		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy

##		wire_D = joint_D/(1-reduction)	## 这是规律, 是直径的缩减率，不是面积的缩减率。  (根据joint_D可以知道wire_D，所以提供stp文件给客户即可)
##		wire_R = wire_D/2.0

		## 不需要知道approach_H，因为会倒圆角bell_R

		## 4. bell (round)
		## case file: assembly_WDBDRHS2000213.pdf
		case_H = 14
		case_OD = 28   ## case type: 28x14
		case_R = case_OD/2
		interference = 0.030		;changing

		nib_to_top = 3.0
		nib_bot_to_bot = case_H - nib_to_top - nib_H
		case_land_H = 0.3
		case_ID = nib_OD - interference*2			;changing1   ## interference fit
		case_exit_H = nib_bot_to_bot - case_land_H
		case_exit_angle = 60
		case_land_ID = 3.0   ## different for another drawing(3.5)
		case_entrance_cut = 1.0       ## refer to case_WDBDRHS20002M
		case_entrance_cut_angle = 30  ## refer to case_WDBDRHS20002M
		land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.
		case_corner_chamfer = 0.5

		rivet_H = 0.5
		rivet_L = 0.55
		rivet_offset = 0.005 ## offset in height (5um)

##		cut_angle_y = 15	  			;changing1

	elif nib_type == 'D12H10': ## 75-E-464-32-P080
		nib_OD = 12
		nib_H = 10
		nib_R = nib_OD/2

		## partial reduction
		reduction_angle = 11   ## so, wire_D = bearing_D*1.11
		reduction = 0.2
##		joint_to_reduction_top = 0.388  ## 也就是stp文件中的名义reduction的整个高度，从reduction top 到reduction和exit的交点joint的距离。

		## 1. bearing (首先要确定的参数)
		bearing_D = 0.8
		bearing_R = bearing_D/2
		bearing_length = 0.28
##		joint_D = 0.09   ## stp文件提供的reduction和exit的交会线的直径，即草图中的d1，该点实际上不在bearing和relief上。
##		bearing_mid_to_bot = 1.947   ## 一般取2   bering mid to bot
##		bearing_length = bearing_D*0.35   ## 这是规律
##		joint_to_bearing_top = 0.5*(bearing_D - joint_D)/tanD(reduction_angle/2.0)
##		nib_thick = nib_R - bearing_D/2		;please_check

		## 2. relief
		relief_dy = bearing_length	## 这是规律
		relief_angle = 27

		## 3. exit
##		exit_dy = bearing_mid_to_bot - 1.5*bearing_length
		exit_angle = 90

		## 4. reduction
	##	reduction_angle = 11
	##	reduction = 0.2
##		reduction_dy = joint_to_reduction_top - joint_to_bearing_top
##		wire_D = joint_D/(1-reduction)	## 这是规律, 是直径的缩减率，不是面积的缩减率。  (根据joint_D可以知道wire_D，所以提供stp文件给客户即可)
		wire_D = 0.889
		wire_R = wire_D/2.0

		## 5. approach
		approach_angle = 40
##		approach_dy = nib_H - exit_dy - relief_dy - bearing_length - reduction_dy
		## 不需要知道approach_H，因为会倒圆角bell_R
		approach_reduction_round = 1.0

		## 6. bell (round)
		bell_R = 2.3

		## nib corner cut
		cut_angle_y = 45	  			;changing
		if cut_angle_y == 15:
			cut_height = 1.0  ## nib
			cut_round = 5.65
		else:
			cut_height = 0.5
			cut_round = 0

		## case file: 75-E-464-31-P010
		case_OD = 28   ## case type: 28x14
		case_H = 14
		case_R = case_OD/2.0

		interference = 0.03		;changing   ## 9*6 nib: 20-40um, 12*10 nib: 40-60um
		case_ID = nib_OD - interference*2	;changing  ## use shrink fit, not initial_closure

		case_entrance_cut = 1.5
		case_entrance_cut_angle = 30

		rivet_H = 0.5
		rivet_ID = 8
		rivet_L = (nib_OD - rivet_ID)/2.0
		rivet_R = rivet_ID/2
		rivet_offset = 0.004 	;changing1	## offset in height, rivet与nib之间的间隙，考虑shrink fit后会消除。

		nib_to_top = 0.7
		nib_bot_to_bot = case_H - nib_to_top - nib_H

		case_land_H = 0.5   ## 0.3-0.5
		case_land_ID = 6.5   ## different for another drawing(3.5)
		land_corner_R = 0.1   ## this corner is corresponding to the chamfer in the nib.

		case_exit_H = nib_bot_to_bot - case_land_H
		case_exit_angle = 60

		case_corner_chamfer = 1.0


	locals2globals(locals0,locals(),save_var=True)

	return

def main_A0232_wiredraw_919():
	## VER: 2015-01-14, v1.0

	check_script_file('DN_A0232_fric01_deg30.py')
	purpose = 'parameter study from Paramount.'
	history='DM: based on D2; CD:compare with BD; Based on AM; AU: mass scale=0.1; AS: use mass scale; A9: add thermal properties; A5:add heat transfer; A1: model for implicit to explicit'

	existed_cae = 'CH_A0232_explicit_fric01_316L_deg60'	;changing1
	existed_odb = 'CH_A0232_explicit_fric01_316L_deg60'	;changing1

	locals0 = locals().keys()   ## need both stp file and assembly file with bearing dimensions.
	## for D12H10 nib, the bearing diameter=0.8mm, then wire diameter= 0,889
	## for D9H6 nib, the bearing diameter=0.1mm, then wire diameter=0,111
	## bell->approach -> reduction -> bearing -> relief->exit

	nib_type = 'D9H6'		;changing1   ## D6H7, D9H6


	analysis1 = 1				;changing   ## 1, 12, None
	antype1 = 'stress'				;changing	## stress, thermal_stress
	analysis1_title = inp_file_title	;changing1

	analysis2 = 2				;changing	## 2, None
	analysis2_title = analysis1_title + '_drawing'	;changing1

	friction = 0.1			;changing
	draw_time = 1.5e-4  		;changing1
	carbide_yield = 5000	;changing1

	if analysis1 in empty:
		open_cae(existed_cae, new_name=analysis1_title)
	else:
		blank_cae(analysis1_title)

##	raise Exception

	get_nib_dimensions(nib_type)

	## wire
	wire_length = 20		;changing1
	wire_cut_H = 1
	speed = -16*1000		;changing1
	wire_cut_x=0.1
	wire_cut_y = 0.2

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'
	wire = 'wire'
	wire_A1 = 'wire_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

##	raise Exception
	material_database()
	create_contact_props(friction=friction)				;changing

##	raise Exception

	## wire elastic
##	wire_plastic = (275,0), (690, 0.2), (960, 0.4), (1206, 0.6), (1654, 1), (2240, 1.6)  ## hardening steel
##	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
##	set_plastic('Steel', wire_plastic)	;changing
##	set_plastic('Steel', (500, 0))	;changing

	wire_plastic = (425,0,20),(575,0.03,20),(660,0.06,20),(730,0.09,20),(760,0.12,20),(790,0.15,20), \
					(400,0,200),(530,0.03,200),(610,0.06,200),(660,0.09,200),(700,0.12,200),(710,0.15,200)
	set_plastic('Steel_SS316L', wire_plastic)	;changing1

	set_plastic('H3F',(carbide_yield,0))		;changing1

##	raise Exception

	if analysis1 not in empty:
		if analysis1 == 2:
##			open_cae('_imported_' + nib_type, new_name=analysis1_title)
			open_cae(existed_cae, new_name=analysis1_title)

			edges = edge_select('nib0',x=(MID,MAX),z=MAX)
			sketch = edges_to_sketch(edges,sketchname='sk_nib')
			s1 = sketch['sketch']

			if cut_angle_y == 45:
				loc1 = find_loc(s1,x=MAX,groupY=MIN)
				loc2 = find_loc(s1,y=MIN,groupX=MAX)

				edges = geometry_select(s1,x=(loc1[0],loc2[0]),y=(loc1[1],loc2[1]))
				del_geometry(s1,edges)
				connect_points(s1,loc2,('x',_xmax(s1)),loc1)

				sketch_to_shell(s1,partname='nib',symmetric=True)
				bias_cut('nib',cut_sides='bot_right',point1=(_xmax('nib'),_ymin('nib') + cut_height),angle_with_Y=cut_angle_y)

			else:
				sketch_to_shell(s1,partname='nib',symmetric=True)

			edges = edge_select('case0',x=(MID,MAX),z=MAX)
			sketch = edges_to_sketch(edges,sketchname='sk_case')
			s1 = sketch['sketch']
			sketch_to_shell(s1,partname='case',symmetric=True)

			new_instance('nib')
			new_instance('case')

		else:
			## Nib
			s1 = create_base_sketch('sk_nib')
			loc0 = (bearing_R,0)
			loc1 = loc0

			if relief_dy > 0:
				connect_points(s1,loc0,ytilt(-relief_dy,relief_angle/2))
				loc1 = last_point
			connect_points(s1,loc1,ytilt(-exit_dy,exit_angle/2),('x',nib_R),('dy',nib_H))

			if bearing_length > 0:
				connect_points(s1,loc0,('dy',bearing_length))
				loc1 = last_point

			if approach_angle not in empty:  ## there is approach slope line
				locs = connect_points(s1,loc1,ytilt(reduction_dy,reduction_angle/2),ytilt(approach_dy,approach_angle/2),('x',nib_R))
				round_sketch_corner(s1,loc=locs[-2],radius=bell_R)
			else:
				line1 = slope_construction(s1,loc=loc1,angle=90 - reduction_angle/2)
				dict1 = create_tangent_circle(s1,radius=bell_R,center_x=10, center_y=(MAX,-bell_center_to_top),tangent_line=line1, toY=_ymax(s1))
				connect_points(s1,loc1,dict1['start'])
				connect_points(s1,dict1['end'],('x',nib_R))
				round_sketch_corner(s1,loc=dict1['end'],radius=bell_round)

			sketch_to_shell(s1,partname='nib',symmetric=True)

			move_part(nib,y1=MIN,y2=nib_bot_to_bot)
			bias_cut(nib,cut_sides='bot_right',point1=(nib_R,_ymin(nib) + cut_height), point2=(nib_R - cut_width,_ymin(nib)))
##			bias_cut(nib,cut_sides='bot_right',point1=(nib_diameter/2,_ymin(nib) + cut_height), angle_with_Y = 15)

			round_corner(nib,x=MAX,groupY=MIN,radius=cut_round)

			edges = edge_select(nib,nx=-1,ny=-1,y=MIN1)
			divide_edge(edges=edges[0],xpar=0.4)

			new_instance(nib)

	##		raise Exception

			## case
			s1 = create_base_sketch('sk_case')
			loc0 = (case_land_ID/2,nib_bot_to_bot)	## nib的底面

			connect_points(s1,loc0,('dy',-case_land_H),ytilt(-nib_bot_to_bot + case_land_H, case_exit_angle/2), ('x',case_R),('y',case_H))
			locs = loc0,('x',case_ID/2),('dy',nib_H + rivet_offset),('dx',-rivet_L),('dy',rivet_H),('dx',rivet_L)
			connect_points(s1,points=locs)

			connect_points(s1,last_point,('y',case_H),('x',case_R))

			sketch_to_shell(s1,partname='case',symmetric=True)

			bias_cut(case,cut_sides='bot_right',point1=(case_R,case_corner_chamfer),angle_with_Y=45)
			bias_cut(case,cut_sides='top_right',point1=(case_R,case_H - case_corner_chamfer),angle_with_Y=45)

			loc = find_loc(case,y=MAX,groupX=MIN)
			bias_cut(case,cut_sides='top_left',point1=(loc[0],loc[1] - case_entrance_cut,0),angle_with_Y=case_entrance_cut_angle)

			new_instance(case)

	##	divide(case,y=_ymin(nib,x=MAX))

		## wire
		create_rectangle_shell('wire',corner1=(0,0),corner2=(wire_R, wire_length),axis_symmetric = True)
		move_part(wire,y1=MIN,y2=_ymin(nib) + 1.5)

	##	bias_cut(wire, cut_sides='bot_right', point1=(wire_R, _ymin(wire) + 0.2, 0), point2=(wire_R*0.7, _ymin(wire), 0))
		bias_cut(wire,cut_sides=('+x','-y'), point1=(wire_R, _ymin(wire) + wire_cut_H), point2=(wire_R/2,_ymin(wire)))
	##	round_corner(wire,radius=5,x=MAX,groupY=MIN)

		vertices = vertice_select(wire,x=MAX,groupY=MIN)
		ignore_vertices(wire,vertices=vertices)

		new_instance(wire)

	##	divide(wire,y=_ymin(wire) + wire_cut_H)
		divide(wire,y=_ymin(wire) + wire_cut_H + 0.5)	;changing1

		set_mat(nib,mat='H3F')
		set_mat(case,mat='Steel_C45')
##		set_mat(wire,mat='Steel')	;changing1
		set_mat(wire,mat='Steel_SS316L')	;changing

		## step
		times1 = myrange(0,1,0.05)
		timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1

		times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,10, 0.5) + myrange(11,200, 2.0)		;changing1
		timepoints2 = create_timepoints(times2,factor=1e-5)

		if analysis1 == 1:
			create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)
			field_output_request(timepoints=timepoints1,variables=ALL)
		elif analysis1 == 12:
			if 'temp' not in antype1:
				create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
##				create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='transient',matrix_storage='UNSYMMETRIC')
				create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
			else:
				create_coupled_temp_displacement_step(stepname='shrink_fit',period=4e-5)
				create_coupled_temp_displacement_step(stepname='draw',timePeriod=draw_time,response='transient')
			field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

		## create surfaces
		edges = edge_select(case_A1,ny=1,groupY=MIN)
		create_surface('case_land',edges=edges)

		please_check
		edges = edge_select('case_A1',nx=-1,x=(MIN1,MAX),y=_yspace('nib'))
		create_surface('case_ID',edges=edges)

		please_check
		edges1 = edge_select(nib_A1,nx=1)  ## use for general contact
	##	edges1 = edge_select(nib_A1,x=MAX,y=MID)
		create_surface('nib_OD',edges=edges1)

		edges = edge_select(nib_A1,nx=1,ny=-1)
	##	edges = unselect(edges, edges1)
		create_surface('nib_corner', edges=edges)

		edges = edge_select(case_A1,x=case_ID/2,y=_ymin(nib,x=MAX) - 0.1)
		create_surface('case_corner',edges=edges)

		edges = edge_select(nib_A1,y=MIN)
		create_surface('nib_bot', edges=edges)

		edges3s = edge_select(wire_A1,nx=1)
		create_surface('wire_surf',edges=edges3s)

		vertices = vertice_select(nib_A1,x=MIN)
		edges3m = vertices_to_edges(vertices)
		create_surface('nib_surf',edges=edges3m)

		edges1 = edge_select(nib_A1,y=MAX)
		create_surface('nib_top',edges=edges1)

		edges2 = edge_select(case_A1,y=_ymax(nib_A1) + rivet_offset)
		create_surface('rivet_bot',edges=edges2)

		get_current_model()

	##	raise Exception

		## mesh case
		edges = edge_select(case,x=(MIN,case_ID/2.0 + 0.1),y=(MIN1,MAX1))
		seed_edges(case,edges=edges,esize=0.15)	;changing1

		mesh_2D(case,esize=0.5)		;changing1

		## mesh nib
	##	esize = 0.02	;changing
	##	edges = edge_select(nib,nx=-1,y=(MIN,MID))

		esize = round(min(bearing_length/3,0.05),3)
	##	edges = edge_select(nib,x=(MIN,MIN1))
		edges = edge_select(nib,poiRefX=(MIN,wire_R))
		seed_edges(nib,edges=edges, esize=esize)			;changing1

	##	edges = edge_select(nib,x=MIN)
	##	seed_edges(nib,edges=edges, enum=4)		;changing1

	##	edges = edge_select(nib,nx=1)
	##	seed_edges(nib,edges=edges,esize=0.1)

		mesh_2D(nib,esize=0.15)	;changing1

		## mesh wire
		edges = edge_select(wire,y=MAX) + edge_select(wire,y=MIN)
		seed_edges(wire,edges=edges,enum=12)	;changing1 ## enum

		mesh_2D(wire,esize=esize)

##		raise Exception

		## 以下适用于已经存在过盈
		create_general_contact_std(friction='Friction + Heat generation',interference_pairs=(('nib_OD','case_ID','interfernce_fit')))	;changing1

		## Fix
		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		if analysis1 == 12:
			edges = edge_select(wire_A1,y=MAX)
			apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0,deactive_step='step2')

			faces = face_select(wire_A1,y=MIN1,mark_select=True)
			apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing1

			if 'temp' in antype:
				set_temperature_predefined_field(initial_step=20)	;changing1

				edges = edge_select(wire_A1,nx=1)
				apply_surface_convection('wire_convection',faces=edges,h = 1000,step='step2')	;changing1

				edges = edge_select(nib_A1,nx=-1)
				apply_surface_convection('nib_convection',faces=edges,h = 1000,step='step2')		;changing1

		else:
			edges = edge_select(wire_A1,y=MAX)
			apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0)

		_results_dict = { 'Nib':('S1','PEEQ'), 'CASE':('U','Mises','PEEQ')}

##		existed_odb = analysis1_title	;changing1
		create_inp(analysis1_title,request_num=6,submit=False)
		mdb.jobs[analysis1_title].submit()

##		raise Exception

	if analysis2 not in empty:
		if analysis1 not in empty:
			mdb.jobs[analysis1_title].waitForCompletion()

		copy_model(to_name = 'draw')
		del mdb.models['Model-1']
		clear_model_settings()
		create_heat_from_plastic_work(['wire','nib'])

	##	raise Exception
		times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,10, 0.5) + myrange(11,200, 2.0)		;changing1
		timepoints2 = create_timepoints(times2,factor=1e-5)

##		raise Exception

		create_coupled_temp_displacement_step(step='draw', timePeriod=draw_time, response='dynamic')	;changing1
##		create_dynamic_explicit_step(step='draw', timePeriod=draw_time)
		field_output_request(timepoints=timepoints2)

##		choose_element_type('case')
##		choose_element_type('nib')
##		choose_element_type('wire')
		choose_element_types()
		import_initial_stress(analysis1_title)				;changing1
		set_temperature_predefined_field(initial_step=20)	;changing1

##		create_general_contact_exp(prop='Friction + Heat generation')	;changing  ## not supported for 2D

##		changing1
		s2s_interact_exp('int_nib_support', mfaces='nib_bot', sfaces='case_land', prop='Friction + Heat conduction',sliding='small')

		s2s_interact_exp('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',prop='Friction + Heat conduction',sliding='small')

		s2s_interact_exp('int_nib_rivet', mfaces='nib_top', sfaces='rivet_bot',prop='Friction + Heat conduction',sliding='small')

	##	s2s_interact_exp('int_nib_corner',mfaces='nib_corner',sfaces='case_corner')  ## 在有初始过盈的情况下，必须设置shrink fit,否则一开始由于侵入，不收敛。
	##	s2s_interact_exp('int_nib_corner2',mfaces='nib_corner',sfaces='case_land')

		s2s_interact_exp('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',prop='Friction + Heat generation')

##		raise Exception

		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
		apply_velocity(name='pull_speed',faces=faces, Vy=speed)	;changing

		edges = edge_select(wire_A1,nx=1)
##		apply_surface_convection('wire_convection',faces=edges,h = 'Heat convection')
		apply_surface_convection('wire_convection',faces=edges,h = 1000)	;changing1

		edges = edge_select(nib_A1,nx=-1)
##		apply_surface_convection('nib_convection',faces=edges,h = 'Heat convection')
		apply_surface_convection('nib_convection',faces=edges,h = 1000)		;changing1

		mdb.saveAs(analysis2_title)

		create_inp(analysis2_title,clear_jobs=False)
		mdb.jobs[analysis2_title].submit()


	return

def main_A0237_sintering_process():
	## VER: 2015-04-07, v1.0

	check_script_file('AO_A0237_CTE_delta1_Rh060.py')
	purpose = 'simulating the sintering process, with simplified CTE method, import the initial green density distribution.'
	history = 'A1: based on D2_A0232'

	locals0 = locals().keys()
	powder = 'powder'	;	powder_A1 = 'powder_A1'
	analysis1_title = inp_file_title

	cylind_R = 3
	cylind_H = 22
	Rh0 = 0.6			;changing
	low_T = 20			;changing1
	deltaT = 1			;changing
	C1 = 0.02			;changing
	high_T = deltaT + low_T
	segment = False		;changing

	locals2globals(locals0,locals(),save_var=True)

	blank_cae(analysis1_title)

	s1 = create_base_sketch('s_powder')
	connect_points(s1,(0,0),(cylind_R,0),(cylind_R,cylind_H),(0,cylind_H),(0,0))
	sketch_to_shell(s1,partname='powder',symmetric=True)

	material_database()
	create_contact_props(friction=0.1)				;changing1

##	set_mat(powder,mat='H10F')

	divide(powder, y=15)
	divide(powder, y=7)

	CTE1 = density_with_PEG_to_CTE(0.5,deltaT=deltaT,C1=C1)
	CTE2 = density_with_PEG_to_CTE(0.55,deltaT=deltaT,C1=C1)
	CTE3 = density_with_PEG_to_CTE(0.6,deltaT=deltaT,C1=C1)
	CTE = density_with_PEG_to_CTE(Rh0, deltaT=deltaT, C1=C1)

	modulus = get_bulk_modulus(583000, 0.23)	;changing
	mat1 = create_simple_material('mat1',modulus=modulus, poisson=0.23, CTE=CTE1)
	mat2 = create_simple_material('mat2',modulus=modulus, poisson=0.23, CTE=CTE2)
	mat3 = create_simple_material('mat3',modulus=modulus, poisson=0.23, CTE=CTE3)
	mat = create_simple_material('mat',modulus=modulus, poisson=0.23, CTE=CTE)

	if segment == True:
		faces = face_select(powder,y=MAX1)
		set_mat(powder, objs=faces, mat=mat3)	;changing1

		faces = face_select(powder,y=MID)
		set_mat(powder, objs=faces, mat=mat2)	;changing1

		faces = face_select(powder,y=MIN1)
		set_mat(powder, objs=faces, mat=mat1)	;changing1

	else:
		set_mat(powder, mat=mat)

##	raise Exception

##	set_CTE('H10F',CTE)			;changing
##	set_modulus('H10F',200000)	;changing

	new_instance(powder)

	create_general_static_step()

	mesh_2D(powder,esize=0.5)

	## load, BC
	set_temperature_predefined_field(initial_step=high_T, modifys=('step1',low_T))	;changing1

	edges = edge_select(powder_A1,y=MIN)
	apply_disp_fix('bot_fix',edges=edges,Uy=0, UR3=0)

	create_inp(analysis1_title,request_num=6,submit=False)
	mdb.jobs[analysis1_title].submit()

	return

def main_A0238_HPHT_PDC():
	## VER: 2014-04-22, v1.0, PDC cutter residual analysis
	## started on: 2014-04-22

	check_script_file('A8_A0238_PDC_model.py')		;changing
	history = 'A5: based on new corrected geometry; A1: based on DN_A0232_fric01_deg30'

##	import_stp('458400001_new.stp', part_names={1:'carbide',2:'diamond'},scale=25.4)
	open_cae('_A0238_model_imported.cae', new_name=inp_file_title)

##	raise Exception

	## Source: tooling report,
	H11N_plastic = ((2070.0, 0.0, 25.0),
			(1940,0.0, 250.0),
			(1200,0.0, 750),  (1800, 0.005,  750),
			(800, 0.0, 800),  (1450, 0.0075, 800),
			(580, 0.0, 900),  (950,  0.0075, 900),
			(250, 0.0, 1000), (500,  0.02,   1000),
			(250, 0.02, 1100))                        ;changing
##			(50,  0.0, 1200), (50,   0.025,  1200)   ## 变形不属于塑性变形，也对室温的应力实际贡献不大。

	set_plastic('H11N', H11N_plastic)

##	H11N_elastic = (569419.0, 0.22, 25.0), (566120.0, 0.22, 100.0), (560551.0, 0.23, 200.0),  \
##				   (554344.0, 0.23, 300.0), (547997.0, 0.23, 400.0), (541515.0, 0.23, 500.0),  \
##				   (534469.0, 0.23, 600.0), (525941.0, 0.23, 700.0), (514549.0, 0.23, 800.0)

	E0 = 570000  ## 570GPa
	H11N_elastic = (1.0*E0, 0.22, 25), (0.98*E0, 0.22, 200), (0.96*E0, 0.23, 400), (0.94*E0, 0.23, 600), (0.9*E0, 0.23, 800), (0.86*E0, 0.23, 900),  \
					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200)	;changing
##					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200), (0.205*E0, 0.24, 1300)

	set_modulus('H11N', H11N_elastic)

##	H11N_expansion = (5.21e-06, 25.0), (6.78e-06, 800.0) ## Source: ludwig report

##	H11N_expansion = (5.21e-06, 25.0), (5.6e-06, 200.0), (5.99e-06, 400.0), (6.39e-06, 600.0), (6.78e-06, 800.0) ## Source: ludwig report
###	H11N_expansion = (5.21e-06, 25.0), (5.6e-06, 200.0), (5.99e-06, 400.0), (6.39e-06, 600.0), (6.78e-06, 800.0), (7.18e-6, 1000), (7.56e-6, 1200)   ## 线性拟合外推 (Source: ludwig report)
##	H11N_expansion = (5.8e-6, 20), (6.8e-6, 200), (6.7e-6, 300), (6.0e-6, 400), (5.9e-6, 500), (5.7e-6, 600), (5.5e-6, 700), (5.4e-6, 800),  \
##					(5.5e-6, 900), (5.4e-6, 1000), (5.4e-6, 1200)  ## Source: tooling report, TM R&D 44600, room temp to high temp
##	H11N_expansion = (5.8e-6, 25), (5.4e-6, 1200)  ## Only two ends

##	H11N_expansion = (5.8e-6, 20), (6.45e-6, 200), (6.55e-6, 300), (6.4e-6, 400), (6.3e-6, 500), (6.2e-6, 600), (6.1e-6, 700), (6.0e-6, 800),  \
##					(5.9e-6, 900), (5.8e-6, 1000)  ## Source: tooling report, TM R&D 44600, H10F, transient CTE

	H11N_expansion = (5.2e-6, 20), (5.4e-6, 400), (5.7e-6, 800)   ## H11N by Stefan

##	H11N_expansion = (5.4e-6, 400), (5.7e-6, 800)  ## Source: tooling report (stress level is high)
	set_CTE('H11N', H11N_expansion)	;changing1

	## H11
	copy_material('H11N','H11')
	H11_elastic = (0.001*E0, 0.22, 22),(0.1*E0, 0.22, 23),(0.5*E0, 0.22, 24),(1.0*E0, 0.22, 25), (0.98*E0, 0.22, 200), (0.96*E0, 0.23, 400), (0.94*E0, 0.23, 600), (0.9*E0, 0.23, 800), (0.86*E0, 0.23, 900),  \
					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200)	;changing
##					(0.81*E0, 0.24, 1000), (0.715*E0, 0.24, 1100), (0.522*E0, 0.24, 1200), (0.205*E0, 0.24, 1300)

	set_modulus('H11',H11_elastic)

	## PCD
	PCD_expansion = (1.72e-6, 20), (2.39e-6, 200), (3.06e-6, 400),(3.72e-6, 600), (4.39e-6, 800)
	set_CTE('PCD',PCD_expansion)

	changing1
##	PCD_elastic = (875000, 0.14, 25), (850000, 0.14, 600), (820000, 0.14, 700), (200000, 0.14, 1300)
	PCD_elastic = (1045000, 0.14, 25), (990000, 0.14, 700), (415000, 0.14, 1300)	 ## decrease by 5% at 700degC.
##	PCD_elastic = (1045000, 0.14, 25), (990000, 0.14, 700)		;changing	 ## decrease by 5% at 700degC.
	set_modulus('PCD', PCD_elastic)

	## PCD1
	copy_material('PCD','PCD1')
	PCD1_elastic = (1045000*0.001, 0.14, 22),(1045000*0.1, 0.14, 23), (1045000*0.5, 0.14, 24), (1045000, 0.14, 25), (990000, 0.14, 700), (415000, 0.14, 1300)	 ## decrease by 5% at 700degC.
	set_modulus('PCD1',PCD1_elastic)

	locals0 = locals().keys()

	## original
	diamond_D0 = 16.9672    ## 17.5768
	diamond_H0 =  2.9

	shrink = 0.05	;changing
	neck_D0 = 17.0394	## 17.0434
	interface_D = neck_D0
	neck_D0 = neck_D0 - shrink

	carbide_H0 = 6.80212
	carbide_D0 = 17.7546
	total_H0 = diamond_H0 + carbide_H0  ## 10.032

	## diameter scale and pressing dimensions
##	diamond_Hg = diamond_H0		;changing		## original: 2.92
##	carbide_Hg = carbide_H0						## original: 9.112
##	total_Hg = carbide_Hg + diamond_Hg			## original: 10.032

	## green part
	diamond_Hg = 3.0						;changing  ## diamond_Hg一般2mm左右。
	carbide_Hg = total_H0 - diamond_Hg		;changing
	total_Hg = diamond_Hg + carbide_Hg
##	carbide_Hg = total_Hg - diamond_Hg
	neck_Dg = neck_D0			;changing1
	radius = neck_Dg/2

	thick_ratio = round(diamond_Hg/total_Hg, 2)
	D_ratio = round(neck_Dg/neck_D0,2)
##	D_ratio = 1.0		;changing


	## after material remove (cutted)
##	diamond_Hc = 2.1
##	total_Hc = 8.0
##	carbide_Hc = 5.9
##	cylind_D = 15.875

	diamond_Hc = 2.1		;changing
	total_Hc = 8.0
	carbide_Hc = total_Hc - diamond_Hc
	cylind_D = 15.875
	final_R = cylind_D/2.0    ## 7.9375

	axial_tor = 0.04	;changing1
	radial_tor = 0.045	;changing1
	carbide_cut = carbide_Hg - carbide_Hc - axial_tor
	diamond_cut = diamond_Hg - diamond_Hc - axial_tor

	create_geometry = True		;changing
	remove = True				;changing
	cal_time = 270				;changing1
	if remove == False:
		cal_time = 250

	high_temp = 1200   ;changing1
	room_temp = 25
	half_symm = False	;changing1
	merge = True
	transient = False	;changing1
	esize = 0.5			;changing1
	temperature_only = False	;changing1
	pressure_only = False		;changing1
	increase_press = False		;changing1

	if increase_press == True:
		high_temp = 1300
	elif temperature_only == True:
		high_temp = 1300
	elif pressure_only == True:
		high_temp = 25

	carbide = 'carbide'
	diamond = 'diamond'
	compound = 'compound'
	plate = 'plate'

	carbide_A1 = 'carbide_A1'
	diamond_A1 = 'diamond_A1'
	compound_A1 = 'compound_A1'
	plate_A1 = 'plate_A1'

	locals2globals(locals0,locals(),save_var=True)

	if neck_Dg - cylind_D < 0.3:
		print neck_Dg - cylind_D
		raise Exception('*** too small neck_Dg or too large cylind_D')

	if remove == True:
		if carbide_cut < 0.1:
			print ' '
			print fnln(),'(carbide_Hg, carbide_Hc, axial_tor, carbide_cut)=',(carbide_Hg, carbide_Hc, axial_tor, carbide_cut)
			print ' '
			raise Exception('*** carbide_cut is too small: ' + str(carbide_cut))

		if diamond_cut < 0.1:
			print ' '
			print fnln(),'(diamond_Hg, diamond_Hc, axial_tor, carbide_cut)=',(diamond_Hg, diamond_Hc, axial_tor, carbide_cut)
			print ' '
			raise Exception('*** diamond_cut is too small: ' + str(diamond_cut))

	if high_temp == 1300:  ## 25sec时才将到1300度
		temp_table = ((0, 1300), (25, 1300), (28, 1292), (31, 1275), (34, 1256), (37, 1240), (40, 1222),
			(43,1200), (50, 1167), (53,1147), (56,1126), (59, 1100), (62,1084), (65,1063),(75, 1000), (90, 882),
				(99, 812), (108, 741), (121, 647), (130, 577), (139, 507), (151, 415), (166, 324), (179, 242),
				(188, 198), (198, 166), (213, 132), (229, 112), (241, 90), (250, 25),(255,25),(260,24),(265,23),(270,22))	;changing1

		## 25sec时，压强开始施加
		press_table = ((0,0), (25, 0), (30,7400), (37, 7400), (43,7400), (50, 7300),
				(59, 7120), (75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

		if increase_press == True:
			table1 = press_table[2:-2]
			table1 = shift_table(table1,dy=-7400)
			table1 = shift_table(table1,absolute=True)
			table1 = tolist(press_table[:2]) + tolist(table1) + tolist(press_table[-2:])
			table1 = totable(table1)
			press_table = table1
			save_user_data(press_table)
			print fnln(),table1
##  ((0, 0), (25, 0), (30, 0), (37, 0), (43, 0), (50, 100), (59, 280), (75, 580), (90, 920), (99, 1100), (108, 1300), (121, 1600), (130, 1800),
##  (139, 2000), (151, 2300), (166, 2800), (179, 3400), (188, 3800), (198, 4300), (213, 5100), (229, 6000), (241, 6700), (250, 7400), (255, 0), (270, 0))

	elif high_temp == 1200: ## 43sec时，才降到1200degC
		temp_table = ((0, 1200),  (43,1200), (50, 1167), (53,1147), (56,1126), (59, 1100), (62,1084), (65,1063),(75, 1000), (90, 882),
				(99, 812), (108, 741), (121, 647), (130, 577), (139, 507), (151, 415), (166, 324), (179, 242),
				(188, 198), (198, 166), (213, 132), (229, 112), (241, 90), (250, 25),(255,25),(260,24),(265,23),(270,22))	;changing1

		## 43sec时，压强开始施加
		press_table = ((0,0),(43,0), (50, 7300), (59, 7120), (75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

		if increase_press == True:
			table1 = press_table[2:-2]
			table1 = shift_table(table1,dy=-7400)
			table1 = shift_table(table1,absolute=True)
			table1 = tolist(press_table[:2]) + tolist(table1) + tolist(press_table[-2:])
			table1 = totable(table1)
			press_table = table1
			save_user_data(press_table)
			print fnln(),table1

##		((0, 0), (43, 0), (50, 100), (59, 280), (75, 580), (90, 920), (99, 1100), (108, 1300), (121, 1600), (130, 1800), (139, 2000),
##		(151, 2300), (166, 2800), (179, 3400), (188, 3800), (198, 4300), (213, 5100), (229, 6000), (241, 6700), (250, 7400), (255, 0), (270, 0))

	elif high_temp == 1100:
		temp_table = ((0, 1100),  (59, 1100), (62,1084), (65,1063),(75, 1000), (90, 882),
				(99, 812), (108, 741), (121, 647), (130, 577), (139, 507), (151, 415), (166, 324), (179, 242),
				(188, 198), (198, 166), (213, 132), (229, 112), (241, 90), (250, 25),(255,25),(260,24),(265,23),(270,22))

		## 59sec时，压强开始施加
		press_table = ((0,0),(59, 0), (65,6950),(75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

	if pressure_only:
		temp_table = (0,25),(250, 25),(255,25),(260,24),(265,23),(270,25)

		press_table = (0,0),(5, 7400), (250, 740),(255,0),(270,0)
##		press_table = ((0,0), (25, 0), (30,7400), (37, 7400), (43,7400), (50, 7300),
##				(59, 7120), (75, 6820), (90, 6480), (99, 6300), (108, 6100), (121, 5800),
##				(130, 5600), (139, 5400), (151, 5100), (166, 4600), (179, 4000),
##				(188, 3600), (198, 3100), (213, 2300), (229, 1400), (241, 700), (250, 0),(255,0),(270,0))	;please_check

	_m.TabularAmplitude(name='Amp_temp', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(temp_table))
	_m.TabularAmplitude(name='Amp_press', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(press_table))

	times1 = [0.001, 0.005, 0.01, 0.05, 0.1, 0.2, 0.4, 0.6, 0.8, 0.9, 0.95, 1.0]
	timepoints1 = create_timepoints(times1, name='TimePoints-1', factor=5)	;changing1

	times2 = [0.001, 0.01, 0.02, 0.04, 0.06, 0.08, 0.1, 0.12, 0.14, 0.16, 0.18, 0.2, 0.25, 0.3,0.35, 0.4, 0.45, 0.5,0.55, 0.6,0.65, 0.7,0.75, 0.8,0.85, 0.9, 0.95, 1.0]
	times2 = scale_list(times2,270) + [1, 2, 12, 25, 37, 50, 59, 74, 90, 99, 108, 121, 130, 139, 151, 166, 179, 188, 198, 213, 229, 241, 250, 255, 260, 265, 270]
	timepoints2 = create_timepoints(times2, name='TimePoints-2')

##	temp_table2 = (0,1200),    (10,200),(15,25),  (20,25),(25,24),(30,23),(35,22)	;changing
##	press_table2 = (0,0),(9,0),(10,7400),(15,7400),(20,0),(35,0)
##
##	times3 = (0,9,10,15,20,25,30,35)
##	timepoints3 = create_timepoints(times3, name='TimePoints-3')
##
##	_m.TabularAmplitude(name='Amp_temp2', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(temp_table2))
##	_m.TabularAmplitude(name='Amp_press2', timeSpan=STEP, smooth=SOLVER_DEFAULT, data=totable(press_table2))

	create_general_static_step('cooling', period=cal_time)
	if remove == True:
		create_general_static_step('remove', period=5)	;changing1

	field_output_request(timepoints={'cooling':timepoints2, 'remove':timepoints1},later_remove=('remove','P'))  ;changing1
##	raise Exception

	if create_geometry == True:
		cylinder_grow('car1',ndir='y',OD1=neck_D0, OD2=carbide_D0, L12=carbide_H0,L=10)			## 多长些
		cylinder_grow('dim1',ndir='y',OD1=neck_D0, OD2=diamond_D0, L12=diamond_H0, L=-10)

		edges = edge_select('interface',diameter=interface_D)
		x1,x2,y1,y2,z1,z2 = objs_space(edges)  ## 确保其高度与neck的位置重合。

		new_instance('car1')
		new_instance('dim1')
		move_instances('interface_A1',y1=y1,y2=0)

		merge_instances(insts=['car1_A1','dim1_A1'], partname='compound0',boundary='remove')
		new_instance('compound0')

		## 用界面来partition
		boolean_divide('compound0', cutters='interface_A1', del_cutters=True)

		## compound0缩放
		if PK(neck_Dg, neck_D0) != 0:
			scale_part(compound0,'compound', scale=neck_Dg/neck_D0)
		else:
			rename('compound0','compound')

		new_instance(compound)

##		raise Exception

		## 切掉多余的
		faces = face_select(compound)
		edges = edge_select(compound,edir='circular',y=(MIN1,MAX1),faces=faces,groupY=MIN)
		yloc = edges[0].pointOn[0][1]
		yloc = round(yloc,5)

		if _ymax(compound) - yloc > carbide_Hg:
			bias_cut(compound,cut_sides='+y',y=yloc + carbide_Hg)

		if yloc - _ymin(compound) > diamond_Hg:
			bias_cut(compound,cut_sides='-y',y=yloc - diamond_Hg)

		cells = cell_select(compound,y=MIN1)
		set_mat(compound,cells=cells,mat='PCD')

		cells = unselect(compound,cells)
		set_mat(compound,cells=cells,mat='H11N')

##		raise Exception
		bias_cut(compound, cut_sides='-x', x=MID)
		bias_cut(compound, cut_sides='+z', z=MID)

		create_rigid_plane('plate',length=15,width=15,ndir='y',offset=_ymin(compound),xmin=0,zmax=0)
		new_instance('plate')

##		raise Exception

		if remove == True:
			divide(compound,y=_ymin(compound) + diamond_cut)
			divide(compound,y=_ymax(compound) - carbide_cut)

			circular_divide('compound', ndir='y',D=cylind_D + 2*radial_tor, center=(0,0,0))

			cells = cell_select(compound,mat='H11N',groupY=MIN)
			cells1 = unselect(_mat(compound,mat='H11N'),cells)
			cross_set_mat(compound,cells=cells1,mat='H11')

			cells = cells_in_y('compound')[1]
			cells1 = cell_select(compound,mat='PCD')
			cells1 = unselect(cells1,cells)
			cross_set_mat(compound,cells=cells1,mat='PCD1')

##		s1 = create_base_sketch('s_plate',ndir='y')
##		s1.rectangle(point1=(0.0, 0.0), point2=(15, -15))
##		_m.Part(name='plate', dimensionality=THREE_D, type=DISCRETE_RIGID_SURFACE)
##		p = _m.parts['plate']
##		p.BaseShell(sketch=s1)
##		get_current_model()
##		rotate_part('plate',angle_x=90, rotate_center=(0,0,0))
##
##		move_part('plate',x1=MIN,x2=0, y1=MIN,y2=_ymin(compound_A1), z1=MAX,z2=0)	;changing1
##		new_instance('plate')

	## mesh (mesh region可以用于interact and load, BC)
	choose_element_type(compound)
	set_element_shape(compound,eshape='TET')
	mesh_region(compound,esize=esize,try_twice=True)	;changing1

	hex_mesh('plate',esize=esize)	;changing1

##	raise Exception

	## interact
	sfaces = face_select(compound_A1,y=MIN)
	mfaces = create_surface(faces=_inst(plate_A1).faces, side='+y')	;changing1
	s2s_contact_std('interact', name='plate_support',mfaces=mfaces, sfaces=sfaces,step='cooling')

  	history_output_request(rigid_body=plate_A1,variables=['RF','S'])   ## 此时，现有assembly，才能有history output request.

	## Load, BC (may based on deformed nodes.)
	apply_disp_fix(name='RP_fix',referencePoints=plate_A1,fix_all=True,step='step1')  ## plate整个过程都被fix

	if transient == True:
		set_temperature_predefined_field(initial_step=high_temp)
		set_temperature_BC('HPHT', amplitude='Amp_temp',step='cooling')
	else:
		set_temperature_predefined_field(initial_step=high_temp,modifys=[('cooling','Amp_temp')])
##		set_temperature_predefined_field(initial_step=high_temp,modifys=[('cooling','Amp_temp2')])	;changing

	apply_disp_symm('x',faces=faces_of_insts(x=0))
	apply_disp_symm('z',faces=faces_of_insts(z=0))

	if temperature_only == False:
		faces = face_select('compound_A1', ndir='conical')	;changing1
		apply_pressure('side_pressure', faces=faces, amplitude='Amp_press',step='cooling')	;changing1

		faces = face_select(compound_A1, y=MAX)		;changing1
		apply_pressure('end_pressure', faces=faces, amplitude='Amp_press',step='cooling')	;changing1

	apply_gravity(Gy=-9800)


	## model change
	if remove == True:
		ycells = cells_in_y(compound_A1)
		final_cells = ycells[1:3]
		set1 = create_set(name='final_cells', cells=final_cells)

		remove_cells = unselect(_inst(compound_A1).cells,final_cells)
		model_change(cells=remove_cells,step='remove',active=False)		;changing1

		faces1 = face_select(compound_A1,cells=final_cells, x=0)
		apply_disp_symm('x',faces=faces1,step='remove')

		faces2 = face_select(compound_A1,cells=final_cells, z=0)
		apply_disp_symm('z',faces=faces2,step='remove')

		y1 = ylocs(compound,x=0,z=0,axis=True)[1]
		nodes = node_select(compound_A1,y=y1,exterior=False)
		apply_disp_fix('node_fix',nodes=nodes,step='remove',Uy=0)

##		raise Exception


##		vertices = vertice_select(compound_A1,x=0,z=0,y=_ymin(compound_A1) + carbide_cut)
##		apply_disp_fix('final_y',vertices=vertices,step='remove',Uy=0)

##		faces3 = face_select(compound_A1,cells=final_cells, y=_ymin(compound_A1) + carbide_cut)	;please_check  ## _ymin(compound_A1) + carbide_cut
##		apply_disp_fix('final_y',faces=faces3,step='remove',Uy=0)	## 面约束比点约束更能保证model change的收敛

		apply_disp_fix(name='RP_fix',referencePoints=plate_A1,fix_all=True,step='remove')   ## 可有可无，为什么?
		get_current_model()

##	raise Exception

	global _results_dict
	_results_dict = {'var':('PCD_H', 'carbide_Hg', 'thick_ratio','cylind_D','high_temp'), 'H11N':('S1','Mises','S11','S22','U'), 'PCD':('S1','Mises','S11','S22')}

	create_inp(inp_file_title,request_num=6) ;please_check
##	back_run()
	mdb.jobs[inp_file_title].submit()

	return

def main_A0235_wiredraw_thermal_conduction():
	## VER: 2015-04-14, v1.0

	check_script_file('BP_A0235_grove4_big_oil_1000.py')
	purpose = 'Optimize the wire draw thermal conduction optimation.'
	history = 'A1: based on B1_A0237_density_output'

	locals0 = locals().keys()
	case = 'case'		;	case_A1 = 'case_A1'
	nib = 'nib'			;	nib_A1 = 'nib_A1'
	wire = 'wire'		;	wire_A1 = 'wire_A1'

	antype1 = 'stress','temp'		;changing1
	analysis1_title = inp_file_title

	case_H = 28
	case_OD = 42
	Nib_type = '16x16'
	nib_H = 16
	nib_OD = 16

	changing
##	h_water = 1600	## 600, 700, 800, 900, 1000
##	h_oil = h_water - 300
##	h_oil = 1000
##	h_water = h_oil - 300
##	h_water = h_oil
	h_oil = 1000
	h_water = 700
	have_wire = True	;changing

	grove_num = 4	;changing
	grove_depth = 6
	if grove_num > 0:
		if grove_num == 4:
			grove_width = 3
		elif grove_num == 3:
			grove_width = 4
		elif grove_num == 2:
			grove_width = 5
		grove_to_edge = (case_H - (2*grove_num - 1)*grove_width)/2.0
	else:
		groove_depth = 0
		groove_width = 0

	case_exit_angle = 60
	case_land_H = 0.5
	case_bot_to_nib = 7
	case_exit_diameter = 10.5

	case_mouth_diameter = 22
	case_mouth_H = case_H - nib_H - case_bot_to_nib  ## entrance

	interference = 0.07		;changing
	case_ID = nib_OD - 2*interference

	approach_R = 17
	approach_center_to_top = 10.65
	bearing_length = 0.3			;changing   ## 实际上，通常bearing_length = bearing_D*0.35

	reduction_dy = 3.5
	reduction_angle = 9
	bearing_D = 0.4

	exit_dy = 3.184
	exit_angle = 90

	cut_angle_y = 15
	cut_height = 1.15
	cut_width = cut_height*tanD(cut_angle_y)
	cut_round_y = 5
	cut_round_x = 0

##	cut_height = 0.484
##	cut_angle1 = 30
##	cut_height1 = 0.242
##	cut_angle2 = 45
##	cut_round_x = 0.242
##	cut_round_y = 0

	locals2globals(locals0,locals(),save_var=True)

	blank_cae(analysis1_title)

	s1 = create_base_sketch('sk_nib')
	loc0 = (bearing_D/2.0, exit_dy + bearing_length)
	loc1 = create_line_then_circle(s1,loc0,tangent_angle=90 - reduction_angle/2, radius=approach_R,side='+y', center_x='+',center_y=nib_H - approach_center_to_top, toY=nib_H,fix_y=True)
	connect_points(s1,last_point,('x',nib_OD/2),('y',cut_height))

	connect_points(s1,last_point,{'y':0,'angle':-cut_angle_y})
##	connect_points(s1,last_point,{'dy':-cut_height1,'angle':-cut_angle1},{'y':0, 'angle':-45})

	connect_points(s1,loc0,('dy',-bearing_length),{'y':0,'angle':exit_angle/2.0},last_point)

##	raise Exception

##	loc1 = last_point

##	connect_points(s1,loc0,{'y':0,'angle':exit_angle/2},('x',nib_OD/2),('y',nib_H),loc1)

	sketch_to_shell(s1,partname='nib',symmetric=True)

##	bias_cut(nib,cut_sides='bot_right',point1=(nib_OD/2,_ymin(nib) + cut_height), angle_with_Y = 15)
	round_corner(nib,x=MAX,groupY=MIN,radius=cut_round_y)
	round_corner(nib,groupX=MAX,y=MIN,radius=cut_round_x)

	loc1 = find_loc(nib,x=_xmin(nib) + 0.15, groupY=MAX)	;changing1
	loc2 = find_loc(nib,x=_xmin(nib) + 0.5, groupY=MIN)	;changing1
	divide_faces_by_two_points(nib,point1=loc1,point2=loc2)

	s1 = create_base_sketch('sk_wire')
	connect_points(s1,(bearing_D/2, exit_dy/2), (bearing_D/2, exit_dy*3),('dx',-bearing_D/2), ('y',exit_dy/2),('dx',bearing_D/2))
##	sketch_to_wire(s1,partname='wire',ptype='analytical',symmetric=True)
	sketch_to_shell(s1,partname='wire',symmetric=True)


##	raise Exception

	s1 = create_base_sketch('sk_case')
	loc0 = (case_OD/2, 0)
	connect_points(s1,loc0,('x',18/2),{'x':case_exit_diameter/2,'angle':60},('y',case_bot_to_nib))
	connect_points(s1,loc0,('y',case_H),('x',(case_OD - case_mouth_diameter)/2),('dy',-case_mouth_H),('x',case_ID/2),('dy',-nib_H),('x',case_exit_diameter/2))
	sketch_to_shell(s1,partname='case',symmetric=True)

	## create fins:
	if grove_num > 0:
		for i in range(grove_num):
			plane_cut(case,x=(case_OD/2,case_OD/2 - grove_depth),y=(grove_to_edge + i*grove_width*2, grove_to_edge + i*grove_width*2 + grove_width))

	move_part(nib,y1=MIN,y2=case_bot_to_nib)
	new_instance(nib)
	new_instance(case)

	if have_wire == True:
		new_instance(wire,dy=_ymin(nib),dx=0.1)	;changing

	edge = edge_select(nib,y=MIN)
	divide_edge(edge,x=_xmin(case))

	material_database()
	create_contact_props()

	set_mat(nib,'H3F')
	set_mat(case,'Steel_C45')

	if 'temp' not in antype1:
		create_general_static_step()		;changing1
	else:
		create_coupled_temp_displacement_step()
	field_output_request(variables=ALL)

##	raise Exception

	## meshing
	edges = edge_select(case,x=(MIN,case_ID/2.0 + 0.1),y=(MIN1,MAX1))
	seed_edges(case,edges=edges,esize=0.3)	;changing1

	mesh_2D(case,esize=0.5)		;changing1

	edges = edge_select(nib,poiRefX=(MIN,0.1))
	seed_edges(nib,edges=edges, esize=0.15)

	mesh_2D(nib,esize=0.3)	;changing1

	edges = edge_select('case_A1',nx=-1,x=(MIN1,MAX),y=_yspace('nib'))
	create_surface('case_ID',edges=edges)

	please_check
	edges1 = edge_select(nib_A1,nx=1)  ## use for general contact
	create_surface('nib_OD',edges=edges1)

	edges = edge_select(wire_A1,x=MAX)
	msurface = create_surface('surf_wire',edges=edges)

	edges = edge_select('nib_A1',poiRefX=(MIN,0.1))
	ssurface = create_surface('surf_nib',edges=edges)

	if have_wire == True:
##		msurface = create_surface(wire_A1,side='-x')
##
##		edges = edge_select('nib_A1',poiRefX=(MIN,0.1))
##		ssurface = create_surface('nib_A1',edges=edges)
##		s2s_contact_std('interact',name='wire_nib',mfaces=msurface, sfaces=ssurface)	## cannot be included in the general contact

		set_mat(wire,mat='Rigid')
		mesh_2D(wire,esize = 0.2)
##		RP = create_RP(wire_A1)
##		part_to_rigid_body(wire_A1,RP=RP)

		edges = edge_select(wire_A1,y=MAX) + edge_select(wire_A1,y=MIN)
		apply_disp_fix('wire_fix',edges=edges,Ux=0, Uy=0, UR3=0)
##		apply_BC_on_RP_2D(wire_A1, RP=RP, Ux=0, Uy=0, UR3=0)

	create_general_contact_std(friction='Friction + Heat conduction',interference_pairs=(('nib_OD','case_ID','interfernce_fit'),('surf_wire','surf_nib','interference_fit') ))	;changing1

	edges = edge_select(case_A1,y=MIN)
	apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

	if 'temp' in antype1:
		set_temperature_predefined_field(initial_step=20)	;changing1

		faces = face_select('nib_A1',x=MIN1)
		set_temperature_BC('heat_source',objs=faces, temp=600)	;changing1

##		 换热系数：	空气自然对流 5 ～ 25, 气体强制对流：20-100，
##					水的自然对流：200-1000，水的强制对流：1000-1500,
##					油类的强制对流：50-1500
				##  water: 600-750, light hydrocarbon: 400-550

		edges = edge_select(nib_A1,nx=-1)
		apply_surface_convection('oil_cooling',faces=edges,h = h_oil, T_air=40)	;changing

		edges = edge_select(nib_A1,y=MAX) + edge_select(nib_A1,y=MIN,x=_xmin(case) - 1)
		apply_surface_convection('nib_top',faces=edges,h = h_oil, T_air=40)			;changing

		edges = edge_select(case_A1,x=(_xmax(case) - grove_depth - 1,MAX),y=(MIN1,MAX1))
		create_surface('case_surface',edges=edges)	## 用于观察heat_flux
		apply_surface_convection('water_cooling',faces=edges,h = h_water)	;changing

		edges = edge_select(case_A1, y=MAX) + edge_select(case_A1, y=MIN)
		apply_surface_convection('case_end', faces=edges, h=300)

		edges = edge_select(case_A1,y=MAX1,groupX=MIN)
		apply_surface_convection('oil_on_case1', faces=edges, h=h_oil, T_air=40)

		edges = edge_select(case_A1,nx=-1,ny=-1)
		apply_surface_convection('oil_on_case2', faces=edges, h=h_oil, T_air=40)

##	raise Exception

	global _results_dict
	_results_dict = {'var':('interference',  'h_water', 'h_oil', 'grove_num'), 'case_A1':('S1',('TEMP','MIN'),('HFL','MIN')),'case_surface':('HFL') }

	create_inp(analysis1_title,request_num=6,submit=False)
	mdb.jobs[analysis1_title].submit()

	return

def apply_CTE_from_density_with_PEG(part,densities,bulk_modulus=400e3,deltaT=1,density_th=14.48,Yield=None,C1=0.024,offset=0):
	## VER: 2015-11-26, v1.8
	## density_th is the theoretical density_th

	## Example:
##	apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=diff,
##		density_th=density_th,Yield=Yield)	;changing

	part = check_part(part)
	if type_of(densities) != 'DICT':
		raise Exception('*** density dict with density and its element labels are required.')

	print ' '
	print fnln(),'Applying CTEs based on density levels...'
	print ' '

	label_dict = elem_label_to_index(part)

	if offset in empty:
		offset = 0

	print fnln(),'density offset=',offset

##	if abs(offset) >= 1:
##		offset = offset/100

	if C1 > 1:
		C1 = C1/100.

	if density_th > 1:
		density_th = density_th*1e3*KD

	print fnln(),'C1=',C1

##	raise Exception

##	>>> density_with_PEG_to_CTE(8.23,Rho_th=14.94,C1=2.174)   ## average density=8.43
##	0.1862
##	>>>

	CTEs = []
	for dens in densities.keys():
		dens1 = dens + offset	;changing
		CTE = density_with_PEG_to_CTE(dens1,deltaT=deltaT,Rho_th=density_th,C1=C1)   ## suchas: dens=5.375 g/cc
		matname = modify_string(str(dens), '.')
		matname = 'mat' + matname
		CTEs.append(CTE)

		## Double confirm density
##		if dens == 8.43:
##			print fnln(),'dens=',dens,', CTE=',CTE
##			raise Exception

		elements = densities[dens]
		create_simple_material(name=matname, modulus=bulk_modulus, poisson=0.23, CTE=CTE,density=density_th,Yield=Yield)
		set_mat(part, mat=matname, elements=elements,label_dict=label_dict)

	CTEs = _sort(CTEs)
	print len(_m.materials),'materials are applied.'

	return CTEs

def main_A0241_PDC_shearing_cap():
	## VER: 2015-07-04, v1.0
	## Requestor: Eugene, support Varel Intl.

	check_script_file('AH_A0241_carbide_cap_sup_R0_L05.py')
	purpose = 'Static stress analysis for cap redesign.'

	locals0 = locals().keys()

	ID = 13.512
	chamfer_length = 0.5	;changing
	round_R = 0			;changing
	support = True		;changing
	angle = 90			;changing
	force = 10000	## 1000kgf

	Cap = 'Cap'			;	Cap_A1 = 'Cap_A1'
	cylind = 'cylind'	;	cylind_A1 = 'cylind_A1'

	locals2globals(locals0,locals(),save_var=True)

	open_cae('ca2141.cae')
	save_as(inp_file_title)

	cylinder_grow('cylind',OD=ID,L=15,ndir='x')
	rotate_part('cylind',angle_x=90)
	bias_cut('cylind',y=0,cut_sides='-y')
	new_instance('cylind')

##	raise Exception

	if chamfer_length > 0 or round_R > 0:
		corner = copy_part('cylind',newpart_name='corner')
		new_instance('corner')

		edges = edge_select('cylind',x=MIN,edir='circular')
		if chamfer_length > 0:
			chamfer_edges('cylind',edges=edges,length=chamfer_length)
		elif round_R > 0:
			round_edges('cylind',edges=edges,radius=round_R)

		boolean_cut('corner_A1',cutters='cylind_A1',newpart_name='corner')
		new_instance('corner')

		merge_instances(('corner_A1','cylind_A1'),partname='cylind',boundary='keep')
		new_instance('cylind')

	divide('Cap',z=0)
	divide('Cap',x=1.605545)

	faces = face_select('Cap',x=MAX1,ny=-1,shape='plane')
	divide_by_datum_plane('cylind',plane=faces[0])

	work_faces = face_select('Cap',nx=-1,ny=-1,x=MIN1)
	centroid = centroid_of_faces(work_faces)

	divide_faces(p='Cap',faces=work_faces,y=centroid[1])

	divide('cylind',z=0)

	if round_R > 0 or chamfer_length > 0:
		vertices1 = vertice_select('cylind',x=MIN,groupZ=MAX)
		vertices2 = vertice_select('cylind',x=MIN,groupZ=MIN)
		faces = vertices_to_faces(vertices1 + vertices2)
		remove_faces('cylind',faces=faces)

	set_mat(Cap,mat='H15F')	;changing

	cells = cell_select(cylind,x=MAX1)
	set_mat(cylind,cells=cells, mat='Diamond')

	cells = unselect(cylind,cells)
	if cells not in empty:
		set_mat(cylind,cells=cells,mat='H15F')	;changing

##	raise Exception

	if support == False:
		cells = cell_select('cylind',x=MAX1)
		remove_cells('cylind',cells=cells)

	if support == False and round_R == 0 and chamfer_length == 0:
		del_insts('cylind_A1')

	create_general_static_step()

	## Mesh
	set_element_shape('Cap',eshape='TET')
	choose_element_type('Cap')
	mesh_region('Cap',esize=0.3)

	if len(_part('cylind').cells)>0:
		set_element_shape('cylind',eshape='TET')
		mesh_region('cylind',esize=0.3)

	## Interaction
	if chamfer_length > 0 or round_R > 0 or support == True:
		p = 'Cap_A1'
		faces1 = face_select(p,diameter=ID)
		faces2 = face_select(p,x=0)

		p = 'cylind_A1'
		faces11 = face_select(p,diameter=ID)
		faces22 = face_select(p,x=0)

		if support == False:
			s2s_tie('wall_tie',mfaces=faces1,sfaces=faces11)
			s2s_tie('end_tie',mfaces=faces2,sfaces=faces22)
		else:
			s2s_tie('wall_tie',sfaces=faces1,mfaces=faces11)
			s2s_tie('end_tie',sfaces=faces2,mfaces=faces22)

	## Load
##	work_faces = face_select('Cap',nx=-1,ny=-1,x=MIN1)
##	centroid = centroid_of_faces(work_faces)
##	create_datum_point(a,loc=centroid)

##	vertices = box_select(_inst('Cap_A1').vertices,x=centroid[0],y=centroid[1],z=centroid[2])

	work_faces = face_select('Cap_A1',nx=-1,ny=-1,x=MIN1)
	area = get_area(work_faces)

	normal_p = force*sinD(angle)/area
	shear_p = force*cosD(angle)/area
	apply_pressure('load',faces=work_faces,MPa=normal_p)

##	vertice = vertice_at('Cap_A1',loc=centroid)
##	control_point = create_set(name='control_point',vertices=vertice)
##	coupling_faces_to_point(faces=work_faces,control_point=control_point,UR1=ON,UR2=ON,UR3=ON,coupling_type='distributing')	;changing

##	region = a.sets['control_point']
##	_m.ConcentratedForce(name='Load-1', createStepName='step1', region=region1, cf1=normal_f, cf2=shear_f, distributionType=UNIFORM, field='', localCsys=None)

	if support == True:
		faces = face_select('cylind_A1',x=MAX)
		apply_disp_fix('fix_x',faces=faces,Ux=0)

		faces = face_select('cylind_A1',y=0)
		apply_disp_fix('fix_y',faces=faces,Uy=0,Uz=0)
	else:
		faces = face_select('Cap_A1',x=MAX1,nx=1,ny=1)
		apply_disp_fix('fix_x',faces=faces,Ux=0)

		faces = face_select('Cap_A1',x=MAX1,ny=-1,shape='cylindrical')
		apply_disp_fix('fix_y',faces=faces,Uy=0,Uz=0)

	create_inp(inp_file_title,request_num=6,submit=False)
	mdb.jobs[inp_file_title].submit()

	return

def main_A0242_sintering_project_insert():
	## VER: 2015-04-29, v1.0

	check_script_file('E6_A0242_mexico_insert_noC_7_8_test1.py')	;changing
	purpose = 'Try the simple geometry, like PS21 sample.'
	history = 'E6:7-7.2-7.8-8, 5-95vol%; DN:shrinkage=20%, shift to average; DG:doubled sintered loss; D5:sinter loss=0.024; CO:No equation, have tray; CN:约束方程,modulus=200; C9:no ejection; B8:Tet element shape; A0: based on BM_A0235'

##	compaction_odb = 'A0235-compensated_mat_medimesh_2784_EJ'
##	compaction_odb = 'C0235-insert_original_mesh_2784_2'
##	compaction_odb = 'E0235-insert_comp_2784'  ## small, 1GB
##	compaction_odb = 'E0235-insert_original_2784'		;changing

##	compaction_odb = 'G0235-insert_comp_test1'

	if 'test1' in inp_file_title:
		compaction_odb = 'H0235-insert_comp_test1'	;changing
	elif 'test2' in inp_file_title:
		compaction_odb = 'H0235-insert_comp_test2'	;changing

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	_import = True			;changing
	output_density = True	;changing
	apply_mat = True		;changing
	density_step = 0.001		;changing1
##	dens_range = (5.5, 6.5, 10, 11)
##	dens_range = (5, 6.5, 8.5, 10)	;changing
##	dens_range = (7, 7.2, 7.8, 8)	;changing
	dens_range = (7,7.2,7.8,8)	;changing

	if _import == True:
		apply_mat = True

	if _import == True:
		if output_density == True:
			open_odb(compaction_odb)
			write_density_and_element_labels(step_name='uppressing',filename=density_file, ranges=dens_range, reference=7.5,
				step_in=density_step, step_out=density_step) ;changing

		import_part_from_odb(compaction_odb,part_name='green',step_name='uppressing',frame=-1, copy_nodeset=False,force_name=True)	;changing
		new_instance('green')

		p1 = 'green_A1'

		ymid = 4.859E-03   ## 23.E-06
		small_D = 6.46
		big_D = 13.1   ## 13.03

		## create sets:
		nodes1 = nodes_by_face(p1,z=MAX,nz=1)
		nodes2 = nodes_by_face(p1,x=MIN,nx=-1)
		nodes = common_objs(nodes1,nodes2)
		create_set(setname='dim_width_big',objs=nodes)

		nodes = node_select(p1,x=0,err=0.1)
		create_set(setname='dim_width_mid',objs=nodes)

		nodes1 = nodes_by_face(p1,z=MAX,nz=1)
		nodes2 = nodes_by_face(p1,x=MAX,nx=1)
		nodes = common_objs(nodes1,nodes2)
		create_set(setname='dim_width_small',objs=nodes)

		nodes = node_select(p1,y=0)
		create_set(setname='dim_length_mid',objs=nodes)

		nodes = node_select(p1,y=0, groupX=(MIN,_xmin(p1) + 2))
		create_set(setname='dim_height_left',objs=nodes)

		nodes = node_select(p1,y=0, groupX=(MAX,_xmax(p1) - 1))
		create_set(setname='dim_height_right',objs=nodes)

		nodes1 = nodes_by_face(p1,z=MAX,nz=1)
		nodes2 = nodes_by_face(p1,y=MIN,ny=-1)
		nodes = common_objs(nodes1,nodes2)
		create_set(setname='dim_length_ymin',objs=nodes)

		nodes1 = nodes_by_face(p1,z=MAX,nz=1)
		nodes2 = nodes_by_face(p1,y=MAX,ny=1)
		nodes = common_objs(nodes1,nodes2)
		create_set(setname='dim_length_ymax',objs=nodes)

		nodes1 = nodes_by_face(p1,z=MIN,nz=-1)
		nodes_botx = node_select(p1,nodes=nodes1,y=0)
		create_set(setname='dim_bot_mid',nodes=nodes_botx)

		nodes1 = nodes_by_face(p1,z=MAX,nz=1)
		nodes_topx = node_select(p1,nodes=nodes1,y=0)
		create_set(setname='dim_top_mid',nodes=nodes_topx)

		node1 = node_select(p1,nodes=nodes_topx,x=(0,MAX),groupX=MIN)
		node2 = node_select(p1,nodes=nodes_topx,x=(0,MIN),groupX=MAX)
		create_set(setname='dim_bigR_x',nodes=node1+node2)

		nodes1 = nodes_by_face(p1,z=MAX,nz=1)
		nodes_topy = node_select(p1,nodes=nodes1,x=0)
		node1 = node_select(p1,nodes=nodes_topy,y=(0,MAX),groupY=MIN)
		node2 = node_select(p1,nodes=nodes_topy,y=(0,MIN),groupY=MAX)
		create_set(setname='dim_bigR_y',nodes=node1+node2)

		nodes1 = nodes_by_face(p1,z=MIN,nz=-1)
		nodes_boty = node_select(p1,nodes=nodes1,x=0)
		node1 = node_select(p1,nodes=nodes_boty,y=(0,MAX),groupY=MIN)
		node2 = node_select(p1,nodes=nodes_boty,y=(0,MIN),groupY=MAX)
		create_set(setname='dim_smallR_y',nodes=node1+node2)

		nodes1 = nodes_by_face(p1,z=MIN,nz=-1)
		nodes_botx = node_select(p1,nodes=nodes1,y=0)
		node1 = node_select(p1,nodes=nodes_botx,x=(0,MAX),groupX=MIN)
		node2 = node_select(p1,nodes=nodes_botx,x=(0,MIN),groupX=MAX)
		create_set(setname='dim_smallR_x',nodes=node1+node2)

		nodes1 = nodes_by_face(p1,x=small_D/2.0,nx=-1)
		nodes2 = nodes_by_face(p1,z=MIN,nz=-1)
		nodes = common_objs(nodes1,nodes2)
		create_set(setname='dim_smallR',nodes=nodes)
		half_smallR = node_select(p1,nodes=nodes,y=(0,MAX))
		nodes = set2objs('dim_bot_mid')
		create_set(setname='dim_bot_arc',nodes=nodes + half_smallR)

		nodes = set2objs('dim_bigR_x')
		nodes = nodes_sort_byx(nodes)
		x = nodes[1].coordinates[0]
		nodes1 = nodes_by_face(p1,x=x,nx=-1,angle=20)

##		nodes1 = nodes_by_face(p1,x=big_D/2.0,nx=-1)
		nodes2 = nodes_by_face(p1,z=MAX,nz=1)
		nodes = common_objs(nodes1,nodes2)
		create_set(setname='dim_bigR',nodes=nodes)

		half_bigR = node_select(p1,nodes=nodes,y=(0,MAX))
		nodes = set2objs('dim_top_mid')
		create_set(setname='dim_top_arc',nodes=nodes + half_bigR)

		nodes1 = set2objs('dim_bigR')
		nodes2 = nodes_by_face(p1,z=MAX,nz=1)
		nodes2 = get_edge_nodes(nodes2)
		nodes3 = set2objs('dim_smallR')
		create_set(setname='dim_xy_frame',nodes=nodes1+nodes2+nodes3)

		nodes1 = set2objs('dim_smallR')
		nodes2 = nodes_by_face(p1,z=MIN,nz=-1)
		nodes2 = get_edge_nodes(nodes2)
		create_set(setname='dim_bot_edges',nodes=nodes1+nodes2)

		nodes = nodes_by_face(p1,z=MAX,nz=1)
		create_set(setname='dim_top_nodes',nodes=nodes)

		nodes = nodes_by_face(p1,z=MIN,nz=-1)
		create_set(setname='dim_bot_nodes',nodes=nodes)

		nodes1 = set2objs('dim_length_mid')
		nodes2 = set2objs('dim_smallR')
		nodes2 = node_select(p1,nodes=nodes2,y=(0,MAX))
		nodes3 = set2objs('dim_bigR')
		nodes3 = node_select(p1,nodes=nodes3,y=(0,MAX))
		nodes = nodes1 + nodes2 + nodes3
		create_set(setname='dim_mid_profile',nodes=nodes)

		save_mdb(cae_no_mat)			;changing1

	else:
		if apply_mat == False:
			open_cae(cae_with_mat)
		else:
			open_cae(cae_no_mat)

	save_mdb(inp_file_title)

##	raise Exception

	locals0 = locals().keys()
	part1 = 'part1'		;	part1_A1 = 'part1_A1'

	analysis1_title = inp_file_title
	bulk_modulus = 400e3	;changing1	## 400GPa
	Yield = None				;changing1
	sinter_loss = 2.418		;changing
	shrinkage = 0.1968		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
	density_th = 14.44		;changing1

	deltaT = 1				;changing1
	support = 'BOT'
	have_tray = False		;changing1
	fric = 0.1				;changing1

	green = 'green'	;	green_A1 = 'green_A1'
	plate = 'plate'				;	plate_A1 = 'plate_A1'
	p1 = 'green_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	open_odb(compaction_odb)
##	density_avg = average_density()	;changing
	density_avg = density_distribution(th=density_th)['average']
	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
	diff = 2*(density_avg - density_lab)/density_th*100		;changing
	if 'noshift' in inp_file_title:
		diff = None	;changing

	## SMIL
	if apply_mat == True:
		densities = read_density_and_element_labels(density_file)

		sinter_loss = 0	;changing
		diff = 0		;changing
		apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=diff,
			density_th=density_th,Yield=Yield)	;changing

		save_mdb(cae_with_mat)
		save_mdb(inp_file_title)

	if len(_m.steps) == 1:
		create_general_static_step()

	field_output_request()

##	_m.fieldOutputRequests['F-Output-1'].setValues(variables=('S', 'PE', 'PEEQ', 'LE', 'U', 'RF', 'CF', 'IVOL','EVOL','CSTRESS', 'CDISP', 'COORD'))

	if len(_m.interactionProperties) == 0:
		create_contact_props(friction=fric)	;changing1

	if have_tray == True:
		create_block('plate',x=(0,25),y=(0,25),z=(0,0.5))
		if support == 'BOT':
			move_part('plate',x1=MID,x2=0,y1=MID,y2=0,z1=MAX,z2=_zmin('green'))
		elif support == 'TOP':
			move_part('plate',x1=MID,x2=0,y1=MID,y2=0,z1=MIN,z2=_zmax('green'))

		edges = edge_select('plate',z=MID)
		seed_edges('plate',edges=edges,enum=1)
		hex_mesh('plate',esize=0.2)

		if 'Graphite' not in _m.materials.keys():
			material_database()
		set_mat('plate',mat='Graphite')

		create_mesh_part('plate')
		new_instance('plate')

		if support == 'BOT':
			nodes = node_select('plate_A1',z=MIN)	;changing1
		elif support == 'TOP':
			nodes = node_select('plate_A1',z=MAX)	;changing1
		apply_disp_fix('plate_fix',nodes=nodes,fix_all=True)

	nodes = _inst('green_A1').nodes[:]  ;changing1 ## only for green part
	region = a.Set(nodes=nodes, name='all_nodes')
	set_temperature_predefined_field('Temp_field',region=region, initial_step=25+deltaT, modify=25)

	if have_tray:
		_m.Gravity(name='Gravity', createStepName='step1', comp3=-9800.0, distributionType=UNIFORM, field='')	;changing1

##	raise Exception
	nodes = set2objs('dim_smallR_y')
	apply_disp_fix('fix_x',nodes=nodes,U1=0,UR3=0)	;changing1

##	apply_disp_fix('fix_z',nodes=nodes[0],U3=0,UR1=0,UR3=0)

	nodes = set2objs('dim_smallR_x')
	apply_disp_fix('fix_y',nodes=nodes,U2=0,UR3=0)	;changing1

	elements = elems_by_face(p1,nz=1,z=MAX)
	seq = list2sequence(p1,elements=elements)
	a.Surface(face1Elements=seq, name='surf_top')

	elements = elems_by_face(p1,nz=-1,z=MIN)
	seq = list2sequence(p1,elements=elements)
	a.Surface(face1Elements=seq, name='surf_bot')

	elements = elems_by_face(p1,ny=-1,y=MIN)
	seq = list2sequence(p1,elements=elements)
	a.Surface(face1Elements=seq, name='surf_ymin')

	elements = elems_by_face(p1,ny=1,y=MAX)
	seq = list2sequence(p1,elements=elements)
	a.Surface(face1Elements=seq, name='surf_ymax')

	elements = elems_by_face(p1,nx=-1,x=MIN)
	seq = list2sequence(p1,elements=elements)
	a.Surface(face1Elements=seq, name='surf_xmin')

	elements = elems_by_face(p1,nx=1,x=MAX)
	seq = list2sequence(p1,elements=elements)
	a.Surface(face1Elements=seq, name='surf_xmax')

##	raise Exception

	## 约束方程
##	create_constraint_equation(nodes[0],nodes[1],dof='Uz')

	if have_tray:
		create_general_contact_std(friction='Friction')

	else:
		nodes = set2objs('dim_smallR_x')
		nodes = nodes_sort_byx(nodes)	;changing1
		apply_disp_fix('fix_z_x',nodes=nodes[1],U3=0)		;changing1  ## +x原来偏小0.05mm
		apply_disp_fix('fix_z_x',nodes=nodes[0],U3=0.05)	;changing1

		nodes = set2objs('dim_smallR_y')
		nodes = nodes_sort_byy(nodes)	;changing1
		apply_disp_fix('fix_z_y',nodes=nodes[1],U3=0)		;changing1  ## +x原来偏小0.05mm
		apply_disp_fix('fix_z_y',nodes=nodes[0],U3=0.05)	;changing1

	create_inp(analysis1_title,request_num=6,submit=False)
##	mdb.jobs[analysis1_title].submit()

	return

def main_A0245_sintering_coromant_insert():
	## VER: 2015-08-06, v1.0

	check_script_file('B5_A0245_Coromant_insert_noC_7_8.py')	;changing
	purpose = 'Sintering for Coromant insert to check the dimension prediction presion.'
	history='B5:based on successful B4, avg density=6.77; B3:5-95 discount; A1:based on DX_A0242_H0235_comp_test2_shift_5_10'

	compaction_odb = 'A0233-Coromant_insert_rough_mesh_die'   ## filling density = 3.37, 压坯平均密度6.77(47%)
##	compaction_odb = 'A0233-Coromant_insert_rough_die2_den'   ## filling density 根据粉体重量/体积计算得出，大约是3.77, 压坯平均密度7.57(52%)

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	_import = True			;changing
	output_density = True	;changing
	apply_mat = True		;changing
	density_step = 0.001		;changing1
##	dens_range = (5.5, 6.5, 10, 11)
##	dens_range = (5, 6.5, 8.5, 10)	;changing
	dens_range = (7, 7.2, 7.8, 8)	;changing
	if _import == True:
		apply_mat = True

	if _import == True:
		if output_density == True:
			open_odb(compaction_odb)
			write_density_and_element_labels(step_name='pressing',filename=density_file, ranges=dens_range, reference=7.5,
				step_in=density_step, step_out=density_step) ;changing

		import_part_from_odb(compaction_odb,part_name='green',step_name='pressing',frame=-1, copy_nodeset=False,force_name=True)	;changing
		new_instance('green')

		p1 = 'green_A1'

		nodes = nodes_by_face(p1,y=MAX,ny=1)
		create_set(setname='dim_ymid',nodes=nodes)

		nodes = nodes_by_face(p1,x=MAX,nx=1)
		create_set(setname='dim_xmid',nodes=nodes)

		nodes = nodes_by_face(p1,z=MIN,nz=-1)
		create_set(setname='dim_zmid',nodes=nodes)

		save_mdb(cae_no_mat)			;changing1

	else:
		if apply_mat == False:
			open_cae(cae_with_mat)
		else:
			open_cae(cae_no_mat)

	save_mdb(inp_file_title)

	locals0 = locals().keys()
	part1 = 'part1'		;	part1_A1 = 'part1_A1'

	analysis1_title = inp_file_title
	bulk_modulus = 400e3	;changing1	## 400GPa
	Yield = None				;changing1
	sinter_loss = 2.418		;changing
	shrinkage = 0.1968		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
	density_th = 14.44		;changing1

	deltaT = 1				;changing1
	support = 'BOT'
	have_tray = False		;changing1
	fric = 0.1				;changing1

	green = 'green'	;	green_A1 = 'green_A1'
	plate = 'plate'				;	plate_A1 = 'plate_A1'
	p1 = 'green_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	open_odb(compaction_odb)
##	density_avg = average_density()	;changing
	density_avg = density_distribution(th=density_th)['average']
	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
	print fnln(),'density_avg=',density_avg
	print fnln(),'density_lab=',density_lab

	session.viewports['Viewport: 1'].odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

##	diff = round(2*(density_avg - density_lab)/density_th*100,3)		;changing
	diff = round(0*(density_avg - density_lab)/density_th*100,3)	;changing
	print fnln(),'diff=',diff,'in percentage'

	if 'noshift' in inp_file_title:
		diff = None	;changing
	elif 'shift' in inp_file_title:
		diff = diff
	else:
		diff = None

	print fnln(),'diff=',diff

##	raise Exception

	## SMIL
	if apply_mat == True:
		densities = read_density_and_element_labels(density_file)

##		sinter_loss = 0	;changing
		diff = 0		;changing
		apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=diff,
			density_th=density_th,Yield=Yield)	;changing

		save_mdb(cae_with_mat)
		save_mdb(inp_file_title)

	if len(_m.steps) == 1:
		create_general_static_step()

	field_output_request()

	if len(_m.interactionProperties) == 0:
		create_contact_props(friction=fric)	;changing1

	nodes = _inst('green_A1').nodes[:]  ;changing1 ## only for green part
	region = a.Set(nodes=nodes, name='all_nodes')
	set_temperature_predefined_field('Temp_field',region=region, initial_step=25+deltaT, modify=25)

	## boundary conditions
	apply_disp_fix('fix_x',nodes='dim_xmid',Ux=0)
	apply_disp_fix('fix_y',nodes='dim_ymid',Uy=0)
	apply_disp_fix('fix_z',nodes='dim_zmid',Uz=0)

	p1 = 'green_A1'
	elems = elems_by_face(p1,y=MIN,x=0,ny=-1,angle=5)	;changing
	create_surface('Surf_big_face',elements=elems,poi=p1,angle=1,axis='y')

	elems = elems_by_face(p1,x=0,y=0,z=MAX,angle=5,nz=1)
	create_surface('Surf_end_face',elements=elems,poi=p1,angle=3,axis='z')

	elems = elems_by_face(p1,y=0,z=0,x=MIN,angle=5,nx=-1)
	create_surface('Surf_side_face',elements=elems,poi=p1,angle=3,axis='x')

	create_inp(analysis1_title,request_num=6,submit=False)
	mdb.jobs[analysis1_title].submit()

	return

def main_A0243_sintering_MAP_insert():
	## VER: 2015-08-06, v1.0

	check_script_file('AB_A0243_MAP_sintering_insert_ALE_02.py')	;changing
	purpose = 'Sintering for EPZ MAP sintering, with Ludwig, Kevin.'
	history='A1:model'

	compaction_odb = 'G0243-MAP_hole_double_K8.odb'
##	compaction_odb = 'G0243-MAP_hole_single_K2.odb'

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	_import = True			;changing
	output_density = True	;changing
	apply_mat = True		;changing
	density_step = 0.001		;changing1
##	dens_range = (5.5, 6.5, 10, 11)
##	dens_range = (5, 6.5, 8.5, 10)	;changing
	dens_range = (7, 7.2, 7.8, 8)	;changing
	if _import == True:
		apply_mat = True

	if _import == True:
		if output_density == True:
			open_odb(compaction_odb)
			write_density_and_element_labels(step_id=-1,filename=density_file, ranges=dens_range, reference=7.5,
				step_in=density_step, step_out=density_step) ;changing

		import_part_from_odb(compaction_odb,part_name='green',step_id=-1,frame=-1, copy_nodeset=False,force_name=True)	;changing
		new_instance('green')

##		raise Exception

		p1 = 'green_A1'

##		nodes = nodes_by_face(p1,y=MAX,ny=1)
##		create_set(setname='dim_ymid',nodes=nodes)
##
##		nodes = nodes_by_face(p1,x=MAX,nx=1)
##		create_set(setname='dim_xmid',nodes=nodes)

##		nodes = nodes_by_face(p1,z=MIN,nz=-1)
##		create_set(setname='dim_zmid',nodes=nodes)

		save_mdb(cae_no_mat)			;changing1

	else:
		if apply_mat == False:
			open_cae(cae_with_mat)
		else:
			open_cae(cae_no_mat)

	save_mdb(inp_file_title)

	locals0 = locals().keys()
	part1 = 'part1'		;	part1_A1 = 'part1_A1'

	analysis1_title = inp_file_title
	bulk_modulus = 400e3	;changing1	## 400GPa
	Yield = None				;changing1
	sinter_loss = 2.418		;changing
	shrinkage = 0.1968		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
	density_th = 14.44		;changing1

	deltaT = 1				;changing1
	support = 'BOT'
	have_tray = False		;changing1
	fric = 0.1				;changing1

	green = 'green'	;	green_A1 = 'green_A1'
	plate = 'plate'				;	plate_A1 = 'plate_A1'
	p1 = 'green_A1'

	## dimensions
	pin_length = 20

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	open_odb(compaction_odb)
##	density_avg = average_density()	;changing
	density_avg = density_distribution(th=density_th)['average']
	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
	print fnln(),'density_avg=',density_avg
	print fnln(),'density_lab=',density_lab

	session.viewports['Viewport: 1'].odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

##	diff = round(2*(density_avg - density_lab)/density_th*100,3)		;changing
	diff = round(0*(density_avg - density_lab)/density_th*100,3)	;changing
	print fnln(),'diff=',diff,'in percentage'

	if 'noshift' in inp_file_title:
		diff = None	;changing
	elif 'shift' in inp_file_title:
		diff = diff
	else:
		diff = None

	print fnln(),'diff=',diff

##	raise Exception

	## SMIL
	if apply_mat == True:
		densities = read_density_and_element_labels(density_file)

##		sinter_loss = 0	;changing
		diff = 0		;changing
		apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=diff,
			density_th=density_th,Yield=Yield)	;changing

		save_mdb(cae_with_mat)
		save_mdb(inp_file_title)

	if len(_m.steps) == 1:
		create_general_static_step()

	field_output_request()

	if len(_m.interactionProperties) == 0:
		create_contact_props(friction=fric)	;changing1

	nodes = _inst('green_A1').nodes[:]  ;changing1 ## only for green part
	region = a.Set(nodes=nodes, name='all_nodes')
	set_temperature_predefined_field('Temp_field',region=region, initial_step=25+deltaT, modify=25)

	## boundary conditions
	nodes = nodes_by_face(p1,z=MIN,nz=-1)
	create_set(setname='dim_zmid',nodes=nodes)

##	apply_disp_fix('fix_x',nodes='dim_xmid',Ux=0)
##	apply_disp_fix('fix_y',nodes='dim_ymid',Uy=0)
##	apply_disp_fix('fix_z',nodes=nodes,Uz=0,UR3=0,UR1=0,UR2=0)
##	apply_disp_fix('fix_xy',nodes=nodes[0],Ux=0,Uy=0)

	n1 = a.instances['green_A1'].nodes
	nodes1 = n1[3:4]+n1[15063:15064]
	region = a.Set(nodes=nodes1, name='Set-3')
	mdb.models[_m.name].DisplacementBC(name='BC-1', createStepName='Initial',
	    region=region, u1=UNSET, u2=SET, u3=SET, ur1=SET, ur2=SET, ur3=SET,
	    amplitude=UNSET, distributionType=UNIFORM, fieldName='', localCsys=None)

	n1 = a.instances['green_A1'].nodes
	nodes1 = n1[7533:7534]+n1[22593:22594]
	region = a.Set(nodes=nodes1, name='Set-4')
	mdb.models[_m.name].DisplacementBC(name='BC-2', createStepName='Initial',
	    region=region, u1=SET, u2=UNSET, u3=SET, ur1=SET, ur2=SET, ur3=SET,
	    amplitude=UNSET, distributionType=UNIFORM, fieldName='', localCsys=None)

##	raise Exception

	p1 = 'green_A1'
##	elems = elems_by_face(p1,y=MIN,x=0,ny=-1,angle=5)	;changing
##	create_surface('Surf_big_face',elements=elems,poi=p1,angle=1,axis='y')
##
##	elems = elems_by_face(p1,x=0,y=0,z=MAX,angle=5,nz=1)
##	create_surface('Surf_end_face',elements=elems,poi=p1,angle=3,axis='z')
##
##	elems = elems_by_face(p1,y=0,z=0,x=MIN,angle=5,nx=-1)
##	create_surface('Surf_side_face',elements=elems,poi=p1,angle=3,axis='x')

	create_inp(analysis1_title,request_num=6,submit=False)
	mdb.jobs[analysis1_title].submit()

	return



def main_A0248_button_powder_compaction():
	## VER: 2014-09-05, v1.0
	## Reference: main_A0194_powder_compaction()

	check_script_file('DB2_A0248_button_tangent_5068H_nu25_deg30.py')
	history = 'CI7:0.8*divide_length; AV:apply ALE to whole model; AN:only top ALE(not converged); AM:top+bot ALE; AL:fine mesh land; AK:fine mesh, complete run; AJ:complete run; AF: rebuild bpunch based on powder bottom edges; AE:with ALE; A1:based on BG_A0224'

	blank_cae(inp_file_title)

	locals0 = locals().keys()

	analysis1_title = inp_file_title	;changing1

	product = '5068H'   ## 5068H
	with_tangent = True		;changing

	if product == '50160':
		## 规律: PFH = PH + dip + PV + OB
		## dip: 第一步，上冲没入中模中，一般dip=1-4mm
		## PV:  第二步, 上冲+中模同时运动
		## OB:  第三步, 上冲最后一压
		## L:   中模往下走PV(在第二步)后，下冲底部到中模顶部的距离，所以：L=PHF - PV。也即: PHF = PV + L
		## AB:  也就是L，即脱模时中模往下走的全部距离，以便让green part完全暴露出来。所以：AB=L=PHF-PV, 也即: PFH = PV + AB

		PW = 61
		PH = 28.15
		L = 45.1
		PV = 17
		OB = 1
		PFH = L + PV
		dip = 4

		if with_tangent == True:   ## usually with tangent to land
			die_D = 20.2
			die_R = die_D/2.0

			## contraction: 0.82
			## Ejector drawing No: GT9S180_ejB
			ejector_know = 'x'
			ejector_R = 10.25				;changing
			ejector_tangent_angle = 30   	;changing ##    17
			ejector_land = 0.1         ##  0.08
			ejector_land_R = 0.07       ##    0.05
			ejector_depth = None  ## ???????

			## contraction: 0.82
			## drawing No. TOWXT895/5082-P
			tpunch_know = 'x'
			tpunch_land = 0.09   ## after round
			tpunch_land_R = 0.07

			tpunch_land_angle = 19
			tpunch_cap_angle = 25.25
			tpunch_mid_round = 0.62
			tpunch_top_round = 1.85

			tpunch_mid_D = 19.4	## 比die_D略小
			tpunch_OD = die_D
			tpunch_mid2top = 2.47  ## 到帽顶的距离

		else:
			die_D = 20.2
			die_R = die_D/2.0

			## contraction: 0.82
			## Ejector drawing No: GT9S180_ejB
			ejector_know = 'x'
			ejector_R = 10.25		;changing
			ejector_tangent_angle = None    ##    17
			ejector_land = 0.1         ##  0.08
			ejector_land_R = 0.07       ##    0.05
			ejector_depth = None  ## ???????

			## contraction: 0.82
			## drawing No. TOWXT895/5082-P
			tpunch_know = 'x'
			tpunch_land = 0.09   ## after round
			tpunch_land_R = 0.07

			tpunch_land_angle = 19
			tpunch_cap_angle = 25.25
			tpunch_mid_round = 0.62
			tpunch_top_round = 1.85

			tpunch_mid_D = 19.4	## 比die_D略小
			tpunch_OD = die_D
			tpunch_mid2top = 2.47  ## 到帽顶的距离

	elif product == '5068H':
		## 规律: PFH = PH + dip + PV + OB
		## dip: 第一步，上冲没入中模中，一般dip=1-4mm
		## PV:  第二步, 上冲+中模同时运动
		## OB:  第三步, 上冲最后一压
		## L:   中模往下走PV(在第二步)后，下冲底部到中模顶部的距离，所以：L=PHF - PV。也即: PHF = PV + L
		## AB:  也就是L，即脱模时中模往下走的全部距离，以便让green part完全暴露出来。所以：AB=L=PHF-PV, 也即: PFH = PV + AB

		PW = 113.54
		PH = 35.02
		L = 56.2
		PV = 21
		OB = 1.5
		PFH = L + PV
		dip = 4

		if with_tangent == True:
			die_D = 23.942
			die_R = die_D/2.0

			## contraction: 0.82
			## Ejector drawing No: GT9S180_ejB
			ejector_know = 'x'
			ejector_R = 12.35				;changing
			ejector_tangent_angle = 30  	;changing ##    17
			ejector_land = 0.12         ##  0.08
			ejector_land_R = 0.07       ##    0.05
			ejector_depth = None  ## ???????

			## contraction: 0.82
			## drawing No. TOWXT895/5082-P
			tpunch_know = 'x'
			tpunch_land = 0.1   ## after round
			tpunch_land_R = 0.06

			tpunch_land_angle = 14.5
			tpunch_cap_angle = None
			tpunch_mid_round = None
			tpunch_top_round = 0.93

			tpunch_mid_D = None	## 比die_D略小
			tpunch_mid2top = None  ## 到帽顶的距离

			tpunch_depth = 3.22

		else:
			die_D = 23.942
			die_R = die_D/2.0

			## contraction: 0.82
			## Ejector drawing No: GT9S180_ejB
			ejector_know = 'x'
			ejector_R = 12.26		;changing
			ejector_tangent_angle = None    ##    17
			ejector_land = 0.1         ##  0.08
			ejector_land_R = 0.06       ##    0.05
			ejector_depth = None  ## ???????

			## contraction: 0.82
			## drawing No. TOWXT895/5082-P
			tpunch_know = 'x'
			tpunch_land = 0.1   ## after round
			tpunch_land_R = 0.06

			tpunch_land_angle = 14.5
			tpunch_cap_angle = None
			tpunch_mid_round = None
			tpunch_top_round = 0.93

			tpunch_mid_D = None	## 比die_D略小
			tpunch_mid2top = None  ## 到帽顶的距离
			tpunch_depth = 3.22


	tpunch = 'tpunch'		;	tpunch_A1 = 'tpunch_A1'
	bpunch = 'bpunch'		;	bpunch_A1 = 'bpunch_A1'
	powder = 'powder'		;	powder_A1 = 'powder_A1'
	die = 'die'				;	die_A1 = 'die_A1'

	locals2globals(locals0,locals(),save_var=True)


##	dx = 'dx'
##	dy = 'dy'
##	x = 'x'
##	y = 'y'

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	## bottom punch
	s1 = create_base_sketch('sk_ejector')

	point1,point2,circle=create_arc(s1,center=(0,ejector_R),radius=ejector_R,quarter=4)
	s1.FixedConstraint(entity=circle)

	if with_tangent == True:
		line2 = create_construction(s1,point1=(0,0),angle=90-ejector_tangent_angle,fix=False)
		tangent_loc = tangent_constraint(s1,circle,line2)


##		create_construction(s1,x=die_R - ejector_land - ejector_land_R)
		arc1 = geometry_at(s1,point2)
		del_geometry(s1,arc1)

		x1 = tangent_loc[0]
		x2 = die_R - ejector_land - ejector_land_R

		if x2 < x1:
			raise Exception('*** Tangent angle is two small.')
		connect_points(s1,tangent_loc,xytilt(Ay=ejector_tangent_angle,x1=x1,x2=x2),('x',die_R),('dx',0.5))

	else:
		if ejector_know == 'x':
			bias_cut_sketch(s1,x=die_R - ejector_land - ejector_land_R)

			loc = find_loc(s1,x=MAX)
			connect_points(s1,loc,('x',die_R),('dx',0.5))

	locs = locs_of_sketch(s1,y=MAX)
	round_sketch_corner(s1,loc=locs[0],radius=ejector_land_R)

##	raise Exception

	## top punch, 画草图时，最好从punch_OD开始。
	s1 = create_base_sketch('sk_tpunch')
	loc0 = (die_R + 0.5, 0)

	if tpunch_know == 'y':  ## y方向的尺寸是明确的
		locs = connect_points(s1, loc0, (x,tpunch_OD/2.0), (dx,-tpunch_land), xytilt(dx=-die_R + tpunch_mid_D/2, Ay=tpunch_land_angle),
			xytilt(dy=tpunch_mid2top,Ax=-tpunch_cap_angle), (x, 0))
	elif tpunch_know == 'x':  ## x方向的尺寸是明确的
		if product == '50160': ## with top mid
			locs = connect_points(s1, loc0, ('x',die_R), ('dx',-tpunch_land - tpunch_land_R),
			xytilt(x1=die_R - tpunch_land - tpunch_land_R,x2=tpunch_mid_D/2,Ay=tpunch_land_angle),
			xytilt(dy=tpunch_mid2top,Ax=-tpunch_cap_angle), ('x', 0))

			mid_loc = locs[-3]

		elif product == '5068H':
			locs = connect_points(s1, loc0, ('x',die_R), ('dx',-tpunch_land - tpunch_land_R))
			connect_points(s1,xytilt(y=tpunch_depth,Ay=-tpunch_land_angle))
			connect_points(s1,('x',0))

	loc1 = locs_of_sketch(s1,y=MIN)[0]
	round_sketch_corner(s1,loc=loc1,radius=tpunch_land_R)

	locs = locs_of_sketch(s1,sort='x')
	round_sketch_corner(s1,loc=locs[1],radius=tpunch_top_round)

	if is_number(tpunch_mid_round):
		round_sketch_corner(s1,loc=mid_loc,radius=tpunch_mid_round)

##	raise Exception

	if 'fill_volume0' in globals().keys():
		assembly_and_fill(top_sketch='sk_tpunch',bot_sketch='sk_ejector',fill_volume=fill_volume0) ## s_punch和s_ejector会被移动。
	elif 'PFH' in globals().keys():
		assembly_and_fill(top_sketch='sk_tpunch',bot_sketch='sk_ejector',PFH=PFH,weight_density=False) 	;changing ## s_punch和s_ejector会被移动。

##	raise Exception

	bot_points = xlocs(powder,ny=-1,x=(MIN1,MAX1))

	vertices = vertice_select(powder,ny=-1,x=(MIN1,MAX1))
	if vertices not in empty:
		ignore_vertices(powder,vertices=vertices)

	if len(bot_points) >=2:
		divide(powder,x=bot_points[-2])

	## ignore left top corner
	divide_length = _ylength(tpunch)
	edges = edge_select(powder,x=MIN)
	divide_edge(edges,y=_ymax(powder) - 0.25*divide_length)	;changing   ## 上冲越深，需要劈开的距离越大，反之越小。
	## 粉体密度越低，系数越可调大。反之，系数要调小。
	## 网格密度越大，相当于粉体密度增大。

	vertices = vertice_select(powder,x=MIN,y=MAX)
	ignore_vertices(powder,vertices=vertices)

	## steps, output
	times1 = myrange(0,1,0.05) + [0.001, 0.002, 0.005, 0.01, 0.02]	## 调试一开始需要仔细观察。
	timepoints1 = create_timepoints(times1)	;changing1

	create_dynamic_explicit_step(step='move', timePeriod=1.0)

	field_output_request(timepoints=timepoints1)

##	raise Exception

	edges = edge_select(powder,x=MAX1)
	seed_edges(powder,edges=edges,enum=10)	;changing   ## 10

	edges = edge_select(powder,x=MIN1)
	seed_edges(powder,edges=edges,enum=25,fixed=True)  ;changing    ## 网格过疏时，左上角可能会冒出来。good: 30

##	edges = edge_select(powder,y=MID,exterior=False)
##	seed_edges(powder,edges=edges,enum=1,fixed=True)

##	edges = edge_select(powder,x=MAX)
##	bias_seed_edges(powder,edges=edges,enum=50,ratio=30,single_dir=False,flip=False)

	set_element_shape(powder, objs=_part(powder).faces, technique='STRUCTURE')
	mesh_region(powder,esize=2)	;changing

##	raise Exception

	adaptive_mesh_control()
	apply_adaptive_mesh(elements=_inst('powder_A1').elements, frequency=1,sweep=10)	## ;changing  (不好，会使应力由下冲位置移到上冲位置)
##	elems = element_select('powder_A1',x=(die_R, die_R*0.3)) + \
##		element_select('powder_A1',poiRefY=(MAX,-L/5)) + \
##		element_select('powder_A1',y=(MIN,L/6))					;changing
##	apply_adaptive_mesh(elements=elems, frequency=1,sweep=10)
	## 经验：如果与上冲接触的粉体不采用自适应，可能会冒出来；同样地，如果与下冲接触的粉体不采用自适应，计算过程中也可能会冒出来。
	## 冒出来不是接触的问题，而是由于没有自适应，过于刚硬。

	## Interact
	m_punch = create_surface(tpunch_A1,side='-y')
	m_ejector = create_surface(bpunch_A1,side='+y')
	m_die = create_surface(die_A1,side='-x')

	elems = element_select('powder_A1',poiRefY=(MAX,-1.5*divide_length))
	surf_top = create_surface(elements=elems,name='surf_top',select_sym=True)

	elems = element_select('powder_A1',poiRefX=(MAX,-die_R/5))  ;changing
	surf_right = create_surface(elements=elems,name='surf_right')

	elems = element_select('powder_A1',y=(_ymin('powder_A1'),_ylength(bpunch)))  ;changing
	surf_bot = create_surface(elements=elems,name='surf_bot')

##	raise Exception

	changing
	s2s_interact_exp('int_punch',master_region=m_punch, slave_region=surf_top)
	s2s_interact_exp('int_die',master_region=m_die, slave_region=surf_right)
	s2s_interact_exp('int_ejector',master_region=m_ejector, slave_region=surf_bot)


	## Loads
	punch_depth = _ylength(tpunch)
	total_compressed = punch_depth + PFH - PH
	## before: punch_depth + L + PV
	## after: PH
	## total compressed: punch_depth + L + PV - PH （上冲的压缩量+下冲的压缩量）
	## 其中die的行程(等效下冲动): PV
	## 实际上，下冲不动 ，所以total compressed也就是上冲的全部行程。

	## top punch走total_compressed
	_m.TabularAmplitude(name='top_move', timeSpan=STEP,
	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, -dip), (0.50, -dip - PV),  (1.0, -total_compressed)))

	## die只走PV, bot punch始终不动。
	_m.TabularAmplitude(name='die_move', timeSpan=STEP,
	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, 0), (0.50, -PV),  (1.0, -PV)))

##	_m.TabularAmplitude(name='top_move2', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, -dip - PV),  (0.5, -total_compressed)))

	apply_BC_on_RP_2D(bpunch_A1,U1=0,U2=0,UR3=0,stepname='step1')	## bpunch is always stable
	apply_BC_on_RP_2D(tpunch_A1,U1=0,UR3=0,stepname='step1')
	apply_BC_on_RP_2D(die_A1,U1=0,UR3=0,stepname='step1')

##	apply_BC_on_RP_2D(tpunch_A1,U2=0,stepname='step1',modifys=('step2','U2','top_move'))
##	apply_BC_on_RP_2D(tpunch_A1,U2=0,stepname='step1',modifys=[('step2','U2','top_move'),('step3','U2','top_move2')])
##	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1',modifys=('step2','U2','top_move2'))
	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1')

##	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step1',modifys=('step2','U2','die_move'))	;changing
##	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step3')
	apply_BC_on_RP_2D(die_A1,U2=1,amplitude='die_move',stepname='step1')

##	apply_gravity()

	raise Exception

##	check1()
	create_inp(inp_file_title,request_num=6) 		;please_check
	mdb.jobs[inp_file_title].submit()
##	back_run()

	return

def main_A0253_tunnel_boring_ring():
	## VER: 2015-11-12, v1.0

	check_script_file('BH_A0253_TBM_ring2_ter.py')

	if 'ring_bis' in inp_file_title:
		stp_file = 'composite-tbm-ring_bis_asm'
	elif 'ring_ter' in inp_file_title:
		stp_file = 'composite-tbm-ring_ter_asm'
	elif 'ring2_bis' in inp_file_title:
		stp_file = 'composite-tbm-ring2_bis_asm'
	elif 'ring2_ter' in inp_file_title:
		stp_file = 'composite-tbm-ring2_ter_asm'

	open_cae(stp_file, new_name=inp_file_title)

	locals0 = locals().keys()

	analysis1_title = inp_file_title	;changing1

	load = 241.5*2   ## MPa

	locals2globals(locals0,locals(),save_var=True)

	cut_instances(z=0,cut_sides='+z')
	cut_instances(y=0,cut_sides='-y')

	faces = face_select('p-1',z=0)
	base = faces_to_shellpart(faces,name='base')

	faces = face_select('p-2',z=0)
	base = faces_to_shellpart(faces,name='carbide')

	del_insts()

	set_mat('base',mat='Steel')
	set_mat('carbide',mat='H15F')
	set_plastic('Steel',(1100,0),(1600,0.015))		;changing

	divide('base',x=0)
	divide('base',y=189)

	new_instance('base')
	new_instance('carbide')

	create_general_static_step()
	field_output_request();

	mesh_2D('base',esize=1)
	mesh_2D('carbide')

	## Interact
	y0 = ylocs('base',x=0)[1]

	edges1 = get_connected_edges('base_A1',loc=(0,y0,0))
	surf1 = create_surface('base_side',edges=edges1)

	edges2 = _inst('carbide_A1').edges
	surf2 = create_surface('carbide_side',edges=edges2)

	s2s_tie('tie',mregion=surf2,sregion=surf1)

	## Load and BC
	edges = edge_select('base_A1',y=MIN)
	apply_disp_fix('fix_base',edges=edges,Ux=0,Uy=0,Uz=0,UR3=0)

	edges = edge_select('base_A1',poiRefY=(MAX,-1))
	surf3 = create_surface('surf_top',edges=edges)
	apply_pressure('press',edges=edges,MPa=load)

	create_inp(inp_file_title,request_num=6) 		;please_check
	mdb.jobs[inp_file_title].submit()

	return

def main_A0247_wiredraw_919():
	## VER: 2015-01-14, v1.0

	check_script_file('E2_A0247_wiredraw_9x6_B45_Red11_int35_h07_num5.py')
	purpose = 'parameter study from Paramount.'
	history='A7:use double precision; A1:based on job#:A0232'

##	existed_cae = 'CH_A0232_explicit_fric01_316L_deg60'	;changing1
##	existed_odb = 'CH_A0232_explicit_fric01_316L_deg60'	;changing1

	locals0 = locals().keys()   ## need both stp file and assembly file with bearing dimensions.
	## for D12H10 nib, the bearing diameter=0.8mm, then wire diameter= 0,889
	## for D9H6 nib, the bearing diameter=0.1mm, then wire diameter=0,111
	## bell->approach -> reduction -> bearing -> relief->exit

	nib_type = 'D9H6'		;changing1  ## D6H7, D9H6
	## analysis1=1: only shrink-fit
	## analysis1=12: step1=shrink-fit, step2=drawing (dynamic implic if no thermal, coupled temp-disp if with thermal in antype1)

	## 1-shrinkfit, 2-drawing
	## analysis1: implicit analysis
	analysis1 = 1				;changing1   ## 1, 12, None
	antype1 = 'stress'				;changing1		## stress, thermal_stress
	analysis1_title = inp_file_title	;changing1

	## 显式动力学分析： create_coupled_temp_displacement_step
	analysis2 = 2				;changing1	## 2, None
	analysis2_title = analysis1_title + '_drawing'	;changing1

	friction = 0.1			;changing
	draw_time = 1.5e-4  		;changing1
	carbide_yield = 5000	;changing1

	if analysis1 in empty:
		open_cae(existed_cae, new_name=analysis1_title)
	else:
		blank_cae(analysis1_title)

##	raise Exception

	get_nib_dimensions(nib_type)

	## wire
	wire_D = 0.34			;changing
	wire_R = wire_D/2
	wire_length = 20		;changing1
	wire_cut_H = 1

	speed = -10*1000		;changing1
	wire_cut_x=0.1
	wire_cut_y = 0.2

	## nib cut
	cut_angle_y = 45		;changing
	cut_width = 0.3
	cut_height = cut_width/tanD(cut_angle_y)
##	cut_height = 1.15
##	cut_width = cut_height*tanD(cut_angle_y)
	cut_round_y = 0.5		;changing
	cut_round_x = 0

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'
	wire = 'wire'
	wire_A1 = 'wire_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

##	raise Exception
	material_database()
	create_contact_props(friction=friction)				;changing

##	raise Exception

	## wire elastic
##	wire_plastic = (275,0), (690, 0.2), (960, 0.4), (1206, 0.6), (1654, 1), (2240, 1.6)  ## hardening steel
##	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
##	set_plastic('Steel', wire_plastic)	;changing
##	set_plastic('Steel', (500, 0))	;changing

	wire_plastic = (425,0,20),(575,0.03,20),(660,0.06,20),(730,0.09,20),(760,0.12,20),(790,0.15,20), \
					(400,0,200),(530,0.03,200),(610,0.06,200),(660,0.09,200),(700,0.12,200),(710,0.15,200)
	set_plastic('Steel_SS316L', wire_plastic)	;changing1

	set_plastic('H3F',(carbide_yield,0))		;changing1

##	raise Exception

	if analysis1 not in empty:
		if analysis1 == 2:  ##
##			open_cae('_imported_' + nib_type, new_name=analysis1_title)
			open_cae(existed_cae, new_name=analysis1_title)

			edges = edge_select('nib0',x=(MID,MAX),z=MAX)
			sketch = edges_to_sketch(edges,sketchname='sk_nib')
			s1 = sketch['sketch']

			if cut_angle_y == 45:
				loc1 = find_loc(s1,x=MAX,groupY=MIN)
				loc2 = find_loc(s1,y=MIN,groupX=MAX)

				edges = geometry_select(s1,x=(loc1[0],loc2[0]),y=(loc1[1],loc2[1]))
				del_geometry(s1,edges)
				connect_points(s1,loc2,('x',_xmax(s1)),loc1)	;changing

				sketch_to_shell(s1,partname='nib',symmetric=True)
				bias_cut('nib',cut_sides='bot_right',point1=(_xmax('nib'),_ymin('nib') + cut_height),angle_with_Y=cut_angle_y)

			else:
				sketch_to_shell(s1,partname='nib',symmetric=True)

			edges = edge_select('case0',x=(MID,MAX),z=MAX)
			sketch = edges_to_sketch(edges,sketchname='sk_case')
			s1 = sketch['sketch']
			sketch_to_shell(s1,partname='case',symmetric=True)

			new_instance('nib')
			new_instance('case')

		else:
			## Nib
			s1 = create_base_sketch('sk_nib')
			loc0 = (bearing_R,0)
			loc1 = loc0

##			print fnln(),loc0,xytilt4(Ay=relief_dy,dy=-relief_angle/2)

			if relief_dy > 0:
				connect_points(s1,loc0,xytilt4(dy=-relief_dy,Ay=relief_angle/2))
				loc1 = last_point

			connect_points(s1,loc1,xytilt4(dy=-exit_dy,Ay=exit_angle/2),('x',nib_R),('dy',nib_H))


			if bearing_length > 0:
				connect_points(s1,loc0,('dy',bearing_length))
				loc1 = last_point
##			raise Exception

			if approach_angle not in empty:  ## there is approach slope line
				locs = connect_points(s1,loc1,xytilt1(dy=reduction_dy,Ay=reduction_angle/2),xytilt1(dy=approach_dy,Ay=approach_angle/2),('x',nib_R))
				round_sketch_corner(s1,loc=locs[-2],radius=bell_R)
			else:
				line1 = slope_construction(s1,loc=loc1,angle=90 - reduction_angle/2)
				dict1 = create_tangent_circle(s1,radius=bell_R,center_x=10, center_y=(MAX,-bell_center_to_top),tangent_line=line1, toY=_ymax(s1))
				connect_points(s1,loc1,dict1['start'])
				connect_points(s1,dict1['end'],('x',nib_R))
				round_sketch_corner(s1,loc=dict1['end'],radius=bell_round)

			sketch_to_shell(s1,partname='nib',symmetric=True)

			move_part(nib,y1=MIN,y2=nib_bot_to_bot)
			bias_cut(nib,cut_sides='bot_right',point1=(nib_R,_ymin(nib) + cut_height), point2=(nib_R - cut_width,_ymin(nib)))
##			bias_cut(nib,cut_sides='bot_right',point1=(nib_diameter/2,_ymin(nib) + cut_height), angle_with_Y = 15)

			round_corner(nib,x=MAX,groupY=MIN,radius=cut_round_y)
			round_corner(nib,y=MIN,groupX=MAX,radius=cut_round_x)

			edges = edge_select(nib,nx=-1,ny=-1,y=MIN1)
			divide_edge(edges=edges[0],xpar=0.4)

			new_instance(nib)

##			raise Exception

			## case
			s1 = create_base_sketch('sk_case')
			loc0 = (case_land_ID/2,nib_bot_to_bot)	## nib的底面

			connect_points(s1,loc0,('dy',-case_land_H),xytilt4(dy=-nib_bot_to_bot + case_land_H, Ay=case_exit_angle/2), ('x',case_R),('y',case_H))
			locs = loc0,('x',case_ID/2),('dy',nib_H + rivet_offset),('dx',-rivet_L),('dy',rivet_H),('dx',rivet_L)
			connect_points(s1,points=locs)

			locs = last_point, ('y',case_H - case_entrance_cut), xytilt1(dy=case_entrance_cut,Ay=case_entrance_cut_angle), ('x',case_R)
			connect_points(s1,points=locs)

			sketch_to_shell(s1,partname='case',symmetric=True)

			bias_cut(case,cut_sides='bot_right',point1=(case_R,case_corner_chamfer),angle_with_Y=45)
			bias_cut(case,cut_sides='top_right',point1=(case_R,case_H - case_corner_chamfer),angle_with_Y=45)

##			raise Exception

##			loc = find_loc(case,y=MAX,groupX=MIN)
##			bias_cut(case,cut_sides='top_left',point1=(loc[0],loc[1] - case_entrance_cut,0),angle_with_Y=case_entrance_cut_angle)
##			raise Exception

			new_instance(case)

	##	divide(case,y=_ymin(nib,x=MAX))

##		raise Exception

		## wire
		yloc = ylocs('nib',x=MIN)[-1] + 2
		create_rectangle_shell('wire',corner1=(0,0),corner2=(wire_R, wire_length),axis_symmetric = True)
##		move_part(wire,y1=MIN,y2=yloc)
		move_part(wire,y1=MIN,y2=_ymin(nib) + 1.5)

	##	bias_cut(wire, cut_sides='bot_right', point1=(wire_R, _ymin(wire) + 0.2, 0), point2=(wire_R*0.7, _ymin(wire), 0))
		bias_cut(wire,cut_sides=('+x','-y'), point1=(wire_R, _ymin(wire) + wire_cut_H), point2=(wire_R/2,_ymin(wire)))
	##	round_corner(wire,radius=5,x=MAX,groupY=MIN)

		vertices = vertice_select(wire,x=MAX,groupY=MIN)
		ignore_vertices(wire,vertices=vertices)

		new_instance(wire)

##		raise Exception

	##	divide(wire,y=_ymin(wire) + wire_cut_H)
		divide(wire,y=_ymin(wire) + wire_cut_H + 0.5)	;changing1

		set_mat(nib,mat='H3F')
		set_mat(case,mat='Steel_C45')
##		set_mat(wire,mat='Steel')	;changing1
		set_mat(wire,mat='Steel_SS316L')	;changing

		## step
		times1 = myrange(0,1,0.05)
		timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1

		times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,10, 0.5) + myrange(11,200, 2.0)		;changing1
		timepoints2 = create_timepoints(times2,factor=1e-5)

		if analysis1 == 1:
			create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)
			field_output_request(timepoints=timepoints1,variables=ALL)
		elif analysis1 == 12:
			if 'thermal' not in antype1:
				create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
##				create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='transient',matrix_storage='UNSYMMETRIC')
				create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')
			else:
				create_coupled_temp_displacement_step(stepname='shrink_fit',period=4e-5)
				create_coupled_temp_displacement_step(stepname='draw',timePeriod=draw_time,response='transient')
			field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

		## create surfaces
		edges = edge_select(case_A1,ny=1,groupY=MIN)
		create_surface('case_land',edges=edges)

		please_check
		edges = edge_select('case_A1',nx=-1,x=(MIN1,MAX),y=_yspace('nib'))
		create_surface('case_ID',edges=edges)

		please_check
		edges1 = edge_select(nib_A1,nx=1)  ## use for general contact
	##	edges1 = edge_select(nib_A1,x=MAX,y=MID)
		create_surface('nib_OD',edges=edges1)

		edges = edge_select(nib_A1,nx=1,ny=-1)
	##	edges = unselect(edges, edges1)
		create_surface('nib_corner', edges=edges)

		edges = edge_select(case_A1,x=case_ID/2,y=_ymin(nib,x=MAX) - 0.1)
		create_surface('case_corner',edges=edges)

		edges = edge_select(nib_A1,y=MIN)
		create_surface('nib_bot', edges=edges)

		edges3s = edge_select(wire_A1,nx=1)
		create_surface('wire_surf',edges=edges3s)

		vertices = vertice_select(nib_A1,x=MIN)
		edges3m = vertices_to_edges(vertices)
		create_surface('nib_surf',edges=edges3m)

		edges1 = edge_select(nib_A1,y=MAX)
		create_surface('nib_top',edges=edges1)

		edges2 = edge_select(case_A1,y=_ymax(nib_A1) + rivet_offset)
		create_surface('rivet_bot',edges=edges2)

		get_current_model()

##		raise Exception

		## mesh case
		edges = edge_select(case,x=(MIN,case_ID/2.0 + 0.1),y=(MIN1,MAX1))
		seed_edges(case,edges=edges,esize=0.15)	;changing1

		mesh_2D(case,esize=0.5)		;changing1

		## mesh nib
	##	esize = 0.02	;changing
	##	edges = edge_select(nib,nx=-1,y=(MIN,MID))

		ref0 = bearing_length/4
		if ref0 < 0.02:
			esize = 0.02
		elif ref0 > 0.07:
			esize = 0.07
		else:
			esize = ref0
		esize = round(esize,3)		;changing
##		esize = round(min(bearing_length/3,0.05),3)
##		esize = round(min(bearing_length/3,0.05),3)
	##	edges = edge_select(nib,x=(MIN,MIN1))
		edges = edge_select(nib,poiRefX=(MIN,wire_R))
##		seed_edges(nib,edges=edges, esize=esize)			;changing1
		seed_edges(nib,edges=edges, enum=5)	;changing

	##	edges = edge_select(nib,x=MIN)
	##	seed_edges(nib,edges=edges, enum=4)		;changing1

	##	edges = edge_select(nib,nx=1)
	##	seed_edges(nib,edges=edges,esize=0.1)

		mesh_2D(nib,esize=0.15)	;changing1

		## mesh wire
		edges = edge_select(wire,y=MAX) + edge_select(wire,y=MIN)
		seed_edges(wire,edges=edges,enum=12)	;changing1 ## enum

		mesh_2D(wire,esize=esize)

##		raise Exception

		## 以下适用于已经存在过盈
		create_general_contact_std(friction='Friction + Heat generation',interference_pairs=(('nib_OD','case_ID','interfernce_fit')))	;changing1

##		raise Exception

		## Fix
		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

##		raise Exception

		if analysis1 == 12:
			edges = edge_select(wire_A1,y=MAX)
			apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0,deactive_step='step2')

			faces = face_select(wire_A1,y=MIN1,mark_select=True)
			apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing1

			if 'thermal' in antype1:
				set_temperature_predefined_field(initial_step=20)	;changing1

				edges = edge_select(wire_A1,nx=1)
				apply_surface_convection('wire_convection',faces=edges,h = 1000,step='step2')	;changing1

				edges = edge_select(nib_A1,nx=-1)
				apply_surface_convection('nib_convection',faces=edges,h = 1000,step='step2')		;changing1

		else:
			edges = edge_select(wire_A1,y=MAX)
			apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0)

		_results_dict = { 'Nib':('S1','PEEQ'), 'CASE':('U','Mises','PEEQ')}

##		raise Exception

##		existed_odb = analysis1_title	;changing1
		create_inp(analysis1_title,request_num=6,submit=False)
		mdb.jobs[analysis1_title].submit()

##		raise Exception

	if analysis2 not in empty:
		if analysis1 not in empty:
			mdb.jobs[analysis1_title].waitForCompletion()

		copy_model(to_name = 'draw')
		del mdb.models['Model-1']
		clear_model_settings()
		create_heat_from_plastic_work(['wire','nib'])

		antype2 = 'stress','temp'	;changing

	##	raise Exception
		times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,10, 0.5) + myrange(11,200, 2.0)		;changing1
		timepoints2 = create_timepoints(times2,factor=1e-5)

##		raise Exception

		create_coupled_temp_displacement_step(step='draw', timePeriod=draw_time, response='dynamic')	;changing1
##		create_dynamic_explicit_step(step='draw', timePeriod=draw_time)
		field_output_request(timepoints=timepoints2)

##		choose_element_type('case')
##		choose_element_type('nib')
##		choose_element_type('wire')
		choose_element_types()
		import_initial_stress(analysis1_title)				;changing1
		set_temperature_predefined_field(initial_step=20)	;changing1

##		create_general_contact_exp(prop='Friction + Heat generation')	;changing  ## not supported for 2D

##		changing1
		s2s_interact_exp('int_nib_support', mfaces='nib_bot', sfaces='case_land', prop='Friction + Heat conduction',sliding='small')

		s2s_interact_exp('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',prop='Friction + Heat conduction',sliding='small')

		s2s_interact_exp('int_nib_rivet', mfaces='nib_top', sfaces='rivet_bot',prop='Friction + Heat conduction',sliding='small')

	##	s2s_interact_exp('int_nib_corner',mfaces='nib_corner',sfaces='case_corner')  ## 在有初始过盈的情况下，必须设置shrink fit,否则一开始由于侵入，不收敛。
	##	s2s_interact_exp('int_nib_corner2',mfaces='nib_corner',sfaces='case_land')

		s2s_interact_exp('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',prop='Friction + Heat generation')

##		raise Exception

		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
		apply_velocity(name='pull_speed',faces=faces, Vy=speed)	;changing

		edges = edge_select(wire_A1,nx=1)
##		apply_surface_convection('wire_convection',faces=edges,h = 'Heat convection')
		apply_surface_convection('wire_convection',faces=edges,h = 1000)	;changing1

		edges = edge_select(nib_A1,nx=-1)
##		apply_surface_convection('nib_convection',faces=edges,h = 'Heat convection')
		apply_surface_convection('nib_convection',faces=edges,h = 1000)		;changing1

##		raise Exception

		mdb.saveAs(analysis2_title)

		create_inp(analysis2_title,clear_jobs=False)
		mdb.jobs[analysis2_title].submit()


	return


def main_A0258_press_tool_design():
	## started: 2014-06-13, started, 2015-03-26 continued

	check_script_file('CO_A0258_press_tool_R015_deg60_nosym.py')		;changing
	history = 'C0: to check inner radius effect; B7:no hole; AX:hole fix; AU:hole not fixed; AS:with steel DAM outside the steel case; A1:model'

	blank_cae(inp_file_title)

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	locals0 = locals().keys()

	analysis1_title = inp_file_title	;changing1

	## 长方形的case的外围尺寸不能修改
	## 200t设备，对各个模具都一样
	case_length = 580
	case_width = 149.5

##	dam_width = 250
##	dam_length = case_length

	hole_fix = False			;changing1
	have_frame = True			;changing
	model = '3D'				;changing
	if model == '3D':
		hole_fix = False

	case_OD_x = case_width
	case_OD_y = case_length

	frame_ID_x = case_OD_x
	frame_ID_y = case_OD_y

	## 200t设备，对各个模具都一样
	frame_thick = 150
	die_thick = 95

	bot_open_x = 100
	frame_width = 600
	if model == '2D':
##		frame_width = frame_width + (case_width - bot_open_x)*2   ## compensate
		frame_width = frame_width + case_width*1.5

	frame_OD_x = frame_width
	frame_thick_x = (frame_width - case_width)/2

	bot_open_y = 500
	frame_thick_y = 170
	if model == '2D':
##		frame_thick_y = frame_thick_y + (case_length - bot_open_y)  ## compensate
		frame_thick_y = frame_thick_y + case_length/4

	frame_OD_y = frame_ID_y + 2*frame_thick_y
	frame_length = frame_OD_y

	axial_pressure_max = 164   ## 164MPa
##	work_ratio = 0.841				;changing1
##	work_pressure = axial_pressure_max*work_ratio
	work_pressure = 138
	work_ratio = work_pressure/axial_pressure_max

	lateral_coefficient = 0.5	;changing1
	cavity_num = 1

	carbide_mat = 'H10F'		;changing1

	situation = 'work'	;changing  ## work or max
	design = 'old'		;changing
	if design == 'old':
		carbide_cavity_x = 19.086   ## ID cannot change, sintered D=20.3mm  (carbide_cavity_x is the carbide_cavity_x)
		carbide_cavity_y = 295
		work_ton = 100    ## origin: 150ton
		max_ton = 178

	else:
		carbide_cavity_x = 38.95   ## ID cannot change, sintered D=30.3mm
		carbide_cavity_y = 235  ;changing # original: 235 (156)(77)
		piece_length = 79  ## 77 + 79=156, 156+79=235

	## origin
##	carbide_wall_x = 28.025
##	carbide_wall_y = 20

##	wall = globals()['wall']
##	carbide_wall_x = 28	;changing
##	carbide_wall_y = 23

##	carbide_OD_x = carbide_cavity_x + 2*carbide_wall_x
##	carbide_OD_y = carbide_cavity_y + 2*carbide_wall_y

##	wall = carbide_wall_x

##	carbide_wall_x = (carbide_OD_x - carbide_cavity_x)/2
####	carbide_wall_y = (carbide_OD_y - carbide_cavity_y)/2
##	carbide_OD_y = carbide_cavity_y + 2*carbide_wall_y

	if design == 'old':
		carbide_OD_x = 60
		carbide_OD_y = 345
	else:
		carbide_OD_x = 95
		carbide_OD_y = 275  	;changing		## original: 275 (200)

	carbide_wall_x = (carbide_OD_x - carbide_cavity_x)/2
	carbide_wall_y = (carbide_OD_y - carbide_cavity_y)/2

	cavity_area = carbide_cavity_x*carbide_cavity_y

##	axial_ton_max = axial_pressure_max*cavity_area/(1000*9.8)*cavity_num
##	work_ton = axial_ton_max*work_ratio

	PH = 30		;changing	### origin: 10
	force_max = pressure_on_area(carbide_cavity_x, carbide_cavity_y,axial_pressure=axial_pressure_max,lateral_coefficient=lateral_coefficient)  ## (178.24, 10650.93, 164.0, 82.0)
	force_work = pressure_on_area(carbide_cavity_x, carbide_cavity_y,ton=work_ton,lateral_coefficient=lateral_coefficient)	## 150 10650.93 138.02 69.01
	if situation == 'max':
		side_pressure = force_max[3]	;changing1
	else:
		side_pressure = force_work[3]

##	area1 = 26.38*403.75		## 10650.925
##	ton1 = 178  ## 178 ton force
##	axial_ref1 = round(ton1*9800/area1,1)   ## 163.8 MPa
##	side1 = axial_ref1*lateral_coefficient   ## 98.28MPa
##
##	area2 = 26.38*403.75		## 10650.925
##	ton2 = 150  ## 178 ton force
##	axial_ref2 = round(ton2*9800/area1,1)   	## 138.0 MPa
##	side2 = axial_ref2*lateral_coefficient		## 82.8 MPa

	## max: (178, 10650.93, 163.78, 98.27)
	force_old_max = ton_on_area(178, 403.75, 26.38, lateral_coefficient)   ## sintered D=20.3mm, 20.3/26.38 = 0.77

	## work: (150, 10650.93, 138.02, 82.81)
	force_old_work = ton_on_area(150, 403.75, 26.38, lateral_coefficient)

	## max: (153, 9153.25, 163.81)
	force1_new_max = ton_on_area(153, 235, 38.95, lateral_coefficient)

	## max: (153.18, 9153.25, 164.0, 98.4)
	force2_new_max = pressure_on_area(164, 235, 38.95, lateral_coefficient)	## sintered D=30.3mm, 30.3/38.95 = 0.778

	## max: (50.19, 2999.15, 164.0, 98.4)
	force3_new_max = pressure_on_area(164, 77, 38.95, lateral_coefficient)

	## max: (101.68, 6076.2, 164.0, 98.4)
	force4_new_max = pressure_on_area(164, 156, 38.95, lateral_coefficient)

	interference = 0.06   ## coventry: 80um, taiwan: 60um

	case_ID_x = carbide_OD_x - interference*2
	case_ID_y = carbide_OD_y - interference*2

	case_wall_x = (case_OD_x - case_ID_x)/2
	case_wall_y = (case_OD_y - case_ID_y)/2
	ratio_x = round(carbide_wall_x/case_wall_x,2)
	ratio_y = round(carbide_wall_y/case_wall_y,2)

	corner_R = 8		## carbide outer R
	inner_R = 0.15		;changing  ## carbide inner R, origin = 0.15
	cavity_angle = 60	;changing  ## Angle for cutting edge, origin=62
	hole_D = 9
	hole2hole = 180
	hole2edge_y = (case_length - 3*hole2hole)/2
	hole2edge_x = (case_width - 125)/2
	symm = ''	;changing   ## origin: 'xy'

	hole_x = case_OD_x/2 - hole2edge_x
	hole_y1 = case_OD_y/2 - hole2edge_y - hole2hole
	hole_y2 = case_OD_y/2 - hole2edge_y

	carbide = 'carbide'		;		carbide_A1 = 'carbide_A1'
	frame = 'frame'			;		frame_A1 = 'frame_A1'
	case = 'case'			;		case_A1 = 'case_A1'

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception
	## carbide
	s1 = create_base_sketch('sk_carbide')
	if symm == 'xy':
		connect_points(s1,(carbide_cavity_x/2,0),('dy',carbide_cavity_y/2))
		connect_points(s1,xytilt3(x=0,Ay=cavity_angle),('y',carbide_OD_y/2),('x',carbide_OD_x/2),('y',0),(carbide_cavity_x/2,0))

		round_sketch_corner(s1,loc=(carbide_cavity_x/2, carbide_cavity_y/2),radius=inner_R)
		round_sketch_corner(s1,loc=(carbide_OD_x/2, carbide_OD_y/2),radius=corner_R)
	elif symm in empty:
		connect_points(s1,(carbide_cavity_x/2,0),('dy',carbide_cavity_y/2))
		connect_points(s1,xytilt3(x=-carbide_cavity_x/2,Ay=cavity_angle),('y',-carbide_cavity_y/2))
		connect_points(s1,xytilt1(x=carbide_cavity_x/2,Ay=cavity_angle),('y',0))
		round_sketch_corner(s1,loc=(carbide_cavity_x/2, carbide_cavity_y/2),radius=inner_R)
		round_sketch_corner(s1,loc=(-carbide_cavity_x/2, -carbide_cavity_y/2),radius=inner_R)

		connect_points(s1,(carbide_OD_x/2,0),('y',carbide_OD_y/2),('x',-carbide_OD_x/2),('y',-carbide_OD_y/2),('x',carbide_OD_x/2),('y',0))
		round_sketch_corner(s1,loc=(carbide_OD_x/2, carbide_OD_y/2),radius=corner_R)
		round_sketch_corner(s1,loc=(-carbide_OD_x/2, carbide_OD_y/2),radius=corner_R)
		round_sketch_corner(s1,loc=(-carbide_OD_x/2, -carbide_OD_y/2),radius=corner_R)
		round_sketch_corner(s1,loc=(carbide_OD_x/2, -carbide_OD_y/2),radius=corner_R)

	if model == '3D':
		extrude_sketch_to_part('carbide', sketch=s1, length=die_thick)

		divide(carbide,z=_zmid(carbide) - PH/2)
		divide(carbide,z=_zmid(carbide) + PH/2)

	else:
		sketch_to_shellpart(s1,partname='carbide')


	## case
	s1 = create_base_sketch('sk_case')
	if symm in empty:
		connect_points(s1,(case_OD_x/2, case_OD_y/2),('x',-case_OD_x/2),('y',-case_OD_y/2),('x',case_OD_x/2),('y',case_OD_y/2))
		connect_points(s1,(case_ID_x/2, case_ID_y/2),('x',-case_ID_x/2),('y',-case_ID_y/2),('x',case_ID_x/2),('y',case_ID_y/2))
		round_sketch_corner('sk_case',loc=(case_ID_x/2, case_ID_y/2),radius=corner_R)
		round_sketch_corner('sk_case',loc=(-case_ID_x/2, case_ID_y/2),radius=corner_R)
		round_sketch_corner('sk_case',loc=(-case_ID_x/2, -case_ID_y/2),radius=corner_R)
		round_sketch_corner('sk_case',loc=(case_ID_x/2, -case_ID_y/2),radius=corner_R)
	elif symm == 'xy':
		connect_points(s1,(case_OD_x/2, case_OD_y/2),('x',0),('y',case_ID_y/2),('x',case_ID_x/2),('y',0),('x',case_OD_x/2),('y',case_OD_y/2))
		round_sketch_corner('sk_case',loc=(case_ID_x/2, case_ID_y/2),radius=corner_R)

##	raise Exception


##	create_rectangle_shell('case0',corner2=(case_OD_x/2, case_OD_y/2),axis_symmetric = False)
##	plane_cut('case0',x=(0,case_ID_x/2), y=(0,case_ID_y/2))
##
####	s1 = create_base_sketch('sk_hole')
####	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y), radius=hole_D/2)
####	create_circle(s1,center=(case_OD_x/2 - hole2edge_x, case_OD_y/2 - hole2edge_y - hole2hole), radius=hole_D/2)
####	plane_cut('case0',sketch=s1)
##
##	shellpart_to_sketch('case0',sketchname='sk_case')
##	round_sketch_corner('sk_case',loc=(case_ID_x/2, case_ID_y/2),radius=corner_R)

	if model == '3D':
		extrude_sketch_to_part('case',sketch='sk_case',length=die_thick)

	else:
		sketch_to_shellpart('sk_case',partname='case')

##	raise Exception
	## frame

	if model == '3D':
		if symm == 'xy':
			create_block('frame',x=(0,frame_width/2),y=(0,frame_length/2), z=(0,frame_thick))
			hex_cut('frame', x=(0,frame_ID_x/2),y=(0,frame_ID_y/2), z=(frame_thick - die_thick, frame_thick))
			hex_cut('frame', x=(0,bot_open_x/2),y=(0,bot_open_y/2),z=(MIN,MAX))
		elif symm == '':
			create_block('frame',x=(-frame_width/2,frame_width/2),y=(-frame_length/2,frame_length/2), z=(0,frame_thick))
			hex_cut('frame', x=(-frame_ID_x/2,frame_ID_x/2),y=(-frame_ID_y/2,frame_ID_y/2), z=(frame_thick - die_thick, frame_thick))
			hex_cut('frame', x=(-bot_open_x/2,bot_open_x/2),y=(-bot_open_y/2,bot_open_y/2),z=(MIN,MAX))

##		drill_hole('frame',x=hole_x, y=hole_y1, D=hole_D)
##		drill_hole('frame',x=hole_x, y=hole_y2, D=hole_D)

		divide('frame',z=frame_thick - die_thick)
		move_part('case',z1=MIN,z2=frame_thick - die_thick)
		move_part('carbide',z1=MIN,z2=frame_thick - die_thick)

##		cylinder_grow('pin',ndir='z', center0=(hole_x,hole_y1,0),OD=hole_D,L=frame_thick)
##		divide('pin',z=frame_thick - die_thick)
##		new_instance('pin')
##		new_instance('pin', dy=hole2hole)

	else:
		create_rectangle_shell('frame',corner2 = (frame_width/2,frame_length/2))
		plane_cut('frame',x=(0,frame_ID_x/2),y=(0,frame_ID_y/2))

	divide(frame,x=frame_ID_x/2)
	divide(frame,y=frame_ID_y/2)
	divide(frame,x=-frame_ID_x/2)
	divide(frame,y=-frame_ID_y/2)

	new_instance('carbide')
	new_instance('case')
	if have_frame == True:
		new_instance('frame')

##	raise Exception

	set_mat(carbide,mat=carbide_mat)
	set_mat(case,mat='Steel_D2')
	set_mat(frame,mat='Steel_D2')
##	set_mat(pin,mat='Steel')

##	raise Exception

	create_general_static_step(period=1)
##	if model == '2D':
##		create_general_static_step(period=1)

	period = 1
	_m.TimePoint(name='TimePoints-1', points=((0.001*period, ),(0.002*period, ), (0.01*period, ), (0.02*period, ),(0.1*period, ), (0.2*period, ), (0.4*period, ), (0.6*period, ),
		(0.8*period, ), (0.9*period, ), (0.95*period, ), (1.0*period, )))

	field_output_request(timepoints = 'TimePoints-1')

##	raise Exception

	if model == '2D':
		## interaction
		medges = edge_select(carbide_A1,poiRefX=(MAX,-corner_R - 1),y=(MAX,MIN1))
		sedges = edge_select(case_A1,x=(MIN1,case_ID_x/2),y=(MIN1,case_ID_y/2))
		s2s_interact_std('fit',mfaces=medges,sfaces=sedges,prop='Friction',overclosure='shrink_fit')	;changing

		if 'frame_A1' in a.instances.keys():
			sedges = edge_select(frame_A1,x=frame_ID_x/2)
			medges = edge_select(case_A1,x=MAX)
			s2s_interact_std('damming',mfaces=medges,sfaces=sedges,step='step1')

			sedges = edge_select(frame_A1,y=frame_ID_y/2)
			medges = edge_select(case_A1,y=MAX)
			s2s_interact_std('damming',mfaces=medges,sfaces=sedges,step='step1')


		## load, BC
		edges = edges_of_insts(x=0)
		apply_disp_fix('xsym',edges=edges,Ux=0,UR3=0)

		edges = edges_of_insts(y=0)
		apply_disp_fix('ysym',edges=edges,Uy=0,UR3=0)

		changing1
		if hole_fix == True:
			edges = edge_select(case_A1,radius=hole_D/2)
			apply_disp_fix('hole_fix',edges=edges,Ux=0,Uy=0,UR3=0)

##		## side_pressure
		edges = edge_select(carbide_A1,x=(MIN1,carbide_cavity_x/2),y=(MIN1,carbide_cavity_y/2))
		apply_pressure('pressing',edges=edges,MPa=side_pressure,create_step='step1')

	elif model == '3D':
		## interaction
		pass
		raise Exception

		if symm == 'xy':
			mfaces = face_select(carbide_A1,nx=1) + face_select(carbide_A1,ny=1)
			sfaces = face_select(case_A1,x=case_ID_x/2) + face_select(case_A1,y=case_ID_y/2) + face_select(case_A1,radius=corner_R)
		elif symm == '':
			pass

		s2s_interact_std('fit',mfaces=mfaces,sfaces=sfaces,prop='Friction',overclosure='shrink_fit')	;changing

		if have_frame == True:
			mfaces = face_select(case_A1,x=MAX)
			sfaces = face_select(frame_A1,x=_xmax(case))
			s2s_interact_std('dam_x', mfaces=mfaces, sfaces=sfaces)

			mfaces = face_select(case_A1,y=MAX)
			sfaces = face_select(frame_A1,y=_ymax(case))
			s2s_interact_std('dam_y', mfaces=mfaces, sfaces=sfaces)

			sfaces = face_select(case_A1,z=MIN)
			mfaces = face_select(frame_A1,z=_zmin(case))
			s2s_interact_std('dam_z', mfaces=mfaces, sfaces=sfaces)

##		sfaces = face_select(pin_A1,z=0.1,mark_select=True)
##		mfaces = face_select(frame_A1,radius=hole_D/2., y=(hole_y1 - hole_D, hole_y1 + hole_D))
##		s2s_tie('tie-1',mfaces=mfaces,sfaces=sfaces)
##
##		sfaces = face_select(pin_A2,z=0.1,mark_select=True)
##		mfaces = face_select(frame_A1,radius=hole_D/2., y=(hole_y2 - hole_D, hole_y2 + hole_D))
##		s2s_tie('tie-2',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A1,z=MAX1,mark_select=True)
##		sfaces = face_select(case_A1,radius=hole_D/2., y=(hole_y1 - hole_D, hole_y1 + hole_D))
##		s2s_interact_std('pin-1',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A2,z=MAX1,mark_select=True)
##		sfaces = face_select(case_A1,radius=hole_D/2., y=(hole_y2 - hole_D, hole_y2 + hole_D))
##		s2s_interact_std('pin-2',mfaces=mfaces,sfaces=sfaces)

		## load, BC
		faces = faces_of_insts(x=0)
		apply_disp_symm('x',faces=faces)

		faces = faces_of_insts(y=0)
		apply_disp_symm('y',faces=faces)

##		if have_frame == True:
##			faces = faces_of_insts(z=0)
##			apply_disp_fix('zfix',faces=faces,Uz=0)

		edges = edges_of_insts(y=0,z=_zmax(carbide))
		apply_disp_fix('zfix',edges=edges, Uz=0)

		faces = get_inner_faces(carbide_A1)
		faces = face_select(carbide_A1,z=MID,faces=faces,mark_select=True)

		apply_pressure('pressing',faces=faces,MPa=side_pressure,create_step='step1')

##	raise Exception

	## meshing
	if model == '2D':
		## mesh
##		edges = edge_select(carbide,edir='circular')
		enum = 4
		if inner_R <= 0.5:
			enum = 2

		if inner_R > 0:
			edges = edge_select(carbide,radius=inner_R)
			seed_edges(carbide,edges=edges,enum=enum)

		edges = edge_select(carbide,x=MIN1,ny=-1)
		seed_edges(carbide,edges=edges,enum=3)	;changing

		mesh_part(carbide,esize=4)

		edges = edge_select(case,radius=corner_R)
		seed_edges(case,edges=edges,enum=4)

		edges = edge_select(case,radius=hole_D/2)
		seed_edges(case,edges=edges,enum=12)

		mesh_part(case,esize=4)

		## mesh frame
		edges = edge_select(frame,x=frame_ID_x/2) + edge_select(frame,y=frame_ID_y/2)
		seed_edges(frame,edges=edges, esize=3)

		edges = edge_select(frame,y=MAX1,exterior=False)
		bias_seed_single(frame,edges=edges, ratio=10,enum=20,fine_dir='-y')

		edges = edge_select(frame,x=MAX1,exterior=False)
		bias_seed_single(frame,edges=edges, ratio=10,enum=20,fine_dir='-x')

		mesh_part(frame,esize=5)

	elif model == '3D':
		## carbide
##		edges = edge_select(carbide,edir='circular')
		if inner_R > 0:
			edges = edge_select(carbide,radius=inner_R)
			seed_edges(carbide,edges=edges,enum=4)

		edges = edge_select(carbide,edir='z')
		seed_edges(carbide,edges=edges, esize=8)

		edges = edge_select('carbide',x=MIN1,thenYseq=-2)
		seed_edges(carbide,edges=edges,enum=3)

		mesh_part(carbide,esize=4)

		## mesh case
		edges = edge_select(case,radius=corner_R)
		seed_edges(case,edges=edges,enum=4)

		edges = edge_select(case,radius=hole_D/2)
		seed_edges(case,edges=edges,enum=12)

		edges = edge_select(case,edir='z')
		seed_edges(case,edges=edges, esize=8)

		mesh_part(case,esize=4)
		mesh_part(frame,esize=8)
##		mesh_part(pin)

##	raise Exception

	global _results_dict
	_results_dict = {'var':('interference',  'force_max', 'corner_R', 'ratio_x','ratio_y','carbide_mat','side_pressure'), 'carbide_A1':('S1','Mises','U1','U2'), 'case_A1':('S1','Mises','U1','U2')}

	create_inp(inp_file_title,request_num=6) ;please_check
	mdb.jobs[inp_file_title].submit()

	return

def main_A0256_sintering_USM_insert():
	## VER: 2015-11-17, v1.0

	check_script_file('D4_A0256_USM_insert_real_16hr.py')	;changing
	purpose = 'Sintering for USM insert to predict the nominal radius of 30, comparison with Mexico. Request by Anders.'
	history='B4:(7.5, 7.7, 8.3, 8.5), B1: model'

	locals0 = locals().keys()

##	compaction_odb = 'A0256-A_USM_ALE'   ## first odb, dense mesh, mass scale=500
##	compaction_odb = 'A0256-A_USM_roughmesh_ALE_Mass'   ## rough mesh, mass scale=200
##	compaction_odb = 'A0256-R25_USM_ALE_PHB'
##	compaction_odb = 'A0256-R27_USM_ALE_PHB_3'
##	compaction_odb = 'A0256-A_USM_ALE_real_OB'
##	compaction_odb = 'A0256-A_USM_ALE_RF_Rough1'
##	compaction_odb = 'A0256-A_USM_ALE_RF_Rough2'
##	compaction_odb = 'A0256-A_USM_ALE_RF_Rough3'
	compaction_odb = 'A0256-A_USM_ALE_real_kinematic'

	## import part from odb
	## nodes = node_select('p1',x=0), light(nodes), rotate, query node
	auto_label = True	;changing
	if auto_label == True:
		p1 = import_part_from_odb(odbname=compaction_odb,part_name='p1',step_id=-1,frame=-1)

		nodes1 = node_select(p1,x=0,y=(MID,MAX),groupY=MIN,endZ=MAX)
		nodes2 = node_select(p1,x=0,y=(MID,MIN),groupY=MAX,endZ=MAX)
		nodes3 = node_select(p1,y=0,x=(MID,MIN),groupX=MAX,endZ=MAX)
		nodes4 = node_select(p1,y=0,x=(MID,MAX),groupX=MIN,endZ=MAX)
		if nodes1 in empty or nodes2 in empty or nodes3 in empty or nodes4 in empty:
			raise Exception('*** Fail to pick the nodes automatically')
		else:
			nodes_x0 = [nodes1[0].label, nodes2[0].label]
			nodes_y0 = [nodes3[0].label, nodes4[0].label]

	else:
		## nodes in zmax direction
		## for nodes_x0: nodes = node_select(p1,x=0), then plot_nodes(nodes), then query node in GUI
		## for nodes_x0: nodes = node_select(p1,x=0), then plot_nodes(nodes), then query node in GUI

		if compaction_odb == 'A0256-R25_USM_ALE_PHB':   ## R25
			nodes_x0 = [5,13]
			nodes_y0 = [10,18]

		elif compaction_odb == 'A0256-R27_USM_ALE_PHB_3':  ## R27
			nodes_x0 = [18,10]
			nodes_y0 = [3,15]
		elif compaction_odb == 'A0256-A_USM_ALE_RF_Rough1':
			nodes_y0 = [11,4]
			nodes_x0 = [6,16]
		elif compaction_odb == 'A0256-A_USM_ALE_RF_Rough3':
			nodes_x0 = [6,16]
			nodes_y0 = [11,4]

	## product dimensions
	mid_length = 18.4
	arc_length = 12.2

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	_import = True			;changing
	output_density = True	;changing
	apply_mat = True		;changing

##	dens_range = (5.5, 6.5, 10, 11)
##	dens_range = (5, 6.5, 8.5, 10)	;changing
##	dens_range = (7, 7.2, 7.8, 8)	;changing  ## for shrinkage = 19.3
##	dens_range = (0.5, 0.3, 0.3, 0.5)	;changing    ## bigger range for lower part density

##	dens_range = (0.1,0.15,0.8,0.9)
	dens_range = (0.05,0.1,0.85,0.90)	;changing
	offset = -0.3		   ;changing
	sinter_loss = 2.174    ;changing ##  2.418		;changing
	shrinkage =   0.18     ;changing ##  0.1968		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
	density_th =  14.94    ;changing ##  14.44		;changing1

	locals2globals(locals0,locals(),save_var=True)

	target_density = shrinkage_to_density_with_PEG(shrinkage,C1=sinter_loss, Rho_th = density_th)  ## 8.42
	print ' '
	print fnln(),'sinter_loss =',sinter_loss, ', density_th =',density_th
	print fnln(),'shrinkage =',shrinkage, ', target_density=',target_density

##	reference_density = 8.3		;changing   ## 8.0=18.8, 8.4=17.43

##	raise Exception

	if _import == True:
		apply_mat = True

	if _import == True:
		if output_density == True:
			open_odb(compaction_odb)

			density_processing(Rho_th=density_th,low=0.02,high=0.97)
			dens1 = _density_vol
			density_processing(Rho_th=density_th,ranges=dens_range,retreat=True,density_vol=dens1,method='linear')
			dens2 = _density_vol

			write_density_and_element_labels(density_vol=dens2,filename=density_file)	;changing

		## Kevin: the last step name is uppressing
		import_part_from_odb(odbname=compaction_odb,part_name='green',step_id=-1,frame=-1, copy_nodeset=False,force_name=True)	;changing
		new_instance('green')

		save_mdb(cae_no_mat)			;changing1

	else:
		if apply_mat == False:
			open_cae(cae_with_mat)
		else:
			open_cae(cae_no_mat)

	save_mdb(inp_file_title)

##	raise Exception

	locals0 = locals().keys()
	part1 = 'part1'		;	part1_A1 = 'part1_A1'

	analysis1_title = inp_file_title
	bulk_modulus = 400e3	;changing1	## 400GPa
	Yield = None			;changing1

	deltaT = 1				;changing1
	support = 'BOT'
	have_tray = False		;changing1
	fric = 0.1				;changing1

	green = 'green'	;	green_A1 = 'green_A1'
	plate = 'plate'				;	plate_A1 = 'plate_A1'
	p1 = 'green_A1'

	## dimensions
	pin_length = 20

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	open_odb(compaction_odb)
	density_avg = density_distribution(th=density_th)['average']
	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
	print fnln(),'density_avg=',density_avg
	print fnln(),'density_lab=',density_lab

	session.viewports['Viewport: 1'].odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

	## SMIL
	if apply_mat == True:
		densities = read_density_and_element_labels(density_file)

		print fnln(),'sinter_loss=',sinter_loss   ## No problem

		apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=offset,
			density_th=density_th,Yield=Yield)	;changing

		save_mdb(cae_with_mat)
		save_mdb(inp_file_title)

	if len(_m.steps) == 1:
		create_general_static_step()

	field_output_request()

	if len(_m.interactionProperties) == 0:
		create_contact_props(friction=fric)	;changing1

	nodes = _inst('green_A1').nodes[:]  ;changing1 ## only for green part
	region = a.Set(nodes=nodes, name='all_nodes')
	set_temperature_predefined_field('Temp_field',region=region, initial_step=25+deltaT, modify=25)

	## boundary conditions
	nodes = node_select('green_A1',z=0,err=0.25)
	create_set(setname='dim_zmid',nodes=nodes)

	nodes2 = node_select('green_A1',nodes=nodes,y=(MAX,mid_length/2.),x=(-arc_length/2.0,arc_length/2.0))
	create_set(setname='dim_arc_ymax',nodes=nodes2)

	apply_disp_fix(name='BC_x',nodes=nodes_x0,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix(name='BC_y',nodes=nodes_y0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

	create_inp(analysis1_title,request_num=6,submit=False)
	mdb.jobs[analysis1_title].submit()

	## post processing:
	## create the node path='arc'
##	>>> radius_of_fit_nodes(path='arc')
##	35.376

##  For internal radius, import the part from the sintered odb, part name=p1
##	nodes = node_select('p1',x=0)
##	plot_nodes(nodes)  ## then measure the distance in GUI
##	nodes = node_select('p1',y=0)
##	plot_nodes(nodes)  ## then measure the distance in GUI

## ISO view, measure the height of a corner.

	return

def main_A0262_sintering_Carmex_insert():
	## VER: 2016-04-05, v1.0, 10:30am
	## Change at least the script file name and compaction_odb

	check_script_file('BD_A0262_carmex_sinter_115.py')	;changing
	purpose = 'Model provided by Mexico Raul, similar to Carmex insert, with distortion in both main surface and side surface. Request by Anders.'
	history='BB: offset=-0.2; BA: offset=0.4; B1: model'

	locals0 = locals().keys()

##	compaction_odb = 'A0262-insert_no_dot_2'
	compaction_odb = 'B0262-insert_no_dot_rough'

	## import part from odb
	## nodes = node_select('p1',x=0), light(nodes), rotate, query node
	auto_label = True	;changing
	p1 = import_part_from_odb(odbname=compaction_odb,part_name='p1',step_id=-1,frame=-1)
	globals()['p1'] = p1

##	raise Exception

	if auto_label == True:
		topside = MIN 	;changing 	## z direction, toppunch side, with high density at suroundings
		nodes_x01 = node_select(p1,x=0,y=(MID,MAX),groupRefY=(MIN,0.3),endZ=topside)
		nodes_x02 = node_select(p1,x=0,y=(MID,MIN),groupRefY=(MAX,-0.3),endZ=topside)
		nodes_y01 = node_select(p1,y=0,x=(MID,MIN),groupRefX=(MAX,-0.3),endZ=topside)
		nodes_y02 = node_select(p1,y=0,x=(MID,MAX),groupRefX=(MIN,0.3),endZ=topside)

		if nodes_x01 in empty or nodes_x02 in empty or nodes_y01 in empty or nodes_y02 in empty:
			raise Exception('*** Fail to pick the nodes automatically')
		else:
			nodes_x0 = [nodes_x01[0].label, nodes_x02[0].label]
			nodes_y0 = [nodes_y01[0].label, nodes_y02[0].label]

	else:
		## nodes in zmax direction
		## for nodes_x0: nodes = node_select(p1,x=0), then plot_nodes(nodes), then query node in GUI
		## for nodes_x0: nodes = node_select(p1,x=0), then plot_nodes(nodes), then query node in GUI
		nodes1 = node_select(p1,x=0,y=(MID,MAX))
		light(nodes1)  ##  Pick the node manually

		if compaction_odb == 'A0256-R25_USM_ALE_PHB':   ## R25
			nodes_x0 = [5,13]
			nodes_y0 = [10,18]

		elif compaction_odb == 'A0256-R27_USM_ALE_PHB_3':  ## R27
			nodes_x0 = [18,10]
			nodes_y0 = [3,15]
		elif compaction_odb == 'A0256-A_USM_ALE_RF_Rough1':
			nodes_y0 = [11,4]
			nodes_x0 = [6,16]
		elif compaction_odb == 'A0256-A_USM_ALE_RF_Rough3':
			nodes_x0 = [6,16]
			nodes_y0 = [11,4]

	## product dimensions
	mid_length = 18.4
	arc_length = 12.2

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	_import = True			;changing
	output_density = True	;changing
	apply_mat = True		;changing

##	dens_range = (0.1,0.15,0.8,0.9)
	dens_range = (0.05,0.1,0.85,0.90)	;changing

	density_th =  14.15     ;changing ##  14.44		;changing1    12EF, AM70, 1024
	sinter_loss = 2.757     ;changing ##  2.174, 2.418		;changing
	shrinkage =   0.195     ;changing ##  prefer 19%? (AM70 powder)		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
	offset = -0.3		    ;changing   ## parameter of apply_CTE_from_density_with_PEG(). 当收缩率大于19%时（例如12EF)，可考虑offset=-0.35或-0.4，当收缩率小于18时，可考虑offset=-0.25或-0.2
	## offset=-0.4: avg shrinkage=20.77, offset=-0.3: average shrinkage=20.41
	## use real_shrinkage() to get the real shrinkage

	locals2globals(locals0,locals(),save_var=True)

	target_density = shrinkage_to_density_with_PEG(shrinkage,C1=sinter_loss, Rho_th = density_th)  ## 8.42
	print ' '
	print fnln(),'sinter_loss =',sinter_loss, ', density_th =',density_th
	print fnln(),'shrinkage =',shrinkage, ', target_density=',target_density

	if _import == True:
		apply_mat = True

	if _import == True:
		if output_density == True:
			open_odb(compaction_odb)

			density_processing(Rho_th=density_th,low=0.02,high=0.97)
			dens1 = _density_vol
			density_processing(Rho_th=density_th,ranges=dens_range,retreat=True,density_vol=dens1,method='linear')
			dens2 = _density_vol

			write_density_and_element_labels(density_vol=dens2,filename=density_file)	;changing

		## Kevin: the last step name is uppressing
		import_part_from_odb(odbname=compaction_odb,part_name='green',step_id=-1,frame=-1, copy_nodeset=False,force_name=True)	;changing
		new_instance('green')

		save_mdb(cae_no_mat)			;changing1

	else:
		if apply_mat == False:
			open_cae(cae_with_mat)
		else:
			open_cae(cae_no_mat)

	save_mdb(inp_file_title)

##	raise Exception

	locals0 = locals().keys()
	part1 = 'part1'		;	part1_A1 = 'part1_A1'

	analysis1_title = inp_file_title
	bulk_modulus = 400e3	;changing1	## 400GPa
	Yield = None			;changing1

	deltaT = 1				;changing1

	green = 'green'			;	green_A1 = 'green_A1'
	p1 = 'green_A1'

	## dimensions
	length = 25.6
	thick = 3.2

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	open_odb(compaction_odb)
	density_avg = density_distribution(th=density_th)['average']
	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
	print fnln(),'density_avg=',density_avg
	print fnln(),'density_lab=',density_lab

	session.viewports['Viewport: 1'].odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

	## SMIL
	if apply_mat == True:
		densities = read_density_and_element_labels(density_file)

		print fnln(),'sinter_loss=',sinter_loss   ## No problem

		apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=offset,
			density_th=density_th,Yield=Yield)	;changing

		save_mdb(cae_with_mat)
		save_mdb(inp_file_title)

	create_general_static_step()

##	if len(_m.interactionProperties) == 0:
##		create_contact_props(friction=0.1)	;changing1

	nodes = _inst('green_A1').nodes[:]  ;changing1 ## only for green part
	region = a.Set(nodes=nodes, name='all_nodes')
	set_temperature_predefined_field('Temp_field',region=region, initial_step=25+deltaT, modify=25)

	## boundary conditions
	nodes = node_select('green_A1',z=MID,err=0.25)
	create_set(setname='dim_zmid',nodes=nodes)

	nodes = node_select('green_A1',x=0,err=0.25)
	create_set(setname='dim_xmid',nodes=nodes)

	nodes = node_select('green_A1',y=0,err=0.25)
	create_set(setname='dim_ymid',nodes=nodes)

	nodes = nodes_by_face('green_A1',nx=-1,x=MIN)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_xmin',axis='x',by_fine=True)

	nodes = nodes_by_face('green_A1',nx=1,x=MAX)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_xmax',axis='x',by_fine=True)

	nodes = nodes_by_face('green_A1',ny=-1,y=MIN)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_ymin',axis='y',by_fine=True)

	nodes = nodes_by_face('green_A1',ny=1,y=MAX)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_ymax',axis='y',by_fine=True)

	nodes = nodes_by_face('green_A1',nz=1,z=MAX)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_zmax',axis='z',by_fine=True)

	nodes = nodes_by_face('green_A1',nz=-1,z=MIN)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_zmin',axis='z',by_fine=False)

##	nodes = nodes_by_face(p1,nx=1,x=MAX)
##	nodes2 = node_select(p1,nodes=nodes,z=MID,err=0.05)
##	create_set(setname='dim_arc_xmax',nodes=nodes2)
##
##	elems = element_select('green_A1',x=MAX,nx=1)
##	elements_to_surface(elems,name='surf_xmax',axis='x')
##
##	elems = element_select('green_A1',x=MIN,nx=-1)
##	elements_to_surface(elems,name='surf_xmin',axis='x')
##
##	elems = element_select('green_A1',y=MAX,ny=1)
##	elements_to_surface(elems,name='surf_ymax',axis='y')
##
##	elems = element_select('green_A1',y=MIN,ny=-1)
##	elements_to_surface(elems,name='surf_ymin',axis='y')
##
##	elems = element_select('green_A1',z=MAX,nz=1)
##	elements_to_surface(elems,name='surf_zmax',axis='z')
##
##	elems = element_select('green_A1',z=MIN,nz=-1)
##	elements_to_surface(elems,name='surf_zmin',axis='z')

	apply_disp_fix(name='BC_x',nodes=nodes_x0,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix(name='BC_y',nodes=nodes_y0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

##	raise Exception

	create_inp(analysis1_title,request_num=1,submit=False)
	mdb.jobs[analysis1_title].submit()

	## post processing: import deformed part as p1,
##	nodes = nodes_by_face('p1',x=MAX,nx=1)
##	nodes = node_select('p1',nodes=nodes,groupZ=MID)
##	node1 = node_select('p1',nodes=nodes,endX=MIN)
##	objs_space(node1)
##	node2 = node_select('p1',nodes=nodes,endX=MAX)
##	objs_space(node2)
##	gap in x: 79um, 73um, avg=76um



	return

def main_A0259_GEA_thermal_expansion():
	## started: 2016-03-20, v1.0

	check_script_file('G8_A0259_GEA_H15N_int30_nostem_RT.py')		;changing
	history = 'G6:-30degC; FQ: carbide=C20C, bush_ID=11.4 for bot and top; FO: top gap=15um; CI: root_OD = tip_OD; B1:model'

	blank_cae(inp_file_title)

	material_database()
	create_contact_props(friction=0.3)	;changing				;please_check('default=0.15')

	locals0 = locals().keys()

	analysis1_title = inp_file_title	;changing1

 	bush_ID0 = 11.4                 ## M24 drawing: 0.3718*Kin
 	have_shaft = False			;changing

 	have_case = True			;changing1
 	interference_case = 30e-3   ;changing    ## nominal=46um, min=30, max=60

 	shaft_gap = 25e-3			;changing   ## origin:75um
 	shaft_OD = bush_ID0 - shaft_gap*2

	topbush_ID = bush_ID0	;changing
 	topbush_tip_OD = 16.05
##	topbush_tip_OD = 16.14	;changing
 	topbush_root_OD = 16.14   ## outer diameter at root
 	topbush_flange_OD = 23.87      ## bottom=29
 	topbush_flange_thick = 3.2
 	topbush_chamfer = 0.76
 	topbush_root_round = 0.63
 	topbush_H = 9.14   ## not include flange thick
 	topfat_H = 3.68
 	topthin_H = topbush_H - topfat_H
 	topbush_tip_chamfer = 0.5

	## bot bush
 	botbush_ID = bush_ID0     	## same
 	botbush_tip_OD = 16.05   ## same
##	botbush_tip_OD = 16.14	;changing
 	botbush_root_OD = 16.14   ## same outer diameter at root
 	botbush_flange_OD = 29.97      ## bottom=29
 	botbush_flange_thick = 2.5
 	botbush_root_round = 0.9
 	botbush_H = 10.67   ## not include flange thick
 	botfat_H = 3.68   ;changing   ## same, origin: 3.68
 	botthin_H = botbush_H - botfat_H
 	botbush_tip_chamfer = 0.5
 	botbush_H_all = botbush_H + botbush_flange_thick
 	botbush_tip_thick = 1.9
 	botbush_flange_OD3 = 20.68
 	botbush_flange_OD2 = 16.3
 	botbush_flange_OD1 = 13.11
 	botbush_cut1 = 0.61
 	botbush_cut2 = 1.83
 	botbush_tip_ID_chamfer = False	;changing1
 	botbush_ID_chamfer = 1.2		;changing  ## for one chamfer situation

	chamfer_num = 2				;changing	## 1,2

	bush_mat = 'carbide'		;changing		## carbide, steel
	carbide = 'H15N'			;changing		## H6N, H15N, C20C
	have_force = False			;changing
	force = 500					;changing1
 	high_temperature = F2C(800)   	## degF
 	low_temperature = -30		;changing
 	move = False					;changing

 	case_ID1 = topbush_root_OD - interference_case*2      ;changing1  ## most top ID
 	case_OD1 = 21.029  ## most top OD
 	case_L1 = 11.1     ## top part
 	section_L1 = case_L1

 	case_ID2 = case_ID1
 	case_OD2 = 25.52   ## thickness = 4.71mm
 	case_L2 = 17.94    ## mid part, with screw for fix
 	section_L2 = case_L2

 	case_ID3 = case_ID1  ## 内侧面的最底部直径
 	case_OD3 = 28.977
 	case_L3 = 12.89
 	section_L3 = case_L3

 	case_ID4 = 31.75
 	case_OD4 = 50.69
 	case_L4 = 12.89

 	case_ID = case_ID1

 	case_thick_34 = 5.23
 	case_inner_L = case_L1 + case_L2 + case_L3 + case_thick_34
 	section4_L = case_L4 + case_thick_34

 	case = 'case'
 	shaft = 'shaft'

 	locals2globals(locals0,locals(),save_var=True)

	## GEA bush (top bush)
	s1 = create_base_sketch('sk_bush')
	loc0 = (topbush_ID/2,0)
	connect_points(s1,loc0,('dy',topbush_H + topbush_flange_thick),('x',topbush_tip_OD/2),('dy',-topthin_H + 0.3), (topbush_root_OD/2, topbush_flange_thick + topfat_H - 0.3), \
		(topbush_root_OD/2,topbush_flange_thick), ('x',topbush_flange_OD/2),('dy',-topbush_flange_thick),loc0)

	loc2 = (topbush_root_OD/2,topbush_flange_thick)
	round_sketch_corner(s1,loc=loc2,radius=topbush_root_round)

##	loc3 = (topbush_root_OD/2,topbush_flange_thick + topfat_H)
##	round_sketch_corner(s1,loc=loc3,radius=topbush_root_round)

	revolve_sketch_to_part('bush',s1,angle=180)	;changing1

	edges = edge_select('bush',D = topbush_ID,y=MIN)
 	chamfer_edges('bush',edges=edges,length=topbush_chamfer)

 	edges = edge_select('bush',D=topbush_tip_OD,y=MAX)
 	chamfer_edges('bush',edges=edges,length=topbush_tip_chamfer)

 	edges = edge_select('bush',D=topbush_ID,y=MAX)
 	chamfer_edges('bush',edges=edges,length=topbush_tip_chamfer)

## 	raise Exception

	## Steel case
	s1 = create_base_sketch('sk_case')
	loc0 = (case_ID/2,0)
	connect_points(s1,loc0,(case_ID/2,case_inner_L),('x',case_OD1/2),('dy',-case_L1),('x',case_OD2/2),('dy',-case_L2),('x',case_OD3/2),('dy',-case_L3),
		('x',case_OD4/2),('dy',-case_L4 - case_thick_34),('x',case_ID4/2),('y',0),loc0)

 	revolve_sketch_to_part('case',s1,angle=180)	;changing1

## 	raise Exception

 	edges = edge_select('case',D = case_ID)
 	chamfer_edges('case',edges=edges,length=1)

 	move_part('bush',y1 = _ymin('bush') + topbush_flange_thick, y2 = _ymin('case') + case_L4)

 	new_instance('bush')
 	new_instance('case')

  	copy_part('bush','topbush',mirror_y = _ymax('bush'))
 	move_part('topbush',y1=_ymax('topbush') - topbush_flange_thick,y2=_ymax('case'))
 	new_instance('topbush')

	del_parts('bush')

	## bottom bush
	## GEA bush
	s1 = create_base_sketch('sk_botbush')
	loc0 = (botbush_ID/2,0)
	if chamfer_num == 2:
		connect_points(s1,loc0,('x',botbush_tip_OD/2), ('dy',-botthin_H + 0.3),(botbush_root_OD/2, -botthin_H - 0.3), (botbush_root_OD/2,-botbush_H),('x',botbush_flange_OD/2),  \
			('dy',-botbush_tip_thick),(botbush_flange_OD3/2, -botbush_H_all), (botbush_flange_OD2/2,-botbush_H_all), \
			(botbush_flange_OD1/2, -botbush_H_all + botbush_cut1), (botbush_ID/2,-botbush_H_all + botbush_cut2), loc0)
	elif chamfer_num == 1:
		connect_points(s1,loc0,('x',botbush_tip_OD/2), ('dy',-botthin_H + 0.3),(botbush_root_OD/2, -botthin_H - 0.3), (botbush_root_OD/2,-botbush_H),('x',botbush_flange_OD/2), \
			('dy',-botbush_tip_thick),(botbush_flange_OD3/2, -botbush_H_all), (botbush_ID/2,-botbush_H_all),loc0)

##	raise Exception

	loc2 = (botbush_root_OD/2,-botbush_H)
	round_sketch_corner(s1,loc=loc2,radius=botbush_root_round)

	revolve_sketch_to_part('botbush',s1,angle=180)	;changing1

	if botbush_tip_ID_chamfer == True:
		edges = edge_select('botbush',D = botbush_ID,y=MAX)
	 	chamfer_edges('botbush',edges=edges,length=botbush_tip_chamfer)

	if chamfer_num == 1:
		edges = edge_select('botbush',D = botbush_ID,y=MIN)
 		chamfer_edges('botbush',edges=edges,length=botbush_ID_chamfer)

	edges = edge_select('botbush',D = botbush_tip_OD,y=MAX)
 	chamfer_edges('botbush',edges=edges,length=botbush_tip_chamfer)

	move_part('botbush',y1=_ymin('botbush') + botbush_flange_thick, y2 = _ymin('case') + case_L4)
	new_instance('botbush')

## 	raise Exception

	## shaft
	cylinder_grow('shaft',ndir='y',L=_ymax('topbush') + 10 - _ymin('case'),OD=shaft_OD)
	bias_cut('shaft',z=0,cut_sides='+z')
	move_part('shaft',y1=MIN,y2=_ymin('case'))
	new_instance('shaft')

	divide('case',y=_ymin('topbush') - 1)
	divide('case',y=_ymax('botbush') + 1)

	divide('shaft',y=_ymin('topbush') - 6)
	divide('shaft',y=_ymax('botbush') + 1)

##	raise Exception

	## apply material
	set_mat('shaft',mat='Steel_PH174')
	set_mat('case',mat='Steel_PH174')
	if bush_mat == 'carbide':
		set_mat('botbush',mat=carbide)    	;changing1 ## bottom bush
		set_mat('topbush',mat=carbide)   	;changing1 ## top bush
	else:
		set_mat('topbush',mat='Steel_PH174')	;changing1
		set_mat('botbush',mat='Steel_PH174')

	divide('shaft',x=0)
	divide('case',x=0)
	divide('botbush',x=0)
	divide('topbush',x=0)
	divide('shaft',y=_ymin('shaft') + 2)

	divide('case',y=_ymax('case') - 1)
	circular_divide('case',ndir='y',D=case_OD3)

##	raise Exception

	## mesh
	mesh_part('botbush',esize=0.6)
	mesh_part('topbush',esize=0.6)
	mesh_part('shaft',esize=0.8)

	edges = edge_select('case',y=_ymid('topbush'))
	seed_edges('case',edges=edges,esize=0.5)

	edges = edge_select('case',y=_ymin('case') + section4_L + 1)
	seed_edges('case',edges=edges,esize=0.5)

	mesh_part('case',esize=1)

	create_general_static_step(stepname='expan')
	if have_force == True:
		create_general_static_step(stepname='force')

	if move == True:
##		create_dynamic_implicit_step(stepname='move',timePeriod=0.1, application='transient',matrix_storage='UNSYMMETRIC')
		create_general_static_step(stepname='move',timePeriod=0.1)
##	raise Exception

	## interact
	case_inner_top = face_select('case_A1',D=case_ID,y=_ymid('topbush'),mark_select=True)
	create_surface('case_inner_top',faces=case_inner_top)

	case_inner_bot = face_select('case_A1',D=case_ID,y=_ymax('botbush')-5,mark_select=True) + \
					face_select('case_A1',y=(_ymin('case_A1') + case_L4,_ymax('botbush')), shape='conical')
	faces1 = face_select('case_A1',D=case_ID,y=_ymax('botbush')-5,mark_select=True)
	create_surface('case_inner_bot',faces=faces1)

	faces = face_select('botbush_A1',D=botbush_ID)
	botbush_inner = select_by_expand_faces(faces,angle=80)
	create_surface('botbush_inner',faces=botbush_inner)

	faces = face_select('botbush_A1',y=(_ymin('botbush') + botbush_flange_thick,_ymax('botbush') - 5),z=(-0.1,MIN))
	botbush_outer = unselect(faces,botbush_inner)

	faces = face_select('botbush_A1',y=(_ymin('botbush') + 4.5, _ymax('botbush') - 5),z=(-0.1,MIN))
	faces2 = unselect(faces,botbush_inner)
	create_surface('botbush_outer',faces=faces2)

	face1 = face_select('topbush_A1',D=topbush_ID)
	ymax = objs_space(face1)[3]
	face2 = face_select('topbush_A1',y=ymax + 0.2, mark_select=True,shape='conical')
	topbush_inner = face1 + face2
	create_surface('topbush_inner',faces=topbush_inner)

	faces = face_select('topbush_A1',y=(_ymax('case'),_ymin('topbush') + 5),z=(-0.1,MIN))
	topbush_outer = unselect(faces,topbush_inner)

	faces = face_select('topbush_A1',y=(_ymax('case') - 3,_ymin('topbush') + 5),z=(-0.1,MIN))
	faces2 = unselect(faces,topbush_inner)
	create_surface('topbush_outer',faces=faces2)

##	raise Exception

	if have_case == True:
		s2s_interact_std('fit_bush_case_bot',mfaces=botbush_outer,sfaces=case_inner_bot,prop='Friction',overclosure='shrink_fit')
		s2s_interact_std('fit_bush_case_top',mfaces=topbush_outer,sfaces=case_inner_top,prop='Friction',overclosure='shrink_fit')

	if have_shaft == True:
		shaft_faces = face_select('shaft_A1',y=_ymid('botbush'),mark_select=True,z=(-0.1,MIN))
		s2s_interact_std('fit_bush_shaft_bot',mfaces=shaft_faces,sfaces=botbush_inner,prop='Friction',overclosure='shrink_fit')

		shaft_faces = face_select('shaft_A1',y=_ymid('topbush'),mark_select=True,z=(-0.1,MIN))
		s2s_interact_std('fit_bush_shaft_top',mfaces=shaft_faces,sfaces=topbush_inner,prop='Friction',overclosure='shrink_fit')

	if have_case == True:
		mfaces = face_select('topbush_A1',y=_ymax('topbush') - topbush_flange_thick)
		sfaces = face_select('case_A1',y=MAX)
		s2s_interact_std('cover_top',mfaces=mfaces,sfaces=sfaces,prop='Friction')

		sfaces = face_select('botbush_A1',y=_ymin('botbush') + botbush_flange_thick)
		mfaces = face_select('case_A1',y=_ymin('botbush') + botbush_flange_thick)
		s2s_interact_std('cover_bot',mfaces=mfaces,sfaces=sfaces,prop='Friction')

	if have_case == False:
		del_insts('case_A1')

	if have_shaft == False:
		del_insts('shaft_A1')

##	create_cylind_csys()

##	raise Exception

	## loads and BCs
##	set_temperature_predefined_field(initial=20,modify=high_temperature)  	;changing

##	apply_gravity(Gy=-9800)		;changing

	faces=faces_of_insts(z=0)
	apply_disp_symm('z',faces=faces)

	if interference_case < 15e-3:  ## No contact
		faces = face_select('case_A1',y=MIN)
		apply_disp_fix('case_fix_y',faces=faces,Uy=0)

		edges = edge_select('case_A1',z=MIN)
		apply_disp_fix('case_fix_x',edges=edges,Ux=0)

		edges = edge_select('botbush_A1',z=MIN)
		apply_disp_fix('bush_fix_x',edges=edges,Ux=0)

		edges = edge_select('topbush_A1',z=MIN)
		apply_disp_fix('bush_fix_x',edges=edges,Ux=0)

	if have_shaft == True:
		faces = face_select('shaft_A1',y=MIN)
		apply_disp_fix('shaft_fix',faces=faces,Uy=0,deactive_step='next')

	## force
	if have_force == True:
		changing1
		faces = face_select('case_A1',y=MIN)
		apply_disp_fix('case_fix',faces=faces,Uy=0,Ux=0, step='step2')

		vertice = vertice_select('shaft_A1',y=(MIN1,_ymin('botbush')),x=MAX)
		apply_force(name='pointforce',vertices=vertice,CF1=-force/2,stepname='step2')

		faces = face_select('case_A1',D=case_OD2)
		apply_disp_fix('fix_sect2',faces=faces,Ux=0,Uz=0,step='step2')

##		faces = face_select('case_A1',D=case_OD4)
##		apply_disp_fix('fix_sect4',faces=faces,Ux=0,Uz=0,step='step2')

	if move == True:
		faces = face_select('shaft_A1',y=MIN)
		apply_velocity('move',faces=faces, Vy=50,step='step3')	;changing

	if shaft_gap >= 50e-3:
		rotate_instances(insts='shaft_A1',rotate_center=(0,_ymid('shaft_A1'),0),angle_z = -atan(100*shaft_gap/_ylength('shaft')))
##		rotate_instances(insts='shaft_A1',rotate_center=(0,_ymid('shaft_A1'),0),angle_z = -1)

##	raise Exception

	create_inp(analysis1_title,request_num=6,submit=False)
	mdb.jobs[analysis1_title].submit()

	return

def main_A02431_sintering_MAP_insert():
	## VER: 2016-04-05, v1.0, 10:30am
	## Change at least the script file name and compaction_odb

	check_script_file('AD_A02431_MAP_sintering_insert_double_K8.py')	;changing
	purpose = 'Model provided by Mexico Raul, similar to Carmex insert, with distortion in both main surface and side surface. Request by Anders.'
	history='BB: offset=-0.2; BA: offset=0.4; B1: model'

	locals0 = locals().keys()

	compaction_odb = 'G0243-MAP_hole_double_K8.odb'

	## import part from odb
	## nodes = node_select('p1',x=0), light(nodes), rotate, query node
	auto_label = True	;changing
	p1 = import_part_from_odb(odbname=compaction_odb,part_name='p1',step_id=-1,frame=-1)
	globals()['p1'] = p1

##	raise Exception

	if auto_label == True:
		topside = MAX 	;changing 	## axial = z direction, toppunch side, with high density at suroundings
		nodes_x01 = node_select(p1,x=0,y=(MID,MAX),groupRefY=(MIN,0.3),endZ=topside)
		nodes_x02 = node_select(p1,x=0,y=(MID,MIN),groupRefY=(MAX,-0.3),endZ=topside)
		nodes_y01 = node_select(p1,y=0,x=(MID,MIN),groupRefX=(MAX,-0.3),endZ=topside)
		nodes_y02 = node_select(p1,y=0,x=(MID,MAX),groupRefX=(MIN,0.3),endZ=topside)

		if nodes_x01 in empty or nodes_x02 in empty or nodes_y01 in empty or nodes_y02 in empty:
			raise Exception('*** Fail to pick the nodes automatically')
		else:
			nodes_x0 = [nodes_x01[0].label, nodes_x02[0].label]
			nodes_y0 = [nodes_y01[0].label, nodes_y02[0].label]

	else:
		## nodes in zmax direction
		## for nodes_x0: nodes = node_select(p1,x=0), then plot_nodes(nodes), then query node in GUI
		## for nodes_x0: nodes = node_select(p1,x=0), then plot_nodes(nodes), then query node in GUI
		nodes1 = node_select(p1,x=0,y=(MID,MAX))
		light(nodes1)  ##  Pick the node manually

		if compaction_odb == 'A0256-R25_USM_ALE_PHB':   ## R25
			nodes_x0 = [5,13]
			nodes_y0 = [10,18]

		elif compaction_odb == 'A0256-R27_USM_ALE_PHB_3':  ## R27
			nodes_x0 = [18,10]
			nodes_y0 = [3,15]
		elif compaction_odb == 'A0256-A_USM_ALE_RF_Rough1':
			nodes_y0 = [11,4]
			nodes_x0 = [6,16]
		elif compaction_odb == 'A0256-A_USM_ALE_RF_Rough3':
			nodes_x0 = [6,16]
			nodes_y0 = [11,4]

	## product dimensions
	mid_length = 18.4
	arc_length = 12.2

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	_import = True			;changing
	output_density = True	;changing
	apply_mat = True		;changing

##	dens_range = (0.1,0.15,0.8,0.9)
	dens_range = (0.05,0.1,0.85,0.90)	;changing

	density_th =  14.44     ;changing ##  14.44		;changing1    12EF, AM70, 1024
	sinter_loss = 2.418     ;changing ##  2.174, 2.418		;changing
	shrinkage =   0.1968     ;changing ##  prefer 19%? (AM70 powder)		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
	offset = -0.3		    ;changing   ## parameter of apply_CTE_from_density_with_PEG(). 当收缩率大于19%时（例如12EF)，可考虑offset=-0.35或-0.4，当收缩率小于18时，可考虑offset=-0.25或-0.2
	## offset=-0.4: avg shrinkage=20.77, offset=-0.3: average shrinkage=20.41
	## use real_shrinkage() to get the real shrinkage

	locals2globals(locals0,locals(),save_var=True)

	target_density = shrinkage_to_density_with_PEG(shrinkage,C1=sinter_loss, Rho_th = density_th)  ## 8.42
	print ' '
	print fnln(),'sinter_loss =',sinter_loss, ', density_th =',density_th
	print fnln(),'shrinkage =',shrinkage, ', target_density=',target_density

	if _import == True:
		apply_mat = True

	if _import == True:
		if output_density == True:
			open_odb(compaction_odb)

			density_processing(Rho_th=density_th,low=0.02,high=0.97)
			dens1 = _density_vol
			density_processing(Rho_th=density_th,ranges=dens_range,retreat=True,density_vol=dens1,method='linear')
			dens2 = _density_vol

			write_density_and_element_labels(density_vol=dens2,filename=density_file)	;changing

		## Kevin: the last step name is uppressing
		import_part_from_odb(odbname=compaction_odb,part_name='green',step_id=-1,frame=-1, copy_nodeset=False,force_name=True)	;changing
		new_instance('green')

		save_mdb(cae_no_mat)			;changing1

	else:
		if apply_mat == False:
			open_cae(cae_with_mat)
		else:
			open_cae(cae_no_mat)

	save_mdb(inp_file_title)

##	raise Exception

	locals0 = locals().keys()
	part1 = 'part1'		;	part1_A1 = 'part1_A1'

	analysis1_title = inp_file_title
	bulk_modulus = 400e3	;changing1	## 400GPa
	Yield = None			;changing1

	deltaT = 1				;changing1

	green = 'green'			;	green_A1 = 'green_A1'
	p1 = 'green_A1'

	## dimensions
	length = 25.6
	thick = 3.2

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	open_odb(compaction_odb)
	density_avg = density_distribution(th=density_th)['average']
	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
	print fnln(),'density_avg=',density_avg
	print fnln(),'density_lab=',density_lab

	session.viewports['Viewport: 1'].odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

	## SMIL
	if apply_mat == True:
		densities = read_density_and_element_labels(density_file)

		print fnln(),'sinter_loss=',sinter_loss   ## No problem

		apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=offset,
			density_th=density_th,Yield=Yield)	;changing

		save_mdb(cae_with_mat)
		save_mdb(inp_file_title)

	create_general_static_step()

##	if len(_m.interactionProperties) == 0:
##		create_contact_props(friction=0.1)	;changing1

	nodes = _inst('green_A1').nodes[:]  ;changing1 ## only for green part
	region = a.Set(nodes=nodes, name='all_nodes')
	set_temperature_predefined_field('Temp_field',region=region, initial_step=25+deltaT, modify=25)

	## boundary conditions
	nodes = node_select('green_A1',z=MID,err=0.25)
	create_set(setname='dim_zmid',nodes=nodes)

	nodes = node_select('green_A1',x=0,err=0.25)
	create_set(setname='dim_xmid',nodes=nodes)

	nodes = node_select('green_A1',y=0,err=0.25)
	create_set(setname='dim_ymid',nodes=nodes)

##	nodes = nodes_by_face('green_A1',nx=-1,x=MIN)
##	elems = nodes_to_elements(nodes)
##	elements_to_surface(elems,name='surf_xmin',axis='x',by_fine=True)
##
##	nodes = nodes_by_face('green_A1',nx=1,x=MAX)
##	elems = nodes_to_elements(nodes)
##	elements_to_surface(elems,name='surf_xmax',axis='x',by_fine=True)
##
##	nodes = nodes_by_face('green_A1',ny=-1,y=MIN)
##	elems = nodes_to_elements(nodes)
##	elements_to_surface(elems,name='surf_ymin',axis='y',by_fine=True)
##
##	nodes = nodes_by_face('green_A1',ny=1,y=MAX)
##	elems = nodes_to_elements(nodes)
##	elements_to_surface(elems,name='surf_ymax',axis='y',by_fine=True)

	nodes = nodes_by_face('green_A1',nz=1,z=MAX)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_zmax',axis='z',by_fine=True)

	nodes = nodes_by_face('green_A1',nz=-1,z=MIN)
	elems = nodes_to_elements(nodes)
	elements_to_surface(elems,name='surf_zmin',axis='z',by_fine=False)

##	nodes = nodes_by_face(p1,nx=1,x=MAX)
##	nodes2 = node_select(p1,nodes=nodes,z=MID,err=0.05)
##	create_set(setname='dim_arc_xmax',nodes=nodes2)
##
##	elems = element_select('green_A1',x=MAX,nx=1)
##	elements_to_surface(elems,name='surf_xmax',axis='x')
##
##	elems = element_select('green_A1',x=MIN,nx=-1)
##	elements_to_surface(elems,name='surf_xmin',axis='x')
##
##	elems = element_select('green_A1',y=MAX,ny=1)
##	elements_to_surface(elems,name='surf_ymax',axis='y')
##
##	elems = element_select('green_A1',y=MIN,ny=-1)
##	elements_to_surface(elems,name='surf_ymin',axis='y')
##
##	elems = element_select('green_A1',z=MAX,nz=1)
##	elements_to_surface(elems,name='surf_zmax',axis='z')
##
##	elems = element_select('green_A1',z=MIN,nz=-1)
##	elements_to_surface(elems,name='surf_zmin',axis='z')

	apply_disp_fix(name='BC_x',nodes=nodes_x0,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
	apply_disp_fix(name='BC_y',nodes=nodes_y0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

##	raise Exception

	create_inp(analysis1_title,request_num=1,submit=False)
	mdb.jobs[analysis1_title].submit()

	## post processing: import deformed part as p1,
##	nodes = nodes_by_face('p1',x=MAX,nx=1)
##	nodes = node_select('p1',nodes=nodes,groupZ=MID)
##	node1 = node_select('p1',nodes=nodes,endX=MIN)
##	objs_space(node1)
##	node2 = node_select('p1',nodes=nodes,endX=MAX)
##	objs_space(node2)
##	gap in x: 79um, 73um, avg=76um

	return

def main_A0219_button_powder_compaction_923():
	## VER: 2014-09-05, v1.0
	## Reference: main_A0194_powder_compaction()

##	check_script_file('BF_A0219_button_compaction_divide.py')
	history = 'AV:apply ALE to whole model; AN:only top ALE(not converged); AM:top+bot ALE; AL:fine mesh land; AK:fine mesh, complete run; AJ:complete run; AF: rebuild bpunch based on powder bottom edges; AE:with ALE; A1:based on BG_A0224'

	blank_cae(inp_file_title)

	refresh()

	locals0 = locals().keys()

	analysis1 = 1				;changing1   ## 1, 12, None
	_solver = 'explicit'		;changing1
	_DOFs = 'disp'				;changing1
	analysis1_title = inp_file_title	;changing1

	## contraction: 0.82
	## Ejector drawing No: GT9S180_ejB
	with_tangent = True

	ejector_R = 10.82
	ejector_know = 'y'
	ejector_depth = 10.19
	ejector_land_R = 0.05
	ejector_land = 0.08
	ejector_tangent_angle = 17
	ejector_circle_depth = 7.657	## 注意，保持depth, open是算出来的。
	ejector_circle_open = 20.696
	ejector_OD = 22.402
	ejector_clearance = 1e-3	;changing

	die_R = ejector_OD/2.0

	## contraction: 0.82
	## drawing No. TOWXT895/5082-P
	tpunch_land = 0.08
	tpunch_land_angle = 15
	tpunch_cap_angle = 24.25
	tpunch_land_R = 0.05
	tpunch_mid_round = 2.44
	tpunch_top_round = 3.66
	tpunch_circle_open = 19.745	## 21.951
	tpunch_OD = 22.402
	tpunch_depth = 7.44
	tpunch_mid2top = 2.805
	tpunch_mid2bot = tpunch_depth - tpunch_mid2top

	PH = 39.65
	PV = 20.2
	L = 53.74
	PFH = L + PV
	dip = 4			;changing

	reverse = False

	tpunch = 'tpunch'		;	tpunch_A1 = 'tpunch_A1'
	bpunch = 'bpunch'		;	bpunch_A1 = 'bpunch_A1'
	powder = 'powder'		;	powder_A1 = 'powder_A1'
	die = 'die'				;	die_A1 = 'die_A1'

	locals2globals(locals0,locals(),save_var=True)

## pressing parameter
##	Pressed Weight: 111g+/-0.5
##	Pressed Height: 39.65mm+/-0.08
##	L: 53.74
##	PV: 20.2
##	OB: 1.3
##	Pre-load: 1.5

	dx = 'dx'
	dy = 'dy'
	x = 'x'
	y = 'y'

##	create_materials_HM()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	## bottom punch
	s1 = create_base_sketch('sk_ejector')

	point1,point2,circle = create_arc(s1,center=(0,ejector_R),radius=ejector_R,quarter=4)
	s1.FixedConstraint(entity=circle)

	bias_cut_sketch(s1,y=ejector_circle_depth,side='+')
	loc = find_loc(s1,x=MAX)

	connect_points(s1,loc,xytilt1(dy=ejector_depth - ejector_circle_depth, Ay=ejector_tangent_angle),{'x':ejector_OD/2.0},{'dx':0.5})
##	connect_points(s1,loc,ytilt(ejector_depth - ejector_circle_depth, ejector_tangent_angle),{'x':ejector_OD/2.0})

	loc1 = find_loc(s1,y=MAX,groupX=MIN)
	round_sketch_corner(s1,loc=loc1,radius=ejector_land_R)

	## top punch, 画草图时，最好从punch_OD开始。
	s1 = create_base_sketch('sk_tpunch')
	loc0 = (tpunch_OD/2.0 + 0.5, 0)

	locs = connect_points(s1, loc0, (x,tpunch_OD/2.0), (dx,-tpunch_land), xytilt2(dy=tpunch_mid2bot, Ay=tpunch_land_angle),
		xytilt2(dy=tpunch_mid2top,  Ax=tpunch_cap_angle), (x, 0))


	round_sketch_corner(s1,loc=locs[2], radius=tpunch_land_R)
	round_sketch_corner(s1,loc=locs[-3], radius=tpunch_mid_round)
	round_sketch_corner(s1,loc=locs[-2], radius=tpunch_top_round)

##	## extend sketch
##	connect_points(s1,'xmin',(dy,-5))	## 必须是自上而下，否则surface side顺序不一致

##	raise Exception
	if 'fill_volume0' in globals().keys():
		assembly_and_fill(top_sketch='sk_tpunch',bot_sketch='sk_ejector',fill_volume=fill_volume0) ## s_punch和s_ejector会被移动。
	elif 'PFH' in globals().keys():
		assembly_and_fill(top_sketch='sk_tpunch',bot_sketch='sk_ejector',PFH=PFH) ## s_punch和s_ejector会被移动。


	bot_points = xlocs(powder,ny=-1,x=(MIN1,MAX1))

	vertices = vertice_select(powder,ny=-1,x=(MIN1,MAX1))
	ignore_vertices(powder,vertices=vertices)

	if len(bot_points) >=2:
		divide(powder,x=bot_points[-2])

##	loc1 = loc_at('powder',y=MID,x=MIN)
##	loc2 = loc_at('powder',y=MID,x=MAX)
##	loc1 = loc1[0],loc1[1]-ylength(bpunch),loc1[2]
##	divide_faces_by_two_points('powder',point1=loc1,point2=loc2)

	divide('powder',y=MID)

##	raise Exception

	## ignore left top corner
##	global divide_length
##	divide_length = ylength(tpunch)
##	edges = edge_select(powder,x=MIN)
##	divide_edge(edges,y=_ymax(powder) - 0.3*ylength(tpunch))	;changing   ## 上冲越深，需要劈开的距离越大，反之越小。
	## 粉体密度越低，系数越可调大。反之，系数要调小。reference: 0.25
	## 网格密度越大，相当于粉体密度增大。
	## 如果不用ALE也能跑完（land的radius不能很好体现），则系数应该小些?

	changing
##	vertices = vertice_select(powder,x=MIN,y=MAX)  ## ignore可能会带来tensile space的问题（拉引力极限太小)
##	ignore_vertices(powder,vertices=vertices)


##	edges = edge_select(powder,ny=-1)
##	vertices =vertice_select(powder,edges=edges,xpoint=MIN1)
##	loc = vertices[0].pointOn[0]
##	ignore_vertices(powder,vertices=vertices)

##	edges = edge_select(powder,x=MIN1,ny=-1)
##	divide_edge(edges[0],x=loc[0])
##	edges = edge_select(powder,x=MIN1,ny=-1)
##	radius = get_radius(edges[0])
##	print radius

##	raise Exception

##	move_instances(bpunch_A1,dy=-ejector_clearance)	;changing
##	del_parts(bpunch)

##	edges_to_wirepart(edges,partname='bpunch',ptype='discrete',pshape='axisym')
##	new_instance('bpunch')
###	edges = edge_select(powder,ny=-1)
###	s1 = edges_to_sketch(edges,sketchname='sk_bpunch', ndir='z',offset=0)
###
###	x1,y1 = find_loc(s1,x=MAX)
###	connect_points(s1,(x1+0.5, y1),(x1,y1))
###	sketch_to_wire(s1,partname='bpunch',symmetric=True,ptype='analytical')
###	new_instance('bpunch')

##	raise Exception

##	edges_to_wirepart(_part(bpunch).edges,partname='bpunch2', ptype='discrete',pshape='axisym')
##	raise Exception

##	merge_edges(bpunch)

###	pt = vertice_select(bpunch,x=MIN)[0]
###	create_RP(bpunch,loc=pt.pointOn[0],name='tpunch', clear_RP=True)
###	new_instance(bpunch)

##	raise Exception

##	## vertical cut
##	offset_x_top = 5
##	offset_x_bot = 3
##
##	## horizontal cut
##	offset_y_top1 = 2*ylength(tpunch)	;changing
##	offset_y_top2 = 2*ylength(tpunch)	;changing
##
##	offset_y_bot1 = ylength(tpunch) - 3 ## left
##	offset_y_bot2 = ylength(tpunch) ## right

#####	point1 = (_xmax(powder) - offset_x_bot, _ymin(powder, x=_xmax(powder) - offset_x_bot), 0)
#####	point2 = (_xmax(powder) - offset_x_top, _ymax(powder),0)
##	point1 = locs_of_poi(powder, x=_xmax(powder) - offset_x_bot, thenY=MIN)[0]
##	point2 = locs_of_poi(powder,x=_xmax(powder) - offset_x_top, thenY=MAX)[0]
##	divide_faces_by_two_points(powder, faces=_part(powder).faces, point1=point1, point2=point2)  ## vertical

#	point1 = (0,_ymax(powder) - offset_y_top1,0)
#	point2 = (_xmax(powder),_ymax(powder) - offset_y_top2,0)
##	divide_faces_by_two_points(powder, faces=_part(powder).faces, point1=point1, point2=point2)

##	point1 = (0,_ymin(powder, x=MAX) + offset_y_bot1, 0)
##	point2 = (die_R, _ymin(powder, x=MAX) + offset_y_bot2, 0)
##	divide_faces_by_two_points(powder, faces=_part(powder).faces, point1=point1, point2=point2)

##	vertice = vertice_select(powder,ny=-1,xpoint=MIN1)
##	loc = vertice[0].pointOn[0]
##	loc1 = loc[0] - 5, _ymax(powder),0		;changing
##	divide_faces_by_two_points(powder, _part(powder).faces, point1=loc, point2=loc1)

##	## land
##	edge_width = ejector_land - 0.01
##	divide(powder,x=_xmax(powder) - edge_width)

##	raise Exception



	## steps, output
	times1 = myrange(0,1,0.05) + [0.001, 0.002, 0.005, 0.01, 0.02]	## 调试一开始需要仔细观察。
	timepoints1 = create_timepoints(times1)	;changing1

##	create_dynamic_explicit_step(step='remesh', timePeriod=0.001)
##	create_dynamic_explicit_step(step='movePV', timePeriod=0.5)
#	create_dynamic_explicit_step(step='dip', timePeriod=1.0)
	create_dynamic_explicit_step(step='move', timePeriod=1.0)

##	field_output_request(timepoints=(timepoints1))

	## mesh
	edges = edge_select(powder,x=MAX1,exterior=False)
	seed_edges(powder,edges=edges,enum=10)	;changing   ## 10

	edges = edge_select(powder,x=MIN1,exterior=False)
	seed_edges(powder,edges=edges,enum=25,fixed=True)  ;changing    ## 网格过疏时，左上角可能会冒出来。good: 30

	set_element_shape(powder, objs=_part(powder).faces, technique='STRUCTURE') ;changing
	mesh_region(powder,esize=2)	;changing

##	raise Exception

##	adaptive_mesh_control()

	## 首先，要尝试一下不用ALE能跑到哪一步，有时，不用ALE也能填满上盖甚至完成模拟（button)。
##	apply_adaptive_mesh(elements=_inst('powder_A1').elements, frequency=1,sweep=1,step='step1')	## ;changing  (不好，会使应力由下冲位置移到上冲位置)
##	elems = element_select('powder_A1',x=(die_R, die_R*0.3)) + \
##		element_select('powder_A1',ref_yrange=(MAX,-L/5)) + \
##		element_select('powder_A1',y=(MIN,L/6))					;changing

##	elems = element_select('powder_A1',x=(die_R, die_R*0.3)) + element_select('powder_A1',ref_yrange=(MAX,-L/5))
##	apply_adaptive_mesh(elements=elems, frequency=1,sweep=1)	;changing
	## 经验：如果与上冲接触的粉体不采用自适应，可能会冒出来；同样地，如果与下冲接触的粉体不采用自适应，计算过程中也可能会冒出来。
	## 冒出来不是接触的问题，而是由于没有自适应，过于刚硬。

##	raise Exception

	## Interact
	m_punch = create_surface(tpunch_A1,side='-y')
	m_ejector = create_surface(bpunch_A1,side='+y')
	m_die = create_surface(die_A1,side='-x')

##	{{
##	elems = element_select('powder_A1',ref_yrange=(MAX,-ylength(tpunch)/2)) + element_select('powder_A1',ref_xrange=(MIN,0.5),ref_yrange=(MAX,-3*ylength(tpunch)))
##	surf_top = create_surface(elements=elems,name='surf_top',select_sym=True)
##
##	elems = element_select('powder_A1',ref_xrange=(MAX,-die_R/5)) + element_select('powder_A1',ref_yrange=(MAX,-0.5))  				;changing
##	surf_right = create_surface(elements=elems,name='surf_right')
##
##	elems = element_select('powder_A1',ref_yrange=(_ymin('powder_A1'),1.2*ylength(bpunch)))  ;changing
##	surf_bot = create_surface(elements=elems,name='surf_bot')
##	}}

	nodes_top = node_select('powder_A1',y=MAX)
	nodes_top_left = node_select('powder_A1',x=MIN, poiRefY=(MAX,-5*_ylength(tpunch)))

	surf_top = create_nodal_surface('powder_A1',nodes=nodes_top + nodes_top_left,name='surf_top')

##	surf_top_left = create_nodal_surface('powder_A1',nodes=nodes,name='surf_top_left')

	nodes_right = nodes_by_face('powder_A1',nx=1,x=MAX)
	surf_right = create_nodal_surface('powder_A1',nodes=nodes_top + nodes_right,name='surf_right')

	elems = element_select('powder_A1',ny=-1)
	nodes_bot = get_element_facing_nodes(elems,ny=-1)
	surf_bot = create_nodal_surface('powder_A1',nodes=nodes_bot,name='sur_bot')

	changing
	s2s_interact_exp('int_punch1',master_region=m_punch, slave_region=surf_top)
##	s2s_interact_exp('int_punch2',master_region=m_punch, slave_region=surf_top_left)

	s2s_interact_exp('int_die1',master_region=m_die, slave_region=surf_right)
##	s2s_interact_exp('int_die2',master_region=m_die, slave_region=surf_top)

	s2s_interact_exp('int_ejector',master_region=m_ejector, slave_region=surf_bot)

##	raise Exception

	## mesh
	## 与下冲接触的powder edges分成三段。
##	## 1. 底部右段, land
##	edges = edges_at(powder,x=MAX1)
##	seed_edges(powder,edges=edges,enum=10)

##	## 底部中段
##	edges = edge_select(powder,x=bot_points[-2] - 1,exterior=True)
##	bias_seed_edges(powder,edges=edges,enum=30,ratio=30,dense_dir='+x')
##	raise Exception

##	if reverse == False:
##		bias_seed_edges(powder,edges=edges,enum=20,ratio=20,flip=False)   ;changing
##	else:
##		bias_seed_edges(powder,edges=edges,enum=10,ratio=10,flip=True)

#	## 中段
#	edges = edge_select(powder,ref_locx=(MAX,-offset_x_bot + 0.1),y=(0,MIN))
#	if reverse == False:
#		bias_seed_edges(powder,edges=edges,enum=20,ratio=4,flip=True)	;please_check
#	else:
#		bias_seed_edges(powder,edges=edges,enum=6,ratio=2,flip=False)	;please_check

##	raise Exception

	## 底部左段
##	edges = edges_at(powder,x=MIN1,thenY=MIN)
##	seed_edges(powder,edges=edges,esize=1.0)		;changing  ## 可能会影响到底部左下角的变形。0.4 OK for fric=0.2

	## y dir (在压制方向上不要使用bias_seed，否则可能会使网格变形很大。)
##	seed_edges(powder,edges=powder_right_top,esize=0.5)	;changing
	## 右侧边上部
##	edges = edge_select(powder,y=MAX1)
##	bias_seed_edges(powder,edges=edges,enum=10,ratio=20,dense_dir='+y')

	##右侧边底部
##	edges = edge_select(powder,x=MAX,y=0.1)
##	seed_edges(powder,edges=edges,esize=0.5)	;changing
##	bias_seed_edges(powder,edges=edges,enum=20,ratio=20,dense_dir='-y')		;changing

	##侧边中部
##	edges = edge_select(powder,y=MID)
##	seed_edges(powder,edges=edges,enum=10,fixed=True)
##	raise Exception

##	set_element_shape(powder, objs=_part(powder).faces, technique=SWEEP)
##	mesh_region(powder,esize=2.0)	;changing1

##	adaptive_mesh_control()
##	apply_adaptive_mesh(elements=_inst(powder_A1).elements, frequency=1,sweep=1)	;changing  (不好，会使应力由下冲位置移到上冲位置)

##	top_faces = face_select(powder_A1,y=MAX1)
##	bot_faces = face_select(powder_A1,ref_xrange=(MAX,-2),y=0.1,mark_select=True)
##
##	side_faces = face_select(powder_A1,ref_xrange=(MAX,-2)) + top_faces
##	side_faces = remove_repeated_items(side_faces)
####	apply_adaptive_mesh(faces=side_faces, frequency=1,sweep=1,step='remesh')	;changing
##	apply_adaptive_mesh(faces=top_faces + bot_faces, frequency=1,sweep=1,step='move')	;changing

###	apply_adaptive_mesh(faces=top_faces + bot_faces, frequency=1,sweep=1,step='ALE')	;changing
#
#	apply_adaptive_mesh(faces=top_faces + bot_faces, frequency=1,sweep=1,step='step1')	;changing
###	apply_adaptive_mesh(faces=bot_faces, frequency=1,sweep=1,step='step3')	;changing


##	raise Exception

##	## Interact
##	m_punch = create_surface(tpunch_A1,side='-y')
##	m_ejector = create_surface(bpunch_A1,side='+y')
##	m_die = create_surface(die_A1,side='-x')
##
##
##	## top
##	powder_top = edge_select(powder_A1,y=MAX)
##	powder_top_left = edge_select(powder_A1,y=MAX,x=MIN1)
##	powder_top_right = unselect(powder_top, powder_top_left)
####	raise Exception
##
##	## bot
##	powder_bot = edge_select(powder_A1,ny=-1)
##	powder_bot_left = edge_select(powder_A1,x=MIN1,ny=-1)
##	powder_bot_right = edge_select(powder_A1,x=MAX1,ny=-1)
##
##	## left
##	powder_left_top = edge_select(powder_A1,x=MIN,y=MAX1)
##	powder_left_bot = edge_select(powder_A1,x=MIN,y=MIN1)
##
##	## right
##	powder_right = edge_select(powder_A1,x=MAX)
##	powder_right_bot = edge_select(powder_A1,x=MAX,thenY=MIN1)
##	powder_right_top = edge_select(powder_A1,x=MAX, y=MAX1)
##
##
##	changing
##	s2s_interact_exp('int_punch',master_region=m_punch, sedges=powder_top + powder_left_top + powder_right_top)
####	s2s_interact_exp('int_punch',master_region=m_punch, sedges=powder_top + powder_right_top)
##	s2s_interact_exp('int_die',master_region=m_die, sedges = powder_right + powder_top_right + powder_bot_right)
##	s2s_interact_exp('int_ejector',master_region=m_ejector,sedges = powder_left_bot + powder_bot + powder_right_bot,friction=0.1)	;changing
####	s2s_interact_exp('int_ejector',master_region=m_ejector,sedges = powder_bot + powder_right_bot)
##
####	raise Exception

	## Loads
	punch_depth = _ylength(tpunch)
	total_compressed = punch_depth + PFH - PH
	## before: punch_depth + L + PV
	## after: PH
	## total compressed: punch_depth + L + PV - PH （上冲的压缩量+下冲的压缩量）
	## 其中die的行程(等效下冲动): PV
	## 实际上，下冲不动 ，所以total compressed也就是上冲的全部行程。

	## top punch走total_compressed
##	_m.TabularAmplitude(name='top_move', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, -dip), (0.50, -dip - PV),  (1.0, -total_compressed)))

	## die只走PV, bot punch始终不动。
##	_m.TabularAmplitude(name='die_move', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, 0), (0.50, -PV),  (1.0, -PV)))

##	_m.TabularAmplitude(name='top_move2', timeSpan=STEP,
##	    smooth=SOLVER_DEFAULT, data=((0.0, -dip - PV),  (0.5, -total_compressed)))

	apply_BC_on_RP_2D(bpunch_A1,U1=0,U2=0,UR3=0,stepname='step1')	## bpunch is always stable
	apply_BC_on_RP_2D(tpunch_A1,U1=0,UR3=0,stepname='step1')
	apply_BC_on_RP_2D(die_A1,U1=0,UR3=0,stepname='step1')

	check1()
	apply_BC_on_RP_2D(tpunch_A1,U2=0,modifys=('step1',U2,-dip),stepname='Initial')
	apply_BC_on_RP_2D(die_A1,U2=0)


#	apply_BC_on_RP_2D(tpunch_A1,U2=-dip,stepname='step1',modifys=('step2','U2',-dip-PV))
#	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step1',modifys=('step2','U2',-PV))

##	apply_BC_on_RP_2D(tpunch_A1,U2=0,stepname='step1',modifys=('step2','U2','top_move'))
##	apply_BC_on_RP_2D(tpunch_A1,U2=0,stepname='step1',modifys=[('step2','U2','top_move'),('step3','U2','top_move2')])
##	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1',modifys=('step2','U2','top_move2'))
##	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1')

##	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step1',modifys=('step2','U2','die_move'))	;changing
##	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step3')
##	apply_BC_on_RP_2D(die_A1,U2=1,amplitude='die_move',stepname='step1')

##	apply_gravity()

##	raise Exception

##	check1()
	create_job(inp_file_title,request_num=6) 		;please_check
	refresh()
##	mdb.jobs[inp_file_title].submit()
##	back_run()

	return


##def main_A0219_button_powder_compaction_923():
##	## VER: 2014-09-05, v1.0, 2016.5.13
##	## Reference: main_A0194_powder_compaction()
##
##	check_script_file('BH_A0219_button_compaction_divide.py')
##	history = 'AV:apply ALE to whole model; AN:only top ALE(not converged); AM:top+bot ALE; AL:fine mesh land; AK:fine mesh, complete run; AJ:complete run; AF: rebuild bpunch based on powder bottom edges; AE:with ALE; A1:based on BG_A0224'
##
##	blank_cae(inp_file_title)
##
##	locals0 = locals().keys()
##
##	analysis1_title = inp_file_title	;changing1
##
##	## contraction: 0.82
##	## Ejector drawing No: GT9S180_ejB
##	with_tangent = True
##
##	ejector_R = 10.82
##	ejector_know = 'y'
##	ejector_depth = 10.19
##	ejector_land_R = 0.05
##	ejector_land = 0.08
##	ejector_tangent_angle = 17
##	ejector_circle_depth = 7.657	## 注意，保持depth, open是算出来的。
##	ejector_circle_open = 20.696
##	ejector_OD = 22.402
##	ejector_clearance = 1e-3	;changing
##
##	die_R = ejector_OD/2.0
##
##	## contraction: 0.82
##	## drawing No. TOWXT895/5082-P
##	tpunch_land = 0.08
##	tpunch_land_angle = 15
##	tpunch_cap_angle = 24.25
##	tpunch_land_R = 0.05
##	tpunch_mid_round = 2.44
##	tpunch_top_round = 3.66
##	tpunch_circle_open = 19.745	## 21.951
##	tpunch_OD = 22.402
##	tpunch_depth = 7.44
##	tpunch_mid2top = 2.805
##	tpunch_mid2bot = tpunch_depth - tpunch_mid2top
##
##	PH = 39.65
##	PV = 20.2
##	L = 53.74
##	PFH = L + PV
##	dip = 4			;changing
##
##	## 压重和压高的设计值是固定的。所以，实际压型时，填粉高度需要尝试几次以获得正确的压重对应的填粉高度。
##	## 同时通过最后的动作OB(上冲单独下压)来再实现压重的条件下进一步保证压高与设计值一样。
##	## 对于insert，上冲在做最后的OB之前的行程与OB之比大约是10:1比较合适。
##
##	reverse = False
##
##	tpunch = 'tpunch'		;	tpunch_A1 = 'tpunch_A1'
##	bpunch = 'bpunch'		;	bpunch_A1 = 'bpunch_A1'
##	powder = 'powder'		;	powder_A1 = 'powder_A1'
##	die = 'die'				;	die_A1 = 'die_A1'
##
##	locals2globals(locals0,locals(),save_var=True)
##
#### pressing parameter
####	Pressed Weight: 111g+/-0.5
####	Pressed Height: 39.65mm+/-0.08
####	L: 53.74
####	PV: 20.2
####	OB: 1.3
####	Pre-load: 1.5
##
##	dx = 'dx'
##	dy = 'dy'
##	x = 'x'
##	y = 'y'
##
##	material_database()
##	create_contact_props(friction=0.2)					;please_check('default=0.15')
##
##	## bottom punch
##	s1 = create_base_sketch('sk_ejector')
##
##	point1,point2,circle = create_arc(s1,center=(0,ejector_R),radius=ejector_R,quarter=4)
##	s1.FixedConstraint(entity=circle)
##
##	bias_cut_sketch(s1,y=ejector_circle_depth,side='+')
##	loc = find_loc(s1,x=MAX)
##
##	connect_points(s1,loc,xytilt1(dy=ejector_depth - ejector_circle_depth, Ay=ejector_tangent_angle),{'x':ejector_OD/2.0},{'dx':0.5})
####	connect_points(s1,loc,ytilt(ejector_depth - ejector_circle_depth, ejector_tangent_angle),{'x':ejector_OD/2.0})
##
##	loc1 = find_loc(s1,y=MAX,groupX=MIN)
##	round_sketch_corner(s1,loc=loc1,radius=ejector_land_R)
##
##	## top punch, 画草图时，最好从punch_OD开始。
##	s1 = create_base_sketch('sk_tpunch')
##	loc0 = (tpunch_OD/2.0 + 0.5, 0)
##
##	locs = connect_points(s1, loc0, (x,tpunch_OD/2.0), (dx,-tpunch_land), xytilt2(dy=tpunch_mid2bot, Ay=tpunch_land_angle),
##		xytilt2(dy=tpunch_mid2top,  Ax=tpunch_cap_angle), (x, 0))
##
##
##	round_sketch_corner(s1,loc=locs[2], radius=tpunch_land_R)
##	round_sketch_corner(s1,loc=locs[-3], radius=tpunch_mid_round)
##	round_sketch_corner(s1,loc=locs[-2], radius=tpunch_top_round)
##
####	## extend sketch
####	connect_points(s1,'xmin',(dy,-5))	## 必须是自上而下，否则surface side顺序不一致
##
####	raise Exception
##	if 'fill_volume0' in globals().keys():
##		assembly_and_fill(top_sketch='sk_tpunch',bot_sketch='sk_ejector',fill_volume=fill_volume0) ## s_punch和s_ejector会被移动。
##	elif 'PFH' in globals().keys():
##		assembly_and_fill(top_sketch='sk_tpunch',bot_sketch='sk_ejector',PFH=PFH) ## s_punch和s_ejector会被移动。
##
##
##	bot_points = xlocs(powder,ny=-1,x=(MIN1,MAX1))
##
##	vertices = vertice_select(powder,ny=-1,x=(MIN1,MAX1))
##	ignore_vertices(powder,vertices=vertices)
##
##	if len(bot_points) >=2:
##		divide(powder,x=bot_points[-2])
##
####	loc1 = loc_at('powder',y=MID,x=MIN)
####	loc2 = loc_at('powder',y=MID,x=MAX)
####	loc1 = loc1[0],loc1[1]-_ylength(bpunch),loc1[2]
####	divide_faces_by_two_points('powder',point1=loc1,point2=loc2)
##
##	divide('powder',y=MID)
##
####	raise Exception
##
##	## ignore left top corner
####	global divide_length
####	divide_length = _ylength(tpunch)
####	edges = edge_select(powder,x=MIN)
####	divide_edge(edges,y=_ymax(powder) - 0.3*_ylength(tpunch))	;changing   ## 上冲越深，需要劈开的距离越大，反之越小。
##	## 粉体密度越低，系数越可调大。反之，系数要调小。reference: 0.25
##	## 网格密度越大，相当于粉体密度增大。
##	## 如果不用ALE也能跑完（land的radius不能很好体现），则系数应该小些?
##
##	changing
####	vertices = vertice_select(powder,x=MIN,y=MAX)  ## ignore可能会带来tensile space的问题（拉引力极限太小)
####	ignore_vertices(powder,vertices=vertices)
##
##
####	edges = edge_select(powder,ny=-1)
####	vertices =vertice_select(powder,edges=edges,xpoint=MIN1)
####	loc = vertices[0].pointOn[0]
####	ignore_vertices(powder,vertices=vertices)
##
####	edges = edge_select(powder,x=MIN1,ny=-1)
####	divide_edge(edges[0],x=loc[0])
####	edges = edge_select(powder,x=MIN1,ny=-1)
####	radius = get_radius(edges[0])
####	print radius
##
####	raise Exception
##
####	move_instances(bpunch_A1,dy=-ejector_clearance)	;changing
####	del_parts(bpunch)
##
####	edges_to_wirepart(edges,partname='bpunch',ptype='discrete',pshape='axisym')
####	new_instance('bpunch')
#####	edges = edge_select(powder,ny=-1)
#####	s1 = edges_to_sketch(edges,sketchname='sk_bpunch', ndir='z',offset=0)
#####
#####	x1,y1 = find_loc(s1,x=MAX)
#####	connect_points(s1,(x1+0.5, y1),(x1,y1))
#####	sketch_to_wire(s1,partname='bpunch',symmetric=True,ptype='analytical')
#####	new_instance('bpunch')
##
####	raise Exception
##
####	edges_to_wirepart(_part(bpunch).edges,partname='bpunch2', ptype='discrete',pshape='axisym')
####	raise Exception
##
####	merge_edges(bpunch)
##
#####	pt = vertice_select(bpunch,x=MIN)[0]
#####	create_RP(bpunch,loc=pt.pointOn[0],name='tpunch', clear_RP=True)
#####	new_instance(bpunch)
##
####	raise Exception
##
####	## vertical cut
####	offset_x_top = 5
####	offset_x_bot = 3
####
####	## horizontal cut
####	offset_y_top1 = 2*_ylength(tpunch)	;changing
####	offset_y_top2 = 2*_ylength(tpunch)	;changing
####
####	offset_y_bot1 = _ylength(tpunch) - 3 ## left
####	offset_y_bot2 = _ylength(tpunch) ## right
##
#######	point1 = (_xmax(powder) - offset_x_bot, _ymin(powder, x=_xmax(powder) - offset_x_bot), 0)
#######	point2 = (_xmax(powder) - offset_x_top, _ymax(powder),0)
####	point1 = locs_of_poi(powder, x=_xmax(powder) - offset_x_bot, groupY=MIN)[0]
####	point2 = locs_of_poi(powder,x=_xmax(powder) - offset_x_top, groupY=MAX)[0]
####	divide_faces_by_two_points(powder, faces=_part(powder).faces, point1=point1, point2=point2)  ## vertical
##
###	point1 = (0,_ymax(powder) - offset_y_top1,0)
###	point2 = (_xmax(powder),_ymax(powder) - offset_y_top2,0)
####	divide_faces_by_two_points(powder, faces=_part(powder).faces, point1=point1, point2=point2)
##
####	point1 = (0,_ymin(powder, x=MAX) + offset_y_bot1, 0)
####	point2 = (die_R, _ymin(powder, x=MAX) + offset_y_bot2, 0)
####	divide_faces_by_two_points(powder, faces=_part(powder).faces, point1=point1, point2=point2)
##
####	vertice = vertice_select(powder,ny=-1,xpoint=MIN1)
####	loc = vertice[0].pointOn[0]
####	loc1 = loc[0] - 5, _ymax(powder),0		;changing
####	divide_faces_by_two_points(powder, _part(powder).faces, point1=loc, point2=loc1)
##
####	## land
####	edge_width = ejector_land - 0.01
####	divide(powder,x=_xmax(powder) - edge_width)
##
####	raise Exception
##
##
##
##	## steps, output
##	times1 = myrange(0,1,0.05) + [0.001, 0.002, 0.005, 0.01, 0.02]	## 调试一开始需要仔细观察。
##	timepoints1 = create_timepoints(times1)	;changing1
##
####	create_dynamic_explicit_step(step='remesh', timePeriod=0.001)
####	create_dynamic_explicit_step(step='movePV', timePeriod=0.5)
##
##	create_dynamic_explicit_step(step='under filling', timePeriod=0.2)
##	create_dynamic_explicit_step(step='low pressing', timePeriod=0.8)
##	create_dynamic_explicit_step(step='up pressing', timePeriod=0.1)
##
##	field_output_request()
##
##	raise Exception
##
####	field_output_request(timepoints=(timepoints1))
##
##	## mesh
##	edges = edge_select(powder,x=MAX1,exterior=False)
##	seed_edges(powder,edges=edges,enum=10)	;changing   ## 10
##
##	edges = edge_select(powder,x=MIN1,exterior=False)
##	seed_edges(powder,edges=edges,enum=25,fixed=True)  ;changing    ## 网格过疏时，左上角可能会冒出来。good: 30
##
##	set_element_shape(powder, objs=_part(powder).faces, technique='STRUCTURE') ;changing
##	mesh_region(powder,esize=2)	;changing
##
####	raise Exception
##
####	adaptive_mesh_control()
##
##	## 首先，要尝试一下不用ALE能跑到哪一步，有时，不用ALE也能填满上盖甚至完成模拟（button)。
####	apply_adaptive_mesh(elements=_inst('powder_A1').elements, frequency=1,sweep=1,step='step1')	## ;changing  (不好，会使应力由下冲位置移到上冲位置)
####	elems = element_select('powder_A1',x=(die_R, die_R*0.3)) + \
####		element_select('powder_A1',poiRefY=(MAX,-L/5)) + \
####		element_select('powder_A1',y=(MIN,L/6))					;changing
##
####	elems = element_select('powder_A1',x=(die_R, die_R*0.3)) + element_select('powder_A1',poiRefY=(MAX,-L/5))
####	apply_adaptive_mesh(elements=elems, frequency=1,sweep=1)	;changing
##	## 经验：如果与上冲接触的粉体不采用自适应，可能会冒出来；同样地，如果与下冲接触的粉体不采用自适应，计算过程中也可能会冒出来。
##	## 冒出来不是接触的问题，而是由于没有自适应，过于刚硬。
##
####	raise Exception
##
##	## Interact
##	m_punch = create_surface(tpunch_A1,side='-y')
##	m_ejector = create_surface(bpunch_A1,side='+y')
##	m_die = create_surface(die_A1,side='-x')
##
####	{{
####	elems = element_select('powder_A1',poiRefY=(MAX,-_ylength(tpunch)/2)) + element_select('powder_A1',poiRefX=(MIN,0.5),poiRefY=(MAX,-3*_ylength(tpunch)))
####	surf_top = create_surface(elements=elems,name='surf_top',select_sym=True)
####
####	elems = element_select('powder_A1',poiRefX=(MAX,-die_R/5)) + element_select('powder_A1',poiRefY=(MAX,-0.5))  				;changing
####	surf_right = create_surface(elements=elems,name='surf_right')
####
####	elems = element_select('powder_A1',poiRefY=(_ymin('powder_A1'),1.2*_ylength(bpunch)))  ;changing
####	surf_bot = create_surface(elements=elems,name='surf_bot')
####	}}
##
##	nodes_top = node_select('powder_A1',y=MAX)
##	nodes_top_left = node_select('powder_A1',x=MIN, poiRefY=(MAX,-5*_ylength(tpunch)))
##
##	surf_top = create_nodal_surface('powder_A1',nodes=nodes_top + nodes_top_left,name='surf_top')
##
####	surf_top_left = create_nodal_surface('powder_A1',nodes=nodes,name='surf_top_left')
##
##	nodes_right = nodes_by_face('powder_A1',nx=1,x=MAX)
##	surf_right = create_nodal_surface('powder_A1',nodes=nodes_top + nodes_right,name='surf_right')
##
##	elems = element_select('powder_A1',ny=-1)
##	nodes_bot = get_element_facing_nodes(elems,ny=-1)
##	surf_bot = create_nodal_surface('powder_A1',nodes=nodes_bot,name='sur_bot')
##
##	changing
##	s2s_interact_exp('int_punch1',master_region=m_punch, slave_region=surf_top)
####	s2s_interact_exp('int_punch2',master_region=m_punch, slave_region=surf_top_left)
##
##	s2s_interact_exp('int_die1',master_region=m_die, slave_region=surf_right)
####	s2s_interact_exp('int_die2',master_region=m_die, slave_region=surf_top)
##
##	s2s_interact_exp('int_ejector',master_region=m_ejector, slave_region=surf_bot)
##
####	raise Exception
##
##	## mesh
##	## 与下冲接触的powder edges分成三段。
####	## 1. 底部右段, land
####	edges = edges_at(powder,x=MAX1)
####	seed_edges(powder,edges=edges,enum=10)
##
####	## 底部中段
####	edges = edge_select(powder,x=bot_points[-2] - 1,exterior=True)
####	bias_seed_edges(powder,edges=edges,enum=30,ratio=30,dense_dir='+x')
####	raise Exception
##
####	if reverse == False:
####		bias_seed_edges(powder,edges=edges,enum=20,ratio=20,flip=False)   ;changing
####	else:
####		bias_seed_edges(powder,edges=edges,enum=10,ratio=10,flip=True)
##
###	## 中段
###	edges = edge_select(powder,ref_locx=(MAX,-offset_x_bot + 0.1),y=(0,MIN))
###	if reverse == False:
###		bias_seed_edges(powder,edges=edges,enum=20,ratio=4,flip=True)	;please_check
###	else:
###		bias_seed_edges(powder,edges=edges,enum=6,ratio=2,flip=False)	;please_check
##
####	raise Exception
##
##	## 底部左段
####	edges = edges_at(powder,x=MIN1,groupY=MIN)
####	seed_edges(powder,edges=edges,esize=1.0)		;changing  ## 可能会影响到底部左下角的变形。0.4 OK for fric=0.2
##
##	## y dir (在压制方向上不要使用bias_seed，否则可能会使网格变形很大。)
####	seed_edges(powder,edges=powder_right_top,esize=0.5)	;changing
##	## 右侧边上部
####	edges = edge_select(powder,y=MAX1)
####	bias_seed_edges(powder,edges=edges,enum=10,ratio=20,dense_dir='+y')
##
##	##右侧边底部
####	edges = edge_select(powder,x=MAX,y=0.1)
####	seed_edges(powder,edges=edges,esize=0.5)	;changing
####	bias_seed_edges(powder,edges=edges,enum=20,ratio=20,dense_dir='-y')		;changing
##
##	##侧边中部
####	edges = edge_select(powder,y=MID)
####	seed_edges(powder,edges=edges,enum=10,fixed=True)
####	raise Exception
##
####	set_element_shape(powder, objs=_part(powder).faces, technique=SWEEP)
####	mesh_region(powder,esize=2.0)	;changing1
##
####	adaptive_mesh_control()
####	apply_adaptive_mesh(elements=_inst(powder_A1).elements, frequency=1,sweep=1)	;changing  (不好，会使应力由下冲位置移到上冲位置)
##
####	top_faces = face_select(powder_A1,y=MAX1)
####	bot_faces = face_select(powder_A1,poiRefX=(MAX,-2),y=0.1,mark_select=True)
####
####	side_faces = face_select(powder_A1,poiRefX=(MAX,-2)) + top_faces
####	side_faces = remove_repeated_items(side_faces)
######	apply_adaptive_mesh(faces=side_faces, frequency=1,sweep=1,step='remesh')	;changing
####	apply_adaptive_mesh(faces=top_faces + bot_faces, frequency=1,sweep=1,step='move')	;changing
##
#####	apply_adaptive_mesh(faces=top_faces + bot_faces, frequency=1,sweep=1,step='ALE')	;changing
###
###	apply_adaptive_mesh(faces=top_faces + bot_faces, frequency=1,sweep=1,step='step1')	;changing
#####	apply_adaptive_mesh(faces=bot_faces, frequency=1,sweep=1,step='step3')	;changing
##
##
####	raise Exception
##
####	## Interact
####	m_punch = create_surface(tpunch_A1,side='-y')
####	m_ejector = create_surface(bpunch_A1,side='+y')
####	m_die = create_surface(die_A1,side='-x')
####
####
####	## top
####	powder_top = edge_select(powder_A1,y=MAX)
####	powder_top_left = edge_select(powder_A1,y=MAX,x=MIN1)
####	powder_top_right = unselect(powder_top, powder_top_left)
######	raise Exception
####
####	## bot
####	powder_bot = edge_select(powder_A1,ny=-1)
####	powder_bot_left = edge_select(powder_A1,x=MIN1,ny=-1)
####	powder_bot_right = edge_select(powder_A1,x=MAX1,ny=-1)
####
####	## left
####	powder_left_top = edge_select(powder_A1,x=MIN,y=MAX1)
####	powder_left_bot = edge_select(powder_A1,x=MIN,y=MIN1)
####
####	## right
####	powder_right = edge_select(powder_A1,x=MAX)
####	powder_right_bot = edge_select(powder_A1,x=MAX,groupY=MIN1)
####	powder_right_top = edge_select(powder_A1,x=MAX, y=MAX1)
####
####
####	changing
####	s2s_interact_exp('int_punch',master_region=m_punch, sedges=powder_top + powder_left_top + powder_right_top)
######	s2s_interact_exp('int_punch',master_region=m_punch, sedges=powder_top + powder_right_top)
####	s2s_interact_exp('int_die',master_region=m_die, sedges = powder_right + powder_top_right + powder_bot_right)
####	s2s_interact_exp('int_ejector',master_region=m_ejector,sedges = powder_left_bot + powder_bot + powder_right_bot,friction=0.1)	;changing
######	s2s_interact_exp('int_ejector',master_region=m_ejector,sedges = powder_bot + powder_right_bot)
####
######	raise Exception
##
##	## Loads
##	punch_depth = _ylength(tpunch)
##	total_compressed = punch_depth + PFH - PH
##	## before: punch_depth + L + PV
##	## after: PH
##	## total compressed: punch_depth + L + PV - PH （上冲的压缩量+下冲的压缩量）
##	## 其中die的行程(等效下冲动): PV
##	## 实际上，下冲不动 ，所以total compressed也就是上冲的全部行程。
##
##	## top punch走total_compressed
####	_m.TabularAmplitude(name='top_move', timeSpan=STEP,
####	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, -dip), (0.50, -dip - PV),  (1.0, -total_compressed)))
##
##	## die只走PV, bot punch始终不动。
####	_m.TabularAmplitude(name='die_move', timeSpan=STEP,
####	    smooth=SOLVER_DEFAULT, data=((0.0, 0), (0.1, 0), (0.50, -PV),  (1.0, -PV)))
##
####	_m.TabularAmplitude(name='top_move2', timeSpan=STEP,
####	    smooth=SOLVER_DEFAULT, data=((0.0, -dip - PV),  (0.5, -total_compressed)))
##
##	apply_BC_on_RP_2D(bpunch_A1,U1=0,U2=0,UR3=0,stepname='step1')	## bpunch is always stable
##	apply_BC_on_RP_2D(tpunch_A1,U1=0,UR3=0,stepname='step1')
##	apply_BC_on_RP_2D(die_A1,U1=0,UR3=0,stepname='step1')
##
##	apply_BC_on_RP_2D(tpunch_A1,U2=0,modifys=('step1',U2,-dip),stepname='Initial')
##	apply_BC_on_RP_2D(die_A1,U2=0)
##
##
###	apply_BC_on_RP_2D(tpunch_A1,U2=-dip,stepname='step1',modifys=('step2','U2',-dip-PV))
###	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step1',modifys=('step2','U2',-PV))
##
####	apply_BC_on_RP_2D(tpunch_A1,U2=0,stepname='step1',modifys=('step2','U2','top_move'))
####	apply_BC_on_RP_2D(tpunch_A1,U2=0,stepname='step1',modifys=[('step2','U2','top_move'),('step3','U2','top_move2')])
####	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1',modifys=('step2','U2','top_move2'))
####	apply_BC_on_RP_2D(tpunch_A1,U2=1,amplitude='top_move',stepname='step1')
##
####	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step1',modifys=('step2','U2','die_move'))	;changing
####	apply_BC_on_RP_2D(die_A1,U2=0,stepname='step3')
####	apply_BC_on_RP_2D(die_A1,U2=1,amplitude='die_move',stepname='step1')
##
####	apply_gravity()
##
####	raise Exception
##
####	check1()
##	create_inp(inp_file_title,request_num=6) 		;please_check
##	mdb.jobs[inp_file_title].submit()
####	back_run()
##
##	return

def main_A0267_sintering_USM_insert():
	## VER: 2016-05-03, v1.0, 11:00am
	## Change at least the script file name and compaction_odb

	check_script_file('BP_A0267_A0266-I-USM_insert_R80_sym.py')	;changing
	purpose = 'Requested by Ulesis, Mexico. Perform sintering simulating before tool design'
	history='B3:shrinkage=19.5%; B2:shrinkage=19%; B1: model'

	locals0 = locals().keys()

##	compaction_odb = 'A0265-USM_insert_R50_P3'
##	compaction_odb = 'A0265-USM_insert_R50_P3_k2'  ## small OB
##	compaction_odb = 'A0265-H-USM_insert_R50_P3_k2'

##	compaction_odb = 'A0266-F-USM_insert_R80'
##	compaction_odb = 'A0266-DUSM_insert_R80_P4_4'   ## no much simplification
##	compaction_odb = 'A0266-DUSM_insert_R80_P4_4_k2'  ## Error shrinkage, because compaction density is only 40%
##	compaction_odb = 'A0266-F-USM_insert_R80_k2'
##	compaction_odb = 'A0266-H-USM_insert_R80_k2'
##	compaction_odb = 'A0266-I-USM_insert_R80'
##	compaction_odb = 'A0266-I-USM_insert_R80_R65'
	compaction_odb = 'A0266-I-USM_insert_R80_sym'

##	compaction_odb = 'A0267-B-USM_insert_B104_R60'	;changing
##	compaction_odb = 'A0267-USM_insert_B104_R60'
##	compaction_odb = 'A0267-USM_insert_B104_R60_k2'  ## smaller size in odb, different press parameters
##	compaction_odb = 'A0267-USM_insert_B104_R60_k3'  ## small OB, 中模移动距离比上冲小些，变相等于中模的移动速度小些
##	compaction_odb = 'A0267-USM_insert_B104_R60_k2_sym'   ## 1/4 model

##	compaction_odb = 'A0268-USM_insert_B105_R90'
##	compaction_odb = 'A0268-USM_insert_B104_R90_k2'	## smaller size in odb, different press parameters

	## import part from odb
	## 检查p1的名字可以知道所导入的模块
	p1 = import_part_from_odb(odbname=compaction_odb,part_name='p1',step_id=-1,frame=-1)
	globals()['p1'] = p1   ## p1 is the part name, such as: p1='A0267-B-USM_p1_step2_frame30'

	hole_axis = 'z'
	topside = MIN 		;changing 	## z direction, toppunch side, with high density at suroundings; or with smaller hole
	auto_label = True	;changing
	model = 'quarter'	;changing

	if model == 'full':
		if auto_label == True:
			labels = fix_nodes_of_insert(p1,axis_side=topside,angle=40,return_label=True)	;changing
			nodes_x0 = labels[:2]
			nodes_y0 = labels[2:4]

		else:
			## Query节点时：按住shift键，把两个节点都选出来后，再按done。注意选择topside的节点
			if hole_axis == 'z':
				nodes = node_select(p1,x=0,err=0.3)  ## 148, 420
				nodes = node_select(p1,y=0,err=0.3)  ## 1, 5

			if compaction_odb == 'A0267-B-USM_insert_B104_R60':
				nodes_x0 = [149, 420]
				nodes_y0 = [1, 5]

	density_file = '_den_' + compaction_odb + '.txt'	;changing1
	cae_title = '_sin_'+ compaction_odb					;changing1
	cae_no_mat = '_sin1_'+ compaction_odb				;changing1
	cae_with_mat = '_sin2_'+ compaction_odb				;changing1

	_import = True			;changing
	output_density = True	;changing
	apply_mat = True		;changing

##	dens_range = (0.1,0.15,0.8,0.9)
	dens_range = (0.05,0.1,0.85,0.90)	;changing

	## W2B similar to H10F powder, 回收粉，类似于1072粉。
	## grade: 503DPSM
	density_th =  14.28     ;changing ##  14.44		;changing1    12EF, AM70, 1024
	sinter_loss = 2.78     	;changing ##  2.174, 2.418		;changing
	design_shrinkage = 0.19     ;changing ## Used for tool compensation only ##  prefer 19%? (AM70 powder)		;changing  ## 0.8032 (0.1968, used in engineering PU Wuxi)
	offset = -0.3		    ;changing   ## parameter of apply_CTE_from_density_with_PEG(). 当收缩率大于19%时（例如12EF)，可考虑offset=-0.35或-0.4，当收缩率小于18时，可考虑offset=-0.25或-0.2
	## offset=-0.4: avg shrinkage=20.77, offset=-0.3: average shrinkage=20.41
	## use real_shrinkage() to get the real shrinkage

	locals2globals(locals0,locals(),save_var=True)

##	target_density = shrinkage_to_density_with_PEG(shrinkage,C1=sinter_loss, Rho_th = density_th)  ## 8.42
##	print ' '
##	print fnln(),'sinter_loss =',sinter_loss, ', density_th =',density_th
##	print fnln(),'shrinkage =',design_shrinkage, ', target_density=',target_density

	if _import == True:
		apply_mat = True

	if _import == True:
		if output_density == True:
			open_odb(compaction_odb)

			density_processing(Rho_th=density_th,low=0.02,high=0.97)
			dens1 = _density_vol
			density_processing(Rho_th=density_th,ranges=dens_range,retreat=True,density_vol=dens1,method='linear')
			dens2 = _density_vol
			## provided shrinkage in powder certificate or engineering design does not affect the density_processing()

			write_density_and_element_labels(density_vol=dens2,filename=density_file)	;changing

		## Kevin: the last step name is uppressing
		import_part_from_odb(odbname=compaction_odb,part_name='green',step_id=-1,frame=-1, copy_nodeset=False,force_name=True)	;changing
		new_instance('green')

		save_mdb(cae_no_mat)			;changing1

	else:
		if apply_mat == False:
			open_cae(cae_with_mat)
		else:
			open_cae(cae_no_mat)

	save_mdb(inp_file_title)

##	raise Exception

	locals0 = locals().keys()
	part1 = 'part1'		;	part1_A1 = 'part1_A1'

	analysis1_title = inp_file_title
	bulk_modulus = 400e3	;changing1	## 400GPa
	Yield = None			;changing1

	deltaT = 1				;changing1

	green = 'green'			;	green_A1 = 'green_A1'
	p1 = 'green_A1'

	## dimensions
	length = 25.6
	thick = 3.2

	locals2globals(locals0,locals(),save_var=True)

##	raise Exception

	open_odb(compaction_odb)
##	density_avg = density_distribution(th=density_th)['average']
##	density_lab = shrinkage_to_density_with_PEG(shrinkage,Rho_th = density_th)
##	print fnln(),'density_avg=',density_avg
##	print fnln(),'density_lab=',density_lab

##	session.viewports['Viewport: 1'].odbDisplay.contourOptions.setValues(maxAutoCompute=ON, minAutoCompute=ON)

	## SMIL
	if apply_mat == True:
		densities = read_density_and_element_labels(density_file)

		print fnln(),'sinter_loss=',sinter_loss   ## No problem

		apply_CTE_from_density_with_PEG('green',densities=densities,bulk_modulus=bulk_modulus, deltaT=deltaT,C1=sinter_loss, offset=offset,
			density_th=density_th,Yield=Yield)	;changing

		save_mdb(cae_with_mat)
		save_mdb(inp_file_title)

	create_general_static_step()

##	if len(_m.interactionProperties) == 0:
##		create_contact_props(friction=0.1)	;changing1

	p1 = 'green_A1'
	nodes = _inst(p1).nodes[:]  ;changing1 ## only for green part
	region = a.Set(nodes=nodes, name='all_nodes')
	set_temperature_predefined_field('Temp_field',region=region, initial_step=25+deltaT, modify=25)

	## boundary conditions
	nodes = node_select(p1,z=MID,err=0.25)
	create_set(setname='dim_zmid',nodes=nodes)

	nodes = node_select(p1,x=0,err=0.25)
	create_set(setname='dim_xmid',nodes=nodes)

	nodes = node_select(p1,y=0,err=0.25)
	create_set(setname='dim_ymid',nodes=nodes)

	try:
		nodes = nodes_by_face(p1,nx=-1,x=MIN)
		nodes = node_select(p1,nodes=nodes,x=(MID,MIN))
		elems = nodes_to_elements(nodes)
		elements_to_surface(elems,name='surf_xmin',axis='x',by_fine=True)
	except:
		pass

	try:
		nodes = nodes_by_face(p1,nx=1,x=MAX)
		nodes = node_select(p1,nodes=nodes,x=(MID,MAX))
		elems = nodes_to_elements(nodes)
		elements_to_surface(elems,name='surf_xmax',axis='x',by_fine=True)
	except:
		pass

	try:
		nodes = nodes_by_face(p1,ny=-1,y=MIN)
		nodes = node_select(p1,nodes=nodes,y=(MID,MIN))
		elems = nodes_to_elements(nodes)
		elements_to_surface(elems,name='surf_ymin',axis='y',by_fine=True)
	except:
		pass

	try:
		nodes = nodes_by_face(p1,ny=1,y=MAX)
		nodes = node_select(p1,nodes=nodes,y=(MID,MAX))
		elems = nodes_to_elements(nodes)
		elements_to_surface(elems,name='surf_ymax',axis='y',by_fine=True)
	except:
		pass

	try:
		nodes = nodes_by_face(p1,nz=-1,z=MIN)
		nodes = node_select(p1,nodes=nodes,z=(MID,MIN))
		elems = nodes_to_elements(nodes)
		elements_to_surface(elems,name='surf_zmin',axis='z',by_fine=False)
	except:
		pass

	try:
		nodes = nodes_by_face(p1,nz=1,z=MAX)
		nodes = node_select(p1,nodes=nodes,z=(MID,MAX))
		elems = nodes_to_elements(nodes)
		elements_to_surface(elems,name='surf_zmax',axis='z',by_fine=True)
	except:
		pass

	if model == 'full':
		apply_disp_fix(name='BC_x',nodes=nodes_x0,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
		apply_disp_fix(name='BC_y',nodes=nodes_y0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

	elif model in ['quarter', '1/4']:
		nodes = node_select(p1,x=MIN)
		apply_disp_symm('x',nodes=nodes)

		nodes = node_select(p1,y=MIN)
		apply_disp_symm('y',nodes=nodes)

		nodes = node_select(p1,y=MIN)
		nodes1 = node_select(p1,nodes=nodes,groupZ=MIN)
		nodes2 = node_select(p1,nodes=nodes1,groupX=MIN)
		apply_disp_fix(name='BC_z',nodes=nodes2[0],Uz=0)



##	raise Exception

	create_inp(analysis1_title,request_num=1,submit=False)
##	mdb.jobs[analysis1_title].submit()

	## post processing: import deformed part as p1,
##	nodes = nodes_by_face('p1',x=MAX,nx=1)
##	nodes = node_select('p1',nodes=nodes,groupZ=MID)
##	node1 = node_select('p1',nodes=nodes,endX=MIN)
##	objs_space(node1)
##	node2 = node_select('p1',nodes=nodes,endX=MAX)
##	objs_space(node2)
##	gap in x: 79um, 73um, avg=76um

##	density_distribution(low=0.01,high=0.99,th=14.28)

##	p1 = 'BA', priority 2
##	nodes1 = node_select(p1,z=_zmid(p1),x=(-6.5,6.5),err=0.1,poiRefY=(MAX,-2))
##	radius_of_fit_nodes(nodes1,axis='xy')
##	nodes1 = node_select(p1,z=_zmid(p1),y=(-6.5,6.5),err=0.1,poiRefX=(MAX,-2))
##	radius_of_fit_nodes(nodes1,axis='yx')

	## 267, 1/4模型
##	nodes = nodes_by_face(p1,y=MAX,ny=1,angle=10)
##	nodes1 = node_select(p1,z=_zmid(p1),x=(-6.5,6.5),err=0.1,nodes=nodes)
##	radius_of_fit_nodes(nodes1,axis='xy')	## R=61.234(BL,sym model，数据不对称处理), R=62.919((B9,full model)
##	radius_of_fit_nodes(nodes1,axis='xy',sym=True)  ## R=62.797(BL,sym model,数据对称处理),可见，数据需对称处理

##	nodes = nodes_by_face(p1,x=MAX,nx=1,angle=10)
##	nodes1 = node_select(p1,z=_zmid(p1),y=(-6.5,6.5),err=0.1,nodes=nodes)
##	radius_of_fit_nodes(nodes1,axis='yx')	## R=61.792(BL,sym model，数据不对称处理), R=62.68((B9,full model)
##	radius_of_fit_nodes(nodes1,axis='yx',sym=True)  ## R=62.894(BL,sym model,数据对称处理),可见，数据需对称处理

	## 266, 1/4 model, nominal R=65. Job num:BN
##	nodes = nodes_by_face(p1,x=MAX,nx=1,angle=10)
##	nodes1 = node_select(p1,z=_zmid(p1),y=(-5.05,5.05),err=0.1,nodes=nodes)
##	radius_of_fit_nodes(nodes1,axis='yx',sym=True) ## R=53.825

##	nodes = nodes_by_face(p1,y=MAX,ny=1,angle=10)
##	nodes1 = node_select(p1,z=_zmid(p1),x=(-5.05,5.05),err=0.1,nodes=nodes)
##	radius_of_fit_nodes(nodes1,axis='xy',sym=True) ## R=53.951

	## 266, 1/4 model, nominal R=80. Job num:BP
##	nodes = nodes_by_face(p1,nx=1)
##	nodes1 = node_select(p1,z=_zmid(p1),y=(-4.9,4.9),err=0.1,nodes=nodes)
##	radius_of_fit_nodes(nodes1,axis='yx',sym=True) ## R=63.607

##	nodes = nodes_by_face(p1,ny=1)
##	nodes1 = node_select(p1,z=_zmid(p1),x=(-4.9,4.9),err=0.1,nodes=nodes)
##	radius_of_fit_nodes(nodes1,axis='xy',sym=True) ## R=63.195


	## 266, priority 4
##	nodes1 = node_select(p1,z=_zmid(p1)-0.5,x=(-4.9,4.9),err=0.1,poiRefY=(MAX,-2))
##	radius_of_fit_nodes(nodes1,axis='xy')
##	nodes1 = node_select(p1,z=_zmid(p1)-0.5,y=(-4.9,4.9),err=0.1,poiRefX=(MAX,-2))
##	radius_of_fit_nodes(nodes1,axis='yx')

##	nodes = nodes_by_face(p1,z=MAX,nz=1)
##	nodes1 = node_select(p1,nodes=nodes,x=MID,err=0.2)
##	radius_of_fit_nodes(nodes1,axis='yz',negative_axis2=True)

##	nodes = nodes_by_face(p1,z=MAX,nz=1)
##	nodes1 = node_select(p1,nodes=nodes,y=MID,err=0.2)
##	radius_of_fit_nodes(nodes1,axis='xz',negative_axis2=True)

	return

def main_A0269_2rod_cavity_press_tool_design():
	## VER: 2016-08-10, v1.0

	script_file_full = check_script_file('AE_A0269_two_rods_die_wall65mm.py')	;changing

	blank_cae(inp_file_title)
	locals0 = locals().keys()

	analysis1_title = inp_file_title	;changing1

	carbide_OD = 150
	steel_OD = 240   ## 180
	carbide_thick = 40

	cavity_width = 13.135
	cavity_length = 86.25
	cavity_wall = 6.5		## 5.865

	interference = 0.04
	steel_ID = carbide_OD - 2*interference

	ton = 20	;changing  ## 10ton
	datas = pressure_on_area(L=cavity_length,W=cavity_width,ton=ton)
	punch_pressure = datas[2]
	wall_pressure = datas[3]

	carbide_mat = 'H10F'		;changing1	## H10F, Steel_K390
	steel_mat = 'Steel_4340'

	carbide_A1 = 'die_A1'
	case_A1 = 'case_A1'

	locals2globals(locals0,locals(),save_var=True)

	material_database()
	create_contact_props()

	## sketch
	s1 = create_base_sketch('s_die')
	create_circle(s1,diameter=carbide_OD)
	loc0 = (-cavity_wall/2 - cavity_width, cavity_length/2)
	connect_points(s1,loc0,('dx',cavity_width),('dy',-cavity_length),('dx',-cavity_width),loc0)

	loc0 = (cavity_wall/2, cavity_length/2)
	connect_points(s1,loc0,('dx',cavity_width),('dy',-cavity_length),('dx',-cavity_width),loc0)

	s1 = create_base_sketch('s_case')
	create_circle(s1,diameter=steel_OD)
	create_circle(s1,diameter=steel_ID)

	sketch_to_shellpart(partname='die',sketch='s_die')
	sketch_to_shellpart(partname='case',sketch='s_case')

	divide('die',x=0)

	new_instance('die')
	new_instance('case')

	set_mat('die',mat='H10F')
	set_mat('case',mat='Steel_4340')

	create_general_static_step()

	## interaction: shrink fit
	edges1 = edge_select(carbide_A1,radius=carbide_OD/2.)
	edges2 = edge_select(case_A1,radius=steel_ID/2.)
	s2s_interact_std(mfaces=edges1,sfaces=edges2,interference='shrink_fit')

##	edges = edge_select('die_A1',x=(0,MIN),shape='line')
##	apply_pressure('left_press',edges=edges,MPa=wall_pressure)		;please_check
##
##	edges = edge_select('die_A1',x=(0,MAX),shape='line')
##	apply_pressure('right_press',edges=edges,MPa=wall_pressure*0.9)	;please_check

##	edges = edge_select('die_A1',x=(0,MIN),shape='line')
##	apply_pressure('left_press',edges=edges,MPa=70)		;please_check
##
##	edges = edge_select('die_A1',x=(0,MAX),shape='line')
##	apply_pressure('right_press',edges=edges,MPa=60)	;please_check

	edges = edge_select('case_A1',diameter=steel_OD)
	apply_disp_fix('fix',edges=edges)

	edges = edge_select('die_A1',x=-cavity_wall/2)
	apply_pressure('left_press',edges=edges,MPa=10)		;changing

##	edges = edge_select('die_A1',diameter=carbide_OD)
##	apply_disp_fix('fix',edges=edges)

	mesh_part('die',esize=cavity_wall/2)
	mesh_part('case',esize=cavity_wall/2)

	create_inp(inp_file_title, request_num=2) ;please_check
	mdb.jobs[inp_file_title].submit()

def main_A0271_sintering_USM_insert():
	## VER: 2016-08-28, v1.0, 14:00pm
	## Change at least the script file name and compaction_odb

	check_script_file('AW_A0271_H10F_B102_expansion.py')	;changing
	purpose = 'Requested by Ulesis, Mexico. Perform sintering simulating before tool design'
	history='B3:shrinkage=19.5%; B2:shrinkage=19%; B1: model'

##	compaction_odb = 'A0275-N428_Sim_A6'
##	compaction_odb = 'A0265-B102_A7'
##	compaction_odb = 'A0266-B103_A8'
##	compaction_odb = 'A0268-B105_A7'
##	compaction_odb = 'A0267-B104_A7'
	compaction_odb = 'A0265-B102_A7'

	job_name = insert_sintering(compaction_odb=compaction_odb,job_name=inp_file_title,density_th=14.435,sinter_loss=2.505,manual=False,expansion=True)

##	mdb.jobs[job_name].submit()
	'''  ## =============
## 1/4 model, B102

L = 6.0
nodes1 = node_select(p1,z=_zmid(p1)-0.4,x=(0.2,L),err=0.15,poiRefY=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='xy')

nodes1 = node_select(p1,z=_zmid(p1)-0.4,y=(0.2,L),err=0.15,poiRefX=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='yx')

## full model, B103
nodes1 = node_select(p1,y=MAX,err=0.1)
nodes2 = node_select(p1,y=MIN,err=0.1)
average_ydist(nodes1,nodes2)

nodes1 = node_select(p1,z=_zmid(p1)-0.2,x=(-4.5,4.5),err=0.1,poiRefY=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='xy')
nodes1 = node_select(p1,z=_zmid(p1)-0.2,y=(-4.5,4.5),err=0.1,poiRefX=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='yx')

length_of_insert(p1)
diameter_of_insert_hole(p1)
side_radius_of_insert(p1)
dimension_compare('green','compare',sym='xy')

	'''  ## ===========

	return

def main_A0275_sintering_Ramundo_insert():
	## VER: 2016-08-28, v1.0, 14:00pm
	## Change at least the script file name and compaction_odb

	check_script_file('A6_A0275_AM70_N230_expansion.py')	;changing
	purpose = 'Requested by Ulesis, Mexico. Perform sintering simulating before tool design'
	history='B3:shrinkage=19.5%; B2:shrinkage=19%; B1: model'

##	compaction_odb = 'A0275-N428_Sim_A6'
##	compaction_odb = 'A0275-N429_Sim_A7'
	compaction_odb = 'A0275-N230_Sim_A3'

	grade = '074'
	density,sintering_loss = powder_properties(grade)

	job_name = insert_sintering(compaction_odb=compaction_odb,job_name=inp_file_title,density_th=14.13,sinter_loss=2.81,manual=True,expansion=True)

	p1 = a.instances.values()[0]
	nodes1 = node_select(p1,y=MID,x=(-2,2),err=0.05)
	apply_disp_fix('yfix',nodes=nodes1,Uy=0,rots=0)

	nodes2 = node_select(p1,x=0,err=0.05)
	apply_disp_fix('xfix',nodes=nodes2,Ux=0,rots=0)

	nodes3 = node_select(p1,x=0,y=MID,err=0.2,Gz=MAX)
	apply_disp_fix('zfix',nodes=nodes3,Uz=0,rots=0)

##	apply_disp_fix(name='BC_x',nodes=nodes_x0,Ux=0,Uz=0,UR1=0,UR2=0,UR3=0)
##	apply_disp_fix(name='BC_y',nodes=nodes_y0,Uy=0,Uz=0,UR1=0,UR2=0,UR3=0)

	'''   ## 后处理
nodes = nodes_by_face(p1,y=MAX,ny=1,x=(MINp,-0.8),z=_zmid(p1)+2)
objs_span(nodes)
	'''

	return


 ### =========================================================================================
function_labels['main_A0276_sintering_insert_expansion'] = 'inverse sintering', 'expansion', 'compensation','Anders'
def main_A0276_sintering_insert_expansion():
	## VER: 2016-08-28, v1.0, 14:00pm
	## Change at least the script file name and compaction_odb

	script = 'A2_A0276_USMproj_expansion.py'	;changing

	check_script_file(script)
	purpose = 'Requested by Anders Ohlsson, try to get the compensated shape for tool design'
	history='A1: model'

##	compaction_odb = 'A0275-N428_Sim_A6'
##	compaction_odb = 'A0265-B102_A7'
##	compaction_odb = 'A0266-B103_A8'
##	compaction_odb = 'A0268-B105_A7'
##	compaction_odb = 'A0267-B104_A7'
##	compaction_odb = 'A0265-B102_A7'
##	compaction_odb = 'A0256-A_USM_ALE'
	compaction_odb = 'H0235-insert_comp_test1'

##	job_name = insert_sintering(compaction_odb=compaction_odb,job_name=inp_file_title,density_th=14.435,sinter_loss=2.505,manual=False,expansion=True)
##	job_name = insert_sintering(compaction_odb=compaction_odb,job_name=script,density_th=14.94,sinter_loss=2.174,manual=False,expansion=True)  ## A0256
	job_name = insert_sintering(compaction_odb=compaction_odb,job_name=script,density_th=14.44,sinter_loss=2.418,manual=False,expansion=True)  ## A0256

##	mdb.jobs[job_name].submit()
	'''  ## =============
## 1/4 model, B102

L = 6.0
nodes1 = node_select(p1,z=_zmid(p1)-0.4,x=(0.2,L),err=0.15,poiRefY=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='xy')

nodes1 = node_select(p1,z=_zmid(p1)-0.4,y=(0.2,L),err=0.15,poiRefX=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='yx')

## full model, B103
nodes1 = node_select(p1,y=MAX,err=0.1)
nodes2 = node_select(p1,y=MIN,err=0.1)
average_ydist(nodes1,nodes2)

nodes1 = node_select(p1,z=_zmid(p1)-0.2,x=(-4.5,4.5),err=0.1,poiRefY=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='xy')
nodes1 = node_select(p1,z=_zmid(p1)-0.2,y=(-4.5,4.5),err=0.1,poiRefX=(MAX,-2))
radius_of_fit_nodes(nodes1,axis='yx')

length_of_insert(p1)
diameter_of_insert_hole(p1)
side_radius_of_insert(p1)
dimension_compare('green','compare',sym='xy')

	'''  ## ===========

	return

function_labels['main_PV_46Id_build_model'] = 'suntech','module'
def main_PV_46Id_build_model():
##	lineno1 = VER: ('VER: 2012-06-13, v1.5')

##	raise Exception

	script = 'B5_46Id_raise_noenhance_Z_bolt_esize5.py'	;changing

	check_script_file(script)
	purpose = 'Repeat_AK_46Id_raise_noenhance_Z_bolt_esize5.py'
	history='B1: model'

	global ehole_D,mhole_D,bolt_pin_D,ehole_ext,mhole_ext

	locals0 = locals().keys()
	## material property
	EVA100 = 2.5   				#;please_check('100%模量')
	EVAE = 15						;please_check(5, 15)
	silE = 2   						;please_check('default=0.5MPa')
	glassE = 70						;please_check('70,67')
	rubber2_scale = 2.5			#;please_check
	FRPE = 40						;please_check
	pack_mat = 'Silic'				;please_check
	tape_type = 'elastic'		;please_check('elastic,cohesive')
	Tape_strength = 0.3			;please_check('0.3MPa')

	## module/frame/cell
	_module_type = 'Id'			;please_check('W35,R,V40')
	cut_short_flange = False		;please_check
	cut_long_flange = False		;please_check
	frL_bot_width = 25
	has_mid_hole = True			;please_check
	frame_alum_strength = 180	#;please_check
	has_frame = True				;please_check
	has_cell = False				;please_check

	if _module_type[0] in ['W','A','V']:
		has_frame = True
	elif _module_type[0] in ['D','F']:
		has_frame = False
	if _module_type == 'V40':
		has_mid_hole = False

	if _module_type not in script:
		raise 'Confusing module_type',_module_type

	if '_nohole_' in script:
		has_mid_hole = False

	## mount method
	mount_method = 'clamp'		;please_check('标准组件为: clamp, hole, bolt, insert, brail,stack')
	has_mount_clamp = has_mount_hole = has_mount_bolt = has_mount_insert = has_mount_brail = False
	globals()['has_mount_' + mount_method] = True
	if has_mount_hole == True and _module_type[0] != 'R':
		has_mount_bolt = True
##	brief = mount_method + ',' + brief

	## clamp
	clamp_shape = 'Z'				;please_check('T, C, Z, other')
	clamp_thick = 3				;please_check
	clamp_depth_on_glass = 12
	clamp_depth_on_frame = 10
	if '_noclm_' in script:
		has_mount_clamp = False

	## insert
	insert_thick = 4
	insert_top_width = 17
	insert_bot_width = 35

	## rail (注意：压块安装方式下，横梁通常尽可能平行短边）
	has_rail = True									;please_check('模态分析无需rail')
	rail_mat = 'Al_6063'		#;please_check
	beam_num = 1
	support_option = 'long_edge+long_rail'		## long_edge//long_rail, long_edge//short_rail, long_edge + short_rail,
																## short_edge//long_rail, short_edge//short_rail, short_edge+short_rail, mix, long_edge, short_edge
	rail_dir = get_rail_dir(support_option)
	lam2rail = 6				;please_check('无框组件,Diamond')

	## bolt/pin
	bolt_pin_D = 10				;please_check

	## Interact
	clamp2frL = 'interact'		;please_check('正面tie时收敛快，但一定要有预紧力，而且是T-clamp，此时clamp有一定灵活性')
	rail2frL = 'interact'		;please_check
	edge_contact = 'None'			;please_check('None, interact, tie, condition')
	edge_tie_limit = 200			;please_check
	clamp_friction = False	;please_check('standard clamp')

	## load
	load_on_frame = True				;please_check
	load_side = 'top'					;please_check
	press_Pa = 5400					;please_check

	##raise Exception

	bload = 1000					;please_check('default=1500或1000')
	if load_side == 'bot':
		bload = 0

	accel = 2*9800				;please_check
	freq = 1						;please_check
	load_time = 2.0			;please_check
	release_time = 1.0		;please_check

	## damping
	alpha = 0					;please_check
	beta = 0						;please_check
	direct_damping = 0.02		;please_check
	if alpha+beta > 0:
		damp_type = 'rayleigh'
	elif direct_damping > 0:
		damp_type = 'direct'

	## BC
	clamp_fix_area = 'cover+side'		;please_check('bot,side,cover,cover+side,top+bot, None')

	## mesh
	frame_H_esize = 2				;please_check
	flange_thick_enum = 2		;please_check
	outer_wall_enum = 2			;please_check
	inner_wall_enum = 2			;please_check
	glass_enum = 2					;please_check
	glass_enhanced = False		;please_check(True,False)
	frame_enhanced = False		;please_check

	lam_esize = 10
	clamp_esize = 5				;please_check

	DOE_method = 'multiply'		;please_check('multiply','table','DOE')
	please_check('1. DOE_table')

	please_check('2. levels list')
		## 	    			 	   1,	 	2,	   3,	 	4,	 	5,		 6,	 7,	 8,	 9,	 10,   11,   12,   13,   14,   15,   16,   17,   18,   19,   20,    21
	##levels['outer_wall_thick']=   1.3,  1.3,  1.4,  1.4,  1.4,  1.5,   1.5,  1.5,  1.5,  1.5,  1.6,  1.6,  1.6,  1.6,  1.6,  1.7,  1.7,  1.7,  1.7,  1.8,   1.8
	##levels['inner_wall_thick']= 1.7,  1.8,  1.6,  1.7,  1.8,  1.4,   1.5,  1.6,  1.7,  1.8,  1.3,  1.4,  1.5,  1.6,  1.7,  1.3,  1.4,  1.5,  1.6,  1.3,   1.4

	##levels['frame_height'] = 35, 32, 30
	##levels['outer_wall_thick'] = 1.5, 1.4, 1.3

	##levels['top_adhesive_cut'] = [2,  4,  2,  4,  6,  4,  6,  8,  6,  8]
	##levels['bot_adhesive_cut'] = [0,  0,  2,  2,  2,  4,  4,  4,  6,  6]

	##levels['clamp_length'] = 200, 250, 300, 350, 400

	##levels['load_side'] = ['top','bot']
	##levels['clamp2corner'] = [300, 320, 340, 360, 380, 400, 420]		## DW

	##levels['clamp_length'] = 250, 300, 350, 400
	##levels['clamp2corner'] = [220, 240, 260, 280, 300, 320, 340, 360]  ## DV, 3clamps
	##levels['clamp2corner'] = [410, 420, 430, 440, 450,460,470,480,490, 510, 530]		## DV, 2clamps
	##levels['clamp2corner'] = 310, 330, 350, 370, 390, 410, 430  ## DW
	##levels['clamp2corner'] = 150, 180, 210, 250, 290, 330, 370, 410, 450, 480, 500

	##levels['clamp2corner'] = 310, 330, 350, 370, 390

	##levels['clamp2corner'] = 170, 180

	##levels['hole2corner1'] = [100, 120, 150,	200,  250,  300,   350,	 400]
	##levels['hole2corner2'] = [230,	270,  310,  350]

	##levels['lam2rail'] = 6, 9, 12, 15, 18, 21, 24, 27
	##levels['press_Pa'] = 2000, 2400, 3000, 3500, 4000, 4500, 5000
	##levels['Al_6063'] = 140,  170,  200,  240,  280
	##levels['frame_height'] = [55,  60,  65,  70,  75]
	##levels['leg_thick'] =  [2.0,  	2.5,  3.0,  3.5]   ## thickness

	all_treats = get_all_treats_from_levels_list('multiply')	;please_check
	treat_indexs = range(1,len(all_treats) + 1)

	locals2globals(locals0,locals(),save_var=True)

	## dimensions
	get_module_dims(_module_type)

	## hole & bolt

	ehole_D = 5.0  		## mounting hole: 9, electric hole: 5.0
	mhole_D = 8
	if _module_type[0] == 'R':
		mhole_D = 10
##	bolt_pin_D = mhole_D - 0.5			;please_check
##	bolt_pin_D = 10	;please_check
	ehole_ext = 2*ehole_D
	mhole_ext = 2*mhole_D

	please_check('create materials')
##	create_materials_PV()
##	set_hyperElastic(EVA2)
##	set_hyperElastic(Rubber2,model='YEOH')	;please_check
##	set_hyperElastic(Silic2)						;please_check
##	create_contact_props(friction=0.3)					;please_check('default=0.15')

##	raise Exception

	## steps
	change_module('step',renew=True)

	create_general_static_step()
##	create_static_general_step(stepname='step1',initial_inc=0.002)
##	create_coupled_temp_displacement_step()

##	stop()

##	frequency_and_mode_shapes_step(stepname='step1')

##	stop()

	## frequence scanning
##	frequency_response_modal_dynamics_step(stepname='step2',prestep='step1',freq_range=(0,40),beta_damping=beta,alpha_damping=alpha, direct_damping=direct_damping)
##	apply_pressure(name='pressure_top',step='last', faces=top_of(lam_A1), magnitude=press_Pa)

##	stop()

	## modal dynamics
##	amp_1 = create_periodic_amplitude(name='Amp_1',freq=freq,magnitude=1)
##	tab_1 = create_tabular_amplitude(freq=freq,magnitude=1,shape='half-sin',bias='+')		;please_check
##
##	time_response_modal_dynamics_step(stepname='step2',beta_damping=beta,alpha_damping=alpha, direct_damping=direct_damping, output_freq=5, step_time=load_time)
##	_m.Gravity(name='Load_gravity', createStepName='step2', comp3=accel, amplitude=amp_1, distributionType=UNIFORM, field='')
##	apply_pressure(name='pressure_top',step='last', faces=top_of(lam_A1), magnitude=press_Pa, amplitude=tab_1)

##	time_response_modal_dynamics_step(stepname='step3',beta_damping=beta,alpha_damping=alpha, direct_damping=direct_damping, output_freq=10, step_time=release_time)
##
##	stop()

	please_check('create lam')
	if has_frame == True:
		create_std_module(cut_EVA=True,cell_nums=[3,4],frame_adhesive=pack_mat)		;please_check('full cell时边缘的cell的应力可能不准')
	else:
		if _module_type[0] == 'D':
			create_double_lam(glass_length,glass_width,glass_thick1=glass_thick1,glass_thick2=glass_thick2,adhesive_thick=EVA_thick)
		elif _module_type[:2] == 'FL':
##			create_single_lam(glass_length, glass_width, glass_thick, has_EVA_TPT=True)
			create_single_lam(glass_length, glass_width, glass_thick, has_EVA_TPT=False)
		elif _module_type == 'lumeta':
			create_single_lam(FRP_length, FRP_width, FRP_thick, mat='FRP')

		## cell
		if has_cell == True:
	##		create_cell_block(cell_nums=[3,3],cell_bot=['EVA',0.7],cell_top=['EVA',0.7],fill_gap=True)
	##		move_part(cell,x1=MIN,x2=_xmin(lam),y1=MIN,y2=_ymid(lam) + 6*(cell_length + cell_gap),z1=MIN,z2=_zmax(lam))	;please_check
	##		create_cell_block(cell_nums=[3,3],cell_top=['EVA',0.7],fill_gap=True)
			create_cell_block(cell_nums=[1,9],cell_bot=['EVA',0.7],cell_top=['EVA',0.7], fill_gap=True)

			clearance_y = (FRP_length - 18*(cell_length + cell_gap))/2
			clearance_x = (FRP_width - 9*(cell_length + cell_gap))/2
	##		move_part(lam,x1=MIN,x2=_xmin(cell) - clearance_x, y1=MIN,y2=_ymin(cell) - clearance_y,z1=MAX,z2=_zmin(cell))
			move_part(lam,x1=MIN,x2=_xmin(cell), y1=MIN,y2=_ymin(cell),z1=MAX,z2=_zmin(cell))
			new_instance(lam)

			batch_divide(lam,x=[_xmin(cell),_xmax(cell)])
			batch_divide(lam,y=[_ymin(cell),_ymax(cell)])

##	stop()

	## cut model: 1/4 model
	cut_model(x=_xmid(lam_A1),side=-1,cross2part=True)
	cut_model(y=_ymid(lam_A1),side=-1,cross2part=True)

	record_time(1,'lam')

####	## create rect base for uneven Reliathon R3
####	locx = _xmax(frL,z=MAX) + rect_offset
####	move_RP(frL,x=_xmax(frL,z=MAX) + rect_offset,z=MIN)
####	hex_grow(frL,thx=rect_thick,z=(0,-rect_H),addRP=True)
####	hex_grow(frL,x=(0,rect_width),thz=rect_thick,dz=-rect_H,addRP=True)
####	hex_grow(frL,thx=-rect_thick,dx=rect_width,z=(0,-rect_H),addRP=True)
####	move_RP(frL,gohome=True)
####
####	batch_divide(frL,x=[locx,locx + rect_thick, locx + rect_width, locx + rect_width - rect_thick])
######	divide(frL,x=_xmax(frL,z=MAX) + rect_offset/2)
####
####	cells = cell_select(frL,z=(MIN,_zmin(frL) + rect_H))
####	set_mat(frL,cells=cells,mat='Al_6063')
####
####	add2set(frL,'Frame',cells=cells)
####
######	cells = set2objs(frL,'Frame') + cells
######	create_set(frL,cells=cells, name='Frame')
####
####	## fillet
####	radius = 2.5
####	create_fillet(quarter=3,ndir='y',length=get_poi_length(frL),radius=radius)
####	new_instance(fillet,x1=MAX,x2=_xmin(frL,z=MIN),z1=MAX,z2=_zmin(frL,x=MAX),y1=MIN,y2=_ymin(frL))
####
######	create_fillet(quarter=1,ndir='y',length=get_poi_length(frL),radius=radius)
######	new_instance(fillet2,x1=MIN,x2=_xmax(frL,z=MAX),z1=MIN,z2=_zmax(frL,x=MID),y1=MIN,y2=_ymin(frL))
####
####	merge_instances('frL',insts=(frL_A1,fillet_A1),boundary='keep')
####	add2set(frL,'Frame',cells='c_fillet')
####
####	divide(frL,y=_ymax(frL) - kahuang_L)
####	bias_cut(frL,cut_side=['-x','+y'],y=MAX,x=_xmax(frL,z=MAX),angle2X=45)
######	divide(frL,z=_zmax(frL,x=MID) + radius)
####	divide(frL,z=_zmax(frL,x=MID) - base_thick - radius)
####	new_instance(frL)

##	stop()

	##
	change_module('Other_parts',renew=True)

##	raise Exception

	## rail (先建rail，再建clamp)
	if has_rail == True:
		create_std_rail(support_option='long_edge+short_rail', rail2corner=clamp2corner)
		if has_frame == True:
			divide(rail,x=_xmin(frL,z=MIN))

		create_plate('rail2',length=xlength(frS) - 50,x1=MIN,x2=_xmin(frS),y1=MID,y2=_ymax(frL) - clamp2corner, z1=MAX,z2=_zmin(frL) + 5)

##	stop()

##	## insert mounting
##	new_part('insert')
##	clearance = 0.5    ;please_check
##	insert_H = frame_height + 2*insert_thick + clearance
##	hex_grow(insert,x=(-insert_top_width,0),y=(0,500),z=(0,-insert_thick))
##	hex_grow(insert,x=(0,-insert_thick),z=(0,-insert_H))
##	hex_grow(insert,dz=-insert_H, x=(-insert_bot_width,0),z=(0,insert_thick))
##	set_mat(insert,mat='Steel')
##
##	faces = face_select(insert,z=_zmax(insert) - insert_thick)
##	create_set(insert,faces=faces,name='f_insert_top')
##
##	faces = face_select(insert,x=_xmax(insert) - insert_thick)
##	create_set(insert,faces=faces,name='f_insert_side')
##
##	faces = face_select(insert,z=_zmin(insert) + insert_thick)
##	create_set(insert,faces=faces,name='f_insert_bot')
##
##	rotate_part(insert,angle_z=90)
##	move_part(insert,x1=MIN,x2=0,y1=MAX,y2=_ymax(frS) + insert_thick, z1=MAX, z2=_zmax(frS) + insert_thick + clearance)
##	new_instance(insert)

##	stop()

####	## top and bot clamp for one axis module
####	clamp_length = globals()['clamp_length']/2   ## half model of clamp
####	clamp_depth = clamp_depth_on_frame
####	leg_gap_top = 18
####	leg_gap_bot = clamp_thick*2 + leg_gap_top
####	leg_H_top = 25
####	leg_H_bot = 35
####
####	clamp_depth_top = clamp_depth + clamp_thick
####	clamp_width_top = 2*clamp_depth_top + 2*clamp_thick + leg_gap_top
####	clamp_depth_bot = 35
####	clamp_width_bot = 2*clamp_depth_bot + 2*clamp_thick + leg_gap_bot
####	clamp_bot_hang = 15
####	base_width = clamp_width_bot - 2*clamp_bot_hang
####	base_H = 25  ## 25+40 = 65mm, Reliathon G1
####
####	new_part('clamp_top')
####	sheet_grow(clamp_top,x=(0,clamp_width_top),y=(0,clamp_length),thz=clamp_thick)
####
####	move_RP(clamp_top,dx=clamp_depth_top)
####	node_line(clamp_top,z=(0,-leg_H_top),thx=clamp_thick)
####
####	move_RP(clamp_top,dx=clamp_thick + leg_gap_top)
####	node_line(clamp_top,thx=clamp_thick,z=(0,-leg_H_top))
####
####	move_RP(clamp_top,gohome=True)
####	set_mat(clamp_top,mat='Al_6063')
####
####	faces = face_select(clamp_top,z=_zmax(clamp_top) - clamp_thick,x=(0,clamp_depth_top))
####	create_set(clamp_top,faces=faces,name='f_clamp_top')
####
####	faces = face_select(clamp_top,x=clamp_depth_top)
####	create_set(clamp_top,faces=faces,name='f_clamp_side_top')
####
####	new_instance(clamp_top)
####
####
####	## clamp_bot
####	new_part('clamp_bot')
####	sheet_grow(clamp_bot,x=(0,clamp_width_bot),thz=clamp_thick,y=(0,clamp_length))
####	node_line(clamp_bot,dx=clamp_bot_hang, thx=clamp_thick, z=(0,-base_H + clamp_thick))
####	node_line(clamp_bot,dx=clamp_width_bot - clamp_bot_hang, thx=-clamp_thick, z=(0,-base_H + clamp_thick))
####
####	move_RP(clamp_bot,dx=clamp_bot_hang, dz=-base_H + clamp_thick)
####	node_line(clamp_bot,thz=clamp_thick, x=(0,base_width))
####
####	move_RP(clamp_bot,gohome=True)
####
####	node_line(clamp_bot,dx=clamp_depth_bot,thx=clamp_thick,z=(0,leg_H_bot))
####
####	move_RP(clamp_bot,x=clamp_width_bot - clamp_depth_bot)
####	node_line(clamp_bot,thx=-clamp_thick,z=(0,leg_H_bot))
####
####	set_mat(clamp_bot,mat='Al_6063')
####
####	faces = face_select(clamp_bot,z=clamp_thick,x=(0,clamp_depth_bot))
####	create_set(clamp_bot,faces=faces,name='f_clamp_bot')
####
####	faces = face_select(clamp_bot,x=clamp_depth_bot)
####	create_set(clamp_bot,faces=faces,name='f_clamp_side_bot1')
####
####	faces = face_select(clamp_bot,x=clamp_depth_bot + clamp_thick)
####	create_set(clamp_bot,faces=faces,name='f_clamp_side_bot2')
####
####	new_instance(clamp_bot)
####
####	## assembly
####	move_part(clamp_bot,x1=clamp_depth_bot,x2=_xmax(frL),z1=clamp_thick,z2=_zmin(frL),y1=0,y2=_ymin(frL))
####	new_instance(clamp_bot)
####
####	move_part(clamp_top,x1=clamp_depth_top,x2=_xmax(frL) + clamp_thick, z1=0,z2=_zmax(frL),y1=0,y2=_ymin(frL))
####	new_instance(clamp_top)
####
####	new_part('rail')
####	sheet_grow(rail,thz=3,x=(0,150),y=(0,55),mat='Steel')	## rail width = 110mm
####	move_part(rail,z1=MAX,z2=_zmin(clamp_bot),y1=0,y2=_ymin(frL),x1=MID,x2=_xmid(clamp_bot))
####	new_instance(rail)
####
####	bias_cut(clamp_bot,x=MID,cut_side='+x')
####	bias_cut(clamp_top,x=MID,cut_side='+x')
####	bias_cut(rail,x=MID,cut_side='+x')
####
####	divide(frL,y=_ymax(clamp_top))
####	divide(rail,x=_xmin(clamp_bot,z=MIN))
####	batch_divide([clamp_bot,clamp_top,frL],y=_ymax(rail))

##	stop()

	if _module_type[0] == 'R':
		## gasket for reliathon
		gasket_thick = 2
		gasket_H = 7
		gasket_length = 200   ##???★★
		local2global(locals(),'gasket_thick','gasket_H','gasket_length')

		new_part('gasket')
		gasket_width = U_gap_big   ##???★★
		sheet_grow(gasket,thz=gasket_thick,x=(0,gasket_width),y=(0,gasket_length))
		sheet_grow(gasket,thx=gasket_thick,z=(0,gasket_H))
		sheet_grow(gasket,thx=-gasket_thick,dx=gasket_width,z=(0,gasket_H))

		set_mat(gasket,mat=Steel)

		faces = faces_of_cut(gasket,z=0)
		create_set(gasket, objs=faces, name='fm_gasket_bot')

		faces = faces_of_cut(gasket,x=0)
		create_set(gasket,objs=faces, name='fm_gasket_left')

		faces = faces_of_cut(gasket,x=gasket_width)
		create_set(gasket,objs=faces, name='fm_gasket_right')

		move_part(gasket,x1=0,x2=_xmax(frL,z=MAX),y1=gasket_length/2,y2 = _ymin(frL),z1=0,z2=_zmin(frL_A1,x=MAX) + base_thick)
		new_instance(gasket)

		bias_cut(gasket,y=KPy(frL_A1),cut_side='-y')
		divide(frL,y=_ymax(gasket_A1))

		## Reliathon VVVV
		hole2hole = 111
		create_std_rail(width=hole2hole - mhole_D, support_option=support_option,rail2corner=ylength(frL))

		loc = (_xmid(gasket_A1),hole2hole/2,_zmin(gasket))
		drill_hole([frL_A1,gasket_A1],center = loc,ndir='z',D=mhole_D)
		circular_divide(gasket,ndir='z',center=loc,D=mhole_D + 8)

		edges = set2objs(gasket,'e_hole_1')
		faces = faces_of_edges(edges=edges,ndir='z',nz=1)
		create_set(gasket,faces=faces,name='f_gasket_cover')

	##	if has_mount_bolt == True:
	##		create_T_bolt(D1=bolt_pin_D, D0=16)
	##		move_part(bolt,x1=0,x2=_xmid(gasket_A1), y1=0, y2=hole2hole/2, z1=0, z2=_zmin(gasket) + gasket_thick)
	##		divide(bolt,z=_zmin(gasket))
	##		divide(bolt,z=_zmin(frL))
	##		new_instance(bolt)

	##		## Reliathon ^^^^^

##	stop()

	please_check('1. create parts')
	## create clamp
	if has_mount_clamp == True:
		if has_frame == True:
			if clamp_shape == 'Z':
				create_Z_clamp(thick=clamp_thick,clamp_depth=10, length=clamp_length, mat='Al_6063', global_var=True)				;please_check('clamp薄些可能允许clamp较大变形')
			elif clamp_shape == 'T':
				create_T_clamp(thick=clamp_thick,clamp_depth=10, length=clamp_length,height=30, mat='Al_6063', global_var=True)	;please_check

		else:
			create_C_clamp_with_rubber(clamp_length=clamp_length, clamp_thick=4, rubber_thick=2, clamp_depth=12, mouth_height=lam_thick, rubber_mat='Rubber2')	;please_check

		if rail_dir == 'y':
			rotate_part(clamp,angle_z=90)

		move_clamp(clamp,clamp2corner=clamp2corner, support_option=support_option)
		divide_part_in_clamp(clamp,clamp_edge='long')	;please_check

	record_time(1,'parts')

####	## screw type clamp
####	pin_D = 16
####	cap_D = 40
####	## 对应M=36
####
######	create_T_bolt(D1=bolt_pin_D, D0=2*(bolt_pin_D/2 + 1 + 11),L=25, cap_thick=5)
####	create_T_bolt(D1=pin_D, D0=cap_D,L=25, cap_thick=5)
####	move_part(bolt,x1=_xmin(bolt,z=MIN),x2=_xmax(frL) + 1,y1=0,y2=_ymax(frL) - clamp2corner,z1=0,z2=_zmax(frL))
####	new_instance(bolt)
####	bias_cut(bolt,x=MID,cut_side='+x')

##	## hole mounting
##	hole_x = _xmax(frL) - legs_span - bot_flange_hange/2
##	hole_y = _ymax(frL) - clamp2corner
##
##	drill_hole(frL,x=hole_x,y=hole_y,D=mhole_D)
##	drill_hole(rail,x=hole_x,y=hole_y,D=mhole_D)
##
##	create_T_bolt(D1=bolt_pin_D, D0=16)
##	move_part(bolt,x1=0,x2=hole_x, y1=0, y2=hole_y, z1=0, z2=_zmin(frL) + base_thick)
##	new_instance(bolt)
##
##	## divide
##	divide(bolt,z=_zmin(frL))
##	divide(bolt,z=_zmin(rail))
##	batch_divide([rail,frL],y=hole_y)
####	circular_divide(frL,x=hole_x,y=hole_y,D=16)
####	circular_divide(rail,x=hole_x,y=hole_y,D=16)
##
##	divide(frL,x=hole_x)
####
####	batch_divide(frL,y=(hole_y + 15, hole_y - 15))
##### ^^^^^

##	stop()

	## contacts
	change_module('Interaction',renew=True)
	collect_space_of_curved_faces('stud','hole')		;please_check

##	batch_divide(lam,y=[_ymin(rail_A1) - 5, _ymax(rail_A1) + 5])
##	faces_glass = faces_of_cut(lam_A1,z=_zmin(lam_A1,x=MID,y=MID))
##	faces_rail = face_select(rail_A1,faces=top_of(rail_A1),x=(MIN,_xmax(lam)))
##	s2s_interact(mfaces=faces_glass,sfaces=faces_rail,force_create=True)

##	stop()  ## 1.0mins (CA_39Reliathon)

	## screw type clamp
####	if load_side == 'top':
####		s2s_interact(mfaces='fm_bolt_cover',slave_inst=frL_A1,prop='Frictionless')
####	elif load_side == 'bot':
####		s2s_interact(mfaces='fm_bolt_cover',slave_inst=frL_A1,prop='Friction')
####	s2s_interact(mfaces='fm_bolt_pin',sfaces=right_of(frL_A1),force_create=True)

###	## insert type clamp
###	s2s_interact(mfaces='f_insert_top',slave_inst=frS_A1,force_create=True)
###	s2s_interact(mfaces='f_insert_side',slave_inst=frS_A1)
###	s2s_interact(mfaces='f_insert_bot',slave_inst=frS_A1)
###
###	s2s_interact(mfaces='f_insert_top',slave_inst=frL_A1,force_create=True)
###	s2s_interact(mfaces='f_insert_bot',slave_inst=frL_A1)

##	stop()

	if has_frame == True:
		create_contacts()		;please_check('module + 标准clamp + 标准rail')
	else:
		please_check
		find_contacts(action='interact',sfaces='f_clamp_inner_top',master_insts=lam_A1,prop='Friction')
		find_contacts(action='interact',sfaces='f_clamp_inner_bot',master_insts=lam_A1,prop='Friction')
	##	find_contacts(action='tie', slave_parts=['clamp', 'clamp2'],master_parts=['bot_clamp', 'bot_clamp2'], prop='Friction')

##		if 'long_rail' in support_option and antype != 'modal':
		find_contacts(action='interact',master_parts=['rail','rail2'],sfaces=bot_of(lam_A1), force_create=True, refined_insts='both', prop='Friction')

##	stop()


##	s2s_interact(mfaces='f_clamp_top',slave_inst=frL_A1)
##	s2s_interact(mfaces='f_clamp_side_top',sfaces='f_clamp_side_bot2')
##	s2s_interact(mfaces='f_clamp_side_bot1',slave_inst=frL_A1)
##	s2s_interact(mfaces='f_clamp_bot',slave_inst=frL_A1)

##	globals()['debug'] = True
##	s2s_interact(insts=(clamp_top_A1,frL_A1),z=_zmax(frL_A1))
##	s2s_interact(insts=(clamp_top_A1,clamp_bot_A1),x=_xmin(clamp_top) + clamp_depth_top)
##	s2s_interact(insts=(clamp_bot_A1,frL_A1),x=_xmax(frL))
##	s2s_interact(insts=(clamp_bot_A1,frL_A1),z=_zmin(frL))

####	s2s_interact(parts=(clamp_top,frL),z=_zmax(frL),prop='Friction')
####	s2s_interact(parts=(clamp_top,clamp_bot),x=_xmin(clamp_top) + clamp_depth_top)
####	s2s_interact(parts=(clamp_bot,frL),x=_xmax(frL))
####	s2s_interact(parts=(clamp_bot,frL),z=_zmin(frL))
####	s2s_interact(parts=(rail,clamp_bot),z=_zmax(rail))

##	stop()

	## rail2frame contact
##	if clamp2corner < 330:
##		line_locy = _ymin(rail_A1)
##	else:
##		line_locy = _ymax(rail_A1)
##
##	if _module_type == 'W35' and clamp2corner <= 200:
##		edges = edge_select(rail_A1,z=MAX,y=line_locy,edir='x')
##		faces = face_select(frL_A1,z=MIN,y=(line_locy - 1,line_locy + 1))
##		line2surface_tie(edges=edges,faces=faces)
##	elif _module_type == 'V40' and clamp2corner <= 300:
##		edges = edge_select(rail_A1,z=MAX,y=line_locy,edir='x')
##		faces = face_select(frL_A1,z=MIN,y=(line_locy - 1,line_locy + 1))
##		line2surface_tie(edges=edges,faces=faces)

##	stop()

##	stop()
	## Reliathon
##	find_contacts(action='interact',master_parts=gasket,mate_parts=frL)
##	find_contacts(action='interact',master_parts=rail,mate_parts=frL)

	## Reliathon
##	if has_mount_bolt == True:
##		faces = set2objs(gasket_A1,'f_gasket_cover')
##		faces = face_select(gasket_A1,faces=faces,z=_zmin(gasket) + gasket_thick)
##		s2s_interact(mfaces='fm_bolt_cover',sfaces=faces,fix='both')
##
##		pin_faces = set2objs(bolt_A1,'fm_bolt_pin')
##
##		mfaces = face_select(gasket_A1,faces=pin_faces,z=(_zmin(gasket), _zmin(gasket) + gasket_thick))
##		s2s_interact(mfaces=mfaces,sfaces='f_gasket_hole_1',fix='both')
##
##		mfaces = face_select(gasket_A1,faces=pin_faces,z=(_zmin(frL), _zmin(frL) + base_thick))
##		s2s_interact(mfaces=mfaces, sfaces='f_frL_hole_1',fix='both')
##
##		mfaces = face_select(gasket_A1,faces=pin_faces,z=(_zmin(rail),MIN))
##		sfaces = face_select(rail_A1,y=MAX,x=(_xmin(gasket),MAX))
##		s2s_interact(mfaces=mfaces,sfaces=sfaces,fix='both')

##	if has_frame == True and has_rail == True:
##		railedge2frame_contact(edge_contact,rail_inst=rail_A1,frame_inst=frL_A1,y=MIN,z=MAX)

	if mount_method == 'hole' and has_mount_bolt == True:
		## bolt contacts
		faces = faces_of_cut(frL_A1,z=_zmin(frL) + base_thick,y=_yspace(rail))
		s2s_interact(mfaces='fm_bolt_cover',sfaces=faces,fix='m')

		s2s_interact(mfaces=top_of(rail_A1),sfaces=bot_of(frL_A1))

		pin_faces = set2objs(bolt_A1,'fm_bolt_pin')

		mfaces = face_select(bolt_A1,faces=pin_faces,z=(_zmin(frL),_zmin(frL) + base_thick))
		s2s_interact(mfaces=mfaces,sfaces='f_frL_hole_2',fix='both')

		mfaces = face_select(bolt_A1,faces=pin_faces,z=_zspace(rail))
		s2s_interact(mfaces=mfaces,sfaces='f_rail_hole_1',fix='both')

	record_time(2,'contact')

##	stop()

	## load
	apply_gravity(step='step1')
	apply_pressure_on_lam()
	if load_on_frame == True and has_frame == True:
		apply_pressure_on_frame()

	##BC
	faces = faces_of_insts(x=_xmin(lam_A1))
	apply_disp_symm('x',faces=faces)

	faces = faces_of_insts(y=_ymin(lam_A1))
	apply_disp_symm('y',faces=faces)

####	apply_disp_symm('x',faces=right_of(bolt_A1))

##	face=clamp_top_A1.faces.findAt((_xmax(clamp_top) - 0.1, _ymin(clamp_top) + 0.1, _zmax(clamp_top)))
##	apply_disp_fix(faces=face,name='fix_clamp_top',Uz=0)

###	if load_side == 'bot':
###		faces = face_select(clamp_top_A1,z=MIN,ndir='z',y=_ymin(frL) + 0.1)
###		apply_disp_fix(faces=faces,name='fix_clamp_top2',Uz=0)

	if has_rail == True:
		faces = faces_of_insts(find_mdb_insts('rail'),z=MIN)
		apply_disp_fix(faces=faces,name='fix_rail_bot')

	if has_mount_clamp == True:
		apply_clamp_fix(clamp_edge='long',clamp_fix_area=clamp_fix_area)

		if has_frame == True and bload > 0:
			divide(clamp,z=_zmid(clamp))
			faces = faces_of_insts(find_mdb_insts('clamp'),z=MID,exterior=False)

			apply_boltload('boltload',faces=faces,force=bload,step='step1')

		else:
			print this_and_caller(),'★★has_frame=',has_frame,', bload=',bload
			print 'No bolt load was applied.'

	if has_mount_bolt == True:
		faces = faces_of_insts(find_mdb_insts('bolt'),z=MIN)
		apply_disp_fix(faces=faces,name='fix_bolt_bot')

		if bload > 0:
			faces = face_select('bolt_A1',z=_zmin(frL),exterior=False)
			apply_boltload('boltload1',faces=faces,force=bload,step='step1')

			faces =face_select('bolt_A2',z=_zmin(frL),exterior=False)
			apply_boltload('boltload2',faces=faces,force=bload,step='step1')

	if has_mount_insert == True:
		faces = faces_of_insts(find_mdb_insts('insert'),z=MIN)
		apply_disp_fix(faces=faces,name='fix_insert_bot')

	if _module_type[0] == 'R':
		##	faces = faces_of_insts([gasket_A1,frL_A1],radius=mhole_D/2)
		##	apply_disp_fix(objs=faces,name='fix_hole',Ux=0,Uy=0,UR3=0)   ##???★★

		if has_mount_bolt == True:
			apply_disp_fix(faces = top_of(bolt_A1) + bot_of(bolt_A1), name='fix_bolt',Uz=0,Uy=0,Ux=0)
		else:
			apply_disp_fix(faces=set2objs(gasket_A1,'f_gasket_cover'),name='fix_gasket_cover',Uz=0,Ux=0)

		if load_side == 'top':
			faces = faces_of_cut(frL_A1,x=MAX)
			apply_disp_fix(faces=faces,name='fix_frL_right',Ux=0)

	record_time(2.3,'load')

##	stop()

	change_module('Mesh')

	if has_frame == False:  ## Diamond, Frameless module
		## meshing
		## lam
		seed_edge(lam,z=_zmax(lam) - 0.1)
		if 'Glass2' in lam.sets.keys():
			seed_edge(lam,z=_zmin(lam) + 0.1)

		edge_esize = 3
		edges = edge_select(lam,x=(_xmax(lam), _xmax(lam) - clamp_depth), edir='x')
		seed_edges(lam,edges=edges,esize=edge_esize)		;please_check

##		seed_edge(lam,y=_ymid(clamp),esize=clamp_esize, fixed=True)
		edges = edge_select(lam,y=_yspace(clamp),edir='y')
		seed_edges(lam,edges=edges,esize=clamp_esize,fixed=True)

		if beam_num == 3:
##			seed_edge(lam,y=_ymid(clamp2),esize=clamp_esize)
			edges = edge_select(lam,y=_yspace(clamp2),edir='y')
			seed_edges(lam,edges=edges,esize=clamp_esize)

		mesh_part(lam)

		if has_mount_clamp == True:
			## clamp
			seed_edges_of_faces(front_of(clamp),enum_short=2,esize_long=3)
			mesh_part(clamp,esize=clamp_esize)

			if beam_num == 3:
				seed_edges_of_faces(front_of(clamp2),enum_short=2,esize_long=3)
				mesh_part(clamp2,esize=clamp_esize)

		## rail
		if has_rail == True:
			seed_edges_of_faces(right_of(rail),enum_short=2,esize_long=clamp_esize)
			mesh_part(rail,esize=1.5*lam_esize)		;please_check

			if beam_num == 3:
				seed_edges_of_faces(right_of(rail2),enum_short=2,esize_long=clamp_esize)
				mesh_part(rail2,esize=1.5*lam_esize)

	elif has_frame == True:
		## Frame
		if _module_type[0] == 'R':
			## Reliathon
			edges = edges_of_cut(frL,y=_ymax(gasket),edir='x')
			seed_edges(frL,edges=edges,esize=frame_H_esize)

			seed_circle_edges(frL,edges='e_fillet_circle',quarter_seed=3)

		mesh_frame(frL)

##		stop()

		if frL != frS:
			mesh_frame(frS)

		if pack_mat == 'Tape' and tape_type == 'cohesive':
			mesh_cohesive(Tape)

##		stop()
		## lam
		mesh_lam(glass_enum=glass_enum, glass_edge_esize=lip_esize)	;please_check

##		raise Exception

		## rail
		if has_rail == True:
			seed_circle_edges(rail,quarter_seed=4)

			if rail_dir == 'x':
				seed_edges_of_faces(front_of(rail),enum_short=2,esize_long=3)
			elif rail_dir == 'y':
				seed_edges_of_faces(left_of(rail),enum_short=2,esize_long=3)

			mesh_part(rail,esize=clamp_esize)		;please_check

			## rail2
			if 'rail2' in _m.parts.keys():
				if rail_dir == 'x':
					seed_edges_of_faces(right_of(rail2),enum_short=2,esize_long=clamp_esize)
				elif rail_dir == 'y':
					seed_edges_of_faces(front_of(rail2),enum_short=2,esize_long=clamp_esize)

				mesh_part(rail2,esize=lam_esize)		;please_check

		if _module_type[0] == 'R':
			## gasket
			edges = short_edges_of_faces(gasket,y=MIN)
			seed_edges(gasket,edges=edges,enum=2)

			seed_circle_edges(gasket)

			edges = edges_of_cut(gasket,z=_zmax(gasket) - 0.1, edir='z')
			seed_edges(gasket,edges=edges, enum=3)

			mesh_part(gasket,esize=3)

		## bolt
		if has_mount_bolt == True:
			seed_circle_edges(bolt,quarter_seed=4)
			mesh_part(bolt,esize=2)

		if has_mount_insert == True:
			seed_edges_of_faces(left_of(insert),enum_short=2,esize_long=frame_H_esize)
			mesh_part(insert,esize=lam_esize)

		## clamp
		if has_mount_clamp == True:
			if clamp_shape == 'Z':
				seed_circle_edges(clamp,quarter_seed=4)

			if support_option.startswith('long_edge'):
				seed_edges_of_faces(front_of(clamp),enum_short=2,esize_long=frame_H_esize)
			elif support_option.startswith('short_edge'):
				seed_edges_of_faces(left_of(clamp),enum_short=2,esize_long=frame_H_esize)

			mesh_part(clamp,esize=clamp_esize)

###		seed_edges_of_faces(front_of(clamp_top),enum_short=2,esize_long=2)
###		mesh_part(clamp_top,esize=clamp_esize)
###
###		seed_edges_of_faces(front_of(clamp_bot),enum_short=2,esize_long=2)
###		mesh_part(clamp_bot,esize=clamp_esize)

	record_time(3,'mesh')

##	stop()

	return


function_labels['main_wangyf_tianhe_frameless'] = 'PV','module','optimization','lamination','glass','pad','silicone'
def main_wangyf_tianhe_frameless():
	## VER: 2016-10-24, v1.0

	check_script_file('GE_wangyf_frameless_glass_thick35.py')
	purpose = 'optimization of mounting pads.'
	history='G3:optimized model; E1: model'

	locals0 = locals().keys()

	glass_thick = 3.5	;changing ## 2.5
	glass_length = 1658
	glass_width = 992
	EVA_thick = 0.9		;please_check

	pad_length = 220	;changing	## 150, good=220
	pad_width = 30		;changing1	## 30
	pad_thick = 15		;please_check
	silicone_thick = 5	;changing	## 3, good=5

	pad2long = 196		;changing1 	## 196, good=230
	pad2short = 380		;changing	## 349, good=380

	angle = 25
	pressure = 3800		;changing1
	antype = 'stress'	;changing1

	locals2globals(locals0,locals(),save_var=True)

	## PPA
	lam = blank_part('lam')
	create_block(lam,x=glass_width,y=glass_length,z=glass_thick*2 + EVA_thick)
	divide(lam,z=glass_thick)
	divide(lam,z=glass_thick + EVA_thick)

	cells = cell_select(lam,z=MID)
	set_mat(lam,cells=cells, mat='EVA2')

	cells = unselect(lam,cells)
	set_mat(lam,cells=cells, mat='Glass')

	pad = blank_part('pad')
	create_block(pad,x=pad_width,y=pad_length,z=pad_thick + silicone_thick)
	divide(pad,z=pad_thick)

	cells = cell_select(pad,z=MAX1)
	set_mat(pad,cells=cells,mat='Silic2')	;changing	## hyperelastic
##	set_mat(pad,cells=cells,mat='Silic')	;changing

	cells = unselect(pad,cells)
	set_mat(pad,cells=cells,mat='Steel')

	## assembly
	new_instance(lam)

	move_part(pad,z1=MAX,z2=_zmin(lam))
	move_part(pad,x1=MID,x2=pad2long,y1=MID,y2=pad2short)
	new_instance(pad,name='pad1')
	new_instance(pad,name='pad2',x1=MID,x2=glass_width - pad2long)
	new_instance(pad,name='pad3',y1=MID,y2=glass_length - pad2short)
	new_instance(pad,name='pad4',x1=MID,x2=glass_width - pad2long, y1=MID,y2=glass_length - pad2short)

	pad1,pad2,pad3,pad4 = 'pad1','pad2','pad3','pad4'
	batch_divide(lam,x=(_xmin(pad1),_xmax(pad1), _xmin(pad4), _xmax(pad4)))
	batch_divide(lam,y=(_ymin(pad1),_ymax(pad1),_ymin(pad4),_ymax(pad4)))

	create_surface('pad1_top',faces=face_select(pad1,z=MAX))
	create_surface('pad2_top',faces=face_select(pad2,z=MAX))
	create_surface('pad3_top',faces=face_select(pad3,z=MAX))
	create_surface('pad4_top',faces=face_select(pad4,z=MAX))

	faces = faces_of_insts(parts=('pad'),z=_zmin('pad'))
	create_surface('pad_bot',faces=faces)

	freq = 1
	amp_1 = create_periodic_amplitude(name='Amp_1',freq=freq,magnitude=pressure/1e6)	;changing
	tab_1 = create_tabular_amplitude(freq=freq,magnitude=pressure/1e6,shape='half-sin',bias='+')		;please_check

	## SMIL
	## analysis1
	create_general_static_step()

	faces = face_select('lam_A1',z=MAX)
	apply_pressure('pressure',faces=faces,Pa=3800,step='last')
	apply_gravity(Gy=-9800,step='last')


	## analysis2
##	frequency_and_mode_shapes_step()
##	time_response_modal_dynamics_step(stepname='step2',beta_damping=0,alpha_damping=0, direct_damping=0.02, step_time=2)	;changing
##
##	faces = face_select('lam_A1',z=MAX)
##	apply_pressure('pressure',faces=faces,Pa=3800,step='last',amplitude=tab_1)
##	apply_gravity(Gy=-9800,step='last')

##	raise Exception

##	time_response_modal_dynamics_step(stepname='step3',beta_damping=0,alpha_damping=0, direct_damping=0.02, step_time=1)	;changing

	## analysis3
##	frequency_and_mode_shapes_step()
##	frequency_response_modal_dynamics_step(freq_range=(0,30),direct_damping=0.02)

##	raise Exception

	## mesh
	edges = edge_select('lam',x=_xmid('pad1'))
	seed_edges('lam',enum=5,edges=edges)

	edges = edge_select('lam',x=_xmid('pad4'))
	seed_edges('lam',enum=5,edges=edges)

	edges = edge_select('lam',y=_ymid('pad1'))
	seed_edges('lam',enum=10,edges=edges)

	edges = edge_select('lam',y=_ymid('pad4'))
	seed_edges('lam',enum=10,edges=edges)

	edges = edge_select('lam',edir='z')
	seed_edges('lam',edges=edges,enum=2)

	mesh_part('lam',esize=20)

	## pad
	edges = edge_select('pad',x=MID)
	seed_edges('pad',edges=edges,enum=5)

	edges = edge_select('pad',y=MID)
	seed_edges('pad',edges=edges,enum=10)

	edges = edge_select('pad',z=MAX1)
	seed_edges('pad',edges=edges,enum=3)

	edges = edge_select('pad',z=MIN1)
	seed_edges('pad',edges=edges,enum=3)

	mesh_part('pad')

	nodes = node_select('lam_A1',z=MAX,x=MID,y=MID,err=10)
	globals()['center_node'] = nodes[0].label

##	raise Exception

##	n1 = a.instances['lam_A1'].nodes
##	nodes1 = n1[18467:18468]
##	a.Set(nodes=nodes1, name='center')
##
##	mdb.models['Model-1'].HistoryOutputRequest(name='center',
##	    createStepName='step2', variables=('GU', ))
##	regionDef=mdb.models['Model-1'].rootAssembly.sets['center']
##	mdb.models['Model-1'].historyOutputRequests['center'].setValues(variables=(
##	    'GU', ), region=regionDef, sectionPoints=DEFAULT, rebar=EXCLUDE)

##	raise Exception

	find_contacts(action='tie',master_parts='lam',slave_parts='pad')
##	find_contacts(action='interact',master_parts='lam')
##	find_contacts(action='tie',slave_parts='pad')

	faces = faces_of_insts(z=_zmin('pad1'))
	apply_disp_fix('bot_fix',faces=faces,fix_all=True)

##	if type_of(_m.steps.values()[-1]) != 'FrequencyStep':
##		faces = face_select('lam_A1',z=MAX)
##		apply_pressure('pressure',faces=faces,Pa=3800,step='last')
##
##		apply_gravity(Gy=-9800,step='last')

	rotate_instances(angle_x=angle-90)

	create_job()
	submit()

	res = ('VARS','pressure','glass_thick', 'pad_length','pad_width','pad2short','pad2long','silicone_thick'), ('LAM_A1','U','S1'), ('mat_silic2','Mises','S1')
	save_res(res)


	return

def main_A0270_can_tooling():
	## VER: 2016-09-21, v1.0  PPA-SMIL

	check_script_file('DC_A0270_can_tooling_152_152_Nib103.py')

	purpose = 'Parallelism and flatness of surfaces.'
	history='D6:big size; D2: update the interference; A3: shrink-fit at RT; A1: model'

	locals0 = locals().keys()   ## need both stp file and assembly file with bearing dimensions.

	## design = 'spigot'
	design = 'flat'
	if design == 'spigot':
		pocket_D0 = 70.4
		pocket_D2 = 127		;changing	## 127
		pocket_D3 = 146.05
		pocket_D4 = 177.8	;changing	## 177.8
		pocket_OD = pocket_D4
		spigot = pocket_D2

		pocket_thick = 22.5
		pocket_H1 = 9.91
		pocket_H2 = pocket_thick - 5.563
		pocket_H3 = pocket_thick
		pocket_exit_angle = 8

		inter_bot = 0.075	;changing  	## 0.06
		inter_top = 0.162	;changing	## 0.15, 0.165

	else:	## flat
		pocket_D0 = 70.4
		pocket_D2 = 152.4		;changing	## 127
	##	pocket_D3 = 146.05
		pocket_D4 = 152.4	;changing	## 177.8
		pocket_OD = pocket_D4
		spigot = pocket_D2

		pocket_thick = 19.05	## 22.5 for spigot
		pocket_H1 = 19.05	## 9.91 for spigot
	##	pocket_H2 = pocket_thick - 5.563
		pocket_H3 = pocket_thick
		pocket_exit_angle = 8

	inter_bot = 0.115	;changing  	## 0.06
	inter_top = 0.215	;changing	## 0.15, 0.165

##	screw_D = 136.5
##	screw_hole_D1 = 5.6  ## 4x
##	screw_hole_D2 = 1.6  ## 8x

	support_D1 = 80
	support_D2 = 180
	support_H = 10

	carbide_thick = 9.5
	carbide_D0 = 66.3
	carbide_D1 = 77	;changing	## 103,77
	Nib_OD = carbide_D1
	carbide_exit_angle = 8
	carbide_chamfer = 0.8
	carbide_entrance_R = 2.005
##	interference = 0.1		;changing
##	carbide_D1 = pocket_D1 + 2*interference
	carbide_bear_length = 1.52
	chamfer_start = carbide_thick - 3.525

	pocket_D1_bot = carbide_D1 - 2*inter_bot
	pocket_D1_top = carbide_D1 - 2*inter_top

	height_offset = 0.15
	seat_H = pocket_thick - carbide_thick + height_offset

	force = 20000	;changing

	carbide = 'carbide'
	pocket = 'pocket'
	support = 'support'
	carbide_mat = 'H3F'		;changing   ## H3F, C9M

	inps = '2'		;changing ## 1,2,12
	inp1_file_title = inp_file_title
	inp2_file_title = inp_file_title + '_press'

	locals2globals(locals0,locals(),save_var=True)


	if '1' in inps:
		## carbide
		s1 = create_base_sketch('sb_nib')
		loc0 = (carbide_D0/2,carbide_thick)

		set_point0(loc0)
		add_points(('x',carbide_D1/2),('y',0),('x',carbide_D0/2 + chamfer_start*tanD(carbide_exit_angle)),(carbide_D0/2,chamfer_start),loc0)
		poly_line(s1)

	##	connect_points(s1,loc0,('x',carbide_D1/2),('y',0),('x',carbide_D0/2 + chamfer_start*tanD(carbide_exit_angle)),(carbide_D0/2,chamfer_start),loc0)
		round_sketch_corner(s1,loc=loc0,radius=carbide_entrance_R)
		carbide = revolve_sketch_to_part('carbide',s1,angle=360)

		## pocket
		s1 = create_base_sketch('sb_pocket')
		loc0 = (pocket_D0/2,seat_H)

		set_point0(loc0)

		if design == 'spigot':
			loc1 = add_points(('x',pocket_D1_bot/2),(pocket_D1_top/2,pocket_thick),('x',pocket_D2/2 - 2.54),xytilt4(dy=2.54,Ay=45),('y',pocket_H2),
				('x',pocket_D3/2),('y',pocket_H1),('x',pocket_D4/2),('y',0))
		else:
			loc1 = add_points(('x',pocket_D1_bot/2),(pocket_D1_top/2,pocket_thick),('x',pocket_D4/2),('y',0))

		reverse_points()
		add_points(xytilt4(y=0,Ay=pocket_exit_angle),loc1)
		poly_line(s1)
		pocket = revolve_sketch_to_part('pocket',s1,angle=360)

		move_part(carbide,y1=0,y2=seat_H)

	##	raise Exception

		## support
		cylinder_grow('support',ndir='y',ID=support_D1,OD=support_D2,L=support_H)
		move_part('support',y1=MAX,y2=_ymin('pocket'))
		new_instance('support')

		set_mat(carbide,mat=carbide_mat)		;changing  ## H3F, C9M
		set_mat(pocket,mat='Steel_H13')
		set_mat('support',mat='Steel_H13')

		new_instance(carbide)
		new_instance(pocket)

		cut_instances(x=0,side='-')
		cut_instances(z=0,side='+')

		del_insts('support_A1')

		## SMIL
		create_general_static_step()   ## Heating
		if 'support_A1' in a.instances.keys():
			create_general_static_step()   ## Cooling

		## mesh
		mesh_part('carbide',esize=2)  ## 1
		mesh_part('pocket',esize=2)
		mesh_part('support',esize=3)

		## 侧面
		mfaces = face_select('carbide_A1',diameter=carbide_D1)

	##	check1()
		edges = edge_select('pocket_A1',D=pocket_D1_top)
		faces = edges_to_faces(edges)
		sfaces = face_select('pocket_A1',faces=faces,ndir='cylind or conical')
	##	if inter_bot != inter_top:
	##		sfaces = face_select('pocket_A1',faces=faces,ndir='conical')
	##	else:
	##		sfaces = face_select('pocket_A1',faces=faces,ndir='cylindrical')
		s2s_interact_std(mfaces=mfaces,sfaces=sfaces,interference='shrink_fit',friction=0.1)

		## 底面
		faces1 = face_select('carbide_A1',y=MIN)
		faces2 = mate_faces_in_inst('pocket_A1',faces=faces1)
		s2s_interact_std(mfaces=faces1,sfaces=faces2,friction=0)

		if 'support_A1' in a.instances.keys():
			faces1 = face_select('pocket_A1',y=MIN)
			faces2 = face_select('support_A1',y=MAX)
			s2s_interact_std(mfaces=faces2,sfaces=faces1,friction=0,step='step1',surface2surface=True)	;changing   ## 111

		apply_gravity(Gy=-9800)

		## load
		apply_disp_symm('xsym',faces=faces_of_insts(x=0))
		apply_disp_symm('zsym',faces=faces_of_insts(z=0))

		## pocket edge
	##	edges = edge_select('pocket_A1',y=MIN,diameter='inner')	;changing
		edges = edge_select('pocket_A1',y=MIN,diameter='outer')
		apply_disp_fix('yfix',edges=edges,Uy=0,deactive_step='step2')

		faces = face_select('pocket_A1',y=MIN)
		create_surface('pocket_bot',faces=faces)

		faces = face_select('carbide_A1',y=MAX)
		create_surface('carbide_top',faces=faces)

		if 'support_A1' in a.instances.keys():
			## pocket surface
			if design == 'spigot':
				faces = face_select('pocket_A1',D=pocket_D3)	;changing
			else:
				faces = face_select('pocket_A1',D=pocket_D4)
		##	faces = face_select('pocket_A1',D=pocket_D4)	;changing
			apply_disp_fix('pocket fix',faces=faces,Ux=0,Uz=0,step='step2')

			faces = face_select('support_A1',y=MIN)
			apply_disp_fix('support_fix',faces=faces,fix_all=True)

			faces = face_select('carbide_A1',y=MAX)
			area = get_area(faces)
			pressure = force/4/area
			apply_pressure('pressure',faces=faces,MPa=pressure,step='step2')

	##	set_temperature_predefined_field(initial_step=20,modifys=[('step1',500),('step2',20)])   ## shrink-fit at 500degC for 2hr
		create_job()
		submit()

	if inps == '1-2':
		wait()

	if '2' in inps:
		save_as(inp2_file_title)
		create_new_model()
		import_part_from_odb(inp1_file_title,inst_name='POCKET_A1',part_name = 'pocket')
		import_part_from_odb(inp1_file_title,inst_name='CARBIDE_A1',part_name='carbide')
		carbide = 'carbide'
		pocket = 'pocket'

		## support
		cylinder_grow('support',ndir='y',ID=support_D1,OD=support_D2,L=support_H)
		move_part('support',y1=MAX,y2=_ymin('pocket'))
		new_instance('support')

		cut_instances(x=0,side='-')
		cut_instances(z=0,side='+')

		new_instance('carbide')
		new_instance('pocket')

##		raise Exception

		set_mat(carbide,mat=carbide_mat)		;changing  ## H3F, C9M
		set_mat(pocket,mat='Steel_H13')
		set_mat('support',mat='Steel_H13')

		create_general_static_step()   ## Heating

		mesh_part('support',esize=3)

##		nodes = node_select('odb_carbide_A1',y=MAX)
##		carbide_top = create_surface(nodes=nodes,name='carbide_top')

		faces = element_face_select('carbide_A1',y=MAX,ny=1)
		carbide_top = element_faces_to_surface(faces=faces,name='carbide_top')

		faces = element_face_select('pocket_A1',y=MIN,ny=-1)
		pocket_bot = element_faces_to_surface(faces=faces,name='pocket_bot')

		create_general_contact_std()

		## loads and BC
		nodes = nodes_by_face('pocket_A1',nx=1)
		apply_disp_fix('fix_pocket',nodes=nodes,Ux=0,Uz=0)

		faces = face_select('support_A1',y=MIN)
		apply_disp_fix('fix_support',faces=faces,fix_all=True)

		apply_pressure('pressure',surface=carbide_top,MPa=26)

##		raise Exception
		open_odb(inp1_file_title)
		step1,increment1 = get_last_step_frame_number()
##		print fnln(),'increment1=',increment1
##		raise Exception

##		region = a.instances['carbide_A1'].sets['MAT_H3F']
		mdb.models['Model-1'].Stress(name='Predefined Field-1', distributionType=FROM_FILE,
		    fileName='D:/FEM/glass/D9_A0270_can_tooling_152_152_Nib103.odb', step=step1, increment=increment1)

##   		region = a.instances['pocket_A1'].sets['MAT_STEEL_H13']
##		mdb.models['Model-1'].Stress(name='Predefined Field-1', distributionType=FROM_FILE,
##		    fileName='D:/FEM/glass/D8_A0270_can_tooling_152_152_Nib103.odb', step=step1, increment=increment1)

##		import_initial_state(inp1_file_title,insts=['pocket_A1','carbide_A1'])

		create_job(inp2_file_title)
		submit()

	res = ('VARS', 'Nib_OD','spigot', 'pocket_OD', 'inter_bot','inter_top','force','carbide_mat'),('pocket_bot','U2'),('carbide_top','U2'),('pocket_A1','S1')
	save_res(res)

	return

def main_A0279_N926_triangle_insert_powder_compaction():
	## VER: 2017-02-13, v1.0

	check_script_file('A2_A0279_N926_land_sintering.py')
	history = ''

	blank_cae(inp_file_title)

	locals0 = locals().keys()

	analysis1_title = inp_file_title	;changing1
	tangent_D = 11.669
	tangent_R = tangent_D/2
	H = round(tangent_D/2*3,6)
	length = round(tangent_D*ctanD(30),6)
	round_R = 0.368

	locals2globals(locals0,locals(),save_var=True)

	material_database()
	create_contact_props(friction=0.2)					;please_check('default=0.15')

	## Die
	s1 = create_base_sketch('sk_die')

	loc1 = (-2*tangent_R,0)
	loc2 = (tangent_R,length/2)
	loc3 = (tangent_R,-length/2)

	connect_points(s1,loc1,loc2,loc3,loc1)
	round_sketch_corner(s1,loc=loc1,radius=round_R)
	round_sketch_corner(s1,loc=loc2,radius=round_R)
	round_sketch_corner(s1,loc=loc3,radius=round_R)

	return

def mesh_insert(esize):

	dpo = get_dpo()
	if type_of(dpo) != 'PART':
		raise Exception('*** Part display is required.')

	partname = dpo.name
	mesh_part(partname,esize=esize,antype='stress',solver='explicit')
##	p = mdb.models['Model-1'].parts[partname]
##	p.seedPart(size=2.0, deviationFactor=0.1)
##	##    f = p.faces
##	##    p.setMeshControls(regions=f, elemShape=QUAD, algorithm=MEDIAL_AXIS)
##	p.generateMesh()

	vpnow = get_vpnow()
	vpnow.partDisplay.setValues(mesh=ON)

	return

def PI(part1):
	## VER: 2017-09-25, v1.0
	## get the instance of part, if only one instance

	insts = insts_of_part(part1)
	if len(insts) == 1:
		return insts[0]
	elif len(insts) == 0:
		raise Exception('*** No instance created for the part yet.')
	else:
		raise Exception('*** There are more than one instances of the part.')

	return

def plate_with_hole(length=40,width=20,radius=5,pressure=10):
	## VER: 2017-07-12, v1.0

	part1 = create_rectangle_shell('part1',corner1=(-length/2,-width/2),corner2=(length/2,width/2))
	radial_cut(part1,ndir='z',radius=radius)

	divide(part1,x=0)
	divide(part1,y=0)

	set_mat(part1,mat='Steel')   ## material
	inst1 = new_instance(part1)  ## assembly

	create_step('step1')  ## step

	edges = edge_select(inst1,shape='circular')
	apply_pressure(name='pressure',MPa=pressure,edges=edges)  ## load

	edges2 = edge_select(inst1)
	edges2 = unselect(edges2,edges)
	apply_disp_fix(name='fix',edges=edges2,U1=0,U2=0)  ## BC

	edges = edge_select(part1,shape='circular')
	seed_edges(part1,esize=0.5,edges=edges)
	mesh_part(part1,esize=1)  ## mesh

	create_job('job1')  ## job
	submit('job1')

def main_A0283_press_tool():
	## VER: 2017-07-24, v1.0
	## Press tool fatigue crack from Spain, requested by Osca.

	clear()

	check_script_file('C0_A0283_press_int70_gap0_3D.py')
	## BX: tie; AK:no case bot fix

	locals0 = locals().keys()

	analysis1 = 1			;changing1   ## 1, 12, None
	antype1 = 'stress'				;changing1		## stress, thermal_stress
	friction = 0.1			;changing1
	pressure = 100			;changing1  ## MPa

	interference = 0.07  	;changing		## There′s only interference between hard metal and stell of the part1. The interference is 0.0025mm/mm in ? ;so for this ?56mm the interference between steel and hardmetal is 0.14mm
	## ★★确认：直径大0.14mm还是radius大0.14mm? (直径)

	mid_gap = 0.0		;changing ## 0.05-0.1 mm
	esize = 0.7
	threeD = True		;changing

	holeD = 5.2
	holeL = 15
	pattern_R = 52
	cut_R = pattern_R + holeD

	pattern_R2 = 85
	holeD2 = 5.0
	pin2_top = 16
	pin2_angle_space = 30
	have_pin2 = False		;changing

	case_round4 = 4
	case_round1 = 1.5		;changing1

	mid_round = 2
	mid_y_angle = 10
	mid_chamfer = 0.5

	## 顺时针
	mid_IR = 28
	m_loc0 = (28,5)
	m_y1 = 30
	m_x1 = [67 - mid_gap]
	m_y2 = 26
	m_x2 = [60]
	m_y3 = 18
	m_x3 = [67 - mid_gap]
	m_y4 = 14
	m_loc1 = (64.4,14)
	m_y5 = 0
	m_x5 = [42.25]
	m_y6 = 5

	nib_R1 = 18.986
	nib_R2 = 28 + interference
	nib_y1 = 5
	nib_y2 = 30
	nib_height = nib_y2 - nib_y1

	## 逆时针
	c_loc0 = (64.466,13.5)
	case_y_angle = 7
	c_y1 = 0
	c_x1 = [42.499]
	c_y2 = -21
	c_x2 = [69.0]
	c_y3 = -4
	case_support = c_y3
	c_x3 = [92]
	c_y4 = 19
	c_x4 = [104.028]
	c_y5 = 30
	c_x5 = [67]
	c_y6 = 13.5

	locals2globals(locals0,locals(),save_var=True)

	blank_cae(inp_file_title)

	material_database()
	create_contact_props(friction=friction)				;changing1

	## nib
	s1 = create_base_sketch('sk_nib')
	loc0 = (nib_R1,nib_y1)
	connect_points(s1,loc0,[nib_R2],nib_y2,[nib_R1],loc0)
	if threeD == False:
		nib = sketch_to_shell(s1,partname='nib',symmetric=True)
	else:
		nib = revolve_sketch_to_part(sketch=s1,partname='nib',angle=90)

	height = _ylength(nib)
	divide(nib,y=nib_y2 - 0.32*height)
	divide(nib,y=MID)

	## mid
	s1 = create_base_sketch('sk_mid')
	locs = connect_points(s1,m_loc0,m_y1,m_x1,m_y2,m_x2,m_y3,m_x3,m_y4,xytilt3(start=m_loc1,y=m_y5,Ay=mid_y_angle),m_x5,m_y6,m_loc0)
	round_sketch_corner(s1,loc=locs[-2],radius=mid_round)
	if threeD == False:
		mid = sketch_to_shell(s1,partname='mid',symmetric=True)
		pt = (locs[-4][0] - mid_chamfer, locs[-4][1])
		bias_cut(mid,cut_sides=['+x','-y'],point1=pt,angle_with_X=45)
	else:
		mid = revolve_sketch_to_part(sketch=s1,partname='mid',angle=90)
		edges = edge_select(mid,y=MIN,diameter='bigger')
		chamfer_edges(mid,edges=edges,length=mid_chamfer)

	## case
	s1 = create_base_sketch('sk_case')
	locs = connect_points(s1,xytilt3(start=c_loc0,y=c_y1,Ay=case_y_angle),c_x1,c_y2,c_x2,c_y3,c_x3,c_y4,c_x4,c_y5,c_x5,c_y6,c_loc0)
	round_sketch_corner(s1,loc=locs[1],radius=case_round1)
	round_sketch_corner(s1,loc=locs[5],radius=case_round4)
	if threeD == False:
		case = sketch_to_shell(s1,partname='case',symmetric=True)
	else:
		case = revolve_sketch_to_part(sketch=s1,partname='case',angle=90)

	## ring
	s1 = create_base_sketch('sk_ring')
	locs = connect_points(s1,(70.26,-8.713),(74.974,-4),[92],-21,[70.26],(70.26,-8.713))
	if threeD == False:
		ring = sketch_to_shell(s1,partname='ring',symmetric=True)
		bias_cut(ring,cut_sides=['+x','+y'],point1=locs[2],angle_with_X=45,offset_x=-0.5)
	else:
		ring = revolve_sketch_to_part(sketch=s1,partname='ring',angle=90)
		edges = edge_select(ring,y=MAX,diameter='bigger')
		chamfer_edges(ring,edges=edges,length=0.5)

	set_material(nib,mat='H6F')
	set_material(mid,mat='Steel')
	set_material(case,mat='Steel')
	set_material(ring,mat='Steel')

	case_A1 = new_instance(case)
	mid_A1 = new_instance(mid)
	nib_A1 = new_instance(nib)
	ring_A1 = new_instance(ring)

	## pin
	pin = cylinder_grow('pin',ndir='y',D=holeD,L=holeL + (c_y1 - c_y2))
	x01,z01 = radial_pattern(pattern_R,angle=-22.5)
	x02,z02 = radial_pattern(pattern_R,angle=-22.5-45)
	y0 = _ymin(case)
	pin_A1 = new_instance(pin,x1=0,x2=x01,z1=0,z2=z01,y1=MIN,y2=y0)
	pin_A2 = new_instance(pin,x1=0,x2=x02,z1=0,z2=z02,y1=MIN,y2=y0)
	boolean_cut(case_A1,cutters=(pin_A1,pin_A2))
	case_A1 = new_instance(case)

	boolean_cut(mid_A1,cutters=(pin_A1,pin_A2))
	mid_A1 = new_instance(mid)

	circular_divide(case,ndir='y',radius=cut_R)
##	divide(mid,y=_ymax(pin_A1))

	## for tie between case and ring
	faces = face_select('case',y=_ymax('ring'))
	circular_divide(case,ndir='y',faces=faces,radius=pattern_R2)

	faces = face_select('ring',y=_ymax('ring'))
	circular_divide(ring,ndir='y',faces=faces,radius=pattern_R2)

##	raise Exception

	## pin2
	if have_pin2:
		pin2 = cylinder_grow('pin2',ndir='y',D=holeD2,L=pin2_top - _ymin(ring))
		x01,z01 = radial_pattern(pattern_R2,angle=-15)
		x02,z02 = radial_pattern(pattern_R2,angle=-45)
		x03,z03 = radial_pattern(pattern_R2,angle=-75)
		y0 = _ymin(ring)
		pin2_A1 = new_instance(pin2,x1=0,x2=x01,z1=0,z2=z01,y1=MIN,y2=y0)
		pin2_A2 = new_instance(pin2,x1=0,x2=x02,z1=0,z2=z02,y1=MIN,y2=y0)
		pin2_A3 = new_instance(pin2,x1=0,x2=x03,z1=0,z2=z03,y1=MIN,y2=y0)
		boolean_cut(case_A1,cutters=(pin2_A1,pin2_A2,pin2_A3))
		case_A1 = new_instance(case)

		boolean_cut(ring_A1,cutters=(pin2_A1,pin2_A2,pin2_A3))
		ring_A1 = new_instance(ring)

##	raise Exception

	if threeD == True:
		set_material(pin,mat='Steel')
		if have_pin2:
			set_material(pin2,mat='Steel')

##	faces = face_select(mid,D=holeD)
##	loc = faces[1].pointOn[0]
##	divide_by_face(mid,faces[0])
##	divide_by_face(mid,face_at(mid,loc=loc))

##	raise Exception



	## step
	create_step()

	## Mesh
	if threeD == False:
		mesh_part(nib,esize=esize)
		mesh_part(ring,esize=esize)
	else:
		mesh_part(nib,esize=2)
		mesh_part(ring,esize=2)

		mesh_part(pin,esize=1.5)
		if have_pin2:
			mesh_part(pin2,esize=1.5)

	edges = edge_select(mid,radius=mid_round)
	seed_edges(mid,edges=edges,enum=5)

	edges = edges_sort_by_length(_part(mid).edges)
	seed_edges(mid,edges=edges[0][1],enum=2)

##	raise Exception

	if threeD == False:
		mesh_part(mid,esize=esize)
	else:
		mesh_3D_TET_disp_std(mid,esize=3)	;changing

	edges = edge_select(case,radius=case_round1)
	seed_edges(case,edges=edges,enum=5)

	if threeD == False:
		mesh_part(case,esize=esize)
	else:
		if 'pin2_A1' not in a.instances.keys():
			mesh_part(case,esize=2)
		else:
			mesh_3D_TET_disp_std(case,esize=3)	;changing

##	raise Exception

	## interact
##	mfaces = edge_select(nib_A1,x=MAX)
##	sfaces = edges = edge_select(mid_A1,x=MIN)
##	s2s_interact_std('interference',mfaces=mfaces,sfaces=sfaces,interference='shrink_fit',prop='Friction')
##
##	mfaces = edge_select(mid_A1,y=MIN)
##	sfaces = edge_select(case_A1,y=_ymin(mid_A1))
####	s2s_interact_std('tie',mfaces=mfaces,sfaces=sfaces,prop='No seperation')
##	s2s_interact_std('tie',mfaces=mfaces,sfaces=sfaces,prop='Friction')
##
##	mfaces = edge_select('mid_A1',nx=1)
##	sfaces = edge_select('case_A1',nx=-1,y=(_ymin('mid_A1'),MAX))
##	s2s_interact_std('gap',mfaces=mfaces,sfaces=sfaces,prop='Friction')
##
##	mfaces = edge_select(ring_A1,y=MAX)
##	sfaces = edge_select(case_A1,y=_ymax(ring_A1))
##	s2s_interact_std('support',mfaces=mfaces,sfaces=sfaces,prop='Friction')


##	if threeD == True:
##		mfaces = face_select(pin_A1,shape='cylindrical')
##		sfaces = get_cylindrical_mate_face(mfaces,inst2=mid_A1)
##		s2s_tie('pin1_mid',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A1,shape='cylindrical')
##		sfaces = get_cylindrical_mate_face(mfaces,inst2=case_A1)
##		s2s_tie('pin1_case',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A2,shape='cylindrical')
##		sfaces = get_cylindrical_mate_face(mfaces,inst2=mid_A1)
##		s2s_tie('pin2_mid',mfaces=mfaces,sfaces=sfaces)
##
##		mfaces = face_select(pin_A2,shape='cylindrical')
##		sfaces = get_cylindrical_mate_face(mfaces,inst2=case_A1)
##		s2s_tie('pin2_case',mfaces=mfaces,sfaces=sfaces)

	if threeD == True and have_pin2 == False:
		faces = face_select(ring_A1,y=MAX)
		mfaces = face_select(ring_A1,faces=faces,xbigger=True)
		faces = face_select(case_A1,y=_ymax(ring_A1))
		sfaces = face_select(case_A1,faces=faces,xbigger=True)
		s2s_tie('tie_ring_case',mfaces=mfaces,sfaces=sfaces)

	if threeD == False:
		edges = edge_select(nib_A1,x=MAX)
		create_surface('nib_OD',edges=edges)

		edges = edge_select(mid_A1,x=MIN)
		create_surface('mid_ID',edges=edges)
	else:
		faces = face_select('nib_A1',diameter='bigger')
		create_surface('nib_OD',faces=faces)

		faces = face_select('mid_A1',radius=mid_IR)
		create_surface('mid_ID',faces=faces)

	create_general_contact_std(friction='Friction',interference_pairs=(('nib_OD','mid_ID','interfernce_fit')))	;changing1

##	raise Exception

	if threeD == False:
		## load and BC
		edges = edge_select(ring_A1,y=MIN)
		apply_disp_fix('ring_fix',edges=edges,Ux=0,Uy=0, UR3=0)

		## tie
		edges = edge_select(mid_A1,y=MIN)
		nodes = edges_to_nodes(edges)
		nodes = node_select(mid_A1,nodes=nodes,groupX=(MID,MAX))
		apply_disp_fix('mid_fix',nodes=nodes,Uy=0)	;changing

		## good
		locs = xlocs(case)
		edges = edge_select(case_A1,x=locs[-2] - 1, thenY=MIN)
		nodes = edges_to_nodes(edges)
		nodes = node_select(case_A1,nodes=nodes,groupX=(MID,MAX))
		apply_disp_fix('case_support',nodes=nodes,Ux=0)	;changing

		## good
	##	edges = edge_select(nib_A1,x=MIN)
	##	apply_pressure('pressure',MPa=pressure,edges=edges)

		## try
		edges = edge_select(nib_A1,nx=-1,through_y = _ymid(nib_A1) + 0.5)
		apply_pressure('pressure',MPa=pressure,edges=edges)

	else:
		faces = face_select(ring_A1,y=MIN)
		apply_disp_fix('ring_fix',faces=faces,fix_all=True)

		apply_disp_symm('xsym')
		apply_disp_symm('zsym')

		faces = face_select(pin_A1,y=MIN) + face_select(pin_A2,y=MIN)
		apply_disp_fix('pin_fix',faces=faces,Uy=0)

		if have_pin2:
			faces = face_select(pin2_A1,y=MIN) + face_select(pin2_A2,y=MIN) + face_select(pin2_A3,y=MIN)
			apply_disp_fix('pin2_fix',faces=faces,Uy=0)

	apply_gravity(Gy=-9800)

	create_job(inp_file_title)  ## job
##	submit()
##	cliCommand('submit()')

##	if threeD == False:
##		submit(inp_file_title)

##	res = ('name+data','pressure','pad_length','pad_width','pad2short1','pad2long','silicone_thick'), ('LAM_A1','U','S1'), ('mat_silic2','Mises','S1')

	global res
	res = ('var','mid_gap','case_round1','interference','pressure'),('case_A1','S1','S12','U1'),('mid_A1','S1','U1'),('nib_A1','S1','U1')
	if threeD == False:
		mdb.jobs[inp_file_title].waitForCompletion()
		ps()

	return

def main_A0284_wiredraw_919():
	## VER: 2018-10-19, v1.0

	check_script_file('D3_A0284_oldwire_int45_C45.py')
	purpose = 'parameter study for casing, requested by Miguel'
	history='B0:new wire, static shrinkfit+ explicit dynamic drawing; AG: finner mesh, new wire(very low stress in Nib); AF:new wire, uniform mesh(very low stress in Nib); AE:old wire, OK; A9:carbide with yield, wire=235; A8:no carbide yield; A1:based on job#:A0247'

##	existed_cae = 'CH_A0232_explicit_fric01_316L_deg60'	;changing1
##	existed_odb = 'CH_A0232_explicit_fric01_316L_deg60'	;changing1

	locals0 = locals().keys()   ## need both stp file and assembly file with bearing dimensions.
	## for D12H10 nib, the bearing diameter=0.8mm, then wire diameter= 0,889
	## for D9H6 nib, the bearing diameter=0.1mm, then wire diameter=0,111
	## bell->approach -> reduction -> bearing -> relief->exit

	nib_type = 'D9H6'		;changing1  ## D6H7, D9H6
	## analysis1=1: only shrink-fit
	## analysis1=12: step1=shrink-fit, step2=drawing (dynamic implic if no thermal, coupled temp-disp if with thermal in antype1)

	## 1-shrinkfit, 2-drawing
	## analysis1: implicit analysis
	analysis1 = 'shrink-fit'				;changing1   ## 1, 12, None
	antype1 = 'stress'				;changing1		## stress, thermal_stress
	analysis1_title = inp_file_title	;changing1

	## 显式动力学分析： create_coupled_temp_displacement_step, explicit_dynamic
	analysis2 = 'draw'				;changing1	## 2, None
	analysis2_title = analysis1_title + '_drawing'	;changing1

	friction = 0.1				;changing
	draw_time = 0.15e-3  		;changing
	carbide_yield = 5000		;changing1  ##Ludwig的拉丝模拟yield=5230MPa (Job#:A0136)

	if analysis1 in empty:
		open_cae(existed_cae, new_name=analysis1_title)
	else:
		blank_cae(analysis1_title)

##	raise Exception

	get_nib_dimensions(nib_type)  ## will create the global variables in the function

##	raise Exception

	## wire
##	wire_D = 0.34			;changing
##	wire_R = wire_D/2
	wire_length = 5		;changing
	wire_cut_H = 1

	speed = -10*1000		;changing1
	wire_cut_x=0.1
	wire_cut_y = 0.2

	## nib cut
	cut_angle_y = 30		;changing
	cut_width = 0.3
	cut_height = cut_width/tanD(cut_angle_y)
##	cut_height = 1.15
##	cut_width = cut_height*tanD(cut_angle_y)
	cut_round_y = 0.5		;changing
	cut_round_x = 0

	nib = 'nib'
	nib_A1 = 'nib_A1'
	case = 'case'
	case_A1 = 'case_A1'
	wire = 'wire'
	wire_A1 = 'wire_A1'

	locals2globals(locals0,locals(),save_var=True)

##	print get_caller_code()
##	raise Exception

##	raise Exception
	material_database()  ## 此时并没有创建材料
	create_contact_props(friction=friction)				;changing

##	raise Exception

	## wire elastic
##	wire_plastic = (275,0), (690, 0.2), (960, 0.4), (1206, 0.6), (1654, 1), (2240, 1.6)  ## hardening steel
##	wire_plastic = (301, 0), (617, 0.002), (691, 0.005), (708, 0.0075), (721, 0.01), (730, 0.0125), (743, 0.015)   ## 304S steel
##	set_plastic('Steel', wire_plastic)	;changing
##	set_plastic('Steel', (500, 0))	;changing

	wire_plastic = (425,0,20),(575,0.03,20),(660,0.06,20),(730,0.09,20),(760,0.12,20),(790,0.15,20), \
					(400,0,200),(530,0.03,200),(610,0.06,200),(660,0.09,200),(700,0.12,200),(710,0.15,200)

	set_plastic('Steel_SS316L', wire_plastic)	;changing1
	## Ludwig拉的wire: 仅仅设置屈服点yield=200MPa (200,0)。没有更多屈服行为.他的模型是3D

	set_plastic('H3F',(carbide_yield,0))		;changing
	## Ludwig的拉丝模拟也设置了屈服点（5230,0)。模具为3D模型

	set_plastic('Steel',(200,0))	;changing

##	raise Exception

	if analysis1 not in empty:
		if analysis1 == 2:  ## 不创建Nib，而是导入
##			open_cae('_imported_' + nib_type, new_name=analysis1_title)
			open_cae(existed_cae, new_name=analysis1_title)

			edges = edge_select('nib0',x=(MID,MAX),z=MAX)
			sketch = edges_to_sketch(edges,sketchname='sk_nib')
			s1 = sketch['sketch']

			if cut_angle_y == 45:
				loc1 = find_loc(s1,x=MAX,groupY=MIN)
				loc2 = find_loc(s1,y=MIN,groupX=MAX)

				edges = geometry_select(s1,x=(loc1[0],loc2[0]),y=(loc1[1],loc2[1]))
				del_geometry(s1,edges)
				connect_points(s1,loc2,('x',_xmax(s1)),loc1)	;changing

				sketch_to_shell(s1,partname='nib',symmetric=True)
				bias_cut('nib',cut_sides='bot_right',point1=(_xmax('nib'),_ymin('nib') + cut_height),angle_with_Y=cut_angle_y)

			else:
				sketch_to_shell(s1,partname='nib',symmetric=True)

			edges = edge_select('case0',x=(MID,MAX),z=MAX)
			sketch = edges_to_sketch(edges,sketchname='sk_case')
			s1 = sketch['sketch']
			sketch_to_shell(s1,partname='case',symmetric=True)

			new_instance('nib')
			new_instance('case')

		else: ## 创建Nib
			## Nib
			s1 = create_base_sketch('sk_nib')
			loc0 = (bearing_R,0)
			loc1 = loc0

			## 逆时针走，走到右上角
			if relief_dy > 0:
				connect_points(s1,loc0,xytilt4(dy=relief_dy,Ay=relief_angle/2))
				loc1 = last_point

			connect_points(s1,loc1,xytilt4(dy=exit_dy,Ay=exit_angle/2),('x',nib_R),('dy',nib_H))  ## 逆时针走到右上角
			right_top = last_point

			## 顺时针往上走
			if bearing_length > 0:
				connect_points(s1,loc0,('dy',bearing_length))
				loc1 = last_point

			## 顺时针走到右上角
			if approach_angle not in empty:  ## there is approach slope line
				locs = connect_points(s1,loc1,xytilt1(dy=reduction_dy,Ay=reduction_angle/2),xytilt1(dy=approach_dy,Ay=approach_angle/2),('x',nib_R))
				round_sketch_corner(s1,loc=locs[-2],radius=bell_R)
			else:## 特殊情形：bearing top直接一个弧线且到Nib top
				line1 = slope_construction(s1,loc=loc1,angle=90 - reduction_angle/2)
				dict1 = create_tangent_circle(s1,radius=bell_R,center_x=10, center_y=(MAX,-bell_center_to_top),tangent_line=line1, toY=_ymax(s1))
				connect_points(s1,loc1,dict1['start'])
				connect_points(s1,dict1['end'],('x',nib_R))
				round_sketch_corner(s1,loc=dict1['end'],radius=bell_round)

			sketch_to_shell(s1,partname='nib',symmetric=True)

			move_part(nib,y1=MIN,y2=nib_bot_to_bot)
			bias_cut(nib,cut_sides='bot_right',point1=(nib_R,_ymin(nib) + cut_height), point2=(nib_R - cut_width,_ymin(nib)))
##			bias_cut(nib,cut_sides='bot_right',point1=(nib_diameter/2,_ymin(nib) + cut_height), angle_with_Y = 15)

			round_corner(nib,x=MAX,groupY=MIN,radius=cut_round_y)
			round_corner(nib,y=MIN,groupX=MAX,radius=cut_round_x)

			edges = edge_select(nib,nx=-1,ny=-1,y=MIN1)
			divide_edge(edges=edges[0],xpar=0.4)

			new_instance(nib)

			edges = edge_select(nib,x=MIN)
			bearing_top = objs_ymax(edges)
			bearing_bot = objs_ymin(edges)

## {★=== for nib sweep mesh
##			vertices = vertice_select(nib,x=MAX,groupY=MIN)
##			y0 = vertices[0].pointOn[0][1]
##			divide(nib,y=y0)
##
##			edges = edge_select(nib,radius=bell_R)
##			vertices = edges_to_vertices(edges,sort='y')
##			y1 = vertices[0].pointOn[0][1]
##			divide(nib,y=y1)
##
##			vertices = vertice_select(nib,nx=-1,groupY=(y0 + 0.1,y1-0.1))
##			ignore_vertices(nib,vertices=vertices)
## }★===

##			raise Exception

##			edges = edge_select(nib,nx=-1)
##			edges1 = edge_select(nib,radius=bell_R)
##			edges = unselect(edges,edges1)
##			vertices = edges_to_vertices(edges,sort='y')
##			vertices = vertices_sort_byy(vertices,return_obj=True)[1:-1]
##			ignore_vertices(nib,vertices=vertices)
##
##			vertices = vertice_select('nib',y=(MAX,MAX1))
##			vertices = vertices_sort_byx(vertices,return_obj=True)[:-1]
##			ignore_vertices(nib,vertices=vertices)
##
##			edges = edge_select(nib,nx=1)
##			vertices = edges_to_vertices(edges)
##			vertices = vertices_sort_byy(vertices,return_obj=True)[1:-1]
##			ignore_vertices(nib,vertices=vertices)


##			raise Exception

			## case
			s1 = create_base_sketch('sk_case')
			loc0 = (case_land_ID/2,nib_bot_to_bot)	## nib的底面

			## 没有rivet, 有carve
			locs = connect_points(s1,loc0,('dy',-case_land_H),xytilt4(dy=case_exit_H, Ay=case_exit_angle/2), ('x',case_R),
				('dy',carve_bot),xytilt2(Ax=carve_angle/2,dy=carve_open_dy/2),xytilt1(Ax=carve_angle/2,dy=carve_open_dy/2),
				('y',case_H),('dx',-(case_OD - mouth_D)/2),(case_ID2/2,case_H - entrance_cut_dy),('dy',-case_ID2_dy),
				('x',case_ID/2),('dy',-case_ID_dy),loc0)

##			print locs[5]
			round_sketch_corner(s1,loc=locs[5],radius=carve_round)
			round_sketch_corner(s1,loc=locs[-2],radius=land_corner_R)

##			connect_points(s1,loc0,('dy',-case_land_H),xytilt4(dy=case_exit_H, Ay=case_exit_angle/2), ('x',case_R),('y',case_H))
##			locs = loc0,('x',case_ID/2),('dy',nib_H + rivet_offset),('dx',-rivet_L),('dy',rivet_H),('dx',rivet_L)
##			connect_points(s1,points=locs)

##			raise Exception

##			locs = last_point, ('y',case_H - case_entrance_cut), xytilt1(dy=case_entrance_cut,Ay=case_entrance_cut_angle), ('x',case_R)
##			connect_points(s1,points=locs)

			sketch_to_shell(s1,partname='case',symmetric=True)

			bias_cut(case,cut_sides='bot_right',point1=(case_R,case_corner_chamfer),angle_with_Y=45)
			bias_cut(case,cut_sides='top_right',point1=(case_R,case_H - case_corner_chamfer),angle_with_Y=45)

##			raise Exception

##			loc = find_loc(case,y=MAX,groupX=MIN)
##			bias_cut(case,cut_sides='top_left',point1=(loc[0],loc[1] - case_entrance_cut,0),angle_with_Y=case_entrance_cut_angle)
##			raise Exception

			new_instance(case)

	##	divide(case,y=_ymin(nib,x=MAX))

##		raise Exception

		## wire

## {{★===
##		## new wire
##		s1 = create_base_sketch('sk_wire')
##		small_length = 0.5
##		connect_points(s1,(0,0),('x',bearing_R*0.9),('y',small_length),xytilt1(Ay=reduction_angle/2,dx=(wire_R - bearing_R*0.9)),
##			('y',wire_length),('x',0),('y',0))
##		sketch_to_shell(s1,partname='wire',symmetric=True)
##		divide(wire,y=small_length/2)
##
####		edges = edge_select(wire,x=wire_R)
####		divide(wire,y=objs_ymin(edges))
##
##		move_part(wire,y1=small_length,y2=bearing_top)
##		new_instance(wire)
## }★==

## {★==
		## old wire
		yloc = ylocs('nib',x=MIN)[-1] + 2
		create_rectangle_shell('wire',corner1=(0,0),corner2=(wire_R, wire_length),axis_symmetric = True)
	##	move_part(wire,y1=MIN,y2=yloc)
		move_part(wire,y1=MIN,y2=_ymin(nib) + 1.5)

	##	bias_cut(wire, cut_sides='bot_right', point1=(wire_R, _ymin(wire) + 0.2, 0), point2=(wire_R*0.7, _ymin(wire), 0))
		bias_cut(wire,cut_sides=('+x','-y'), point1=(wire_R, _ymin(wire) + wire_cut_H), point2=(wire_R/2,_ymin(wire)))
	##	round_corner(wire,radius=5,x=MAX,groupY=MIN)

		vertices = vertice_select(wire,x=MAX,groupY=MIN)
		ignore_vertices(wire,vertices=vertices)

		new_instance(wire)

	##	divide(wire,y=_ymin(wire) + wire_cut_H)
		divide(wire,y=_ymin(wire) + wire_cut_H + 0.5)	;changing
## }★==

		set_mat(nib,mat='H3F')

		set_mat(case,mat='Steel_C45')
##		set_mat(case,mat='Steel_EN10718')  ## current

##		set_mat(wire,mat='Steel')	;changing1
		set_mat(wire,mat='Steel_SS316L')	;changing

		## step
		times1 = myrange(0,1,0.05)
		timepoints1 = create_timepoints(times1,factor=4e-5)	;changing1

		times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,10, 0.5) + myrange(11,200, 2.0)		;changing1
		timepoints2 = create_timepoints(times2,factor=1e-5)

		if analysis1 == 1 or analysis1 == 'shrink-fit':  ## shrink-fit only
			create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)
			field_output_request(timepoints=timepoints1,variables=ALL)
		elif analysis1 == 12 or analysis1 == 'shrink-fit + draw':
			changing
			if 'thermal' not in antype1:
				create_general_static_step(stepname='shrink_fit',timePeriod=4e-5)		;changing1
##				create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='transient',matrix_storage='UNSYMMETRIC') ## 运行速度极慢
##				create_general_static_step(stepname='draw',timePeriod=draw_time)		;changing1  ## 结果与implicit dynamic类似。

				create_dynamic_implicit_step(stepname='draw',timePeriod=draw_time, application='QUASI_STATIC',matrix_storage='UNSYMMETRIC')  ## good
			else:
				create_coupled_temp_displacement_step(stepname='shrink_fit',period=4e-5)
				create_coupled_temp_displacement_step(stepname='draw',timePeriod=draw_time,response='transient')
			field_output_request(timepoints=(timepoints1, timepoints2),variables=ALL)	;changing1

		## create surfaces
		edges = edge_select(case_A1,ny=1,groupY=MIN)
		create_surface('case_land',edges=edges)

		please_check
##		edges = edge_select('case_A1',nx=-1,x=(MIN1,MAX),y=_yspace('nib'))
		edges = edge_select('case_A1',y=(_ymin('nib_A1')+0.005, MAX1),x=(MIN,MID))  ## 防止有阶梯型的ID
		create_surface('case_ID',edges=edges)

		please_check
		edges1 = edge_select(nib_A1,nx=1)  ## use for general contact
		create_surface('nib_OD',edges=edges1)

		edges = edge_select(nib_A1,nx=1,ny=-1)
		create_surface('nib_corner', edges=edges)

##		raise Exception

##		edges = edge_select(case_A1,x=case_ID/2,y=_ymin(nib,x=MAX) - 0.1)
##		create_surface('case_corner',edges=edges)

		edges = edge_select(nib_A1,y=MIN)
		create_surface('nib_bot', edges=edges)

		edges3s = edge_select(wire_A1,nx=1)
		create_surface('wire_surf',edges=edges3s)

##		vertices = vertice_select(nib_A1,x=MIN)
##		edges3m = vertices_to_edges(vertices)
##		create_surface('nib_surf',edges=edges3m)
		edges = edge_select(nib_A1,nx=-1,y=(bearing_bot - 0.1, bearing_top + 0.1))   ## reduction, bearing, relief
		create_surface('nib_surf',edges=edges)

		edges1 = edge_select(nib_A1,y=MAX)
		create_surface('nib_top',edges=edges1)

##		edges2 = edge_select(case_A1,y=_ymax(nib_A1) + rivet_offset)
##		create_surface('rivet_bot',edges=edges2)

		get_current_model()

##		raise Exception

		## mesh case
		edges = edge_select(case,x=(MIN,case_ID2/2.0 + 0.1),y=(MIN1,MAX1))
		seed_edges(case,edges=edges,esize=0.15)	;changing1

		mesh_2D(case,esize=0.5)		;changing1

		## mesh nib
## {★==
###		edges = edge_select(nib,y=MID,nx=1)
###		seed_edges(nib,edges=edges,esize=0.04)
###
###		faces = face_select(nib,y=MID)
###		set_element_shape(nib,faces=faces,technique=SWEEP)
## }★==

		ref0 = bearing_length/4
		if ref0 < 0.02:
			esize = 0.02
		elif ref0 > 0.07:
			esize = 0.07
		else:
			esize = ref0
		esize = round(esize,3)		;changing

		edges = edge_select(nib,nx=-1,y=(bearing_bot - 0.05, bearing_top + 0.05))
		seed_edges(nib,edges=edges,enum=3)

		edges1 = edge_select(nib,radius=bell_R)
		edges2 = edge_select(nib,nx=-1)
		edges = unselect(edges2,edges1)
		seed_edges(nib,edges=edges,esize=0.08)

		mesh_2D(nib,esize=0.15)	;changing1

##		raise Exception

		## mesh wire
##		edges = edge_select(wire,y=MAX) + edge_select(wire,y=MIN)
##		seed_edges(wire,edges=edges,enum=12)	;changing1 ## enum
##
##		mesh_2D(wire,esize=esize)

##		control = adaptive_mesh_control(predictor='previous', curvature=0.05, weight=(1,0,0), order='first')
##		apply_adaptive_mesh(insts='wire_A1',frequence=1,sweep=2, controls=control)

		edges = edge_select(wire,y=MIN)
		seed_edges(wire,edges=edges,enum=9)

		faces = face_select(wire)
		set_element_shape(wire,faces=faces,technique=SWEEP)

		mesh_2D(wire, esize=0.015)	;changing

##		raise Exception

##		vertices = vertice_select('wire',y=MIN)
##		wire_RP = create_RP('wire',loc=vertices[0],name='RP')
##		RP_set = create_set(objs=wire_RP,name='wire_RP')

##		vertices = vertice_select('wire_A1',y=MIN)
##		wire_RP = create_RP('wire_A1',loc=vertices[0],name='RP')
##		RP_set = create_set(objs=wire_RP,name='wire_RP')
##		raise Exception

		## 以下适用于已经存在过盈
		if 'thermal' not in antype1:
			create_general_contact_std(friction='Friction',interference_pairs=(('nib_OD','case_ID','interfernce_fit')))	;changing1
		else:
			create_general_contact_std(friction='Friction + Heat generation',interference_pairs=(('nib_OD','case_ID','interfernce_fit')))	;changing1

##		raise Exception

		## Fix
		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0)	; changing

##		raise Exception

		if analysis1 == 12:
			## 在shrink-fit阶段需要固定wire
			edges = edge_select(wire_A1,y=MAX)
			apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0,deactive_step='step2')

##			raise Exception

			## 出错
##			apply_disp_fix('wire_xfix',region=RP_set, Ux=0,UR3=0)
##			apply_velocity(name='pull_speed',region=RP_set, Vy=speed, step='step2')	;changing1

			## 在拉伸阶段不需要施加任何约束，仅需施加拉伸速度即可。
			faces = face_select(wire_A1,y=MIN1,mark_select=True)
			apply_velocity(name='pull_speed',faces=faces, Vy=speed, step='step2')	;changing1

			apply_gravity(Gy=-9800)

			if 'thermal' in antype1:
				set_temperature_predefined_field(initial_step=20)	;changing1

				edges = edge_select(wire_A1,nx=1)
				apply_surface_convection('wire_convection',faces=edges,h = 1000,step='step2')	;changing1

				edges = edge_select(nib_A1,nx=-1)
				apply_surface_convection('nib_convection',faces=edges,h = 1000,step='step2')		;changing1

		else:
			edges = edge_select(wire_A1,y=MAX)
			apply_disp_fix('wire_fix',edges=edges,Ux=0,Uy=0,UR3=0)

		_results_dict = { 'Nib':('S1','PEEQ'), 'CASE':('U','Mises','PEEQ')}

##		raise Exception

		existed_odb = analysis1_title	;changing1
		create_inp(analysis1_title,request_num=6,submit=False)
		mdb.jobs[analysis1_title].submit()

##		raise Exception

	if analysis2 not in empty:
		if analysis1 not in empty:
			mdb.jobs[analysis1_title].waitForCompletion()

		antype2 = 'stress'	;changing	## 'stress','temp','stress-temp'
		copy_model(to_name = 'draw')
		del mdb.models['Model-1']
		clear_model_settings()

		if 'temp' in antype2:
			create_heat_from_plastic_work(['wire','nib'])

	##	raise Exception
		times2 = myrange(1,4,0.5) + myrange(4.1,5.4,0.1) + myrange(5.5,10, 0.5) + myrange(11,200, 2.0)		;changing1
		timepoints2 = create_timepoints(times2,factor=1e-5)

##		raise Exception

		if 'temp' in antype2:
			create_coupled_temp_displacement_step(step='draw', timePeriod=draw_time, response='dynamic')	;changing1
		else:
			create_dynamic_explicit_step(step='draw', timePeriod=draw_time)
		field_output_request(timepoints=timepoints2)

##		choose_element_type('case')
##		choose_element_type('nib')
##		choose_element_type('wire')
		choose_element_types()
		import_initial_stress(analysis1_title)				;changing1
		set_temperature_predefined_field(initial_step=20)	;changing1

##		create_general_contact_exp(prop='Friction + Heat generation')	;changing  ## not supported for 2D

##		changing1
		if 'temp' in antype2:
			s2s_interact_exp('int_nib_support', mfaces='nib_bot', sfaces='case_land', prop='Friction + Heat conduction',sliding='small')
			s2s_interact_exp('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',prop='Friction + Heat conduction',sliding='small')
			s2s_interact_exp('int_nib_rivet', mfaces='nib_top', sfaces='rivet_bot',prop='Friction + Heat conduction',sliding='small')
			s2s_interact_exp('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',prop='Friction + Heat generation')
		else:
			s2s_interact_exp('int_nib_support', mfaces='nib_bot', sfaces='case_land', prop='Friction',sliding='small')
			s2s_interact_exp('int_nib_OD', mfaces='nib_OD', sfaces='case_ID',prop='Friction',sliding='small')
			s2s_interact_exp('int_nib_wire', mfaces='nib_surf', sfaces='wire_surf',prop='Friction')

	##	s2s_interact_exp('int_nib_corner',mfaces='nib_corner',sfaces='case_corner')  ## 在有初始过盈的情况下，必须设置shrink fit,否则一开始由于侵入，不收敛。
	##	s2s_interact_exp('int_nib_corner2',mfaces='nib_corner',sfaces='case_land')


##		raise Exception

		edges = edge_select(case_A1,y=MIN)
		apply_disp_fix('case_fix',edges=edges,Uy=0, UR3=0)

		faces = face_select(wire_A1,y=MIN1,mark_select=True)
		apply_velocity(name='pull_speed',faces=faces, Vy=speed)	;changing

		if 'temp' in antype2:
			edges = edge_select(wire_A1,nx=1)
	##		apply_surface_convection('wire_convection',faces=edges,h = 'Heat convection')
			apply_surface_convection('wire_convection',faces=edges,h = 1000)	;changing1

			edges = edge_select(nib_A1,nx=-1)
	##		apply_surface_convection('nib_convection',faces=edges,h = 'Heat convection')
			apply_surface_convection('nib_convection',faces=edges,h = 1000)		;changing1

##		raise Exception

		mdb.saveAs(analysis2_title)

		create_inp(analysis2_title,clear_jobs=False)
		mdb.jobs[analysis2_title].submit()


	return

coding=711102
run1 = main_A0283_press_tool
## (SMIL), S=Step, M=Mesh, I=Interaction, L=Load and BC

def cantilever():

	clear()
	get_current_model()

	create_block('beam',x=(0,10),y=(0,5),z=(0,0.5))
	set_mat('beam',mat='Steel')
	inst1 = new_instance('beam')

	create_dynamic_explicit_step(period=0.001)

	edges = edge_select('beam',x=MID)
	seed_edges('beam',edges=edges,enum=50)

	mesh_part('beam',esize=0.1)

	faces = face_select(inst1,x=MIN)
	apply_disp_fix('xfix',faces=faces,fix_all=True)

	edges = edge_select(inst1,x=MAX,thenZ=MAX)
	apply_disp_fix('disp',edges=edges,Uz=-1,step='step1')

	mdb.saveAs('cantilever')

	create_inp('cantilever',core_num=1)

	return

print ' '
print ' '
print ' '

jobnum = 'A0284'			;changing

get_current_model()
get_user_functions()

if imported == False:
	all_treats, run_indexs = get_all_treats_and_run_indexs(by_table=provide_DOE_table)
	for job_index in run_indexs:
		global_vars_for_this_run(all_treats,job_seq=job_index)
		get_inp_file_title(job_seq=job_index, added_info = cae_name_postfix)

		close_odb(inp_file_title)

		funcs = find_func(str(jobnum))
		if funcs in empty:
			raise Exception('*** No function find by ' + str(jobnum))
		elif len(funcs) >= 2:
			raise Exception('*** More than one functions found by ' + str(jobnum) + ', please provide longer jobnum string, such as: A0206_wiredraw')

		eval(funcs[0])()  	 ## create model, create job and submit

		if len(run_indexs) > 1:
			mdb.jobs[inp_file_title].waitForCompletion()
			post()